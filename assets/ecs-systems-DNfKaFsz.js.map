{"version":3,"file":"ecs-systems-DNfKaFsz.js","sources":["../../js/ecs/components.ts","../../js/ecs/systems/physicsSystem.ts","../../js/ecs/systems/renderSyncSystem.ts","../../js/ecs/systems/combatSystem.ts","../../js/ecs/systems/enemyAISystem.ts","../../js/ecs/world.ts","../../js/ecs/systems/ecsRunner.ts"],"sourcesContent":["/**\n * bitECS Component Definitions\n *\n * Data-oriented component definitions using bitECS v0.4.0 API.\n * Components are Structure-of-Arrays (SoA) for cache locality.\n *\n * Design principles:\n * - SoA layout (separate arrays for each property) for cache locality\n * - TypedArrays for numeric data (Float32Array, Uint8Array, etc.)\n * - Components are pure data - logic goes in systems\n * - Keep components minimal - only the data systems need\n *\n * bitECS v0.4.0 uses plain objects/arrays as components. Access pattern:\n *   Position.x[eid] = 100\n *   Velocity.y[eid] = 5.5\n */\n\n/**\n * Component definitions for registration with world.\n * These are the shape definitions - actual arrays are created by bitECS.\n */\n\n// ============================================================================\n// CORE TRANSFORM COMPONENTS\n// ============================================================================\n\n/**\n * Position in 3D space\n */\nexport const Position = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n/**\n * Velocity vector\n */\nexport const Velocity = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n/**\n * Angular velocity (rotation rate in radians/second)\n * Stored as Euler angles for simplicity\n */\nexport const AngularVelocity = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n/**\n * Rotation as quaternion (most efficient for 3D rotation math)\n */\nexport const Rotation = {\n  x: new Float32Array(10000),  // Quaternion x\n  y: new Float32Array(10000),  // Quaternion y\n  z: new Float32Array(10000),  // Quaternion z\n  w: new Float32Array(10000)   // Quaternion w\n}\n\n/**\n * Scale (uniform or non-uniform)\n */\nexport const Scale = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n// ============================================================================\n// RENDER BRIDGE COMPONENTS\n// ============================================================================\n\n/**\n * Reference to Three.js mesh in render system\n * Uses index into a mesh array for cache-friendly lookup\n */\nexport const MeshRef = {\n  meshIndex: new Uint32Array(10000)  // Index into Three.js mesh array\n}\n\n/**\n * Visual state flags\n */\nexport const Renderable = {\n  visible: new Uint8Array(10000),      // 0 = hidden, 1 = visible\n  castShadow: new Uint8Array(10000),   // 0 = no shadow, 1 = cast shadow\n  receiveShadow: new Uint8Array(10000) // 0 = no receive, 1 = receive shadow\n}\n\n// ============================================================================\n// PHYSICS COMPONENTS\n// ============================================================================\n\n/**\n * Rigidbody physics properties\n */\nexport const Rigidbody = {\n  mass: new Float32Array(10000),\n  drag: new Float32Array(10000),         // Linear drag (space friction)\n  angularDrag: new Float32Array(10000),  // Angular damping\n  isKinematic: new Uint8Array(10000),    // 0 = dynamic, 1 = kinematic (no physics)\n  freezeRotation: new Uint8Array(10000)  // 0 = normal, 1 = freeze rotation\n}\n\n/**\n * Force accumulator (cleared each frame)\n */\nexport const Force = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n/**\n * Torque accumulator (cleared each frame)\n */\nexport const Torque = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n/**\n * Sphere collision detection\n */\nexport const Collider = {\n  radius: new Float32Array(10000)        // Sphere collision radius\n}\n\n// ============================================================================\n// HEALTH & COMBAT COMPONENTS\n// ============================================================================\n\n/**\n * Health and shield data\n */\nexport const Health = {\n  current: new Float32Array(10000),      // Current health\n  max: new Float32Array(10000),          // Maximum health\n  shield: new Float32Array(10000),       // Current shield\n  maxShield: new Float32Array(10000),    // Maximum shield\n  shieldRegenRate: new Float32Array(10000),  // Shield points per second\n  shieldRegenDelay: new Float32Array(10000), // Seconds after damage before regen\n  timeSinceLastDamage: new Float32Array(10000),\n  damageResistance: new Float32Array(10000)  // 0-1 damage reduction percentage\n}\n\n/**\n * Weapon properties\n */\nexport const Weapon = {\n  damage: new Float32Array(10000),       // Damage per hit\n  fireRate: new Float32Array(10000),     // Shots per second\n  range: new Float32Array(10000),        // Maximum range\n  timeSinceLastShot: new Float32Array(10000),\n  level: new Uint8Array(10000)           // Weapon upgrade level\n}\n\n// ============================================================================\n// SPACESHIP COMPONENTS\n// ============================================================================\n\n/**\n * Thrust control state (bitfield for input)\n */\nexport const Thrust = {\n  forward: new Uint8Array(10000),      // 0 or 1\n  backward: new Uint8Array(10000),\n  left: new Uint8Array(10000),\n  right: new Uint8Array(10000),\n  up: new Uint8Array(10000),\n  down: new Uint8Array(10000),\n  boost: new Uint8Array(10000)\n}\n\n/**\n * Thruster properties\n */\nexport const Thruster = {\n  thrustForce: new Float32Array(10000),\n  maxVelocity: new Float32Array(10000),\n  boostMultiplier: new Float32Array(10000),\n  rotationSpeed: new Float32Array(10000),\n  fuelConsumptionRate: new Float32Array(10000),\n  boostConsumptionMultiplier: new Float32Array(10000)\n}\n\n/**\n * Ship state data\n */\nexport const ShipState = {\n  fuel: new Float32Array(10000),\n  maxFuel: new Float32Array(10000),\n  credits: new Uint32Array(10000),\n  isDocked: new Uint8Array(10000),\n  isDestroyed: new Uint8Array(10000),\n  isInvulnerable: new Uint8Array(10000),\n  engineLevel: new Uint8Array(10000),\n  fuelTankLevel: new Uint8Array(10000),\n  hullLevel: new Uint8Array(10000),\n  shieldLevel: new Uint8Array(10000),\n  miningLevel: new Uint8Array(10000),\n  scannerLevel: new Uint8Array(10000),\n  weaponLevel: new Uint8Array(10000)\n}\n\n/**\n * Cargo/inventory data\n */\nexport const Cargo = {\n  maxCapacity: new Float32Array(10000),\n  usedCapacity: new Float32Array(10000),\n  iron: new Uint32Array(10000),        // Iron units\n  gold: new Uint32Array(10000),        // Gold units\n  platinum: new Uint32Array(10000)     // Platinum units\n}\n\n// ============================================================================\n// MINING COMPONENTS\n// ============================================================================\n\n/**\n * Mining laser data\n */\nexport const MiningLaser = {\n  active: new Uint8Array(10000),       // 0 = inactive, 1 = active\n  targetEntity: new Uint32Array(10000), // Entity ID of target (bitECS entity ID)\n  progress: new Float32Array(10000),     // Mining progress (0-1)\n  power: new Float32Array(10000),        // Mining power multiplier\n  range: new Float32Array(10000),        // Maximum mining range\n  ironRate: new Float32Array(10000),     // Mining rate for iron (progress per second)\n  goldRate: new Float32Array(10000),     // Mining rate for gold\n  platinumRate: new Float32Array(10000)  // Mining rate for platinum\n}\n\n/**\n * Mineable resource data (for asteroids)\n */\nexport const Mineable = {\n  resourceType: new Uint8Array(10000), // 0 = iron, 1 = gold, 2 = platinum\n  totalAmount: new Float32Array(10000),  // Total resource amount\n  remainingAmount: new Float32Array(10000), // Remaining resource amount\n  miningDifficulty: new Float32Array(10000), // Difficulty multiplier\n  beingMined: new Uint8Array(10000),   // 0 = not being mined, 1 = being mined\n  startingScale: new Float32Array(10000), // Initial scale for depletion visuals\n  minScale: new Float32Array(10000)      // Minimum scale before destruction\n}\n\n// ============================================================================\n// AI COMPONENTS\n// ============================================================================\n\n/**\n * Enemy AI data\n */\nexport const EnemyAI = {\n  faction: new Uint8Array(10000),      // 0 = spectrals, 1 = other (expand as needed)\n  aiType: new Uint8Array(10000),       // 0 = drone, 1 = other\n  subtype: new Uint8Array(10000),      // 0 = standard, 1 = heavy, 2 = swift\n  detectionRange: new Float32Array(10000),\n  damage: new Float32Array(10000),\n  speed: new Float32Array(10000),\n  playerFound: new Uint8Array(10000),  // 0 = not found, 1 = found\n  spiralAmplitude: new Float32Array(10000),\n  spiralFrequency: new Float32Array(10000),\n  spiralPhase: new Float32Array(10000),\n  timeAlive: new Float32Array(10000),\n  isDroneLike: new Uint8Array(10000),\n  separationInfluence: new Float32Array(10000)\n}\n\n/**\n * Separation force for flocking/avoidance (computed by systems)\n */\nexport const SeparationForce = {\n  x: new Float32Array(10000),\n  y: new Float32Array(10000),\n  z: new Float32Array(10000)\n}\n\n// ============================================================================\n// TAG COMPONENTS (minimal data, mainly for queries)\n// ============================================================================\n\n/**\n * Player entity marker\n */\nexport const Player = {\n  tag: new Uint8Array(10000)  // Always 1 if component exists\n}\n\n/**\n * Enemy entity marker\n */\nexport const Enemy = {\n  tag: new Uint8Array(10000)\n}\n\n/**\n * Asteroid entity marker\n */\nexport const Asteroid = {\n  tag: new Uint8Array(10000)\n}\n\n/**\n * Planet entity marker\n */\nexport const Planet = {\n  tag: new Uint8Array(10000)\n}\n\n/**\n * Projectile entity marker\n */\nexport const Projectile = {\n  tag: new Uint8Array(10000),\n  sourceEntity: new Uint32Array(10000)  // Who fired this\n}\n\n// ============================================================================\n// UTILITY COMPONENTS\n// ============================================================================\n\n/**\n * Lifetime tracking (for particles, projectiles, etc.)\n */\nexport const Lifetime = {\n  age: new Float32Array(10000),          // Time alive in seconds\n  maxAge: new Float32Array(10000)        // When to destroy (-1 = infinite)\n}\n\n/**\n * Trail effect data (for thruster trails, etc.)\n */\nexport const Trail = {\n  enabled: new Uint8Array(10000),\n  particleSystemIndex: new Uint32Array(10000)  // Index into particle system array\n}\n\n// ============================================================================\n// COMPONENT REGISTRATION\n// ============================================================================\n\n/**\n * All game components for easy registration with world\n */\nexport const AllComponents = {\n  // Transform\n  Position,\n  Velocity,\n  AngularVelocity,\n  Rotation,\n  Scale,\n\n  // Render\n  MeshRef,\n  Renderable,\n\n  // Physics\n  Rigidbody,\n  Force,\n  Torque,\n  Collider,\n\n  // Combat\n  Health,\n  Weapon,\n\n  // Spaceship\n  Thrust,\n  Thruster,\n  ShipState,\n  Cargo,\n\n  // Mining\n  MiningLaser,\n  Mineable,\n\n  // AI\n  EnemyAI,\n  SeparationForce,\n\n  // Tags\n  Player,\n  Enemy,\n  Asteroid,\n  Planet,\n  Projectile,\n\n  // Utility\n  Lifetime,\n  Trail\n}\n\n// ============================================================================\n// COMPONENT SUMMARY\n// ============================================================================\n\n/**\n * Example entity compositions:\n *\n * Player Spaceship:\n * - Position, Velocity, Rotation, Scale\n * - MeshRef, Renderable\n * - Rigidbody, Collider\n * - Health, Weapon\n * - Thrust, Thruster, ShipState, Cargo\n * - MiningLaser\n * - Player (tag)\n * - Trail\n *\n * Enemy Drone:\n * - Position, Velocity, Rotation, Scale\n * - MeshRef, Renderable\n * - Rigidbody, Collider\n * - Health, Weapon\n * - EnemyAI, SeparationForce\n * - Enemy (tag)\n * - Lifetime\n *\n * Asteroid:\n * - Position, Velocity, Rotation, Scale\n * - MeshRef, Renderable\n * - Collider\n * - Mineable\n * - Asteroid (tag)\n *\n * Projectile:\n * - Position, Velocity, Rotation\n * - MeshRef\n * - Collider\n * - Projectile (tag)\n * - Lifetime\n */\n","/**\n * Physics System\n *\n * Newtonian physics for space game:\n * - Thrust accumulates velocity\n * - Objects keep moving (Newton's first law)\n * - Small friction for playability\n * - Simple sphere collision detection\n *\n * Based on js/modules/physics.js implementation.\n */\n\nimport {\n  Position,\n  Velocity,\n  AngularVelocity,\n  Rotation,\n  Rigidbody,\n  Force,\n  Torque,\n  Thrust,\n  Thruster,\n  Collider,\n} from '../components'\n\n// Physics constants (from physics.js)\nconst THRUST_FORCE = 0.5\nconst BOOST_MULTIPLIER = 4\nconst MAX_VELOCITY = 25.0\nconst FRICTION = 0.01\n\n/**\n * Apply thrust forces to entities with Thrust + Thruster components\n *\n * Converts thrust input into velocity changes using Newtonian physics.\n * Thrust is applied in local space, then rotated to world space.\n */\nexport function applyThrustSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    // Check if entity has required components\n    if (!hasThrust(eid) || !hasThruster(eid)) continue\n\n    // Calculate thrust vector in local space\n    let thrustX = 0\n    let thrustY = 0\n    let thrustZ = 0\n\n    const boostMult = Thrust.boost[eid] ? BOOST_MULTIPLIER : 1\n\n    if (Thrust.forward[eid]) {\n      thrustZ -= THRUST_FORCE * boostMult\n    }\n    if (Thrust.backward[eid]) {\n      thrustZ += THRUST_FORCE * boostMult\n    }\n    if (Thrust.left[eid]) {\n      thrustX -= THRUST_FORCE\n    }\n    if (Thrust.right[eid]) {\n      thrustX += THRUST_FORCE\n    }\n    if (Thrust.up[eid]) {\n      thrustY += THRUST_FORCE\n    }\n    if (Thrust.down[eid]) {\n      thrustY -= THRUST_FORCE\n    }\n\n    // Early exit if no thrust\n    if (thrustX === 0 && thrustY === 0 && thrustZ === 0) continue\n\n    // Rotate thrust vector from local to world space using quaternion\n    const rotatedThrust = rotateVector(\n      thrustX,\n      thrustY,\n      thrustZ,\n      Rotation.x[eid],\n      Rotation.y[eid],\n      Rotation.z[eid],\n      Rotation.w[eid]\n    )\n\n    // Apply thrust to velocity (scaled by delta time)\n    Velocity.x[eid] += rotatedThrust.x * dt\n    Velocity.y[eid] += rotatedThrust.y * dt\n    Velocity.z[eid] += rotatedThrust.z * dt\n\n    // Cap velocity at max (use Thruster.maxVelocity if set, else default)\n    const maxVel = Thruster.maxVelocity[eid] || MAX_VELOCITY\n    const velLength = Math.sqrt(\n      Velocity.x[eid] ** 2 + Velocity.y[eid] ** 2 + Velocity.z[eid] ** 2\n    )\n\n    if (velLength > maxVel) {\n      const scale = maxVel / velLength\n      Velocity.x[eid] *= scale\n      Velocity.y[eid] *= scale\n      Velocity.z[eid] *= scale\n    }\n  }\n}\n\n/**\n * Apply drag/friction to slow down entities\n *\n * Uses Rigidbody.drag if present, else uses default FRICTION.\n * This is space friction - not realistic but improves playability.\n */\nexport function applyDragSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    if (!hasVelocity(eid)) continue\n\n    // Get drag coefficient\n    let drag = FRICTION\n    if (hasRigidbody(eid)) {\n      drag = Rigidbody.drag[eid]\n    }\n\n    // Apply drag as exponential decay\n    const dragFactor = 1 - drag * dt\n    Velocity.x[eid] *= dragFactor\n    Velocity.y[eid] *= dragFactor\n    Velocity.z[eid] *= dragFactor\n\n    // Zero out very small velocities to prevent float drift\n    if (Math.abs(Velocity.x[eid]) < 0.001) Velocity.x[eid] = 0\n    if (Math.abs(Velocity.y[eid]) < 0.001) Velocity.y[eid] = 0\n    if (Math.abs(Velocity.z[eid]) < 0.001) Velocity.z[eid] = 0\n  }\n}\n\n/**\n * Integrate velocity into position (Newton's first law)\n *\n * Objects in motion stay in motion unless acted upon by a force.\n */\nexport function integratePositionSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    if (!hasPosition(eid) || !hasVelocity(eid)) continue\n\n    Position.x[eid] += Velocity.x[eid] * dt\n    Position.y[eid] += Velocity.y[eid] * dt\n    Position.z[eid] += Velocity.z[eid] * dt\n  }\n}\n\n/**\n * Simple sphere collision detection\n *\n * Checks all pairs of entities with Collider components.\n * On collision, applies separation force to push entities apart.\n *\n * TODO: Use spatial partitioning (octree/grid) for better performance\n */\nexport function collisionSystem(entities: number[]): void {\n  // Simple O(n^2) check - fine for small entity counts\n  // For larger games, use spatial partitioning\n  for (let i = 0; i < entities.length; i++) {\n    const eidA = entities[i]\n    if (!hasCollider(eidA) || !hasPosition(eidA)) continue\n\n    for (let j = i + 1; j < entities.length; j++) {\n      const eidB = entities[j]\n      if (!hasCollider(eidB) || !hasPosition(eidB)) continue\n\n      // Calculate distance between entities\n      const dx = Position.x[eidA] - Position.x[eidB]\n      const dy = Position.y[eidA] - Position.y[eidB]\n      const dz = Position.z[eidA] - Position.z[eidB]\n      const distSq = dx * dx + dy * dy + dz * dz\n\n      // Check collision\n      const radiusSum = Collider.radius[eidA] + Collider.radius[eidB]\n      const radiusSumSq = radiusSum * radiusSum\n\n      if (distSq < radiusSumSq && distSq > 0) {\n        // Collision detected - apply separation\n        const dist = Math.sqrt(distSq)\n        const overlap = radiusSum - dist\n\n        // Normalize separation vector\n        const nx = dx / dist\n        const ny = dy / dist\n        const nz = dz / dist\n\n        // Push entities apart by half the overlap each\n        const separation = overlap * 0.5\n\n        Position.x[eidA] += nx * separation\n        Position.y[eidA] += ny * separation\n        Position.z[eidA] += nz * separation\n\n        Position.x[eidB] -= nx * separation\n        Position.y[eidB] -= ny * separation\n        Position.z[eidB] -= nz * separation\n\n        // Apply bounce to velocity if entities have velocity\n        if (hasVelocity(eidA) && hasVelocity(eidB)) {\n          // Simple elastic collision response\n          const restitution = 0.5 // Bounciness factor\n\n          // Relative velocity\n          const vrelX = Velocity.x[eidA] - Velocity.x[eidB]\n          const vrelY = Velocity.y[eidA] - Velocity.y[eidB]\n          const vrelZ = Velocity.z[eidA] - Velocity.z[eidB]\n\n          // Velocity along collision normal\n          const vn = vrelX * nx + vrelY * ny + vrelZ * nz\n\n          // Don't resolve if velocities are separating\n          if (vn < 0) {\n            // Impulse magnitude\n            const impulse = -(1 + restitution) * vn\n\n            // Apply impulse\n            Velocity.x[eidA] += impulse * nx * 0.5\n            Velocity.y[eidA] += impulse * ny * 0.5\n            Velocity.z[eidA] += impulse * nz * 0.5\n\n            Velocity.x[eidB] -= impulse * nx * 0.5\n            Velocity.y[eidB] -= impulse * ny * 0.5\n            Velocity.z[eidB] -= impulse * nz * 0.5\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Integrate forces into velocity (F = ma)\n *\n * Converts accumulated forces into velocity changes.\n * Forces are cleared at the end of each frame.\n */\nexport function integrateForcesSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    if (!hasForce(eid) || !hasVelocity(eid) || !hasRigidbody(eid)) continue\n\n    // Skip kinematic entities\n    if (Rigidbody.isKinematic[eid]) continue\n\n    const mass = Rigidbody.mass[eid] || 1\n\n    // Calculate acceleration: a = F / m\n    const ax = Force.x[eid] / mass\n    const ay = Force.y[eid] / mass\n    const az = Force.z[eid] / mass\n\n    // Apply acceleration to velocity: v += a * dt\n    Velocity.x[eid] += ax * dt\n    Velocity.y[eid] += ay * dt\n    Velocity.z[eid] += az * dt\n\n    // Clear forces for next frame\n    Force.x[eid] = 0\n    Force.y[eid] = 0\n    Force.z[eid] = 0\n  }\n}\n\n/**\n * Integrate torque into angular velocity\n *\n * Converts accumulated torque into angular velocity changes.\n * Torque is cleared at the end of each frame.\n */\nexport function integrateTorqueSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    if (!hasTorque(eid) || !hasAngularVelocity(eid) || !hasRigidbody(eid))\n      continue\n\n    // Skip kinematic entities or frozen rotation\n    if (Rigidbody.isKinematic[eid] || Rigidbody.freezeRotation[eid]) continue\n\n    const mass = Rigidbody.mass[eid] || 1\n\n    // Calculate angular acceleration: α = τ / I\n    // For simplicity, use mass as moment of inertia\n    const alphax = Torque.x[eid] / mass\n    const alphay = Torque.y[eid] / mass\n    const alphaz = Torque.z[eid] / mass\n\n    // Apply angular acceleration to angular velocity: ω += α * dt\n    AngularVelocity.x[eid] += alphax * dt\n    AngularVelocity.y[eid] += alphay * dt\n    AngularVelocity.z[eid] += alphaz * dt\n\n    // Clear torque for next frame\n    Torque.x[eid] = 0\n    Torque.y[eid] = 0\n    Torque.z[eid] = 0\n  }\n}\n\n/**\n * Apply angular drag to angular velocity\n *\n * Similar to linear drag but for rotational motion.\n */\nexport function applyAngularDragSystem(entities: number[], dt: number): void {\n  for (const eid of entities) {\n    if (!hasAngularVelocity(eid) || !hasRigidbody(eid)) continue\n\n    const angularDrag = Rigidbody.angularDrag[eid]\n    if (angularDrag <= 0) continue\n\n    // Apply angular drag as exponential decay\n    const dragFactor = Math.max(0, 1 - angularDrag * dt)\n    AngularVelocity.x[eid] *= dragFactor\n    AngularVelocity.y[eid] *= dragFactor\n    AngularVelocity.z[eid] *= dragFactor\n\n    // Zero out very small angular velocities\n    if (Math.abs(AngularVelocity.x[eid]) < 0.001) AngularVelocity.x[eid] = 0\n    if (Math.abs(AngularVelocity.y[eid]) < 0.001) AngularVelocity.y[eid] = 0\n    if (Math.abs(AngularVelocity.z[eid]) < 0.001) AngularVelocity.z[eid] = 0\n  }\n}\n\n/**\n * Integrate angular velocity into rotation (quaternion update)\n *\n * Converts angular velocity (Euler) to quaternion rotation changes.\n * This matches the legacy MovementSystem implementation.\n */\nexport function integrateAngularVelocitySystem(\n  entities: number[],\n  dt: number\n): void {\n  for (const eid of entities) {\n    if (\n      !hasAngularVelocity(eid) ||\n      !hasRotation(eid) ||\n      !hasRigidbody(eid)\n    )\n      continue\n\n    // Skip if rotation is frozen\n    if (Rigidbody.freezeRotation[eid]) continue\n\n    // Get angular velocity\n    const angVelX = AngularVelocity.x[eid] * dt\n    const angVelY = AngularVelocity.y[eid] * dt\n    const angVelZ = AngularVelocity.z[eid] * dt\n\n    // Skip if no angular velocity\n    if (\n      Math.abs(angVelX) < 0.0001 &&\n      Math.abs(angVelY) < 0.0001 &&\n      Math.abs(angVelZ) < 0.0001\n    )\n      continue\n\n    // Convert angular velocity change to quaternion\n    // This uses the same approach as the legacy system:\n    // 1. Create Euler from angular change\n    // 2. Convert to quaternion\n    // 3. Multiply with current rotation\n    const rotationDelta = eulerToQuaternion(angVelX, angVelY, angVelZ)\n\n    // Apply rotation change: q_new = q_current * q_delta\n    const qx = Rotation.x[eid]\n    const qy = Rotation.y[eid]\n    const qz = Rotation.z[eid]\n    const qw = Rotation.w[eid]\n\n    const dx = rotationDelta.x\n    const dy = rotationDelta.y\n    const dz = rotationDelta.z\n    const dw = rotationDelta.w\n\n    // Quaternion multiplication\n    Rotation.x[eid] = qw * dx + qx * dw + qy * dz - qz * dy\n    Rotation.y[eid] = qw * dy - qx * dz + qy * dw + qz * dx\n    Rotation.z[eid] = qw * dz + qx * dy - qy * dx + qz * dw\n    Rotation.w[eid] = qw * dw - qx * dx - qy * dy - qz * dz\n\n    // Normalize quaternion to prevent drift\n    const len = Math.sqrt(\n      Rotation.x[eid] ** 2 +\n        Rotation.y[eid] ** 2 +\n        Rotation.z[eid] ** 2 +\n        Rotation.w[eid] ** 2\n    )\n    if (len > 0) {\n      Rotation.x[eid] /= len\n      Rotation.y[eid] /= len\n      Rotation.z[eid] /= len\n      Rotation.w[eid] /= len\n    }\n  }\n}\n\n/**\n * Main physics system - runs all physics subsystems\n *\n * @param entities - Array of entity IDs to process\n * @param dt - Delta time in seconds\n */\nexport function physicsSystem(entities: number[], dt: number): void {\n  // Normalize delta time to 60 FPS for consistent feel\n  const normalizedDt = dt * 60\n\n  // Run physics subsystems in order\n  integrateForcesSystem(entities, normalizedDt) // NEW: Force → velocity\n  integrateTorqueSystem(entities, normalizedDt) // NEW: Torque → angular velocity\n  applyThrustSystem(entities, normalizedDt)\n  applyDragSystem(entities, normalizedDt)\n  applyAngularDragSystem(entities, normalizedDt) // NEW: Angular drag\n  integratePositionSystem(entities, normalizedDt)\n  integrateAngularVelocitySystem(entities, normalizedDt) // NEW: Angular velocity → rotation\n  collisionSystem(entities)\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Rotate a vector by a quaternion\n */\nfunction rotateVector(\n  x: number,\n  y: number,\n  z: number,\n  qx: number,\n  qy: number,\n  qz: number,\n  qw: number\n): { x: number; y: number; z: number } {\n  // Quaternion rotation formula: v' = q * v * q^-1\n  // Optimized version using direct math\n\n  const ix = qw * x + qy * z - qz * y\n  const iy = qw * y + qz * x - qx * z\n  const iz = qw * z + qx * y - qy * x\n  const iw = -qx * x - qy * y - qz * z\n\n  return {\n    x: ix * qw + iw * -qx + iy * -qz - iz * -qy,\n    y: iy * qw + iw * -qy + iz * -qx - ix * -qz,\n    z: iz * qw + iw * -qz + ix * -qy - iy * -qx,\n  }\n}\n\n/**\n * Convert Euler angles (radians) to quaternion\n *\n * This matches the Three.js Quaternion.setFromEuler implementation.\n */\nfunction eulerToQuaternion(\n  x: number,\n  y: number,\n  z: number\n): { x: number; y: number; z: number; w: number } {\n  // Compute half angles\n  const cx = Math.cos(x * 0.5)\n  const cy = Math.cos(y * 0.5)\n  const cz = Math.cos(z * 0.5)\n  const sx = Math.sin(x * 0.5)\n  const sy = Math.sin(y * 0.5)\n  const sz = Math.sin(z * 0.5)\n\n  // XYZ order (Three.js default)\n  return {\n    x: sx * cy * cz + cx * sy * sz,\n    y: cx * sy * cz - sx * cy * sz,\n    z: cx * cy * sz + sx * sy * cz,\n    w: cx * cy * cz - sx * sy * sz,\n  }\n}\n\n/**\n * Component existence checks\n *\n * bitECS v0.4.0 doesn't have built-in component existence checks.\n * We check if the component data is non-zero or has been explicitly set.\n *\n * NOTE: This is a simple approach. For production, track component\n * assignment explicitly (e.g., Set<number> per component).\n */\nfunction hasPosition(eid: number): boolean {\n  return eid < Position.x.length\n}\n\nfunction hasVelocity(eid: number): boolean {\n  return eid < Velocity.x.length\n}\n\nfunction hasAngularVelocity(eid: number): boolean {\n  return eid < AngularVelocity.x.length\n}\n\nfunction hasRotation(eid: number): boolean {\n  return eid < Rotation.x.length\n}\n\nfunction hasForce(eid: number): boolean {\n  return eid < Force.x.length\n}\n\nfunction hasTorque(eid: number): boolean {\n  return eid < Torque.x.length\n}\n\nfunction hasThrust(eid: number): boolean {\n  return eid < Thrust.forward.length\n}\n\nfunction hasThruster(eid: number): boolean {\n  return eid < Thruster.thrustForce.length\n}\n\nfunction hasRigidbody(eid: number): boolean {\n  return eid < Rigidbody.mass.length\n}\n\nfunction hasCollider(eid: number): boolean {\n  return eid < Collider.radius.length\n}\n","/**\n * Render Sync System\n *\n * Bridges bitECS component data to Three.js mesh transforms.\n * This keeps game logic (bitECS) decoupled from rendering (Three.js).\n *\n * Architecture:\n * - bitECS owns all game state (Position, Rotation, Scale)\n * - Three.js meshes are pure rendering artifacts\n * - MeshRef component maps entity ID -> mesh index\n * - Mesh registry maps mesh index -> THREE.Object3D\n */\n\nimport * as THREE from 'three'\nimport {\n  Position,\n  Rotation,\n  Scale,\n  MeshRef,\n  Renderable,\n} from '../components'\n\n/**\n * Mesh registry\n *\n * Maps mesh index (from MeshRef.meshIndex[eid]) to Three.js Object3D.\n * This allows cache-friendly lookup without coupling ECS to Three.js.\n */\nexport type MeshRegistry = Map<number, THREE.Object3D>\n\n/**\n * Sync ECS transform data to Three.js meshes\n *\n * Copies Position, Rotation, Scale from ECS components to mesh transforms.\n * Updates visibility based on Renderable component.\n *\n * @param entities - Array of entity IDs to sync\n * @param meshRegistry - Map of mesh indices to Three.js objects\n */\nexport function renderSyncSystem(\n  entities: number[],\n  meshRegistry: MeshRegistry\n): void {\n  for (const eid of entities) {\n    // Skip entities without mesh reference\n    if (!hasMeshRef(eid)) continue\n\n    // Get mesh from registry\n    const meshIndex = MeshRef.meshIndex[eid]\n    const mesh = meshRegistry.get(meshIndex)\n\n    if (!mesh) {\n      // Mesh not found - might have been destroyed or not yet created\n      continue\n    }\n\n    // Sync position\n    if (hasPosition(eid)) {\n      mesh.position.set(\n        Position.x[eid],\n        Position.y[eid],\n        Position.z[eid]\n      )\n    }\n\n    // Sync rotation (quaternion)\n    if (hasRotation(eid)) {\n      mesh.quaternion.set(\n        Rotation.x[eid],\n        Rotation.y[eid],\n        Rotation.z[eid],\n        Rotation.w[eid]\n      )\n    }\n\n    // Sync scale\n    if (hasScale(eid)) {\n      mesh.scale.set(\n        Scale.x[eid],\n        Scale.y[eid],\n        Scale.z[eid]\n      )\n    }\n\n    // Sync visibility and shadow casting\n    if (hasRenderable(eid)) {\n      mesh.visible = Renderable.visible[eid] !== 0\n\n      // Only set shadow properties if mesh supports them\n      if ('castShadow' in mesh) {\n        mesh.castShadow = Renderable.castShadow[eid] !== 0\n      }\n      if ('receiveShadow' in mesh) {\n        mesh.receiveShadow = Renderable.receiveShadow[eid] !== 0\n      }\n    }\n  }\n}\n\n/**\n * Create a mesh registry entry\n *\n * Helper to add a Three.js object to the registry and return its index.\n *\n * @param registry - Mesh registry\n * @param mesh - Three.js object to register\n * @returns Mesh index to store in MeshRef.meshIndex[eid]\n */\nexport function registerMesh(\n  registry: MeshRegistry,\n  mesh: THREE.Object3D\n): number {\n  // Find next available index\n  let index = 0\n  while (registry.has(index)) {\n    index++\n  }\n\n  registry.set(index, mesh)\n  return index\n}\n\n/**\n * Remove a mesh from the registry\n *\n * @param registry - Mesh registry\n * @param meshIndex - Index to remove\n */\nexport function unregisterMesh(\n  registry: MeshRegistry,\n  meshIndex: number\n): void {\n  registry.delete(meshIndex)\n}\n\n/**\n * Create a new mesh registry\n */\nexport function createMeshRegistry(): MeshRegistry {\n  return new Map()\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Component existence checks\n *\n * Simple bounds check. For production, use explicit component tracking.\n */\nfunction hasPosition(eid: number): boolean {\n  return eid < Position.x.length\n}\n\nfunction hasRotation(eid: number): boolean {\n  return eid < Rotation.x.length\n}\n\nfunction hasScale(eid: number): boolean {\n  return eid < Scale.x.length\n}\n\nfunction hasMeshRef(eid: number): boolean {\n  return eid < MeshRef.meshIndex.length\n}\n\nfunction hasRenderable(eid: number): boolean {\n  return eid < Renderable.visible.length\n}\n\n// ============================================================================\n// USAGE EXAMPLE\n// ============================================================================\n\n/**\n * Example integration into game loop:\n *\n * ```typescript\n * import { world } from './world'\n * import { physicsSystem } from './systems/physicsSystem'\n * import { renderSyncSystem, createMeshRegistry } from './systems/renderSyncSystem'\n *\n * const meshRegistry = createMeshRegistry()\n * const entities: number[] = [] // Track all entities\n *\n * function gameLoop(dt: number) {\n *   // Update game logic\n *   physicsSystem(entities, dt)\n *\n *   // Sync to render\n *   renderSyncSystem(entities, meshRegistry)\n *\n *   // Render Three.js scene\n *   renderer.render(scene, camera)\n * }\n * ```\n *\n * When creating an entity with a mesh:\n *\n * ```typescript\n * const eid = createGameEntity()\n *\n * // Set ECS components\n * Position.x[eid] = 0\n * Position.y[eid] = 0\n * Position.z[eid] = 0\n *\n * // Create Three.js mesh\n * const mesh = new THREE.Mesh(geometry, material)\n * scene.add(mesh)\n *\n * // Register mesh and link to entity\n * const meshIndex = registerMesh(meshRegistry, mesh)\n * MeshRef.meshIndex[eid] = meshIndex\n * Renderable.visible[eid] = 1\n * ```\n */\n","/**\n * Combat System (bitECS)\n *\n * Ported from legacy combat system for projectile collisions, damage,\n * shield regeneration, and lifetime handling.\n */\n\nimport { Collider, Health, Lifetime, Position, Weapon } from '../components'\n\nexport type CollisionEvent = {\n  projectileEid: number\n  targetEid: number\n  hitPosition: { x: number; y: number; z: number }\n}\n\n/**\n * Detect collisions between projectiles and targets using sphere collision.\n */\nexport function projectileCollisionSystem(\n  projectiles: number[],\n  targets: number[]\n): CollisionEvent[] {\n  const events: CollisionEvent[] = []\n\n  for (let i = 0; i < projectiles.length; i++) {\n    const projectileEid = projectiles[i]\n\n    const projX = Position.x[projectileEid]\n    const projY = Position.y[projectileEid]\n    const projZ = Position.z[projectileEid]\n    const projRadius = Collider.radius[projectileEid]\n\n    for (let j = 0; j < targets.length; j++) {\n      const targetEid = targets[j]\n\n      if (targetEid === projectileEid) continue\n\n      const dx = projX - Position.x[targetEid]\n      const dy = projY - Position.y[targetEid]\n      const dz = projZ - Position.z[targetEid]\n      const distSq = dx * dx + dy * dy + dz * dz\n\n      const radiusSum = projRadius + Collider.radius[targetEid]\n      const radiusSumSq = radiusSum * radiusSum\n\n      if (distSq <= radiusSumSq) {\n        let hitX = Position.x[targetEid]\n        let hitY = Position.y[targetEid]\n        let hitZ = Position.z[targetEid]\n\n        if (distSq > 0) {\n          const dist = Math.sqrt(distSq)\n          const nx = dx / dist\n          const ny = dy / dist\n          const nz = dz / dist\n          const targetRadius = Collider.radius[targetEid]\n\n          hitX += nx * targetRadius\n          hitY += ny * targetRadius\n          hitZ += nz * targetRadius\n        }\n\n        events.push({\n          projectileEid,\n          targetEid,\n          hitPosition: { x: hitX, y: hitY, z: hitZ },\n        })\n      }\n    }\n  }\n\n  return events\n}\n\n/**\n * Apply damage from projectile hits to targets.\n */\nexport function damageApplicationSystem(events: CollisionEvent[]): void {\n  for (let i = 0; i < events.length; i++) {\n    const { projectileEid, targetEid } = events[i]\n\n    const baseDamage = Weapon.damage[projectileEid]\n    if (baseDamage <= 0) continue\n\n    const resistance = clamp01(Health.damageResistance[targetEid])\n    const damage = baseDamage * (1 - resistance)\n\n    if (damage <= 0) continue\n\n    const currentShield = Health.shield[targetEid]\n    if (currentShield > 0) {\n      if (damage <= currentShield) {\n        Health.shield[targetEid] = currentShield - damage\n        Health.timeSinceLastDamage[targetEid] = 0\n        continue\n      }\n\n      const remaining = damage - currentShield\n      Health.shield[targetEid] = 0\n      Health.current[targetEid] = Math.max(\n        0,\n        Health.current[targetEid] - remaining\n      )\n      Health.timeSinceLastDamage[targetEid] = 0\n      continue\n    }\n\n    Health.current[targetEid] = Math.max(\n      0,\n      Health.current[targetEid] - damage\n    )\n    Health.timeSinceLastDamage[targetEid] = 0\n  }\n}\n\n/**\n * Regenerate shields for entities over time.\n */\nexport function shieldRegenSystem(entities: number[], dt: number): void {\n  for (let i = 0; i < entities.length; i++) {\n    const eid = entities[i]\n\n    Health.timeSinceLastDamage[eid] += dt\n\n    if (Health.timeSinceLastDamage[eid] > Health.shieldRegenDelay[eid]) {\n      if (Health.shield[eid] < Health.maxShield[eid]) {\n        const regen = Health.shieldRegenRate[eid] * dt\n        Health.shield[eid] = Math.min(\n          Health.maxShield[eid],\n          Health.shield[eid] + regen\n        )\n      }\n    }\n  }\n}\n\n/**\n * Age entities with Lifetime component and return expired IDs.\n */\nexport function lifetimeSystem(entities: number[], dt: number): number[] {\n  const expired: number[] = []\n\n  for (let i = 0; i < entities.length; i++) {\n    const eid = entities[i]\n    Lifetime.age[eid] += dt\n\n    const maxAge = Lifetime.maxAge[eid]\n    if (maxAge > 0 && Lifetime.age[eid] > maxAge) {\n      expired.push(eid)\n    }\n  }\n\n  return expired\n}\n\nfunction clamp01(value: number): number {\n  if (value <= 0) return 0\n  if (value >= 1) return 1\n  return value\n}\n","/**\n * Enemy AI System (bitECS)\n *\n * Ports enemy AI behavior from legacy ECS to bitECS.\n * Handles:\n * - Enemy detection of player (range check)\n * - Pursuit behavior (move toward player)\n * - Spiral movement patterns (sinusoidal offset)\n * - Separation behavior (flocking avoidance)\n * - Difficulty scaling (stats increase over time)\n *\n * Based on js/systems/combat/enemySystem.js and js/components/combat/enemyAI.js\n */\n\nimport {\n  Position,\n  Velocity,\n  Rotation,\n  EnemyAI,\n  SeparationForce,\n  Health,\n  Lifetime,\n  Collider,\n} from '../components'\n\n// Constants from legacy system\nconst SEPARATION_FORCE_MAGNITUDE = 150\nconst SEPARATION_THRESHOLD_MULTIPLIER = 2.5\nconst COLLISION_DISTANCE = 75 // Kamikaze attack distance\n\n/**\n * Enemy Detection System\n *\n * Checks if enemies detect the player based on distance.\n * Sets EnemyAI.playerFound flag when player is within detection range.\n *\n * @param enemies - Array of enemy entity IDs\n * @param playerEid - Player entity ID (or -1 if no player)\n */\nexport function enemyDetectionSystem(\n  enemies: number[],\n  playerEid: number\n): void {\n  if (playerEid === -1) return\n\n  // Get player position\n  const playerX = Position.x[playerEid]\n  const playerY = Position.y[playerEid]\n  const playerZ = Position.z[playerEid]\n\n  for (const eid of enemies) {\n    // Skip if already found player\n    if (EnemyAI.playerFound[eid]) continue\n\n    // Calculate distance to player\n    const dx = Position.x[eid] - playerX\n    const dy = Position.y[eid] - playerY\n    const dz = Position.z[eid] - playerZ\n    const distSq = dx * dx + dy * dy + dz * dz\n\n    const detectionRangeSq = EnemyAI.detectionRange[eid] ** 2\n\n    if (distSq < detectionRangeSq) {\n      EnemyAI.playerFound[eid] = 1\n    }\n  }\n}\n\n/**\n * Enemy Pursuit System\n *\n * Moves enemies toward the player with spiral movement patterns.\n * Implements different movement behaviors based on enemy subtype:\n * - Standard drones: Spiral approach with sinusoidal offset\n * - Heavy drones: Slow, direct approach\n * - Swift drones: Fast zigzag approach\n *\n * @param enemies - Array of enemy entity IDs\n * @param playerEid - Player entity ID (or -1 if no player)\n * @param dt - Delta time in seconds\n */\nexport function enemyPursuitSystem(\n  enemies: number[],\n  playerEid: number,\n  dt: number\n): void {\n  if (playerEid === -1) return\n\n  const playerX = Position.x[playerEid]\n  const playerY = Position.y[playerEid]\n  const playerZ = Position.z[playerEid]\n\n  for (const eid of enemies) {\n    // Only pursue if player has been detected\n    if (!EnemyAI.playerFound[eid]) continue\n\n    // Update time alive\n    EnemyAI.timeAlive[eid] += dt\n\n    // Calculate base direction to player\n    const dx = playerX - Position.x[eid]\n    const dy = playerY - Position.y[eid]\n    const dz = playerZ - Position.z[eid]\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n    if (dist === 0) continue\n\n    // Normalize base direction\n    const baseDirX = dx / dist\n    const baseDirY = dy / dist\n    const baseDirZ = dz / dist\n\n    // Apply movement based on subtype\n    const subtype = EnemyAI.subtype[eid]\n    const speed = EnemyAI.speed[eid]\n\n    if (subtype === 0) {\n      // Standard drone: spiral approach\n      applyStandardDroneMovement(\n        eid,\n        baseDirX,\n        baseDirY,\n        baseDirZ,\n        dist,\n        speed,\n        dt\n      )\n    } else if (subtype === 1) {\n      // Heavy drone: slow, direct approach\n      applyHeavyDroneMovement(eid, baseDirX, baseDirY, baseDirZ, speed, dt)\n    } else if (subtype === 2) {\n      // Swift drone: fast zigzag\n      applySwiftDroneMovement(\n        eid,\n        baseDirX,\n        baseDirY,\n        baseDirZ,\n        dist,\n        speed,\n        dt\n      )\n    }\n\n    // Apply separation force influence\n    applySeparationInfluence(eid, speed, dt)\n\n    // Update rotation to face player (simple LookAt approximation)\n    updateRotationTowardsPlayer(eid, baseDirX, baseDirY, baseDirZ)\n  }\n}\n\n/**\n * Standard drone movement: spiral approach with sinusoidal offset\n */\nfunction applyStandardDroneMovement(\n  eid: number,\n  dirX: number,\n  dirY: number,\n  dirZ: number,\n  distToPlayer: number,\n  speed: number,\n  _dt: number\n): void {\n  void _dt\n\n  const amplitude = EnemyAI.spiralAmplitude[eid]\n  const frequency = EnemyAI.spiralFrequency[eid]\n  const phase = EnemyAI.spiralPhase[eid]\n  const timeAlive = EnemyAI.timeAlive[eid]\n\n  // Dampen amplitude based on distance (closer = tighter spiral)\n  let effectiveAmplitude = amplitude\n  if (distToPlayer < 500) {\n    effectiveAmplitude = amplitude * (distToPlayer / 500)\n  }\n\n  // Calculate spiral offset using time and phase\n  const spiralTime = timeAlive * frequency + phase\n  const spiralOffset = Math.sin(spiralTime) * effectiveAmplitude\n\n  // Create orthogonal basis for spiral movement\n  // Up vector\n  const upX = 0\n  const upY = 1\n  const upZ = 0\n\n  // Right vector (cross product: dir × up)\n  let rightX = dirY * upZ - dirZ * upY\n  let rightY = dirZ * upX - dirX * upZ\n  let rightZ = dirX * upY - dirY * upX\n\n  // Normalize right vector\n  const rightLen = Math.sqrt(\n    rightX * rightX + rightY * rightY + rightZ * rightZ\n  )\n  if (rightLen > 0.1) {\n    rightX /= rightLen\n    rightY /= rightLen\n    rightZ /= rightLen\n  } else {\n    // Fallback if direction is parallel to up\n    rightX = 1\n    rightY = 0\n    rightZ = 0\n  }\n\n  // Apply base movement toward player\n  Velocity.x[eid] = dirX * speed\n  Velocity.y[eid] = dirY * speed\n  Velocity.z[eid] = dirZ * speed\n\n  // Add spiral offset perpendicular to movement\n  Velocity.x[eid] += rightX * spiralOffset\n  Velocity.y[eid] += rightY * spiralOffset\n  Velocity.z[eid] += rightZ * spiralOffset\n}\n\n/**\n * Heavy drone movement: slow, direct approach\n */\nfunction applyHeavyDroneMovement(\n  eid: number,\n  dirX: number,\n  dirY: number,\n  dirZ: number,\n  speed: number,\n  _dt: number\n): void {\n  void _dt\n\n  // Heavy drones move at 70% speed, no spiral\n  const heavySpeed = speed * 0.7\n\n  Velocity.x[eid] = dirX * heavySpeed\n  Velocity.y[eid] = dirY * heavySpeed\n  Velocity.z[eid] = dirZ * heavySpeed\n}\n\n/**\n * Swift drone movement: fast zigzag approach\n */\nfunction applySwiftDroneMovement(\n  eid: number,\n  dirX: number,\n  dirY: number,\n  dirZ: number,\n  _distToPlayer: number,\n  speed: number,\n  _dt: number\n): void {\n  void _distToPlayer\n  void _dt\n\n  // Swift drones move at 150% speed with aggressive zigzag\n  const swiftSpeed = speed * 1.5\n  const timeAlive = EnemyAI.timeAlive[eid]\n\n  // Calculate zigzag offset (faster frequency than standard)\n  const zigzagFrequency = 3.0\n  const zigzagAmplitude = 80\n  const zigzagOffset = Math.sin(timeAlive * zigzagFrequency) * zigzagAmplitude\n\n  // Create right vector for zigzag\n  const upX = 0\n  const upY = 1\n  const upZ = 0\n\n  let rightX = dirY * upZ - dirZ * upY\n  let rightY = dirZ * upX - dirX * upZ\n  let rightZ = dirX * upY - dirY * upX\n\n  const rightLen = Math.sqrt(\n    rightX * rightX + rightY * rightY + rightZ * rightZ\n  )\n  if (rightLen > 0.1) {\n    rightX /= rightLen\n    rightY /= rightLen\n    rightZ /= rightLen\n  } else {\n    rightX = 1\n    rightY = 0\n    rightZ = 0\n  }\n\n  // Apply swift movement with zigzag\n  Velocity.x[eid] = dirX * swiftSpeed + rightX * zigzagOffset\n  Velocity.y[eid] = dirY * swiftSpeed + rightY * zigzagOffset\n  Velocity.z[eid] = dirZ * swiftSpeed + rightZ * zigzagOffset\n}\n\n/**\n * Apply separation force influence to velocity\n */\nfunction applySeparationInfluence(\n  eid: number,\n  speed: number,\n  _dt: number\n): void {\n  void _dt\n\n  const sepX = SeparationForce.x[eid]\n  const sepY = SeparationForce.y[eid]\n  const sepZ = SeparationForce.z[eid]\n\n  const sepLengthSq = sepX * sepX + sepY * sepY + sepZ * sepZ\n\n  if (sepLengthSq > 0.01) {\n    const sepLength = Math.sqrt(sepLengthSq)\n    const influence = EnemyAI.separationInfluence[eid]\n\n    // Dynamic influence based on separation force strength\n    const dynamicInfluence =\n      influence * (0.5 + 0.5 * Math.min(1.0, sepLength / 100))\n\n    // Lerp velocity toward separation direction\n    const targetVelX = (sepX / sepLength) * speed\n    const targetVelY = (sepY / sepLength) * speed\n    const targetVelZ = (sepZ / sepLength) * speed\n\n    Velocity.x[eid] += (targetVelX - Velocity.x[eid]) * dynamicInfluence\n    Velocity.y[eid] += (targetVelY - Velocity.y[eid]) * dynamicInfluence\n    Velocity.z[eid] += (targetVelZ - Velocity.z[eid]) * dynamicInfluence\n  }\n}\n\n/**\n * Update rotation quaternion to face player (simplified LookAt)\n */\nfunction updateRotationTowardsPlayer(\n  eid: number,\n  dirX: number,\n  dirY: number,\n  dirZ: number\n): void {\n  // Simple quaternion from direction vector\n  // This is a simplified version - for production, use proper quaternion LookAt\n\n  // Calculate yaw and pitch from direction\n  const yaw = Math.atan2(dirX, dirZ)\n  const pitch = Math.atan2(dirY, Math.sqrt(dirX * dirX + dirZ * dirZ))\n\n  // Convert to quaternion (Euler to quaternion, YXZ order)\n  const cy = Math.cos(yaw * 0.5)\n  const sy = Math.sin(yaw * 0.5)\n  const cp = Math.cos(pitch * 0.5)\n  const sp = Math.sin(pitch * 0.5)\n\n  Rotation.x[eid] = sp * cy\n  Rotation.y[eid] = sy * cp\n  Rotation.z[eid] = -sp * sy\n  Rotation.w[eid] = cp * cy\n}\n\n/**\n * Enemy Separation System\n *\n * Calculates separation forces between nearby enemies to prevent clustering.\n * Uses spatial partitioning for efficiency (O(n) instead of O(n^2)).\n *\n * @param enemies - Array of enemy entity IDs\n */\nexport function enemySeparationSystem(enemies: number[]): void {\n  // Clear separation forces\n  for (const eid of enemies) {\n    SeparationForce.x[eid] = 0\n    SeparationForce.y[eid] = 0\n    SeparationForce.z[eid] = 0\n  }\n\n  // Simple O(n^2) separation check\n  // For production, use spatial partitioning (octree/grid)\n  for (let i = 0; i < enemies.length; i++) {\n    const eidA = enemies[i]\n    const radiusA = Collider.radius[eidA]\n    const threshold = radiusA * SEPARATION_THRESHOLD_MULTIPLIER\n\n    for (let j = i + 1; j < enemies.length; j++) {\n      const eidB = enemies[j]\n\n      // Calculate distance\n      const dx = Position.x[eidA] - Position.x[eidB]\n      const dy = Position.y[eidA] - Position.y[eidB]\n      const dz = Position.z[eidA] - Position.z[eidB]\n      const distSq = dx * dx + dy * dy + dz * dz\n      const dist = Math.sqrt(distSq)\n\n      // Check if within separation threshold\n      if (dist < threshold && dist > 0) {\n        // Calculate separation force strength\n        const strength = (threshold - dist) / threshold\n\n        // Normalize separation vector\n        const nx = dx / dist\n        const ny = dy / dist\n        const nz = dz / dist\n\n        // Apply separation force\n        const forceX = nx * strength * SEPARATION_FORCE_MAGNITUDE\n        const forceY = ny * strength * SEPARATION_FORCE_MAGNITUDE\n        const forceZ = nz * strength * SEPARATION_FORCE_MAGNITUDE\n\n        // Add to both entities (opposite directions)\n        SeparationForce.x[eidA] += forceX\n        SeparationForce.y[eidA] += forceY\n        SeparationForce.z[eidA] += forceZ\n\n        SeparationForce.x[eidB] -= forceX\n        SeparationForce.y[eidB] -= forceY\n        SeparationForce.z[eidB] -= forceZ\n      }\n    }\n  }\n}\n\n/**\n * Difficulty Scaling System\n *\n * Scales enemy parameters based on game time or difficulty settings.\n * Modifies enemy stats in-place to increase difficulty over time.\n *\n * This system reads from global game state (window.game) to get difficulty parameters.\n *\n * @param enemies - Array of enemy entity IDs\n * @param gameTime - Total game time in seconds\n */\nexport function difficultyScalingSystem(\n  enemies: number[],\n  _gameTime: number\n): void {\n  void _gameTime\n\n  // Check if global difficulty manager exists\n  if (\n    typeof window === 'undefined' ||\n    !window.game ||\n    !window.game.difficultyManager\n  ) {\n    return\n  }\n\n  const diffManager = window.game.difficultyManager\n\n  // Check if horde mode is active\n  const isHordeMode = window.game.isHordeActive || false\n\n  if (isHordeMode && window.game.hordeSurvivalTime !== undefined) {\n    // Horde mode scaling\n    const survivalTime = window.game.hordeSurvivalTime / 1000\n    const minutesPassed = survivalTime / 60\n\n    // Health multiplier\n    const healthMultiplier = 1 + minutesPassed * 0.5\n\n    // Damage multiplier\n    const damageMultiplier = 1 + minutesPassed * 0.3\n\n    // Speed multiplier\n    const speedMultiplier = 1 + minutesPassed * 0.2\n\n    // Apply scaling to all enemies\n    for (const eid of enemies) {\n      // Scale damage\n      EnemyAI.damage[eid] = Math.floor(15 * damageMultiplier) // Base damage 15\n\n      // Scale speed\n      EnemyAI.speed[eid] = 700 * speedMultiplier // Base speed 700\n\n      // Scale health (if enemy has Health component)\n      if (Health.max[eid] > 0) {\n        const baseHealth = 20\n        Health.max[eid] = Math.floor(baseHealth * healthMultiplier)\n        // Don't reduce current health, only increase max\n        if (Health.current[eid] > Health.max[eid]) {\n          Health.current[eid] = Health.max[eid]\n        }\n      }\n    }\n  } else if (diffManager.params) {\n    // Normal difficulty scaling (read from difficulty manager params)\n    // This system doesn't modify params - it reads them\n    // Spawning logic uses diffManager.params.maxEnemies and spawnInterval\n  }\n}\n\n/**\n * Enemy Collision Attack System\n *\n * Checks for kamikaze attacks when enemies get close to player.\n * Destroys the enemy and damages the player on collision.\n *\n * @param enemies - Array of enemy entity IDs\n * @param playerEid - Player entity ID (or -1 if no player)\n */\nexport function enemyCollisionAttackSystem(\n  enemies: number[],\n  playerEid: number\n): void {\n  if (playerEid === -1) return\n\n  const playerX = Position.x[playerEid]\n  const playerY = Position.y[playerEid]\n  const playerZ = Position.z[playerEid]\n\n  for (const eid of enemies) {\n    // Calculate distance to player\n    const dx = Position.x[eid] - playerX\n    const dy = Position.y[eid] - playerY\n    const dz = Position.z[eid] - playerZ\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n    // Check for collision\n    if (dist < COLLISION_DISTANCE) {\n      // Apply damage to player\n      const damage = EnemyAI.damage[eid]\n\n      // Update player health\n      if (Health.current[playerEid] > 0) {\n        // Trigger player damage vibration\n        if (typeof window !== 'undefined' && (window as any).mainMessageBus) {\n          (window as any).mainMessageBus.publish('input.vibrate', { intensity: 0.6, duration: 150 });\n        }\n\n        // First check shields\n        if (Health.shield[playerEid] > 0) {\n          if (Health.shield[playerEid] >= damage) {\n            Health.shield[playerEid] -= damage\n          } else {\n            const remainingDamage = damage - Health.shield[playerEid]\n            Health.shield[playerEid] = 0\n            Health.current[playerEid] -= remainingDamage\n          }\n        } else {\n          // Directly damage health\n          Health.current[playerEid] -= damage\n        }\n\n        // Clamp health to 0\n        if (Health.current[playerEid] < 0) {\n          Health.current[playerEid] = 0\n        }\n      }\n\n      // Mark enemy for destruction (set Lifetime to expire immediately)\n      if (Lifetime.maxAge[eid] > 0) {\n        Lifetime.age[eid] = Lifetime.maxAge[eid]\n      }\n\n      // TODO: Publish explosion VFX event when message bus is integrated\n      // TODO: Play explosion sound when audio system is integrated\n    }\n  }\n}\n","import { createWorld, addEntity, removeEntity } from 'bitecs'\n\n// Create the game world\nexport const world = createWorld()\n\n// Helper to create a new entity\nexport function createGameEntity() {\n  return addEntity(world)\n}\n\n// Helper to remove an entity\nexport function removeGameEntity(eid: number) {\n  return removeEntity(world, eid)\n}\n","/**\n * bitECS System Runner\n *\n * Integrates bitECS systems into the game loop.\n * Runs PARALLEL to legacy ECS - both systems execute each frame.\n */\n\nimport * as THREE from 'three'\nimport {\n  applyThrustSystem,\n  applyDragSystem,\n  integratePositionSystem,\n  collisionSystem,\n  renderSyncSystem,\n  createMeshRegistry,\n  registerMesh,\n  type MeshRegistry,\n  enemyDetectionSystem,\n  enemyPursuitSystem,\n  enemySeparationSystem,\n  difficultyScalingSystem,\n  enemyCollisionAttackSystem,\n  projectileCollisionSystem,\n  damageApplicationSystem,\n  shieldRegenSystem,\n  lifetimeSystem,\n} from './index'\nimport {\n  Position,\n  Velocity,\n  Rotation,\n  Scale,\n  MeshRef,\n  Renderable,\n} from '../components'\nimport { createGameEntity } from '../world'\n\n// Track all bitECS entities\nconst entities: number[] = []\n\n// Track entity categories for systems\nconst enemies: number[] = []\nconst projectiles: number[] = []\nconst entitiesWithHealth: number[] = []\n\n// Track player entity (if any)\nlet playerEntityId = -1\n\n// Track game time for difficulty scaling\nlet gameTime = 0\n\n// Mesh registry for render sync\nlet meshRegistry: MeshRegistry | null = null\n\n/**\n * Initialize bitECS systems\n *\n * Creates the mesh registry and a test entity to verify integration.\n * This test entity has a small velocity and should move across the screen.\n */\nexport function initECS(scene?: THREE.Scene): void {\n  // Create mesh registry\n  meshRegistry = createMeshRegistry()\n\n  // Create test entity to validate the integration\n  const testEntity = createGameEntity()\n  entities.push(testEntity)\n\n  // Set position at origin\n  Position.x[testEntity] = 0\n  Position.y[testEntity] = 5\n  Position.z[testEntity] = 0\n\n  // Give it a small velocity (should drift slowly)\n  Velocity.x[testEntity] = 0.5\n  Velocity.y[testEntity] = 0\n  Velocity.z[testEntity] = 0\n\n  // Set rotation to identity quaternion\n  Rotation.x[testEntity] = 0\n  Rotation.y[testEntity] = 0\n  Rotation.z[testEntity] = 0\n  Rotation.w[testEntity] = 1\n\n  // Set scale\n  Scale.x[testEntity] = 1\n  Scale.y[testEntity] = 1\n  Scale.z[testEntity] = 1\n\n  // Create a simple test mesh (bright green cube)\n  if (scene) {\n    const geometry = new THREE.BoxGeometry(1, 1, 1)\n    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n    const mesh = new THREE.Mesh(geometry, material)\n    scene.add(mesh)\n\n    // Register mesh and link to entity\n    const meshIndex = registerMesh(meshRegistry, mesh)\n    MeshRef.meshIndex[testEntity] = meshIndex\n    Renderable.visible[testEntity] = 1\n    Renderable.castShadow[testEntity] = 0\n    Renderable.receiveShadow[testEntity] = 0\n  }\n\n  console.log('[bitECS] Initialized - test entity created')\n}\n\n/**\n * Update bitECS systems\n *\n * Runs all bitECS systems in order:\n * 1. Physics systems (thrust, drag, integration)\n * 2. AI systems (detection, pursuit, separation, difficulty, collision attack)\n * 3. Combat systems (projectile collision, damage, shield regen, lifetime)\n * 4. Collision system (general collision detection)\n * 5. Render sync (ECS -> Three.js)\n *\n * @param deltaTime - Time step in seconds\n */\nexport function updateECS(deltaTime: number): void {\n  if (!meshRegistry) {\n    console.error('[bitECS] updateECS called before initECS')\n    return\n  }\n\n  // Skip if no entities\n  if (entities.length === 0) return\n\n  // Update game time\n  gameTime += deltaTime\n\n  // 1. Physics systems\n  applyThrustSystem(entities, deltaTime)\n  applyDragSystem(entities, deltaTime)\n  integratePositionSystem(entities, deltaTime)\n\n  // 2. Enemy AI systems\n  if (enemies.length > 0) {\n    enemyDetectionSystem(enemies, playerEntityId)\n    enemyPursuitSystem(enemies, playerEntityId, deltaTime)\n    enemySeparationSystem(enemies)\n    difficultyScalingSystem(enemies, gameTime)\n    enemyCollisionAttackSystem(enemies, playerEntityId)\n  }\n\n  // 3. Combat systems\n  if (projectiles.length > 0) {\n    // Detect projectile-enemy collisions\n    if (enemies.length > 0) {\n      const collisionEvents = projectileCollisionSystem(projectiles, enemies)\n      if (collisionEvents.length > 0) {\n        damageApplicationSystem(collisionEvents)\n      }\n    }\n\n    // Detect projectile-player collisions\n    if (playerEntityId !== -1) {\n      const playerHits = projectileCollisionSystem(projectiles, [playerEntityId])\n      if (playerHits.length > 0) {\n        damageApplicationSystem(playerHits)\n        \n        // Trigger player damage vibration\n        if ((globalThis as any).mainMessageBus) {\n          (globalThis as any).mainMessageBus.publish('input.vibrate', { intensity: 0.6, duration: 150 });\n        }\n      }\n    }\n  }\n\n  // Shield regeneration for all entities with health\n  if (entitiesWithHealth.length > 0) {\n    shieldRegenSystem(entitiesWithHealth, deltaTime)\n  }\n\n  // Lifetime system for all entities (returns expired IDs)\n  const expiredEntities = lifetimeSystem(entities, deltaTime)\n\n  // Clean up expired entities\n  for (const eid of expiredEntities) {\n    removeTrackedEntity(eid)\n    // TODO: Trigger cleanup/removal from scene when entity management is integrated\n  }\n\n  // 4. General collision system\n  collisionSystem(entities)\n\n  // 5. Sync ECS data to Three.js meshes (must be last)\n  renderSyncSystem(entities, meshRegistry)\n}\n\n/**\n * Get the mesh registry (for external entity creation)\n */\nexport function getMeshRegistry(): MeshRegistry | null {\n  return meshRegistry\n}\n\n/**\n * Add an entity to the tracked list\n */\nexport function addTrackedEntity(eid: number): void {\n  if (entities.indexOf(eid) === -1) {\n    entities.push(eid)\n  }\n}\n\n/**\n * Remove an entity from the tracked list and all category lists\n */\nexport function removeTrackedEntity(eid: number): void {\n  // Remove from main entities list\n  const index = entities.indexOf(eid)\n  if (index !== -1) {\n    entities.splice(index, 1)\n  }\n\n  // Remove from category lists\n  const enemyIndex = enemies.indexOf(eid)\n  if (enemyIndex !== -1) {\n    enemies.splice(enemyIndex, 1)\n  }\n\n  const projectileIndex = projectiles.indexOf(eid)\n  if (projectileIndex !== -1) {\n    projectiles.splice(projectileIndex, 1)\n  }\n\n  const healthIndex = entitiesWithHealth.indexOf(eid)\n  if (healthIndex !== -1) {\n    entitiesWithHealth.splice(healthIndex, 1)\n  }\n\n  // Clear player reference if it's the player\n  if (eid === playerEntityId) {\n    playerEntityId = -1\n  }\n}\n\n/**\n * Add an entity to the enemy category\n */\nexport function addEnemy(eid: number): void {\n  addTrackedEntity(eid)\n  if (enemies.indexOf(eid) === -1) {\n    enemies.push(eid)\n  }\n}\n\n/**\n * Add an entity to the projectile category\n */\nexport function addProjectile(eid: number): void {\n  addTrackedEntity(eid)\n  if (projectiles.indexOf(eid) === -1) {\n    projectiles.push(eid)\n  }\n}\n\n/**\n * Add an entity to the health category\n */\nexport function addEntityWithHealth(eid: number): void {\n  addTrackedEntity(eid)\n  if (entitiesWithHealth.indexOf(eid) === -1) {\n    entitiesWithHealth.push(eid)\n  }\n}\n\n/**\n * Set the player entity ID\n */\nexport function setPlayerEntity(eid: number): void {\n  playerEntityId = eid\n  addTrackedEntity(eid)\n  addEntityWithHealth(eid)\n}\n\n/**\n * Get the enemies array (for external systems like UI)\n */\nexport function getEnemies(): number[] {\n  return enemies\n}\n\n/**\n * Get the player entity ID (for external systems like UI)\n */\nexport function getPlayerEntity(): number {\n  return playerEntityId\n}\n"],"names":["Position","Velocity","Rotation","Scale","MeshRef","Renderable","Rigidbody","Collider","Health","Weapon","Thrust","Thruster","EnemyAI","SeparationForce","Lifetime","THRUST_FORCE","BOOST_MULTIPLIER","MAX_VELOCITY","FRICTION","applyThrustSystem","entities","dt","eid","hasThrust","hasThruster","thrustX","thrustY","thrustZ","boostMult","rotatedThrust","rotateVector","maxVel","velLength","scale","applyDragSystem","hasVelocity","drag","hasRigidbody","dragFactor","integratePositionSystem","hasPosition","collisionSystem","i","eidA","hasCollider","j","eidB","dx","dy","dz","distSq","radiusSum","radiusSumSq","dist","overlap","nx","ny","nz","separation","vrelX","vrelY","vrelZ","vn","impulse","x","y","z","qx","qy","qz","qw","ix","iy","iz","iw","renderSyncSystem","meshRegistry","hasMeshRef","meshIndex","mesh","hasRotation","hasScale","hasRenderable","registerMesh","registry","index","createMeshRegistry","projectileCollisionSystem","projectiles","targets","events","projectileEid","projX","projY","projZ","projRadius","targetEid","hitX","hitY","hitZ","targetRadius","damageApplicationSystem","baseDamage","resistance","clamp01","damage","currentShield","remaining","shieldRegenSystem","regen","lifetimeSystem","expired","maxAge","value","SEPARATION_FORCE_MAGNITUDE","SEPARATION_THRESHOLD_MULTIPLIER","COLLISION_DISTANCE","enemyDetectionSystem","enemies","playerEid","playerX","playerY","playerZ","detectionRangeSq","enemyPursuitSystem","baseDirX","baseDirY","baseDirZ","subtype","speed","applyStandardDroneMovement","applyHeavyDroneMovement","applySwiftDroneMovement","applySeparationInfluence","updateRotationTowardsPlayer","dirX","dirY","dirZ","distToPlayer","_dt","amplitude","frequency","phase","timeAlive","effectiveAmplitude","spiralTime","spiralOffset","upX","upY","upZ","rightX","rightY","rightZ","rightLen","heavySpeed","_distToPlayer","swiftSpeed","zigzagOffset","sepX","sepY","sepZ","sepLengthSq","sepLength","dynamicInfluence","targetVelX","targetVelY","targetVelZ","yaw","pitch","cy","sy","cp","sp","enemySeparationSystem","threshold","strength","forceX","forceY","forceZ","difficultyScalingSystem","_gameTime","diffManager","minutesPassed","healthMultiplier","damageMultiplier","speedMultiplier","enemyCollisionAttackSystem","remainingDamage","world","createWorld","createGameEntity","addEntity","entitiesWithHealth","playerEntityId","initECS","scene","testEntity","geometry","THREE.BoxGeometry","material","THREE.MeshBasicMaterial","THREE.Mesh","updateECS","deltaTime","collisionEvents","playerHits","expiredEntities","removeTrackedEntity","enemyIndex","projectileIndex","healthIndex","getEnemies","getPlayerEntity"],"mappings":"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"}