var W=Object.defineProperty;var ee=(R,e,t)=>e in R?W(R,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):R[e]=t;var d=(R,e,t)=>ee(R,typeof e!="symbol"?e+"":e,t);import{G as F,a8 as H,C,N as B,a as E,V as y,ac as q,ad as te,ab as se,r as D,ae as oe,y as _,Z as Y,_ as ae,h as V,B as $,af as ie,M as N,n as ne,ag as re,J as L,z as X,o as U,K as J,a3 as K}from"./three-DBvJLP14.js";class ce{constructor(e,t=4,s=4){d(this,"anomalyScale");this.anomalyScale=t}create(e,t,s,a){const o=new F;o.position.copy(e),o.scale.set(this.anomalyScale,this.anomalyScale,this.anomalyScale);const i=6,n=[];for(let h=0;h<i;h++){const f=400-h*50,m=new H(f,15,16,100),g=.5+h*.05,P=new C().setHSL(g,.9,.6),x=new B({color:P,emissive:P.clone().multiplyScalar(.5),emissiveIntensity:1,metalness:.8,roughness:.2,transparent:!0,opacity:.95}),p=new E(m,x);p.rotation.x=Math.PI/2+h*.2,p.rotation.y=h*.3,o.add(p),n.push({mesh:p,rotationSpeed:{x:.005+h*.002,y:.003+h*.001,z:.001+h*5e-4}})}const r=s(),u=t(r);return o.add(u.mesh),a(o),{type:"vortex",mesh:o,position:e.clone(),rings:n,orb:u,collisionRadius:350,orbCollected:!1,rotationSpeed:new y(.001,.002,.0015)}}update(e,t){e.rings.forEach(s=>{s.mesh.rotation.x+=s.rotationSpeed.x*t,s.mesh.rotation.y+=s.rotationSpeed.y*t,s.mesh.rotation.z+=s.rotationSpeed.z*t})}cleanup(e){e.rings&&e.rings.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose())})}}class he{constructor(e,t=4,s=4){d(this,"anomalyScale");this.anomalyScale=t}create(e,t,s,a){const o=new F;o.position.copy(e),o.scale.set(this.anomalyScale,this.anomalyScale,this.anomalyScale);const i=[],n=20;for(let h=0;h<n;h++){const f=50+Math.random()*100;let m;const g=Math.floor(Math.random()*3);if(g===0)m=new q(f,0);else if(g===1)m=new te(f,0);else{m=new se(f,0);const l=m.attributes.position;for(let A=0;A<l.count;A++){const S=new y;S.fromBufferAttribute(l,A),S.y*=2.5,l.setXYZ(A,S.x,S.y,S.z)}m.computeVertexNormals()}const P=.45+Math.random()*.1,x=.9+Math.random()*.1,p=.6+Math.random()*.2,c=new C().setHSL(P,x,p),w=new B({color:c,metalness:.9,roughness:.1,transparent:!0,opacity:.9,emissive:c.clone(),emissiveIntensity:.5}),b=new E(m,w),M=200+Math.random()*100,I=Math.random()*Math.PI*2,v=Math.random()*Math.PI;b.position.set(M*Math.sin(v)*Math.cos(I),M*Math.sin(v)*Math.sin(I),M*Math.cos(v)),b.rotation.set(Math.random()*Math.PI*2,Math.random()*Math.PI*2,Math.random()*Math.PI*2),o.add(b),i.push({mesh:b,initialPosition:b.position.clone(),floatPhase:Math.random()*Math.PI*2,floatSpeed:.3+Math.random()*.3,floatAmplitude:5+Math.random()*10,rotationSpeed:{x:(Math.random()-.5)*.01,y:(Math.random()-.5)*.01,z:(Math.random()-.5)*.01}})}const r=s(),u=t(r);return o.add(u.mesh),a(o),{type:"crystalCluster",mesh:o,position:e.clone(),crystals:i,orb:u,collisionRadius:300,orbCollected:!1,rotationSpeed:new y(5e-4,.001,5e-4)}}update(e,t){e.crystals.forEach(s=>{s.floatPhase+=t*s.floatSpeed;const a=Math.sin(s.floatPhase)*s.floatAmplitude;s.mesh.position.y=s.initialPosition.y+a,s.mesh.rotation.x+=s.rotationSpeed.x,s.mesh.rotation.y+=s.rotationSpeed.y,s.mesh.rotation.z+=s.rotationSpeed.z})}cleanup(e){e.crystals&&e.crystals.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose())})}}class le{constructor(e,t=4,s=4){d(this,"anomalyScale");this.anomalyScale=t}create(e,t,s,a){const o=new F;o.position.copy(e),o.scale.set(this.anomalyScale,this.anomalyScale,this.anomalyScale);const i=3,n=[];for(let c=0;c<i;c++){const w=200+c*60,b=new H(w,8,16,50),M=.6+c*.1,I=new C().setHSL(M,1,.6),v=new B({color:I,emissive:I.clone().multiplyScalar(.5),emissiveIntensity:1,metalness:.9,roughness:.1,transparent:!1,opacity:1}),l=new E(b,v);l.rotation.x=Math.PI/2+c*Math.PI/3,l.rotation.y=c*Math.PI/4,o.add(l);const A=10+c*5,S=[];for(let z=0;z<A;z++){const G=z/A*Math.PI*2,O=15+Math.random()*10,T=new q(O,0),Q=(M+.5)%1,Z=new C().setHSL(Q,1,.7),j=new B({color:Z,emissive:Z.clone(),emissiveIntensity:.8,metalness:.9,roughness:.1,transparent:!1,opacity:1}),k=new E(T,j);k.position.x=w*Math.cos(G),k.position.y=0,k.position.z=w*Math.sin(G),k.rotation.x=Math.random()*Math.PI,k.rotation.y=Math.random()*Math.PI,k.rotation.z=Math.random()*Math.PI,l.add(k),S.push({mesh:k,initialPosition:k.position.clone(),pulsePhase:Math.random()*Math.PI*2,pulseSpeed:.5+Math.random()*.5})}n.push({mesh:l,crystals:S,rotationSpeed:.1-c*.03,rotationAxis:new y(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize()})}const r=80,u=new D(r,32,32),h=new C().setHSL(.15,1,.6),f=new B({color:h,emissive:h,emissiveIntensity:1,metalness:1,roughness:.3,transparent:!0,opacity:.9}),m=new E(u,f);o.add(m);const g=8,P=[];for(let c=0;c<g;c++){const w=new oe(new y(0,0,0),new y((Math.random()-.5)*200,(Math.random()-.5)*200,(Math.random()-.5)*200),new y((Math.random()-.5)*300,(Math.random()-.5)*300,(Math.random()-.5)*300),new y((Math.random()-.5)*400,(Math.random()-.5)*400,(Math.random()-.5)*400)),b=w.getPoints(20),M=new _().setFromPoints(b),I=new C().setHSL(.15,1,.6),v=new Y({color:I,linewidth:3,transparent:!0,opacity:.8}),l=new ae(M,v);o.add(l),P.push({mesh:l,curve:w,updatePhase:Math.random()*Math.PI*2,updateSpeed:.2+Math.random()*.3})}const x=s(),p=t(x);return o.add(p.mesh),a(o),{type:"nebulaNexus",mesh:o,position:e.clone(),rings:n,core:{mesh:m,pulsePhase:0,pulseSpeed:.5},arcs:P,orb:p,collisionRadius:250,orbCollected:!1,rotationSpeed:new y(3e-4,4e-4,2e-4)}}update(e,t){e.core.pulsePhase+=t*e.core.pulseSpeed;const s=1+.2*Math.sin(e.core.pulsePhase);e.core.mesh.scale.set(s,s,s),e.rings.forEach(a=>{const o=new V().makeRotationAxis(a.rotationAxis,a.rotationSpeed*t);a.mesh.applyMatrix4(o),a.crystals.forEach(i=>{i.pulsePhase+=t*i.pulseSpeed;const n=1+.3*Math.sin(i.pulsePhase);i.mesh.scale.set(n,n,n)})}),e.arcs.forEach(a=>{a.updatePhase+=t*a.updateSpeed;const o=a.curve.v1,i=a.curve.v2;o.x=Math.sin(a.updatePhase)*200,o.y=Math.cos(a.updatePhase*.7)*200,o.z=Math.sin(a.updatePhase*1.3)*200,i.x=Math.sin(a.updatePhase*.8+1)*300,i.y=Math.cos(a.updatePhase*1.2+2)*300,i.z=Math.sin(a.updatePhase*.9+3)*300;const n=a.curve.getPoints(20);a.mesh.geometry.setFromPoints(n),a.mesh.geometry.attributes.position.needsUpdate=!0})}cleanup(e){e.rings&&e.rings.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose())}),e.core&&e.core.mesh&&(e.core.mesh.geometry&&e.core.mesh.geometry.dispose(),e.core.mesh.material&&(Array.isArray(e.core.mesh.material)?e.core.mesh.material.forEach(t=>t.dispose()):e.core.mesh.material.dispose())),e.arcs&&e.arcs.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose())})}}class me{constructor(e,t=4,s=4){d(this,"anomalyScale");this.anomalyScale=t}create(e,t,s,a){const o=new F;o.position.copy(e),o.scale.set(this.anomalyScale,this.anomalyScale,this.anomalyScale);const i=[],n=5;for(let p=0;p<n;p++){const c=250-p*40,w=new $(c,c,c),b=new $(c*.98,c*.98,c*.98),M=new ie(w),I=.3+p*.1,v=new C().setHSL(I,1,.6),l=new Y({color:v,linewidth:2,transparent:!1,opacity:1}),A=new N({color:v,transparent:!0,opacity:.1,side:ne}),S=new re(M,l),z=new E(b,A);o.add(S),o.add(z),i.push({mesh:S,innerBox:z,rotationAxis:new y(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize(),rotationSpeed:.01+p*.005,pulsePhase:Math.random()*Math.PI*2})}const r=200,u=new _,h=new Float32Array(r*3),f=new Float32Array(r);for(let p=0;p<r;p++){const c=p*3,w=100*Math.random(),b=Math.random()*Math.PI*2,M=Math.random()*Math.PI;h[c]=w*Math.sin(M)*Math.cos(b),h[c+1]=w*Math.sin(M)*Math.sin(b),h[c+2]=w*Math.cos(M),f[p]=2+Math.random()*3}u.setAttribute("position",new L(h,3)),u.setAttribute("size",new L(f,1));const m=new X({color:16711935,size:6,blending:U,transparent:!0,opacity:.9}),g=new J(u,m);o.add(g);const P=s(),x=t(P);return o.add(x.mesh),a(o),{type:"quantumFlux",mesh:o,position:e.clone(),frames:i,particles:{mesh:g,positions:h,initialPositions:h.slice(),velocities:Array(r).fill(null).map(()=>new y((Math.random()-.5)*.5,(Math.random()-.5)*.5,(Math.random()-.5)*.5))},orb:x,collisionRadius:230,orbCollected:!1,rotationSpeed:new y(1e-4,2e-4,1e-4)}}update(e,t){e.frames.forEach(o=>{const i=new V().makeRotationAxis(o.rotationAxis,o.rotationSpeed*t);o.mesh.applyMatrix4(i),o.innerBox&&o.innerBox.applyMatrix4(i),o.pulsePhase+=t;const n=1+.05*Math.sin(o.pulsePhase);o.mesh.scale.set(n,n,n),o.innerBox&&o.innerBox.scale.set(n,n,n)});const s=e.particles.positions,a=e.particles.velocities;for(let o=0;o<s.length/3;o++){const i=o*3;s[i]+=a[o].x,s[i+1]+=a[o].y,s[i+2]+=a[o].z;const n=120,r=new y(s[i],s[i+1],s[i+2]);r.length()>n&&(r.normalize().multiplyScalar(n),s[i]=r.x,s[i+1]=r.y,s[i+2]=r.z,a[o].reflect(r.normalize()))}e.particles.mesh.geometry.attributes.position.needsUpdate=!0}cleanup(e){e.frames&&e.frames.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose()),t.innerBox&&(t.innerBox.geometry&&t.innerBox.geometry.dispose(),t.innerBox.material&&(Array.isArray(t.innerBox.material)?t.innerBox.material.forEach(s=>s.dispose()):t.innerBox.material.dispose()))}),e.particles&&e.particles.mesh&&(e.particles.mesh.geometry&&e.particles.mesh.geometry.dispose(),e.particles.mesh.material&&(Array.isArray(e.particles.mesh.material)?e.particles.mesh.material.forEach(t=>t.dispose()):e.particles.mesh.material.dispose()))}}class pe{constructor(e,t=4,s=4){d(this,"anomalyScale");this.anomalyScale=t}create(e,t,s,a){const o=new F;o.position.copy(e),o.scale.set(this.anomalyScale,this.anomalyScale,this.anomalyScale);const i=100,n=new D(i,32,32),r=new B({color:3342387,emissive:8913032,emissiveIntensity:1.5,metalness:1,roughness:0,transparent:!0,opacity:.95}),u=new E(n,r),h=new D(i*1.2,32,32),f=new N({color:10027263,transparent:!0,opacity:.3,side:K}),m=new E(h,f);u.add(m),o.add(u);const g=[],P=4;for(let l=0;l<P;l++){const A=150+l*60,S=4+l*2,z=new H(A,S,16,100),G=new C().setHSL(.75,.9,.1+l*.15),O=new B({color:G,emissive:G.clone().multiplyScalar(.7),emissiveIntensity:.5+l*.2,metalness:.8,roughness:.2,transparent:!0,opacity:.85}),T=new E(z,O);T.rotation.x=Math.random()*Math.PI,T.rotation.y=Math.random()*Math.PI,T.rotation.z=Math.random()*Math.PI,o.add(T),g.push({mesh:T,rotationAxis:new y(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize(),rotationSpeed:.002+l*.001,warpPhase:Math.random()*Math.PI*2,warpSpeed:.5+Math.random()*.5})}const x=300,p=new _,c=new Float32Array(x*3),w=new Float32Array(x);for(let l=0;l<x;l++){const A=l*3,S=120+Math.random()*250,z=Math.random()*Math.PI*2,G=Math.random()*Math.PI;c[A]=S*Math.sin(G)*Math.cos(z),c[A+1]=S*Math.sin(G)*Math.sin(z),c[A+2]=S*Math.cos(G),w[l]=1+Math.random()*3}p.setAttribute("position",new L(c,3)),p.setAttribute("size",new L(w,1));const b=new X({color:8913151,size:5,blending:U,transparent:!0,opacity:.8}),M=new J(p,b);o.add(M);const I=s(),v=t(I);return o.add(v.mesh),a(o),{type:"darkMatter",mesh:o,position:e.clone(),core:{mesh:u,pulsePhase:0},rings:g,particles:{mesh:M,positions:c,initialPositions:c.slice(),phases:Array(x).fill(0).map(()=>Math.random()*Math.PI*2)},orb:v,collisionRadius:200,orbCollected:!1,rotationSpeed:new y(2e-4,3e-4,1e-4)}}update(e,t){e.core.pulsePhase+=t*.5;const s=1+.1*Math.sin(e.core.pulsePhase);e.core.mesh.scale.set(s,s,s),e.rings.forEach(n=>{const r=new V().makeRotationAxis(n.rotationAxis,n.rotationSpeed*t);n.mesh.applyMatrix4(r),n.warpPhase+=t*n.warpSpeed;const u=1+.1*Math.sin(n.warpPhase),h=1+.1*Math.sin(n.warpPhase+Math.PI/3),f=1+.1*Math.sin(n.warpPhase+Math.PI*2/3);n.mesh.scale.set(u,h,f)});const a=e.particles.positions,o=e.particles.initialPositions,i=e.particles.phases;for(let n=0;n<a.length/3;n++){const r=n*3;i[n]+=t;const h=.5+300/(Math.sqrt(o[r]*o[r]+o[r+1]*o[r+1]+o[r+2]*o[r+2])+10);i[n]+=t*h;const f=1+.2*Math.sin(i[n]*.5),m=new y(o[r],o[r+1],o[r+2]),g=i[n]*.2,P=i[n]*.1;m.applyAxisAngle(new y(0,1,0),g),m.applyAxisAngle(new y(0,0,1),P),m.multiplyScalar(f),a[r]=m.x,a[r+1]=m.y,a[r+2]=m.z}e.particles.mesh.geometry.attributes.position.needsUpdate=!0}cleanup(e){e.core&&e.core.mesh&&(e.core.mesh.geometry&&e.core.mesh.geometry.dispose(),e.core.mesh.material&&(Array.isArray(e.core.mesh.material)?e.core.mesh.material.forEach(t=>t.dispose()):e.core.mesh.material.dispose())),e.rings&&e.rings.forEach(t=>{t.mesh&&t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh&&t.mesh.material&&(Array.isArray(t.mesh.material)?t.mesh.material.forEach(s=>s.dispose()):t.mesh.material.dispose())}),e.particles&&e.particles.mesh&&(e.particles.mesh.geometry&&e.particles.mesh.geometry.dispose(),e.particles.mesh.material&&(Array.isArray(e.particles.mesh.material)?e.particles.mesh.material.forEach(t=>t.dispose()):e.particles.mesh.material.dispose()))}}class de{constructor(e,t=4,s=4){d(this,"anomalyTypes");this.anomalyTypes={vortex:new ce(e,t,s),crystalCluster:new he(e,t,s),nebulaNexus:new le(e,t,s),quantumFlux:new me(e,t,s),darkMatter:new pe(e,t,s)}}createAnomaly(e,t,s,a,o){const i=this.anomalyTypes[e];if(!i)throw new Error(`Unknown anomaly type: ${e}`);return i.create(t,s,a,o)}updateAnomaly(e,t){const s=this.anomalyTypes[e.type];s&&typeof s.update=="function"&&s.update(e,t)}cleanupAnomaly(e){const t=this.anomalyTypes[e.type];t&&typeof t.cleanup=="function"&&t.cleanup(e)}getAvailableTypes(){return Object.keys(this.anomalyTypes)}isTypeSupported(e){return e in this.anomalyTypes}}class fe{constructor(e){d(this,"scene");d(this,"anomalies");d(this,"minRadius");d(this,"maxRadius");d(this,"width");d(this,"anomalyScale");d(this,"orbScale");d(this,"orbValues");d(this,"spawnTimer");d(this,"checkInterval");d(this,"spawnChance");d(this,"despawnChance");d(this,"anomalyRegistry");d(this,"anomalyTypes");d(this,"maxAnomalies");this.scene=e,this.anomalies=[],this.minRadius=32e3,this.maxRadius=45e3,this.width=3e3,this.anomalyScale=4,this.orbScale=4,this.orbValues={common:100,uncommon:500,rare:1500,epic:5e3,legendary:15e3},this.spawnTimer=0,this.checkInterval=60,this.spawnChance=.5,this.despawnChance=.3,this.anomalyRegistry=new de(e,this.anomalyScale,this.orbScale),this.anomalyTypes=this.anomalyRegistry.getAvailableTypes(),this.maxAnomalies=5,this.updateAnomalyCountDisplay()}_getRenderer(){const e=window.game;return(e==null?void 0:e.renderer)??null}_addToScene(e){const t=this._getRenderer();t&&typeof t._withGuard=="function"?t._withGuard(()=>t.add&&t.add(e)):this.scene&&typeof this.scene.add=="function"&&this.scene.add(e)}_removeFromScene(e){const t=this._getRenderer();e&&(t&&typeof t._withGuard=="function"?t._withGuard(()=>this.scene.remove(e)):this.scene&&typeof this.scene.remove=="function"&&this.scene.remove(e))}checkAnomalySpawning(e){if(this.spawnTimer+=e,this.spawnTimer>=this.checkInterval){if(this.spawnTimer-=this.checkInterval,this.anomalies.length<this.maxAnomalies&&Math.random()<this.spawnChance){const s=this.anomalyTypes.filter(a=>!this.anomalies.some(o=>o.type===a));if(s.length>0){const a=s[Math.floor(Math.random()*s.length)];this.spawnAnomaly(a),this.updateAnomalyCountDisplay()}}const t=[];this.anomalies.forEach(s=>{Math.random()<this.despawnChance&&t.push(s)}),t.length>0&&(t.forEach(s=>{this.despawnAnomaly(s)}),this.updateAnomalyCountDisplay())}}spawnAnomaly(e){if(console.log(`Spawning ${e} anomaly`),!this.anomalyRegistry.isTypeSupported(e)){console.error(`Unknown anomaly type: ${e}`);return}const t=this.getRandomAnomalyPosition(),s=this.anomalyRegistry.createAnomaly(e,t,a=>this.createEnergyOrb(a),()=>this.getRandomOrbRarity(),a=>this._addToScene(a));this.anomalies.push(s)}despawnAnomaly(e){console.log(`Despawning ${e.type} anomaly`),this._removeFromScene(e.mesh),this.anomalyRegistry.cleanupAnomaly(e),e.orb&&e.orb.mesh&&(e.orb.mesh.geometry&&e.orb.mesh.geometry.dispose(),e.orb.mesh.material&&(Array.isArray(e.orb.mesh.material)?e.orb.mesh.material.forEach(s=>s.dispose()):e.orb.mesh.material.dispose()));const t=this.anomalies.indexOf(e);t!==-1&&this.anomalies.splice(t,1)}updateAnomalyCountDisplay(){const e=document.getElementById("anomaly-count");e&&(e.textContent=this.anomalies.length.toString())}getActiveAnomalyCount(){return this.anomalies.length}update(e){this.checkAnomalySpawning(e);let t=null;const s=window.game;s!=null&&s.spaceship&&s.spaceship.mesh&&(t=s.spaceship.mesh.position);for(let a=0;a<this.anomalies.length;a++){const o=this.anomalies[a];if(o.orbCollected){o.mesh&&o.rotationSpeed&&(o.mesh.rotation.x+=o.rotationSpeed.x*e,o.mesh.rotation.y+=o.rotationSpeed.y*e,o.mesh.rotation.z+=o.rotationSpeed.z*e);continue}let i=!1;t&&(i=t.distanceTo(o.position)<o.orb.size*3*this.orbScale),o.mesh&&o.rotationSpeed&&(o.mesh.rotation.x+=o.rotationSpeed.x*e,o.mesh.rotation.y+=o.rotationSpeed.y*e,o.mesh.rotation.z+=o.rotationSpeed.z*e),this.anomalyRegistry.updateAnomaly(o,e),this.updateOrbEffects(o,i)}}createEnergyOrb(e){let t,s,a,o;switch(e){case"legendary":t=new C(16711680),s=30*this.orbScale,a=.9,o=2;break;case"epic":t=new C(16737792),s=25*this.orbScale,a=.8,o=1.8;break;case"rare":t=new C(10027263),s=22*this.orbScale,a=.7,o=1.5;break;case"uncommon":t=new C(26367),s=20*this.orbScale,a=.6,o=1.2;break;default:t=new C(65382),s=18*this.orbScale,a=.5,o=1;break}const i=new D(s,32,32),n=new B({color:t,emissive:t,emissiveIntensity:a,metalness:.8,roughness:.2,transparent:!0,opacity:.9}),r=new E(i,n),u=s*1.5,h=new D(u,32,32),f=new N({color:t,transparent:!0,opacity:.3,side:K,blending:U}),m=new E(h,f);return r.add(m),{mesh:r,rarity:e,value:this.orbValues[e],size:s,color:t,pulsePhase:0,pulseSpeed:o,glow:m}}getRandomAnomalyPosition(){const e=Math.random()*Math.PI*2,t=this.minRadius+Math.random()*(this.maxRadius-this.minRadius),s=(Math.random()-.5)*this.width;return new y(Math.cos(e)*t,s,Math.sin(e)*t)}getRandomOrbRarity(){const e=Math.random();return e<.005?"legendary":e<.025?"epic":e<.1?"rare":e<.3?"uncommon":"common"}getRegionInfo(){return{center:new y(0,0,0),innerRadius:this.minRadius,outerRadius:this.maxRadius}}findClosestAnomaly(e,t=8e3){let s=null,a=t;return this.anomalies.forEach(o=>{const i=e.distanceTo(o.position);i<a&&(a=i,s=o)}),s}collectOrb(e){if(!e||e.orbCollected)return null;const t={rarity:e.orb.rarity,value:this.orbValues[e.orb.rarity]||100};return e.orbCollected=!0,e.orb&&e.orb.mesh&&(e.orb.mesh.visible=!1,e.orb.glow&&(e.orb.glow.visible=!1)),t}checkCollision(e,t){return!e||!t||!t.position?!1:e.distanceTo(t.position)<t.orb.size*2*this.orbScale}updateOrbEffects(e,t){if(!(!e||!e.orb||e.orbCollected))if(t){const s=1.5+Math.sin(performance.now()*.005)*.5;e.orb.mesh.scale.set(s,s,s);const a=e.orb.mesh.material;a&&(Array.isArray(a)?a.forEach(o=>{o.emissiveIntensity=2}):a.emissiveIntensity=2)}else{const s=1+Math.sin(performance.now()*.002)*.2;e.orb.mesh.scale.set(s,s,s);const a=e.orb.mesh.material;a&&(Array.isArray(a)?a.forEach(o=>{o.emissiveIntensity=.8}):a.emissiveIntensity=.8)}}updateForSystem(e){console.log("Updating space anomalies for new star system"),this.clearAllAnomalies(),this.spawnTimer=this.checkInterval,this.updateAnomalyCountDisplay()}clearAllAnomalies(){[...this.anomalies].forEach(t=>{this.despawnAnomaly(t)}),this.anomalies=[],this.updateAnomalyCountDisplay()}}export{fe as SpaceAnomalies};
//# sourceMappingURL=spaceAnomalies-bosCSd9q.js.map
