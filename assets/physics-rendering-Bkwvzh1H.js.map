{"version":3,"file":"physics-rendering-Bkwvzh1H.js","sources":["../../js/systems/rendering/renderSystem.js","../../js/systems/physics/collisionSystem.js","../../js/systems/rendering/visualEffectsSystem.js"],"sourcesContent":["/**\n * RenderSystem - Manages visual representation of entities\n * \n * Syncs entity transforms with Three.js meshes and handles rendering.\n */\n\nimport * as THREE from 'three';\nimport { System } from '../../core/system.js';\n\nexport class RenderSystem extends System {\n    constructor(world, scene, camera, renderer) {\n        super(world);\n        this.requiredComponents = ['TransformComponent', 'MeshComponent'];\n        this.priority = 100; // Run at the end of the update cycle\n        \n        // Three.js references\n        this.scene = scene;\n        this.camera = camera;\n        // Don't store renderer reference to avoid issues\n        this.renderer = null;\n        \n        // Track meshes for frustum culling\n        this.meshEntities = new Map();\n        \n        // Frustum for view culling\n        this.frustum = new THREE.Frustum();\n        this.projScreenMatrix = new THREE.Matrix4();\n        \n        // Listen for entity events\n        this.world.messageBus.subscribe('entity.created', this.onEntityCreated.bind(this));\n        this.world.messageBus.subscribe('entity.destroyed', this.onEntityDestroyed.bind(this));\n        \n        // Also listen for component.added events directly to catch component additions\n        this.world.messageBus.subscribe('component.added', this.onComponentAdded.bind(this));\n        \n        console.log(\"RenderSystem initialized - handling mesh updates only, no rendering\");\n    }\n    \n    /**\n     * Handle component added event\n     * @param {object} message Event message\n     */\n    onComponentAdded(message) {\n        const entity = message.data.entity;\n        const componentType = message.data.componentType;\n        \n        // Only interested if one of our required components was added\n        if (componentType !== 'MeshComponent' && componentType !== 'TransformComponent') {\n            return;\n        }\n        \n        // Check if we're already tracking this entity\n        if (this.meshEntities.has(entity.id)) {\n            return;\n        }\n        \n        console.log(`RenderSystem: Component ${componentType} added to entity ${entity.id}`);\n        \n        // Check if entity now has all required components\n        if (entity.getComponent('TransformComponent') && entity.getComponent('MeshComponent')) {\n            console.log(`Entity ${entity.id} now has all required components, adding to scene`);\n            this.addEntityToScene(entity);\n        }\n    }\n    \n    /**\n     * Initialize the rendering system\n     */\n    initialize() {\n        // Verify the system has scene and camera references\n        if (!this.scene || !this.camera) {\n            console.error('RenderSystem missing required Three.js scene or camera references');\n            return;\n        }\n        \n        // Process any entities that already exist\n        const entities = this.world.getEntitiesWithComponents(['TransformComponent', 'MeshComponent']);\n        entities.forEach(entity => {\n            this.addEntityToScene(entity);\n        });\n    }\n    \n    /**\n     * Handle entity created event\n     * @param {object} message Event message\n     */\n    onEntityCreated(message) {\n        const entity = message.data.entity;\n        \n        // Log entity creation for debugging\n        console.log(`RenderSystem received entity.created event for entity ${entity.id}`);\n        \n        // List all components for debugging\n        console.log(`Entity ${entity.id} components:`, Array.from(entity.components.keys()).join(', '));\n        \n        // Check if entity has required components using getComponent for better debugging\n        const transform = entity.getComponent('TransformComponent');\n        const mesh = entity.getComponent('MeshComponent');\n        \n        if (transform && mesh) {\n            console.log(`Entity ${entity.id} has required components, adding to scene`);\n            this.addEntityToScene(entity);\n        } else {\n            // Check if the entity might get components later\n            console.log(`Entity ${entity.id} missing required components (has transform: ${!!transform}, has mesh: ${!!mesh}), will check later`);\n            \n            // Set up a one-time component added listener\n            const checkComponentsAdded = (msg) => {\n                // Only process if it's about our entity\n                if (msg.data.entity?.id !== entity.id) return;\n                \n                // Log the added component\n                console.log(`Entity ${entity.id} got component ${msg.data.componentType}`);\n                \n                // Check if now it has the required components\n                const transform = entity.getComponent('TransformComponent');\n                const mesh = entity.getComponent('MeshComponent');\n                \n                if (transform && mesh) {\n                    console.log(`Entity ${entity.id} now has required components, adding to scene`);\n                    this.addEntityToScene(entity);\n                    \n                    // Remove this listener after processing\n                    this.world.messageBus.unsubscribe('component.added', checkComponentsAdded);\n                }\n            };\n            \n            // Subscribe to component added events\n            this.world.messageBus.subscribe('component.added', checkComponentsAdded);\n        }\n    }\n    \n    /**\n     * Handle entity destroyed event\n     * @param {object} message Event message\n     */\n    onEntityDestroyed(message) {\n        const entity = message.data.entity;\n        \n        // Check if we're tracking this entity\n        if (this.meshEntities.has(entity.id)) {\n            this.removeEntityFromScene(entity);\n        }\n    }\n    \n    /**\n     * Add entity mesh to scene\n     * @param {Entity} entity Entity to add\n     */\n    addEntityToScene(entity) {\n        const meshComponent = entity.getComponent('MeshComponent');\n        \n        // Debug output all component keys\n        console.log(`Entity ${entity.id} components for scene addition:`, Array.from(entity.components.keys()).join(', '));\n        \n        // Skip if mesh component is missing\n        if (!meshComponent || !meshComponent.mesh) {\n            console.warn(`Entity ${entity.id} has no valid mesh to add to scene`);\n            \n            // Debug output if we have a meshComponent but no mesh\n            if (meshComponent && !meshComponent.mesh) {\n                console.warn(`Entity ${entity.id} has MeshComponent but mesh property is ${meshComponent.mesh}`);\n            }\n            return;\n        }\n        \n        // Handle bounding sphere carefully - THREE.Group objects don't have geometry\n        if (meshComponent.mesh.geometry) {\n            // Only compute if it's a mesh with geometry and not a Group\n            if (!meshComponent.mesh.geometry.boundingSphere && typeof meshComponent.mesh.geometry.computeBoundingSphere === 'function') {\n                meshComponent.mesh.geometry.computeBoundingSphere();\n            }\n        } else if (meshComponent.mesh.isGroup) {\n            // It's a Group object (no direct geometry property)\n            console.log(`Entity ${entity.id} uses a THREE.Group - skipping bounding sphere computation`);\n        }\n        \n        // Ensure we have access to the scene\n        if (!this.scene) {\n            console.error(`Cannot add entity ${entity.id} mesh to scene - scene reference is missing`);\n            return;\n        }\n        \n        // Add mesh to scene directly (don't check for parent)\n        this.scene.add(meshComponent.mesh);\n        \n        // Make sure mesh is visible\n        meshComponent.mesh.visible = true;\n        \n        // Apply entity transform to mesh\n        const transform = entity.getComponent('TransformComponent');\n        if (transform) {\n            meshComponent.mesh.position.copy(transform.position);\n            meshComponent.mesh.quaternion.copy(transform.quaternion);\n            meshComponent.mesh.scale.copy(transform.scale);\n        }\n        \n        // Log debug info about entity being added\n        console.log(`Added entity ${entity.id} mesh to scene - position: ${meshComponent.mesh.position.x.toFixed(0)},${meshComponent.mesh.position.y.toFixed(0)},${meshComponent.mesh.position.z.toFixed(0)}`);\n        \n        // Track this entity for updates\n        this.meshEntities.set(entity.id, entity);\n    }\n    \n    /**\n     * Remove entity mesh from scene\n     * @param {Entity} entity Entity to remove\n     */\n    removeEntityFromScene(entity) {\n        const meshComponent = entity.getComponent('MeshComponent');\n        \n        // Remove mesh from scene\n        if (meshComponent.mesh && meshComponent.mesh.parent) {\n            this.scene.remove(meshComponent.mesh);\n        }\n        \n        // Stop tracking this entity\n        this.meshEntities.delete(entity.id);\n    }\n    \n    /**\n     * Update camera frustum for culling\n     */\n    updateFrustum() {\n        if (!this.camera) return;\n        \n        try {\n            // Check if camera matrices are valid\n            if (!this.camera.projectionMatrix || !this.camera.matrixWorldInverse) {\n                console.warn('Camera matrices not initialized');\n                return;\n            }\n            \n            // Create fresh matrices to avoid reference issues\n            this.projScreenMatrix = new THREE.Matrix4();\n            \n            // Multiply matrices to create projection\n            this.projScreenMatrix.multiplyMatrices(\n                this.camera.projectionMatrix,\n                this.camera.matrixWorldInverse\n            );\n            \n            // Set frustum from projection matrix\n            this.frustum = new THREE.Frustum();\n            this.frustum.setFromProjectionMatrix(this.projScreenMatrix);\n        } catch (error) {\n            console.error('Error updating frustum:', error);\n            // If we can't update the frustum, we'll disable culling by setting DEBUG_MODE\n            window.DEBUG_MODE = true;\n        }\n    }\n    \n    /**\n     * Check if a position is visible in the camera frustum\n     * @param {THREE.Vector3} position Position to check\n     * @param {number} radius Bounding sphere radius\n     * @returns {boolean} True if visible\n     */\n    isVisible(position, radius) {\n        // Use a much larger radius for distant objects\n        const visibilityRadius = Math.max(radius, 1000); // Ensure large distant objects remain visible\n        \n        // During development, or for this fix, ALWAYS assume everything is visible to aid debugging\n        // Force to true to bypass the culling system entirely\n        window.DEBUG_MODE = true;\n        return true;\n        \n        // Safely check if position is valid before creating a sphere\n        if (!position || typeof position.x !== 'number') {\n            console.warn('Invalid position for visibility check:', position);\n            return true; // Default to visible if position is invalid\n        }\n        \n        // First try just using containsPoint which is simpler\n        if (this.frustum.containsPoint(position)) {\n            return true;\n        }\n        \n        // Create sphere for intersection test - with error handling\n        try {\n            const sphere = new THREE.Sphere(position.clone(), visibilityRadius);\n            return this.frustum.intersectsSphere(sphere);\n        } catch (error) {\n            console.warn('Error in frustum intersection test:', error);\n            return true; // Default to visible on error\n        }\n    }\n    \n    /**\n     * Update all mesh transforms from entity transforms\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        // Update camera frustum for culling\n        this.updateFrustum();\n        \n        // Try to scan for entities that should be tracked but aren't\n        if (window.DEBUG_MODE && this.world.time % 5 < deltaTime) {\n            this.scanForMissingEntities();\n        }\n        \n        // Update all registered meshes\n        for (const entity of this.meshEntities.values()) {\n            const transform = entity.getComponent('TransformComponent');\n            const meshComponent = entity.getComponent('MeshComponent');\n            \n            // Skip if either component is missing\n            if (!transform || !meshComponent || !meshComponent.mesh) continue;\n            \n            // Check if mesh is in the scene, if not add it\n            if (!meshComponent.mesh.parent && this.scene) {\n                console.log(`RenderSystem: Adding missing mesh for entity ${entity.id} to scene`);\n                this.scene.add(meshComponent.mesh);\n            }\n            \n            // Update mesh from transform\n            meshComponent.mesh.position.copy(transform.position);\n            meshComponent.mesh.quaternion.copy(transform.quaternion);\n            meshComponent.mesh.scale.copy(transform.scale);\n            \n            // Mark transform as updated\n            transform.needsUpdate = false;\n            \n            // Force visibility in debug mode\n            if (window.DEBUG_MODE) {\n                meshComponent.mesh.visible = true;\n                continue;\n            }\n            \n            // Update visibility based on frustum culling\n            if (meshComponent.visible) {\n                // Use a large default radius for better visibility\n                // Handle both mesh geometry and group objects\n                let radius = 500; // Default large radius\n                \n                // Safely check for boundingSphere - handle all cases\n                if (meshComponent.mesh.isGroup) {\n                    // For groups, we don't have a direct boundingSphere, so use default\n                    radius = 500;\n                } else if (meshComponent.mesh.geometry) {\n                    // Only try to access boundingSphere if geometry exists\n                    if (meshComponent.mesh.geometry.boundingSphere) {\n                        radius = meshComponent.mesh.geometry.boundingSphere.radius;\n                    } else if (typeof meshComponent.mesh.geometry.computeBoundingSphere === 'function') {\n                        // Try to compute if not already done\n                        meshComponent.mesh.geometry.computeBoundingSphere();\n                        // Now check if it was created successfully\n                        if (meshComponent.mesh.geometry.boundingSphere) {\n                            radius = meshComponent.mesh.geometry.boundingSphere.radius;\n                        }\n                    }\n                }\n                const isInView = this.isVisible(transform.position, radius);\n                meshComponent.mesh.visible = isInView;\n            } else {\n                meshComponent.mesh.visible = false;\n            }\n        }\n        \n        // Diagnostics - log mesh counts periodically\n        if (window.DEBUG_MODE && this.world.time % 5 < deltaTime) {\n            console.log(`RenderSystem: ${this.meshEntities.size} entities being managed`);\n        }\n        \n        // This system only handles mesh transform updates\n        // The main game renderer handles the actual rendering\n    }\n    \n    /**\n     * Scan for entities that should be tracked but aren't\n     */\n    scanForMissingEntities() {\n        // Get all entities with transform and mesh components\n        const entities = this.world.getEntitiesWithComponents(['TransformComponent', 'MeshComponent']);\n        \n        // Count how many we're not tracking\n        let missingCount = 0;\n        \n        // Add any entities that aren't already being tracked\n        entities.forEach(entity => {\n            if (!this.meshEntities.has(entity.id)) {\n                console.log(`RenderSystem: Found untracked entity ${entity.id} with mesh, adding to scene`);\n                this.addEntityToScene(entity);\n                missingCount++;\n            }\n        });\n        \n        if (missingCount > 0) {\n            console.log(`RenderSystem: Added ${missingCount} missing entities to tracking`);\n        }\n    }\n    \n    /**\n     * Clean up resources when system is destroyed\n     */\n    onDestroyed() {\n        // Dispose of THREE.js matrices\n        this.projScreenMatrix = null;\n        this.frustum = null;\n        \n        // Clean up all entities\n        for (const entity of this.meshEntities.values()) {\n            this.removeEntityFromScene(entity);\n        }\n        \n        // Clear entity map\n        this.meshEntities.clear();\n        \n        // Clear scene reference\n        this.scene = null;\n        this.camera = null;\n        this.renderer = null;\n        \n        // Unsubscribe from all message bus events\n        if (this.world && this.world.messageBus) {\n            // Unsubscribe from entity events\n            this.world.messageBus.unsubscribe('entity.created', this.onEntityCreated.bind(this));\n            this.world.messageBus.unsubscribe('entity.destroyed', this.onEntityDestroyed.bind(this));\n            this.world.messageBus.unsubscribe('component.added', this.onComponentAdded.bind(this));\n        }\n    }\n}","/**\n * CollisionSystem - Handles collision detection and resolution\n * \n * Manages spatial partitioning and collision responses.\n */\n\nimport * as THREE from 'three';\nimport { System } from '../../core/system.js';\nimport { FixedArray } from '../../utils/memoryManager.js';\n\nexport class CollisionSystem extends System {\n    constructor(world) {\n        super(world);\n        this.requiredComponents = ['TransformComponent', 'RigidbodyComponent'];\n        this.priority = 20; // Run after movement system\n        \n        // Spatial partitioning grid\n        this.cells = new Map();\n        this.cellSize = 2000; // Size of each spatial cell (4x the original 500)\n        \n        // Collision tracking to prevent duplicates\n        this.processedCollisions = new Set();\n        \n        // Keep track of entities per cell for quick lookup\n        this.entityCells = new Map();\n        \n        // Pre-allocated arrays to avoid garbage collection\n        this.potentialColliders = new FixedArray(200); // Pre-allocate for 200 potential colliders\n        this.cellsToCheck = new FixedArray(27); // 3^3 neighboring cells\n        \n        // Reusable vectors for collision calculations\n        this.tempVec1 = new THREE.Vector3();\n        this.tempVec2 = new THREE.Vector3();\n        this.collisionNormal = new THREE.Vector3();\n        this.relativeVelocity = new THREE.Vector3();\n    }\n    \n    /**\n     * Process all entities for collisions\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        // Clear spatial grid and tracking sets\n        this.cells.clear();\n        this.processedCollisions.clear();\n        this.entityCells.clear();\n        \n        // Get all entities with required components\n        const entities = this.getEntities();\n        \n        // First pass: populate spatial partitioning grid\n        for (let i = 0; i < entities.length; i++) {\n            this._insertIntoGrid(entities[i]);\n        }\n        \n        // Second pass: check for collisions using spatial partitioning\n        for (let i = 0; i < entities.length; i++) {\n            this._checkCollisionsOptimized(entities[i], deltaTime);\n        }\n    }\n    \n    /**\n     * Insert entity into spatial partitioning grid\n     * @param {Entity} entity Entity to insert\n     * @private\n     */\n    _insertIntoGrid(entity) {\n        const transform = entity.getComponent('TransformComponent');\n        const rigidbody = entity.getComponent('RigidbodyComponent');\n        \n        if (!transform || !rigidbody) return;\n        \n        // Calculate cell coordinates\n        const cellX = Math.floor(transform.position.x / this.cellSize);\n        const cellY = Math.floor(transform.position.y / this.cellSize);\n        const cellZ = Math.floor(transform.position.z / this.cellSize);\n        \n        // Create cell key\n        const cellKey = `${cellX},${cellY},${cellZ}`;\n        \n        // Add entity to cell\n        if (!this.cells.has(cellKey)) {\n            this.cells.set(cellKey, []);\n        }\n        this.cells.get(cellKey).push(entity);\n        \n        // Track which cells this entity is in\n        if (!this.entityCells.has(entity.id)) {\n            this.entityCells.set(entity.id, new Set());\n        }\n        this.entityCells.get(entity.id).add(cellKey);\n        \n        // For special entities like projectiles, add to neighboring cells too\n        const radius = rigidbody.collisionRadius;\n        const isProjectile = entity.hasTag('playerProjectile') || entity.hasTag('particleProjectile');\n        \n        // Fast-moving objects need to be in more cells\n        const overlapFactor = isProjectile ? 5 : 1;\n        \n        // Calculate neighboring cells based on entity size and velocity\n        const cellRadius = Math.ceil((radius * overlapFactor) / this.cellSize);\n        \n        if (isProjectile || cellRadius > 0) {\n            // Get velocity for high-speed projectiles\n            const velocity = rigidbody.velocity || { length: () => 0 };\n            const speedFactor = velocity.length ? Math.min(3, Math.ceil(velocity.length() / 1000)) : 1;\n            \n            // Add to more cells in the direction of movement for fast projectiles\n            for (let dx = -cellRadius; dx <= cellRadius; dx++) {\n                for (let dy = -cellRadius; dy <= cellRadius; dy++) {\n                    for (let dz = -cellRadius; dz <= cellRadius; dz++) {\n                        // Skip the center cell (already added)\n                        if (dx === 0 && dy === 0 && dz === 0) continue;\n                        \n                        // For projectiles, extend further in the direction of movement\n                        if (isProjectile && speedFactor > 1) {\n                            // Skip cells that are not in the direction of movement\n                            const dotProduct = dx * Math.sign(velocity.x || 0) + \n                                               dy * Math.sign(velocity.y || 0) + \n                                               dz * Math.sign(velocity.z || 0);\n                            if (dotProduct < 0) continue;\n                        }\n                        \n                        const neighborKey = `${cellX + dx},${cellY + dy},${cellZ + dz}`;\n                        if (!this.cells.has(neighborKey)) {\n                            this.cells.set(neighborKey, []);\n                        }\n                        this.cells.get(neighborKey).push(entity);\n                        this.entityCells.get(entity.id).add(neighborKey);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Check for collisions with optimized spatial partitioning\n     * @param {Entity} entity Entity to check\n     * @param {number} deltaTime Time since last update in seconds\n     * @private\n     */\n    _checkCollisionsOptimized(entity, deltaTime) {\n        const transform = entity.getComponent('TransformComponent');\n        const rigidbody = entity.getComponent('RigidbodyComponent');\n        \n        if (!transform || !rigidbody || !this.entityCells.has(entity.id)) {\n            return;\n        }\n        \n        // Get all cells this entity is in\n        const entityCellKeys = this.entityCells.get(entity.id);\n        \n        // Reset potential colliders array (reuse to avoid GC)\n        this.potentialColliders.clear();\n        \n        // Collect all potential colliders from all cells this entity is in\n        entityCellKeys.forEach(cellKey => {\n            const cellEntities = this.cells.get(cellKey);\n            if (!cellEntities) return;\n            \n            // Add all entities from this cell to potential colliders\n            for (let i = 0; i < cellEntities.length; i++) {\n                const otherEntity = cellEntities[i];\n                \n                // Skip self\n                if (otherEntity === entity) continue;\n                \n                // Skip if already processed this pair\n                const pairId = entity.id < otherEntity.id ? \n                    `${entity.id}:${otherEntity.id}` : \n                    `${otherEntity.id}:${entity.id}`;\n                \n                if (this.processedCollisions.has(pairId)) continue;\n                \n                // Add to potential colliders\n                this.potentialColliders.push(otherEntity);\n                \n                // Mark this pair as processed\n                this.processedCollisions.add(pairId);\n            }\n        });\n        \n        // Now check collisions with all potential colliders\n        for (let i = 0; i < this.potentialColliders.length; i++) {\n            const otherEntity = this.potentialColliders.get(i);\n            const otherTransform = otherEntity.getComponent('TransformComponent');\n            const otherRigidbody = otherEntity.getComponent('RigidbodyComponent');\n            \n            if (!otherTransform || !otherRigidbody) continue;\n            \n            // Check for collision\n            if (this._checkSphereCollision(\n                transform.position, rigidbody.collisionRadius,\n                otherTransform.position, otherRigidbody.collisionRadius\n            )) {\n                // Process the collision\n                if (rigidbody.isTrigger || otherRigidbody.isTrigger) {\n                    this._handleTrigger(entity, otherEntity);\n                } else {\n                    this._resolveCollision(\n                        entity, otherEntity,\n                        transform, rigidbody,\n                        otherTransform, otherRigidbody\n                    );\n                }\n            }\n        }\n    }\n    \n    /**\n     * Check for sphere-sphere collision\n     * @param {THREE.Vector3} posA Position A\n     * @param {number} radiusA Radius A\n     * @param {THREE.Vector3} posB Position B\n     * @param {number} radiusB Radius B\n     * @returns {boolean} True if collision detected\n     * @private\n     */\n    _checkSphereCollision(posA, radiusA, posB, radiusB) {\n        // Optimized: Use squared distance for better performance\n        const dx = posA.x - posB.x;\n        const dy = posA.y - posB.y;\n        const dz = posA.z - posB.z;\n        const distanceSquared = dx * dx + dy * dy + dz * dz;\n        \n        // Compare with squared sum of radii (more efficient than using square root)\n        const radiusSum = radiusA + radiusB;\n        return distanceSquared <= (radiusSum * radiusSum);\n    }\n    \n    /**\n     * Handle a trigger collision (no physics response)\n     * @param {Entity} entity Entity A\n     * @param {Entity} otherEntity Entity B\n     * @private\n     */\n    _handleTrigger(entity, otherEntity) {\n        // Identify player projectile and enemy - use direct tag access for better performance\n        let playerProjectile = null;\n        let enemyEntity = null;\n        \n        // Use _isPlayerProjectile, _isEnemy flags for faster checks if available\n        const entityIsProjectile = entity._isPlayerProjectile || \n                                   entity.hasTag('playerProjectile') || \n                                   entity.hasTag('particleProjectile');\n                                   \n        const otherIsEnemy = otherEntity._isEnemy || \n                            otherEntity.hasTag('enemy') || \n                            otherEntity.hasComponent('EnemyComponent') || \n                            otherEntity.hasComponent('EnemyAIComponent');\n        \n        if (entityIsProjectile && otherIsEnemy) {\n            playerProjectile = entity;\n            enemyEntity = otherEntity;\n        } else {\n            const otherIsProjectile = otherEntity._isPlayerProjectile || \n                                     otherEntity.hasTag('playerProjectile') || \n                                     otherEntity.hasTag('particleProjectile');\n                                     \n            const entityIsEnemy = entity._isEnemy || \n                                 entity.hasTag('enemy') || \n                                 entity.hasComponent('EnemyComponent') || \n                                 entity.hasComponent('EnemyAIComponent');\n            \n            if (otherIsProjectile && entityIsEnemy) {\n                playerProjectile = otherEntity;\n                enemyEntity = entity;\n            }\n        }\n        \n        // If this is a player projectile hitting an enemy, handle the hit\n        if (playerProjectile && enemyEntity) {\n            console.log(`DIRECT HIT: Player projectile ${playerProjectile.id} hit enemy ${enemyEntity.id}`);\n            \n            // Ignore pooled entities\n            if (enemyEntity.hasTag('pooled')) {\n                console.warn(`Skipping hit on pooled enemy ${enemyEntity.id}`);\n                return;\n            }\n            \n            // Log detailed collision info\n            const projectileTransform = playerProjectile.getComponent('TransformComponent');\n            const enemyTransform = enemyEntity.getComponent('TransformComponent');\n            \n            if (projectileTransform && enemyTransform) {\n                const distance = projectileTransform.position.distanceTo(enemyTransform.position);\n                console.log(`Hit details: Distance=${distance.toFixed(1)}, ProjectilePos=${projectileTransform.position.x.toFixed(0)},${projectileTransform.position.y.toFixed(0)},${projectileTransform.position.z.toFixed(0)}, EnemyPos=${enemyTransform.position.x.toFixed(0)},${enemyTransform.position.y.toFixed(0)},${enemyTransform.position.z.toFixed(0)}`);\n            }\n            \n            // Apply damage to enemy\n            const health = enemyEntity.getComponent('HealthComponent');\n            if (health) {\n                // Apply significant damage - guaranteed to kill in one hit\n                const damage = 1000; // Massive damage to guarantee instant death\n                console.log(`CRITICAL HIT: Applying ${damage} damage to enemy ${enemyEntity.id}`);\n                health.applyDamage(damage, 'particle', playerProjectile);\n                \n                // Double-check if enemy was destroyed \n                if (!health.isDestroyed) {\n                    console.error(\"ERROR: Enemy not destroyed after particle hit! Sending entity.destroyed event...\");\n                    // Instead of forcing destruction, trigger the entity.destroyed event\n                    health.isDestroyed = true;\n                    health.health = 0;\n                    \n                    // Force publish destruction event - this will trigger the proper pool handling\n                    this.world.messageBus.publish('entity.destroyed', {\n                        entity: enemyEntity,\n                        source: playerProjectile,\n                        damageType: 'particle'\n                    });\n                } else {\n                    console.log(\"ENEMY DESTROYED CONFIRMED! Health reached zero and isDestroyed=true\");\n                }\n            }\n            \n            // Get position for effects\n            let position = null;\n            try {\n                position = playerProjectile.getComponent('TransformComponent').position.clone();\n            } catch (error) {\n                // Fallback to enemy position if needed\n                try {\n                    position = enemyEntity.getComponent('TransformComponent').position.clone();\n                } catch (innerError) {\n                    // Use zero as last resort\n                    position = new THREE.Vector3(0, 0, 0);\n                }\n            }\n            \n            // Publish events for the hit\n            this.world.messageBus.publish('collision.trigger', {\n                entityA: playerProjectile,\n                entityB: enemyEntity,\n                projectileHit: true\n            });\n            \n            this.world.messageBus.publish('projectile.hit', {\n                projectile: playerProjectile,\n                target: enemyEntity,\n                position: position\n            });\n            \n            // Destroy the projectile only - the enemy will be handled by its health component\n            this.world.destroyEntity(playerProjectile.id);\n        } else {\n            // Generic trigger event for non-projectile collisions\n            this.world.messageBus.publish('collision.trigger', {\n                entityA: entity,\n                entityB: otherEntity\n            });\n        }\n    }\n    \n    /**\n     * Resolve a physical collision with impulse-based physics\n     * @private\n     */\n    _resolveCollision(entityA, entityB, transformA, rigidbodyA, transformB, rigidbodyB) {\n        // Use reusable vectors instead of creating new ones\n        \n        // Calculate collision normal\n        this.collisionNormal.copy(transformA.position).sub(transformB.position).normalize();\n        \n        // Calculate relative velocity\n        this.relativeVelocity.copy(rigidbodyA.velocity).sub(rigidbodyB.velocity);\n        \n        // Calculate relative velocity along the normal\n        const velocityAlongNormal = this.relativeVelocity.dot(this.collisionNormal);\n        \n        // Only resolve if objects are moving toward each other\n        if (velocityAlongNormal > 0) return;\n        \n        // Calculate restitution (bounciness)\n        const restitution = 0.3;\n        \n        // Calculate inverse masses (handle infinite mass objects for immovable objects)\n        const invMassA = rigidbodyA.isKinematic ? 0 : 1 / rigidbodyA.mass;\n        const invMassB = rigidbodyB.isKinematic ? 0 : 1 / rigidbodyB.mass;\n        \n        // Calculate impulse scalar\n        const impulseScalar = -(1 + restitution) * velocityAlongNormal / (invMassA + invMassB);\n        \n        // Apply impulse\n        // Using our reusable vector and scaling it\n        this.tempVec1.copy(this.collisionNormal).multiplyScalar(impulseScalar * invMassA);\n        this.tempVec2.copy(this.collisionNormal).multiplyScalar(impulseScalar * invMassB);\n        \n        rigidbodyA.velocity.sub(this.tempVec1);\n        rigidbodyB.velocity.add(this.tempVec2);\n        \n        // Position correction to prevent sinking\n        const percent = 0.2; // penetration percentage to correct\n        const slop = 0.01; // penetration allowance\n        \n        // Calculate penetration depth\n        const distanceSquared = transformA.position.distanceToSquared(transformB.position);\n        const radiusSum = rigidbodyA.collisionRadius + rigidbodyB.collisionRadius;\n        const penetration = radiusSum - Math.sqrt(distanceSquared);\n        \n        if (penetration > slop) {\n            const correction = Math.max(penetration - slop, 0) / (invMassA + invMassB) * percent;\n            \n            // Apply correction\n            this.tempVec1.copy(this.collisionNormal).multiplyScalar(correction * invMassA);\n            this.tempVec2.copy(this.collisionNormal).multiplyScalar(correction * invMassB);\n            \n            transformA.position.sub(this.tempVec1);\n            transformB.position.add(this.tempVec2);\n        }\n    }\n}","/**\n * VisualEffectsSystem - Manages visual effects like explosions, damage flashes, etc.\n * \n * This system handles creating and managing visual effects for the game,\n * keeping them separate from game logic.\n */\n\nimport * as THREE from 'three';\nimport { System } from '../../core/system.js';\n\nexport class VisualEffectsSystem extends System {\n    constructor(world) {\n        super(world);\n        this.priority = 70; // Lower priority, run after gameplay systems\n        \n        // Keep track of active effects\n        this.activeEffects = new Map();\n        \n        // Effect counters for unique IDs\n        this.effectCounter = 0;\n        \n        // Setup listeners for effect events\n        this.setupEventListeners();\n        \n        console.log(\"VisualEffectsSystem initialized\");\n    }\n    \n    /**\n     * Set up event listeners for visual effect events\n     */\n    setupEventListeners() {\n        // Listen for explosion effect requests\n        this.world.messageBus.subscribe('vfx.explosion', this.handleExplosionRequest.bind(this));\n        \n        // Listen for damage flash effect requests\n        this.world.messageBus.subscribe('vfx.damageFlash', this.handleDamageFlashRequest.bind(this));\n    }\n    \n    /**\n     * Update all active visual effects\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        // Update all active effects and remove completed ones\n        for (const [id, effect] of this.activeEffects.entries()) {\n            if (!effect.update(deltaTime)) {\n                // Effect is complete, remove it\n                this.removeEffect(id);\n            }\n        }\n    }\n    \n    /**\n     * Handle request to create an explosion effect\n     * @param {object} message The explosion request message\n     */\n    handleExplosionRequest(message) {\n        if (!message || !message.data || !message.data.position) {\n            console.error(\"Invalid explosion effect request\", message);\n            return;\n        }\n        \n        // Extract parameters from message\n        const position = message.data.position;\n        const scale = message.data.scale || 1.0;\n        const duration = message.data.duration || 2.0;\n        \n        // Create explosion effect\n        this.createExplosionEffect(position, scale, duration);\n        \n        // Play explosion sound (use boink instead of explosion)\n        if (window.game && window.game.audio) {\n            window.game.audio.playSound('boink');\n        }\n    }\n    \n    /**\n     * Handle request to create a damage flash effect\n     * @param {object} message The damage flash request message\n     */\n    handleDamageFlashRequest(message) {\n        // Extract intensity from message if available\n        const intensity = message && message.data && message.data.intensity ? \n            message.data.intensity : 0.3;\n        \n        // Create damage flash effect\n        this.createDamageFlashEffect(intensity);\n    }\n    \n    /**\n     * Create an explosion effect at the specified position\n     * @param {THREE.Vector3} position Position for the explosion\n     * @param {number} scale Size scale for the explosion (1.0 = normal)\n     * @param {number} duration Duration in seconds\n     * @returns {number} Effect ID\n     */\n    createExplosionEffect(position, scale = 1.0, duration = 2.0) {\n        // Get access to THREE.js scene\n        if (!this.world.scene) {\n            console.error(\"No scene available for explosion effect\");\n            return -1;\n        }\n        \n        // Create effect container\n        const container = new THREE.Group();\n        container.position.copy(position);\n        container.scale.set(scale, scale, scale);\n        \n        // Create particles for explosion - use object pool if available\n        const particleCount = Math.floor(20 * scale);\n        const particles = [];\n        \n        // Check if pooling system is available\n        const usePooling = window.objectPool && \n                          window.objectPool.pools && \n                          window.objectPool.pools['explosionParticle'];\n        \n        // Create particles with properties\n        for (let i = 0; i < particleCount; i++) {\n            let particle;\n            const size = Math.random() * 2 + 1;\n            \n            if (usePooling) {\n                // Get particle from pool\n                particle = window.objectPool.get('explosionParticle');\n                \n                if (particle) {\n                    // Position randomly within explosion radius\n                    const radius = Math.random() * 10;\n                    const theta = Math.random() * Math.PI * 2;\n                    const phi = Math.random() * Math.PI;\n                    \n                    const particlePos = new THREE.Vector3(\n                        radius * Math.sin(phi) * Math.cos(theta),\n                        radius * Math.sin(phi) * Math.sin(theta),\n                        radius * Math.cos(phi)\n                    );\n                    \n                    // Reset the particle with position relative to container origin\n                    particle.reset(particlePos, size, 0xff5500);\n                    \n                    // Set velocity for animation\n                    particle.velocity.copy(particlePos).normalize().multiplyScalar(\n                        Math.random() * 2 + 1\n                    );\n                    \n                    // Add to container\n                    container.add(particle.mesh);\n                    particles.push(particle);\n                }\n            } else {\n                // Fallback to creating new particles if pool is not available\n                // Use precomputed geometry if available, otherwise create new\n                const geometry = window.game && window.game.explosionGeometry ? \n                                window.game.explosionGeometry : \n                                new THREE.SphereGeometry(size, 8, 8);\n                \n                // Use precomputed material as template if available\n                const material = window.game && window.game.explosionMaterial ? \n                                window.game.explosionMaterial.clone() : \n                                new THREE.MeshBasicMaterial({\n                                    color: 0xff5500,\n                                    transparent: true,\n                                    opacity: 0.8\n                                });\n                \n                const particleMesh = new THREE.Mesh(geometry, material);\n                \n                // Random position within explosion radius\n                const radius = Math.random() * 10;\n                const theta = Math.random() * Math.PI * 2;\n                const phi = Math.random() * Math.PI;\n                \n                particleMesh.position.set(\n                    radius * Math.sin(phi) * Math.cos(theta),\n                    radius * Math.sin(phi) * Math.sin(theta),\n                    radius * Math.cos(phi)\n                );\n                \n                // Store velocity in userData\n                particleMesh.userData.velocity = particleMesh.position.clone().normalize().multiplyScalar(\n                    Math.random() * 2 + 1\n                );\n                \n                // Add to container\n                container.add(particleMesh);\n                particles.push({\n                    mesh: particleMesh,\n                    material: material,\n                    velocity: particleMesh.userData.velocity\n                });\n            }\n        }\n        \n        // Add container to scene\n        this.world.scene.add(container);\n        \n        // Create effect object\n        const effectId = this.effectCounter++;\n        const effect = {\n            id: effectId,\n            type: 'explosion',\n            container: container,\n            particles: particles,\n            duration: duration,\n            elapsed: 0,\n            usePooling: usePooling,\n            update: (dt) => {\n                // Update elapsed time\n                effect.elapsed += dt;\n                \n                // Check if effect is complete\n                if (effect.elapsed >= effect.duration) {\n                    // Clean up explosion particles\n                    if (effect.usePooling) {\n                        // Return particles to pool\n                        effect.particles.forEach(particle => {\n                            window.objectPool.release('explosionParticle', particle);\n                        });\n                    }\n                    // Remove container from scene\n                    this.world.scene.remove(container);\n                    return false;\n                }\n                \n                // Calculate progress (0 to 1)\n                const progress = effect.elapsed / effect.duration;\n                \n                // Update particle positions and opacity\n                effect.particles.forEach(particle => {\n                    if (effect.usePooling) {\n                        // Using pooled particles\n                        // Move particle outward\n                        particle.mesh.position.add(\n                            particle.velocity.clone().multiplyScalar(dt)\n                        );\n                        \n                        // Fade out gradually\n                        particle.material.opacity = 0.8 * (1 - progress);\n                        \n                        // Shrink slightly\n                        particle.mesh.scale.multiplyScalar(0.99);\n                    } else {\n                        // Using direct mesh\n                        // Move particle outward\n                        particle.mesh.position.add(\n                            particle.velocity.clone().multiplyScalar(dt)\n                        );\n                        \n                        // Fade out gradually\n                        particle.material.opacity = 0.8 * (1 - progress);\n                        \n                        // Shrink slightly\n                        particle.mesh.scale.multiplyScalar(0.99);\n                    }\n                });\n                \n                return true;\n            }\n        };\n        \n        // Add to active effects\n        this.activeEffects.set(effectId, effect);\n        \n        return effectId;\n    }\n    \n    /**\n     * Create a damage flash effect on screen\n     * @param {number} intensity Flash intensity (0-1)\n     * @returns {number} Effect ID\n     */\n    createDamageFlashEffect(intensity = 0.3) {\n        // Create a full-screen flash element\n        const flash = document.createElement('div');\n        flash.style.position = 'fixed';\n        flash.style.top = '0';\n        flash.style.left = '0';\n        flash.style.width = '100%';\n        flash.style.height = '100%';\n        flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;\n        flash.style.pointerEvents = 'none';\n        flash.style.zIndex = '1000';\n        flash.style.opacity = '1';\n        flash.style.transition = 'opacity 0.2s ease-out';\n        \n        // Add to DOM\n        document.body.appendChild(flash);\n        \n        // Create effect object\n        const effectId = this.effectCounter++;\n        const effect = {\n            id: effectId,\n            type: 'damageFlash',\n            element: flash,\n            duration: 0.3, // Fixed duration for damage flash\n            elapsed: 0,\n            update: (dt) => {\n                // Update elapsed time\n                effect.elapsed += dt;\n                \n                // Check if effect is complete\n                if (effect.elapsed >= effect.duration) {\n                    // Remove element from DOM\n                    if (document.body.contains(flash)) {\n                        document.body.removeChild(flash);\n                    }\n                    return false;\n                }\n                \n                // Calculate progress (0 to 1)\n                const progress = effect.elapsed / effect.duration;\n                \n                // Fade out\n                flash.style.opacity = (1 - progress).toString();\n                \n                return true;\n            }\n        };\n        \n        // Add to active effects\n        this.activeEffects.set(effectId, effect);\n        \n        return effectId;\n    }\n    \n    /**\n     * Remove an effect and clean up its resources\n     * @param {number} effectId ID of the effect to remove\n     */\n    removeEffect(effectId) {\n        // Get effect\n        const effect = this.activeEffects.get(effectId);\n        if (!effect) return;\n        \n        // Clean up based on effect type\n        if (effect.type === 'explosion') {\n            if (effect.container && this.world.scene) {\n                this.world.scene.remove(effect.container);\n            }\n        } else if (effect.type === 'damageFlash') {\n            if (effect.element && document.body.contains(effect.element)) {\n                document.body.removeChild(effect.element);\n            }\n        }\n        \n        // Remove from active effects\n        this.activeEffects.delete(effectId);\n    }\n    \n    /**\n     * Clean up all effects when system is disabled\n     */\n    onDisabled() {\n        // Remove all active effects\n        for (const effectId of this.activeEffects.keys()) {\n            this.removeEffect(effectId);\n        }\n        \n        // Clear effects map\n        this.activeEffects.clear();\n    }\n} "],"names":["RenderSystem","System","world","scene","camera","renderer","THREE.Frustum","THREE.Matrix4","message","entity","componentType","transform","mesh","checkComponentsAdded","msg","_a","meshComponent","error","position","radius","deltaTime","isInView","entities","missingCount","CollisionSystem","FixedArray","THREE.Vector3","i","rigidbody","cellX","cellY","cellZ","cellKey","isProjectile","cellRadius","velocity","speedFactor","dx","dy","dz","neighborKey","entityCellKeys","cellEntities","otherEntity","pairId","otherTransform","otherRigidbody","posA","radiusA","posB","radiusB","distanceSquared","radiusSum","playerProjectile","enemyEntity","entityIsProjectile","otherIsEnemy","otherIsProjectile","entityIsEnemy","projectileTransform","enemyTransform","distance","health","entityA","entityB","transformA","rigidbodyA","transformB","rigidbodyB","velocityAlongNormal","invMassA","invMassB","impulseScalar","percent","slop","penetration","correction","VisualEffectsSystem","id","effect","scale","duration","intensity","container","THREE.Group","particleCount","particles","usePooling","particle","size","theta","phi","particlePos","geometry","THREE.SphereGeometry","material","THREE.MeshBasicMaterial","particleMesh","THREE.Mesh","effectId","dt","progress","flash"],"mappings":"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"}