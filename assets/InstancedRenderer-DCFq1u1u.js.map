{"version":3,"file":"InstancedRenderer-DCFq1u1u.js","sources":["../../js/systems/rendering/InstancedRenderer.js"],"sourcesContent":["// InstancedRenderer.js - ECS-driven instanced rendering per cell × archetype\n\nimport * as THREE from 'three';\nimport { System } from '../../core/system.js';\n\nexport class InstancedRenderer extends System {\n  constructor(world, scene) {\n    super(world);\n    this.requiredComponents = ['TransformComponent'];\n    this.priority = 95; // run before standard RenderSystem (which is 100)\n    this.scene = scene;\n    this.cellSize = world && world.spatial ? world.spatial.cellSize : 400;\n\n    // cellKey|archetype -> { mesh, count, max, freeIds, dummy }\n    this.cellMeshes = new Map();\n    // entityId -> { key, index }\n    this.entityToInstance = new Map();\n  }\n\n  initialize() {\n    // Nothing on init; will allocate lazily\n  }\n\n  getArchetype(entity) {\n    if (entity.hasTag && entity.hasTag('enemy')) return 'enemy_drone';\n    return null; // others not yet handled\n  }\n\n  getCellKeyFromPosition(pos) {\n    const ix = Math.floor(pos.x / this.cellSize) | 0;\n    const iy = Math.floor(pos.y / this.cellSize) | 0;\n    const iz = Math.floor(pos.z / this.cellSize) | 0;\n    return `${ix}|${iy}|${iz}`;\n  }\n\n  ensureCellMesh(cellKey, archetype, sampleMesh) {\n    const key = `${cellKey}|${archetype}`;\n    let rec = this.cellMeshes.get(key);\n    if (rec) return rec;\n    // Derive geometry/material from sample mesh or simple placeholder\n    let geom, mat;\n    if (sampleMesh && sampleMesh.geometry && sampleMesh.material) {\n      geom = sampleMesh.geometry;\n      mat = sampleMesh.material;\n    } else {\n      geom = new THREE.SphereGeometry(2, 8, 8);\n      mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });\n    }\n    const max = 2048; // capacity per cell × archetype\n    const inst = new THREE.InstancedMesh(geom, mat, max);\n    inst.count = 0;\n    inst.frustumCulled = true;\n    this.scene.add(inst);\n    rec = { mesh: inst, count: 0, max, freeIds: [], dummy: new THREE.Object3D() };\n    this.cellMeshes.set(key, rec);\n    return rec;\n  }\n\n  allocateInstance(rec) {\n    if (rec.freeIds.length > 0) return rec.freeIds.pop();\n    if (rec.count >= rec.max) return -1;\n    const id = rec.count;\n    rec.count++;\n    rec.mesh.count = rec.count;\n    return id;\n  }\n\n  releaseInstance(rec, index) {\n    if (index < 0) return;\n    rec.freeIds.push(index);\n  }\n\n  update(deltaTime) {\n    const world = this.world;\n    if (!world || !world.entityManager) return;\n    const entities = world.getEntitiesWithComponents(['TransformComponent', 'MeshComponent']);\n\n    // Per-frame: hide original meshes for handled archetypes\n    for (const entity of entities) {\n      const archetype = this.getArchetype(entity);\n      if (!archetype) continue;\n      const meshComp = entity.getComponent('MeshComponent');\n      if (meshComp && meshComp.mesh) meshComp.mesh.visible = false;\n      const t = entity.getComponent('TransformComponent');\n      const cellKey = this.getCellKeyFromPosition(t.position);\n      const key = `${cellKey}|${archetype}`;\n      let mapEntry = this.entityToInstance.get(entity.id);\n      let rec = this.cellMeshes.get(key);\n\n      // If entity moved cell or not allocated, (re)allocate\n      if (!mapEntry || mapEntry.key !== key) {\n        // free previous\n        if (mapEntry) {\n          const prev = this.cellMeshes.get(mapEntry.key);\n          if (prev) this.releaseInstance(prev, mapEntry.index);\n        }\n        // ensure mesh\n        rec = this.ensureCellMesh(cellKey, archetype, meshComp ? meshComp.mesh : null);\n        const idx = this.allocateInstance(rec);\n        if (idx === -1) continue; // capacity reached\n        mapEntry = { key, index: idx };\n        this.entityToInstance.set(entity.id, mapEntry);\n      }\n\n      if (!rec) rec = this.cellMeshes.get(key);\n      if (!rec) continue;\n\n      // Update instance matrix\n      rec.dummy.position.copy(t.position);\n      rec.dummy.quaternion.copy(t.quaternion);\n      rec.dummy.scale.set(1, 1, 1);\n      rec.dummy.updateMatrix();\n      rec.mesh.setMatrixAt(mapEntry.index, rec.dummy.matrix);\n      rec.mesh.instanceMatrix.needsUpdate = true;\n    }\n\n    // TODO: CPU frustum cull by toggling entire cell meshes via bounding boxes\n    // and picking instanceId → entityId mapping if needed in future gates.\n  }\n}\n\n\n"],"names":["InstancedRenderer","System","world","scene","entity","pos","ix","iy","iz","cellKey","archetype","sampleMesh","key","rec","geom","mat","THREE.SphereGeometry","THREE.MeshBasicMaterial","max","inst","THREE.InstancedMesh","THREE.Object3D","id","index","deltaTime","entities","meshComp","t","mapEntry","prev","idx"],"mappings":"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"}