const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/InstancedRenderer-BF_LO-uX.js","assets/three-l6xBJAGV.js","assets/core-CQR7b8gS.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { MessageBus } from "./core-CQR7b8gS.js";
import { T as TrianglesDrawMode, a as TriangleFanDrawMode, b as TriangleStripDrawMode, L as Loader, c as LoaderUtils, F as FileLoader, M as MeshPhysicalMaterial, V as Vector2, C as Color, d as LinearSRGBColorSpace, S as SRGBColorSpace, e as SpotLight, P as PointLight, D as DirectionalLight, f as Matrix4, g as Vector3, I as InstancedMesh, Q as Quaternion, h as InstancedBufferAttribute, O as Object3D, i as TextureLoader, j as ImageBitmapLoader, B as BufferAttribute, k as InterleavedBuffer, l as LinearMipmapLinearFilter, N as NearestMipmapLinearFilter, m as LinearMipmapNearestFilter, n as NearestMipmapNearestFilter, o as LinearFilter, p as NearestFilter, R as RepeatWrapping, q as MirroredRepeatWrapping, r as ClampToEdgeWrapping, s as PointsMaterial, t as Material, u as LineBasicMaterial, v as MeshStandardMaterial, w as DoubleSide, x as MeshBasicMaterial, y as PropertyBinding, z as BufferGeometry, A as SkinnedMesh, E as Mesh, G as LineSegments, H as Line, J as LineLoop, K as Points, U as Group, W as PerspectiveCamera, X as MathUtils, Y as OrthographicCamera, Z as Skeleton, _ as AnimationClip, $ as Bone, a0 as InterpolateDiscrete, a1 as InterpolateLinear, a2 as InterleavedBufferAttribute, a3 as Texture, a4 as VectorKeyframeTrack, a5 as NumberKeyframeTrack, a6 as QuaternionKeyframeTrack, a7 as ColorManagement, a8 as FrontSide, a9 as Interpolant, aa as Box3, ab as Sphere, ac as Float32BufferAttribute, ad as ShaderMaterial, ae as UniformsUtils, af as WebGLRenderTarget, ag as HalfFloatType, ah as NoBlending, ai as Clock, aj as AdditiveBlending, ak as Euler, al as BoxGeometry, am as Raycaster, an as SphereGeometry, ao as OctahedronGeometry, ap as MeshPhongMaterial, aq as RingGeometry, ar as Frustum, as as CylinderGeometry, at as TorusGeometry, au as Scene, av as AmbientLight, aw as HemisphereLight, ax as WebGLRenderer, ay as PCFSoftShadowMap, az as ACESFilmicToneMapping, aA as ConeGeometry, aB as BackSide, aC as Sprite, aD as SpriteMaterial, aE as CameraHelper, aF as CircleGeometry, aG as IcosahedronGeometry, aH as TetrahedronGeometry, aI as CanvasTexture, aJ as PlaneGeometry, aK as DodecahedronGeometry, aL as CubicBezierCurve3, aM as EdgesGeometry, aN as PCFShadowMap } from "./three-l6xBJAGV.js";
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/Asteroid-Miner/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
class GLTFLoader extends Loader {
  /**
   * Constructs a new glTF loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  /**
   * Starts loading from the given URL and passes the loaded glTF asset
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  /**
   * Sets the given Draco loader to this loader. Required for decoding assets
   * compressed with the `KHR_draco_mesh_compression` extension.
   *
   * @param {DRACOLoader} dracoLoader - The Draco loader to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  /**
   * Sets the given KTX2 loader to this loader. Required for loading KTX2
   * compressed textures.
   *
   * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  /**
   * Sets the given meshopt decoder. Required for decoding assets
   * compressed with the `EXT_meshopt_compression` extension.
   *
   * @param {Object} meshoptDecoder - The meshopt decoder to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  /**
   * Registers a plugin callback. This API is internally used to implement the various
   * glTF extensions but can also used by third-party code to add additional logic
   * to the loader.
   *
   * @param {function(parser:GLTFParser)} callback - The callback function to register.
   * @return {GLTFLoader} A reference to this loader.
   */
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  /**
   * Unregisters a plugin callback.
   *
   * @param {Function} callback - The callback function to unregister.
   * @return {GLTFLoader} A reference to this loader.
   */
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  /**
   * Parses the given FBX data and returns the resulting group.
   *
   * @param {string|ArrayBuffer} data - The raw glTF data.
   * @param {string} path - The URL base path.
   * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  /**
   * Async version of {@link GLTFLoader#parse}.
   *
   * @async
   * @param {string|ArrayBuffer} data - The raw glTF data.
   * @param {string} path - The URL base path.
   * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.
   */
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
}
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light") return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsDispersionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsBumpExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFTextureAVIFExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
}
class GLTFMeshGpuInstancing {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform2) {
    if ((transform2.texCoord === void 0 || transform2.texCoord === texture.channel) && transform2.offset === void 0 && transform2.rotation === void 0 && transform2.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform2.texCoord !== void 0) {
      texture.channel = transform2.texCoord;
    }
    if (transform2.offset !== void 0) {
      texture.offset.fromArray(transform2.offset);
    }
    if (transform2.rotation !== void 0) {
      texture.rotation = transform2.rotation;
    }
    if (transform2.scale !== void 0) {
      texture.repeat.fromArray(transform2.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p = (t - t0) / td;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
}
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t, t1) {
    const result = super.interpolate_(i1, t0, t, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
}
const WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
const ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  if (uri.search(/\.ktx2($|\?)/i) > 0 || uri.search(/^data\:image\/ktx2/) === 0) return "image/ktx2";
  return "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   *
   * @private
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @private
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(cache, index) {
    if (index === void 0) return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @private
   * @param {Object} cache
   * @param {number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   *
   * @private
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   *
   * @private
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   *
   * @private
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   *
   * @private
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   *
   * @private
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   *
   * @private
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @private
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} [colorSpace]
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform2 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform2) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform2);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   *
   * @private
   * @param {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   *
   * @private
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @private
   * @param {string} originalName
   * @return {string}
   */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @private
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   *
   * @private
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   *
   * @private
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   *
   * @private
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   *
   * @private
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0) continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh) return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   *
   * @private
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   *
   * @private
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.translation:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl = targetNames.length; j < jl; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl = outputArray.length; j < jl; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
const CopyShader = {
  name: "CopyShader",
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Pass {
  /**
   * Constructs a new pass.
   */
  constructor() {
    this.isPass = true;
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  /**
   * Sets the size of the pass.
   *
   * @abstract
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize() {
  }
  /**
   * This method holds the render logic of a pass. It must be implemented in all derived classes.
   *
   * @abstract
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   *
   * @abstract
   */
  dispose() {
  }
}
const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class FullscreenTriangleGeometry extends BufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
}
const _geometry = new FullscreenTriangleGeometry();
class FullScreenQuad {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}
class ShaderPass extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
   * defines and uniforms. It's also valid to pass a custom shader material.
   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
   * the read buffer.
   */
  constructor(shader, textureID = "tDiffuse") {
    super();
    this.textureID = textureID;
    this.uniforms = null;
    this.material = null;
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        name: shader.name !== void 0 ? shader.name : "unspecified",
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this._fsQuad = new FullScreenQuad(this.material);
  }
  /**
   * Performs the shader pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this._fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this._fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this._fsQuad.render(renderer);
    }
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose();
    this._fsQuad.dispose();
  }
}
class MaskPass extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The 3D objects in this scene will define the mask.
   * @param {Camera} camera - The camera.
   */
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  /**
   * Performs a mask pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.color.setMask(true);
    state.buffers.depth.setMask(true);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
}
class ClearMaskPass extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super();
    this.needsSwap = false;
  }
  /**
   * Performs the clear of the currently defined mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
}
class EffectComposer {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
   * be used as the internal read and write buffers. If not given, the composer creates
   * the buffers automatically.
   */
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    this._pixelRatio = renderer.getPixelRatio();
    if (renderTarget === void 0) {
      const size = renderer.getSize(new Vector2());
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType });
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.copyPass.material.blending = NoBlending;
    this.clock = new Clock();
  }
  /**
   * Swaps the internal read/write buffers.
   */
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  /**
   * Adds the given pass to the pass chain.
   *
   * @param {Pass} pass - The pass to add.
   */
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Inserts the given pass at a given index.
   *
   * @param {Pass} pass - The pass to insert.
   * @param {number} index - The index into the pass chain.
   */
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Removes the given pass from the pass chain.
   *
   * @param {Pass} pass - The pass to remove.
   */
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  /**
   * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
   *
   * @param {number} passIndex - The pass index.
   * @return {boolean} Whether the the pass for the given index is the last pass in the pass chain.
   */
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  /**
   * Executes all enabled post-processing passes in order to produce the final frame.
   *
   * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
   * its own time delta value.
   */
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false) continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  /**
   * Resets the internal state of the EffectComposer.
   *
   * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
   * the one from the constructor. If set, it is used to setup the read and write buffers.
   */
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  /**
   * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
   * this method honors the current pixel ration.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  /**
   * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
   * Setting the pixel ratio will automatically resize the composer.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the composer is no longer used in your app.
   */
  dispose() {
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.copyPass.dispose();
  }
}
class RenderPass extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera.
   * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
   * for all objects in the scene.
   * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
   * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
   */
  constructor(scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  /**
   * Performs a beauty pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer, writeBuffer, readBuffer) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== null) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor !== null) {
      renderer.getClearColor(this._oldClearColor);
      renderer.setClearColor(this.clearColor, renderer.getClearAlpha());
    }
    if (this.clearAlpha !== null) {
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearAlpha(this.clearAlpha);
    }
    if (this.clearDepth == true) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear === true) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    renderer.render(this.scene, this.camera);
    if (this.clearColor !== null) {
      renderer.setClearColor(this._oldClearColor);
    }
    if (this.clearAlpha !== null) {
      renderer.setClearAlpha(oldClearAlpha);
    }
    if (this.overrideMaterial !== null) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
}
const LuminosityHighPassShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "luminosityThreshold": { value: 1 },
    "smoothWidth": { value: 1 },
    "defaultColor": { value: new Color(0) },
    "defaultOpacity": { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
  )
};
class UnrealBloomPass extends Pass {
  /**
   * Constructs a new Unreal Bloom pass.
   *
   * @param {Vector2} [resolution] - The effect's resolution.
   * @param {number} [strength=1] - The Bloom strength.
   * @param {number} radius - The Bloom radius.
   * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.
   */
  constructor(resolution, strength = 1, radius, threshold) {
    super();
    this.strength = strength;
    this.radius = radius;
    this.threshold = threshold;
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    this.clearColor = new Color(0, 0, 0);
    this.needsSwap = false;
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    let resx = Math.round(this.resolution.x / 2);
    let resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.renderTargetBright.texture.generateMipmaps = false;
    for (let i = 0; i < this.nMips; i++) {
      const renderTargetHorizontal = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
      renderTargetHorizontal.texture.name = "UnrealBloomPass.h" + i;
      renderTargetHorizontal.texture.generateMipmaps = false;
      this.renderTargetsHorizontal.push(renderTargetHorizontal);
      const renderTargetVertical = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
      renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
      renderTargetVertical.texture.generateMipmaps = false;
      this.renderTargetsVertical.push(renderTargetVertical);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    const highPassShader = LuminosityHighPassShader;
    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
    this.highPassUniforms["luminosityThreshold"].value = threshold;
    this.highPassUniforms["smoothWidth"].value = 0.01;
    this.materialHighPassFilter = new ShaderMaterial({
      uniforms: this.highPassUniforms,
      vertexShader: highPassShader.vertexShader,
      fragmentShader: highPassShader.fragmentShader
    });
    this.separableBlurMaterials = [];
    const kernelSizeArray = [3, 5, 7, 9, 11];
    resx = Math.round(this.resolution.x / 2);
    resy = Math.round(this.resolution.y / 2);
    for (let i = 0; i < this.nMips; i++) {
      this.separableBlurMaterials.push(this._getSeparableBlurMaterial(kernelSizeArray[i]));
      this.separableBlurMaterials[i].uniforms["invSize"].value = new Vector2(1 / resx, 1 / resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this._getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    this.copyUniforms = UniformsUtils.clone(CopyShader.uniforms);
    this.blendMaterial = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this._oldClearColor = new Color();
    this._oldClearAlpha = 1;
    this._basic = new MeshBasicMaterial();
    this._fsQuad = new FullScreenQuad(null);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {
      this.renderTargetsHorizontal[i].dispose();
    }
    for (let i = 0; i < this.renderTargetsVertical.length; i++) {
      this.renderTargetsVertical[i].dispose();
    }
    this.renderTargetBright.dispose();
    for (let i = 0; i < this.separableBlurMaterials.length; i++) {
      this.separableBlurMaterials[i].dispose();
    }
    this.compositeMaterial.dispose();
    this.blendMaterial.dispose();
    this._basic.dispose();
    this._fsQuad.dispose();
  }
  /**
   * Sets the size of the pass.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(width, height) {
    let resx = Math.round(width / 2);
    let resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i = 0; i < this.nMips; i++) {
      this.renderTargetsHorizontal[i].setSize(resx, resy);
      this.renderTargetsVertical[i].setSize(resx, resy);
      this.separableBlurMaterials[i].uniforms["invSize"].value = new Vector2(1 / resx, 1 / resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  }
  /**
   * Performs the Bloom pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this._oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive) renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this._fsQuad.material = this._basic;
      this._basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this._fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this._fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this._fsQuad.render(renderer);
    let inputRenderTarget = this.renderTargetBright;
    for (let i = 0; i < this.nMips; i++) {
      this._fsQuad.material = this.separableBlurMaterials[i];
      this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
      renderer.clear();
      this._fsQuad.render(renderer);
      this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;
      this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i]);
      renderer.clear();
      this._fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i];
    }
    this._fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this._fsQuad.render(renderer);
    this._fsQuad.material = this.blendMaterial;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive) renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this._fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this._fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this._oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  // internals
  _getSeparableBlurMaterial(kernelRadius) {
    const coefficients = [];
    for (let i = 0; i < kernelRadius; i++) {
      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);
    }
    return new ShaderMaterial({
      defines: {
        "KERNEL_RADIUS": kernelRadius
      },
      uniforms: {
        "colorTexture": { value: null },
        "invSize": { value: new Vector2(0.5, 0.5) },
        // inverse texture size
        "direction": { value: new Vector2(0.5, 0.5) },
        "gaussianCoefficients": { value: coefficients }
        // precomputed Gaussian coefficients
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  _getCompositeMaterial(nMips) {
    return new ShaderMaterial({
      defines: {
        "NUM_MIPS": nMips
      },
      uniforms: {
        "blurTexture1": { value: null },
        "blurTexture2": { value: null },
        "blurTexture3": { value: null },
        "blurTexture4": { value: null },
        "blurTexture5": { value: null },
        "bloomStrength": { value: 1 },
        "bloomFactors": { value: null },
        "bloomTintColors": { value: null },
        "bloomRadius": { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);
const FXAAShader = {
  name: "FXAAShader",
  uniforms: {
    "tDiffuse": { value: null },
    "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;

		#define EDGE_STEP_COUNT 6
		#define EDGE_GUESS 8.0
		#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0
		const float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );

		float _ContrastThreshold = 0.0312;
		float _RelativeThreshold = 0.063;
		float _SubpixelBlending = 1.0;

		vec4 Sample( sampler2D  tex2D, vec2 uv ) {

			return texture( tex2D, uv );

		}

		float SampleLuminance( sampler2D tex2D, vec2 uv ) {

			return dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );

		}

		float SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {

			uv += texSize * vec2(uOffset, vOffset);
			return SampleLuminance(tex2D, uv);

		}

		struct LuminanceData {

			float m, n, e, s, w;
			float ne, nw, se, sw;
			float highest, lowest, contrast;

		};

		LuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {

			LuminanceData l;
			l.m = SampleLuminance( tex2D, uv );
			l.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );
			l.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );
			l.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );
			l.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );

			l.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );
			l.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );
			l.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );
			l.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );

			l.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );
			l.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );
			l.contrast = l.highest - l.lowest;
			return l;

		}

		bool ShouldSkipPixel( LuminanceData l ) {

			float threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );
			return l.contrast < threshold;

		}

		float DeterminePixelBlendFactor( LuminanceData l ) {

			float f = 2.0 * ( l.n + l.e + l.s + l.w );
			f += l.ne + l.nw + l.se + l.sw;
			f *= 1.0 / 12.0;
			f = abs( f - l.m );
			f = clamp( f / l.contrast, 0.0, 1.0 );

			float blendFactor = smoothstep( 0.0, 1.0, f );
			return blendFactor * blendFactor * _SubpixelBlending;

		}

		struct EdgeData {

			bool isHorizontal;
			float pixelStep;
			float oppositeLuminance, gradient;

		};

		EdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {

			EdgeData e;
			float horizontal =
				abs( l.n + l.s - 2.0 * l.m ) * 2.0 +
				abs( l.ne + l.se - 2.0 * l.e ) +
				abs( l.nw + l.sw - 2.0 * l.w );
			float vertical =
				abs( l.e + l.w - 2.0 * l.m ) * 2.0 +
				abs( l.ne + l.nw - 2.0 * l.n ) +
				abs( l.se + l.sw - 2.0 * l.s );
			e.isHorizontal = horizontal >= vertical;

			float pLuminance = e.isHorizontal ? l.n : l.e;
			float nLuminance = e.isHorizontal ? l.s : l.w;
			float pGradient = abs( pLuminance - l.m );
			float nGradient = abs( nLuminance - l.m );

			e.pixelStep = e.isHorizontal ? texSize.y : texSize.x;

			if (pGradient < nGradient) {

				e.pixelStep = -e.pixelStep;
				e.oppositeLuminance = nLuminance;
				e.gradient = nGradient;

			} else {

				e.oppositeLuminance = pLuminance;
				e.gradient = pGradient;

			}

			return e;

		}

		float DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {

			vec2 uvEdge = uv;
			vec2 edgeStep;
			if (e.isHorizontal) {

				uvEdge.y += e.pixelStep * 0.5;
				edgeStep = vec2( texSize.x, 0.0 );

			} else {

				uvEdge.x += e.pixelStep * 0.5;
				edgeStep = vec2( 0.0, texSize.y );

			}

			float edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;
			float gradientThreshold = e.gradient * 0.25;

			vec2 puv = uvEdge + edgeStep * edgeSteps[0];
			float pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;
			bool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;

			for ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {

				puv += edgeStep * edgeSteps[i];
				pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;
				pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;

			}

			if ( !pAtEnd ) {

				puv += edgeStep * EDGE_GUESS;

			}

			vec2 nuv = uvEdge - edgeStep * edgeSteps[0];
			float nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;
			bool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;

			for ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {

				nuv -= edgeStep * edgeSteps[i];
				nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;
				nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;

			}

			if ( !nAtEnd ) {

				nuv -= edgeStep * EDGE_GUESS;

			}

			float pDistance, nDistance;
			if ( e.isHorizontal ) {

				pDistance = puv.x - uv.x;
				nDistance = uv.x - nuv.x;

			} else {

				pDistance = puv.y - uv.y;
				nDistance = uv.y - nuv.y;

			}

			float shortestDistance;
			bool deltaSign;
			if ( pDistance <= nDistance ) {

				shortestDistance = pDistance;
				deltaSign = pLuminanceDelta >= 0.0;

			} else {

				shortestDistance = nDistance;
				deltaSign = nLuminanceDelta >= 0.0;

			}

			if ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {

				return 0.0;

			}

			return 0.5 - shortestDistance / ( pDistance + nDistance );

		}

		vec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {

			LuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );
			if ( ShouldSkipPixel( luminance ) ) {

				return Sample( tex2D, uv );

			}

			float pixelBlend = DeterminePixelBlendFactor( luminance );
			EdgeData edge = DetermineEdge( texSize, luminance );
			float edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );
			float finalBlend = max( pixelBlend, edgeBlend );

			if (edge.isHorizontal) {

				uv.y += edge.pixelStep * finalBlend;

			} else {

				uv.x += edge.pixelStep * finalBlend;

			}

			return Sample( tex2D, uv );

		}

		void main() {

			gl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );

		}`
  )
};
const ColorCorrectionShader = {
  name: "ColorCorrectionShader",
  uniforms: {
    "tDiffuse": { value: null },
    "powRGB": { value: new Vector3(2, 2, 2) },
    "mulRGB": { value: new Vector3(1, 1, 1) },
    "addRGB": { value: new Vector3(0, 0, 0) }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec3 powRGB;
		uniform vec3 mulRGB;
		uniform vec3 addRGB;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );

		}`
  )
};
const FilmShader = {
  name: "FilmShader",
  uniforms: {
    "tDiffuse": { value: null },
    "time": { value: 0 },
    "intensity": { value: 0.5 },
    "grayscale": { value: false }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		uniform float intensity;
		uniform bool grayscale;
		uniform float time;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 base = texture2D( tDiffuse, vUv );

			float noise = rand( fract( vUv + time ) );

			vec3 color = base.rgb + base.rgb * clamp( 0.1 + noise, 0.0, 1.0 );

			color = mix( base.rgb, color, intensity );

			if ( grayscale ) {

				color = vec3( luminance( color ) ); // assuming linear-srgb

			}

			gl_FragColor = vec4( color, base.a );

		}`
  )
};
const VignetteShader = {
  name: "VignetteShader",
  uniforms: {
    "tDiffuse": { value: null },
    "offset": { value: 1 },
    "darkness": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float offset;
		uniform float darkness;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			// Eskil's vignette

			vec4 texel = texture2D( tDiffuse, vUv );
			vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
			gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );

		}`
  )
};
class WebGL {
  /**
   * Returns `true` if WebGL 2 is available.
   *
   * @return {boolean} Whether WebGL 2 is available or not.
   */
  static isWebGL2Available() {
    try {
      const canvas = document.createElement("canvas");
      return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns `true` if the given color space is available. This method can only be used
   * if WebGL 2 is supported.
   *
   * @param {string} colorSpace - The color space to test.
   * @return {boolean} Whether the given color space is available or not.
   */
  static isColorSpaceAvailable(colorSpace) {
    try {
      const canvas = document.createElement("canvas");
      const ctx = window.WebGL2RenderingContext && canvas.getContext("webgl2");
      ctx.drawingBufferColorSpace = colorSpace;
      return ctx.drawingBufferColorSpace === colorSpace;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns a `div` element representing a formatted error message that can be appended in
   * web sites if WebGL 2 isn't supported.
   *
   * @return {HTMLDivElement} A `div` element representing a formatted error message that WebGL 2 isn't supported.
   */
  static getWebGL2ErrorMessage() {
    return this._getErrorMessage(2);
  }
  // private
  static _getErrorMessage(version) {
    const names = {
      1: "WebGL",
      2: "WebGL 2"
    };
    const contexts = {
      1: window.WebGLRenderingContext,
      2: window.WebGL2RenderingContext
    };
    let message = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';
    const element = document.createElement("div");
    element.id = "webglmessage";
    element.style.fontFamily = "monospace";
    element.style.fontSize = "13px";
    element.style.fontWeight = "normal";
    element.style.textAlign = "center";
    element.style.background = "#fff";
    element.style.color = "#000";
    element.style.padding = "1.5em";
    element.style.width = "400px";
    element.style.margin = "5em auto 0";
    if (contexts[version]) {
      message = message.replace("$0", "graphics card");
    } else {
      message = message.replace("$0", "browser");
    }
    message = message.replace("$1", names[version]);
    element.innerHTML = message;
    return element;
  }
  // @deprecated, r168
  static isWebGLAvailable() {
    console.warn("isWebGLAvailable() has been deprecated and will be removed in r178. Use isWebGL2Available() instead.");
    try {
      const canvas = document.createElement("canvas");
      return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
    } catch (e) {
      return false;
    }
  }
  static getWebGLErrorMessage() {
    console.warn("getWebGLErrorMessage() has been deprecated and will be removed in r178. Use getWebGL2ErrorMessage() instead.");
    return this._getErrorMessage(1);
  }
}
class Entity {
  constructor(id, world) {
    this.id = id;
    this.world = world;
    this.components = /* @__PURE__ */ new Map();
    this.tags = /* @__PURE__ */ new Set();
    this._isEnemy = void 0;
    this._isPlayer = void 0;
    this._isProjectile = void 0;
    this._isPooled = void 0;
  }
  /**
   * Add a component to this entity
   * @param {Component} component The component to add
   * @returns {Entity} This entity for chaining
   */
  addComponent(component) {
    component.entity = this;
    this.components.set(component.constructor.name, component);
    if (component.onAttached) {
      component.onAttached();
    }
    if (this.world && this.world.messageBus) {
      this.world.messageBus.publish("component.added", {
        entity: this,
        componentType: component.constructor.name,
        component
      });
    }
    return this;
  }
  /**
   * Remove a component from this entity
   * @param {Function|string} componentType The component class or name to remove
   * @returns {Entity} This entity for chaining
   */
  removeComponent(componentType) {
    const component = this.getComponent(componentType);
    if (component) {
      if (component.onDetached) {
        component.onDetached();
      }
      component.entity = null;
      const componentTypeName = typeof componentType === "string" ? componentType : componentType.name;
      this.components.delete(componentTypeName);
      if (this.world && this.world.messageBus) {
        this.world.messageBus.publish("component.removed", {
          entity: this,
          componentType: componentTypeName,
          component
        });
      }
    }
    return this;
  }
  /**
   * Get a component of the specified type
   * @param {Function|string} componentType The component class or name to get
   * @returns {Component|null} The component or null if not found
   */
  getComponent(componentType) {
    if (typeof componentType === "string") {
      return this.components.get(componentType);
    }
    return this.components.get(componentType.name);
  }
  /**
   * Check if this entity has a component of the specified type
   * @param {Function|string} componentType The component class or name to check for
   * @returns {boolean} True if the entity has the component
   */
  hasComponent(componentType) {
    if (typeof componentType === "string") {
      return this.components.has(componentType);
    }
    return this.components.has(componentType.name);
  }
  /**
   * Sync internal tag cache with actual tags
   * @private
   */
  _syncTagCache() {
    this._isEnemy = this.tags.has("enemy");
    this._isPlayer = this.tags.has("player");
    this._isProjectile = this.tags.has("projectile");
    this._isPooled = this.tags.has("pooled");
  }
  /**
   * Add a tag to this entity
   * @param {string} tag The tag to add
   * @returns {Entity} This entity for chaining
   */
  addTag(tag) {
    if (!this.tags.has(tag)) {
      this.tags.add(tag);
      if (tag === "enemy") this._isEnemy = true;
      else if (tag === "player") this._isPlayer = true;
      else if (tag === "projectile") this._isProjectile = true;
      else if (tag === "pooled") this._isPooled = true;
      if (this.world && this.world.entityManager) {
        this.world.entityManager.onTagAdded(this, tag);
        if (!this.world.entityManager.entitiesByTag.has(tag) || !this.world.entityManager.entitiesByTag.get(tag).includes(this)) {
          if (!this.world.entityManager.entitiesByTag.has(tag)) {
            this.world.entityManager.entitiesByTag.set(tag, []);
          }
          this.world.entityManager.entitiesByTag.get(tag).push(this);
        }
      }
    }
    return this;
  }
  /**
   * Remove a tag from this entity
   * @param {string} tag The tag to remove
   * @returns {Entity} This entity for chaining
   */
  removeTag(tag) {
    if (this.tags.has(tag)) {
      this.tags.delete(tag);
      if (tag === "enemy") this._isEnemy = false;
      else if (tag === "player") this._isPlayer = false;
      else if (tag === "projectile") this._isProjectile = false;
      else if (tag === "pooled") this._isPooled = false;
      if (this.world && this.world.entityManager) {
        this.world.entityManager.onTagRemoved(this, tag);
      }
    }
    return this;
  }
  /**
   * Clear all tags from this entity
   * @returns {Entity} This entity for chaining
   */
  clearTags() {
    const allTags = [...this.tags];
    for (const tag of allTags) {
      this.removeTag(tag);
    }
    this._isEnemy = false;
    this._isPlayer = false;
    this._isProjectile = false;
    this._isPooled = false;
    this.tags.clear();
    return this;
  }
  /**
   * Check if this entity has the specified tag
   * @param {string} tag The tag to check for
   * @returns {boolean} True if the entity has the tag
   */
  hasTag(tag) {
    const hasTag = this.tags.has(tag);
    let cacheInconsistent = false;
    if (tag === "enemy" && this._isEnemy !== hasTag) {
      this._isEnemy = hasTag;
      cacheInconsistent = true;
    } else if (tag === "player" && this._isPlayer !== hasTag) {
      this._isPlayer = hasTag;
      cacheInconsistent = true;
    } else if (tag === "projectile" && this._isProjectile !== hasTag) {
      this._isProjectile = hasTag;
      cacheInconsistent = true;
    } else if (tag === "pooled" && this._isPooled !== hasTag) {
      this._isPooled = hasTag;
      cacheInconsistent = true;
    }
    if (cacheInconsistent) {
      this._syncTagCache();
    }
    return hasTag;
  }
}
class EntityManager {
  constructor(world) {
    this.world = world;
    this.entities = /* @__PURE__ */ new Map();
    this.entitiesByComponent = /* @__PURE__ */ new Map();
    this.entitiesByTag = /* @__PURE__ */ new Map();
    this.lastEntityId = 0;
    this.recycledEntities = [];
    this.maxRecycledEntities = 100;
  }
  /**
   * Create a new entity
   * @param {string} name Optional name for the entity
   * @returns {Entity} The created entity
   */
  createEntity(name = "") {
    let entity;
    if (this.recycledEntities.length > 0) {
      entity = this.recycledEntities.pop();
      entity.components.clear();
      entity.tags.clear();
      entity._isEnemy = void 0;
      entity._isPlayer = void 0;
      entity._isProjectile = void 0;
    } else {
      const id = this._generateEntityId();
      entity = new Entity(id, this.world);
    }
    this.entities.set(entity.id.toString(), entity);
    if (name) {
      entity.addTag(name);
    }
    this.world.messageBus.publish("entity.created", { entity });
    return entity;
  }
  /**
   * Destroy an entity and remove all its components
   * @param {Entity|string} entityOrId The entity or entity ID to destroy
   */
  destroyEntity(entityOrId) {
    const id = typeof entityOrId === "string" ? entityOrId : entityOrId.id;
    const entity = this.entities.get(id.toString());
    if (!entity) return;
    this.world.messageBus.publish("entity.destroyed", { entity });
    entity.tags.forEach((tag) => {
      if (this.entitiesByTag.has(tag)) {
        const entities = this.entitiesByTag.get(tag);
        const index = entities.indexOf(entity);
        if (index !== -1) {
          entities.splice(index, 1);
        }
        if (entities.length === 0) {
          this.entitiesByTag.delete(tag);
        }
      }
    });
    for (const [componentType, component] of entity.components.entries()) {
      entity.removeComponent(component.constructor);
    }
    this.entities.delete(id.toString());
    if (this.recycledEntities.length < this.maxRecycledEntities) {
      this.recycledEntities.push(entity);
    }
  }
  /**
   * Get an entity by ID
   * @param {string} id The entity ID
   * @returns {Entity|undefined} The entity or undefined if not found
   */
  getEntity(id) {
    return this.entities.get(id.toString());
  }
  /**
   * Get all entities with the specified tag
   * @param {string} tag The tag to filter by
   * @returns {Entity[]} Array of entities with the tag
   */
  getEntitiesByTag(tag) {
    return this.entitiesByTag.get(tag) || [];
  }
  /**
   * Get all entities that have all the specified components
   * @param {Function[]} componentTypes Array of component types
   * @returns {Entity[]} Array of entities with all components
   */
  getEntitiesWithComponents(componentTypes) {
    if (!componentTypes || componentTypes.length === 0) {
      return Array.from(this.entities.values());
    }
    return Array.from(this.entities.values()).filter((entity) => {
      return componentTypes.every((type) => entity.hasComponent(type));
    });
  }
  /**
   * Get all entities in the manager
   * @returns {Entity[]} Array of all entities
   */
  getEntities() {
    return Array.from(this.entities.values());
  }
  /**
   * Update entity tag index when a tag is added
   * @param {Entity} entity The entity
   * @param {string} tag The tag
   */
  onTagAdded(entity, tag) {
    if (!this.entitiesByTag.has(tag)) {
      this.entitiesByTag.set(tag, []);
    }
    this.entitiesByTag.get(tag).push(entity);
  }
  /**
   * Update entity tag index when a tag is removed
   * @param {Entity} entity The entity
   * @param {string} tag The tag
   */
  onTagRemoved(entity, tag) {
    if (this.entitiesByTag.has(tag)) {
      const entities = this.entitiesByTag.get(tag);
      const index = entities.indexOf(entity);
      if (index !== -1) {
        entities.splice(index, 1);
      }
      if (entities.length === 0) {
        this.entitiesByTag.delete(tag);
      }
    }
  }
  /**
   * Generate a unique entity ID
   * @returns {string} A unique entity ID
   * @private
   */
  _generateEntityId() {
    return (++this.lastEntityId).toString();
  }
}
class SystemManager {
  constructor(world) {
    this.world = world;
    this.systems = [];
    this.systemsByType = /* @__PURE__ */ new Map();
    if (!window.__perf) window.__perf = { systems: {} };
    this._tick = 0;
  }
  /**
   * Register a system with the manager
   * @param {System} system The system to register
   * @returns {System} The registered system
   */
  registerSystem(system) {
    if (this.systemsByType.has(system.constructor.name)) {
      console.warn(`System of type ${system.constructor.name} already registered`);
      return system;
    }
    this.systems.push(system);
    this.systemsByType.set(system.constructor.name, system);
    this.systems.sort((a, b) => a.priority - b.priority);
    return system;
  }
  /**
   * Get a system by type
   * @param {Function} systemType The system class type
   * @returns {System|undefined} The system instance or undefined if not found
   */
  getSystem(systemType) {
    return this.systemsByType.get(systemType.name);
  }
  /**
   * Update all enabled systems
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    this._tick = this._tick + 1 >>> 0;
    for (const system of this.systems) {
      if (!system.enabled) continue;
      const name = system.constructor.name;
      const isHeavy = name === "EnemySystem" || name === "CollisionSystem" || name === "TargetingSystem";
      if (isHeavy && (this._tick & 1) === 1) {
        continue;
      }
      const t0 = performance.now();
      system.update(deltaTime);
      const t1 = performance.now();
      if (window.__perf) {
        if (!window.__perf.systems) window.__perf.systems = {};
        window.__perf.systems[name] = Number(t1 - t0);
      }
    }
  }
  /**
   * Initialize all systems
   * Called once before the first update
   */
  initialize() {
    for (const system of this.systems) {
      if (typeof system.initialize === "function") {
        system.initialize();
      }
    }
  }
  /**
   * Enable a system by type
   * @param {Function} systemType The system class type
   */
  enableSystem(systemType) {
    const system = this.getSystem(systemType);
    if (system) {
      system.enable();
    }
  }
  /**
   * Disable a system by type
   * @param {Function} systemType The system class type
   */
  disableSystem(systemType) {
    const system = this.getSystem(systemType);
    if (system) {
      system.disable();
    }
  }
}
class SpatialHash {
  constructor(cellSize = 200) {
    this.cellSize = cellSize;
    this.map = /* @__PURE__ */ new Map();
    this.entityToCells = /* @__PURE__ */ new Map();
  }
  _key(ix, iy, iz) {
    return `${ix}|${iy}|${iz}`;
  }
  _cellIndex(v) {
    return Math.floor(v / this.cellSize) | 0;
  }
  _computeKeysForAABB(min, max) {
    const ix0 = this._cellIndex(min.x), iy0 = this._cellIndex(min.y), iz0 = this._cellIndex(min.z);
    const ix1 = this._cellIndex(max.x), iy1 = this._cellIndex(max.y), iz1 = this._cellIndex(max.z);
    const keys = [];
    for (let ix = ix0; ix <= ix1; ix++)
      for (let iy = iy0; iy <= iy1; iy++)
        for (let iz = iz0; iz <= iz1; iz++)
          keys.push(this._key(ix, iy, iz));
    return keys;
  }
  insert(entityId, position, radius = 1) {
    const min = { x: position.x - radius, y: position.y - radius, z: position.z - radius };
    const max = { x: position.x + radius, y: position.y + radius, z: position.z + radius };
    const keys = this._computeKeysForAABB(min, max);
    this.entityToCells.set(entityId, keys);
    for (const k of keys) {
      let set = this.map.get(k);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        this.map.set(k, set);
      }
      set.add(entityId);
    }
  }
  update(entityId, position, radius = 1) {
    this.remove(entityId);
    this.insert(entityId, position, radius);
  }
  remove(entityId) {
    const keys = this.entityToCells.get(entityId);
    if (!keys) return;
    for (const k of keys) {
      const set = this.map.get(k);
      if (set) {
        set.delete(entityId);
        if (set.size === 0) this.map.delete(k);
      }
    }
    this.entityToCells.delete(entityId);
  }
  querySphere(center, radius) {
    const min = { x: center.x - radius, y: center.y - radius, z: center.z - radius };
    const max = { x: center.x + radius, y: center.y + radius, z: center.z + radius };
    const keys = this._computeKeysForAABB(min, max);
    const result = /* @__PURE__ */ new Set();
    for (const k of keys) {
      const set = this.map.get(k);
      if (set) for (const id of set) result.add(id);
    }
    return Array.from(result);
  }
}
class EntityIndex {
  constructor() {
    this.entityToView = /* @__PURE__ */ new Map();
    this.tagToEntities = /* @__PURE__ */ new Map();
  }
  setView(entityId, view) {
    this.entityToView.set(entityId, view);
  }
  getView(entityId) {
    return this.entityToView.get(entityId);
  }
  clearView(entityId) {
    this.entityToView.delete(entityId);
  }
  addTag(entityId, tag) {
    let set = this.tagToEntities.get(tag);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      this.tagToEntities.set(tag, set);
    }
    set.add(entityId);
  }
  removeTag(entityId, tag) {
    const set = this.tagToEntities.get(tag);
    if (set) {
      set.delete(entityId);
      if (set.size === 0) this.tagToEntities.delete(tag);
    }
  }
  getByTag(tag) {
    const set = this.tagToEntities.get(tag);
    return set ? Array.from(set) : [];
  }
}
class World {
  constructor(messageBus = null) {
    this.messageBus = messageBus || new MessageBus();
    if (!messageBus && !window.mainMessageBus) {
      window.mainMessageBus = this.messageBus;
    }
    this.entityManager = new EntityManager(this);
    this.systemManager = new SystemManager(this);
    this.spatial = new SpatialHash(400);
    this.index = new EntityIndex();
    this.deltaTime = 0;
    this.time = 0;
    this.lastUpdateTime = 0;
  }
  /**
   * Initialize the world and all systems
   */
  initialize() {
    this.lastUpdateTime = performance.now();
    this.systemManager.initialize();
    this.messageBus.publish("world.initialized", {});
  }
  // Hook for systems to notify when entity moved
  onEntityTransformUpdated(entity) {
    const t = entity.getComponent && entity.getComponent("TransformComponent");
    if (t) this.spatial.update(entity.id, t.position, entity.collisionRadius || 1);
  }
  /**
   * Update all systems
   */
  update() {
    const now = performance.now();
    this.deltaTime = Math.min((now - this.lastUpdateTime) / 1e3, 0.1);
    this.lastUpdateTime = now;
    this.time += this.deltaTime;
    this.messageBus.publish("world.preUpdate", { deltaTime: this.deltaTime, time: this.time });
    this.systemManager.update(this.deltaTime);
    this.messageBus.publish("world.postUpdate", { deltaTime: this.deltaTime, time: this.time });
    if (window.DEBUG_MODE && this.time % 5 < this.deltaTime) {
      Array.from(this.entityManager.entities.values());
      this.getEntitiesWithComponents(["MeshComponent"]);
    }
  }
  /**
   * Create a new entity
   * @param {string} name Optional name for the entity
   * @returns {Entity} The created entity
   */
  createEntity(name = "") {
    return this.entityManager.createEntity(name);
  }
  /**
   * Destroy an entity
   * @param {Entity|string} entityOrId The entity or entity ID to destroy
   */
  destroyEntity(entityOrId) {
    this.entityManager.destroyEntity(entityOrId);
  }
  /**
   * Register a system
   * @param {System} system The system to register
   * @returns {System} The registered system
   */
  registerSystem(system) {
    return this.systemManager.registerSystem(system);
  }
  /**
   * Get entities with specific components
   * @param {Function[]} componentTypes Array of component types
   * @returns {Entity[]} Array of entities with all components
   */
  getEntitiesWithComponents(componentTypes) {
    return this.entityManager.getEntitiesWithComponents(componentTypes);
  }
  /**
   * Get entities with a specific tag
   * @param {string} tag The tag to filter by
   * @returns {Entity[]} Array of entities with the tag
   */
  getEntitiesByTag(tag) {
    return this.entityManager.getEntitiesByTag(tag);
  }
  /**
   * Get a specific entity by ID
   * @param {string} id The entity ID
   * @returns {Entity|undefined} The entity or undefined if not found
   */
  getEntity(id) {
    return this.entityManager.getEntity(id);
  }
  /**
   * Get a system by type
   * @param {Function} systemType The system class type
   * @returns {System|undefined} The system instance or undefined if not found
   */
  getSystem(systemType) {
    return this.systemManager.getSystem(systemType);
  }
}
class WorldSetup {
  constructor() {
    this.world = null;
    this.playerEntity = null;
    this.worldInitialized = false;
  }
  /**
   * Initialize the ECS world asynchronously
   * This is called from the constructor and runs in the background
   */
  async initializeECSWorld(scene, spaceship) {
    try {
      console.log("[COMBAT] Starting ECS world initialization...");
      this.world = new World(window.mainMessageBus);
      console.log(
        "[COMBAT] Created world with messageBus: ",
        this.world.messageBus === window.mainMessageBus ? "Using shared messageBus" : "Created new messageBus"
      );
      if (window.game) {
        window.game.ecsWorld = this.world;
        console.log("[COMBAT] Made ECS world globally available via window.game.ecsWorld");
      }
      this.world.scene = scene;
      console.log(
        `[COMBAT] Set scene reference in ECS world for enemy rendering:`,
        scene ? "Scene available" : "No scene available"
      );
      await this.createPlayerReferenceEntity(spaceship);
      if (!this.world.optimizedProjectiles) {
        try {
          const { OptimizedProjectileStore } = await __vitePreload(async () => {
            const { OptimizedProjectileStore: OptimizedProjectileStore2 } = await import("./OptimizedProjectileStore-By7FFnfF.js");
            return { OptimizedProjectileStore: OptimizedProjectileStore2 };
          }, true ? [] : void 0);
          this.world.optimizedProjectiles = new OptimizedProjectileStore(4096);
          console.log("[COMBAT] OptimizedProjectileStore created");
        } catch (e) {
          console.warn("[COMBAT] OptimizedProjectileStore unavailable:", e);
        }
      }
      console.log("[COMBAT] ECS world initialization complete");
      return this.world;
    } catch (error) {
      console.error("[COMBAT] Error initializing ECS world:", error);
      throw error;
    }
  }
  /**
   * Create a player reference entity in the ECS world
   * This allows enemies and other systems to interact with the player
   */
  async createPlayerReferenceEntity(spaceship) {
    if (!this.world) {
      console.error("[COMBAT] Cannot create player entity - world not available");
      return null;
    }
    if (!spaceship) {
      console.error("[COMBAT] Cannot create player entity - spaceship not available");
      return null;
    }
    try {
      console.log("[COMBAT] Creating player reference entity...");
      if (this.playerEntity) {
        const existingEntity = this.world.getEntity(this.playerEntity.id);
        if (existingEntity) {
          console.log(`[COMBAT] Player entity already exists with ID: ${this.playerEntity.id}`);
          if (!existingEntity.hasTag("player")) {
            console.log("[COMBAT] Re-adding 'player' tag to existing entity");
            existingEntity.addTag("player");
          }
          const transform2 = existingEntity.getComponent("TransformComponent");
          if (transform2 && spaceship.mesh) {
            transform2.position.copy(spaceship.mesh.position);
            transform2.rotation.copy(spaceship.mesh.rotation);
            transform2.quaternion.copy(spaceship.mesh.quaternion);
            if (typeof transform2.setUpdated === "function") {
              transform2.setUpdated();
            }
          }
          if (window.game) {
            window.game.combat = window.game.combat || {};
            window.game.combat.playerEntity = existingEntity;
          }
          return existingEntity;
        } else {
          console.log("[COMBAT] Previous player entity no longer exists, creating new one");
        }
      }
      const playerEntity = this.world.createEntity("player_" + Date.now());
      playerEntity.addTag("player");
      console.log(`[COMBAT] Added 'player' tag to entity ${playerEntity.id}`);
      let TransformComponent2, HealthComponent2;
      try {
        const transformModule = await __vitePreload(() => Promise.resolve().then(() => transform), true ? void 0 : void 0);
        TransformComponent2 = transformModule.TransformComponent;
        console.log("[COMBAT] Successfully imported TransformComponent");
      } catch (error) {
        console.error("[COMBAT] Failed to import TransformComponent:", error);
        TransformComponent2 = class FallbackTransform {
          constructor(position) {
            this.position = position || new Vector3();
            this.rotation = new Euler();
            this.quaternion = new Quaternion();
          }
        };
      }
      try {
        const healthModule = await __vitePreload(() => Promise.resolve().then(() => healthComponent), true ? void 0 : void 0);
        HealthComponent2 = healthModule.HealthComponent;
        console.log("[COMBAT] Successfully imported HealthComponent");
      } catch (error) {
        console.error("[COMBAT] Failed to import HealthComponent:", error);
        HealthComponent2 = class FallbackHealth {
          constructor(health, shield) {
            this.health = health || 100;
            this.shield = shield || 50;
            this.maxHealth = health || 100;
            this.maxShield = shield || 50;
          }
        };
      }
      try {
        const position = spaceship.mesh ? spaceship.mesh.position.clone() : new Vector3();
        const transform2 = new TransformComponent2(position);
        playerEntity.addComponent(transform2);
        console.log(`[COMBAT] Added TransformComponent to player entity with position: ${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)}`);
      } catch (error) {
        console.error("[COMBAT] Error adding TransformComponent to player entity:", error);
      }
      try {
        const health = new HealthComponent2(100, 50);
        playerEntity.addComponent(health);
        console.log("[COMBAT] Added HealthComponent to player entity");
      } catch (error) {
        console.error("[COMBAT] Error adding HealthComponent to player entity:", error);
      }
      this.playerEntity = playerEntity;
      if (window.game) {
        window.game.combat = window.game.combat || {};
        window.game.combat.playerEntity = playerEntity;
        console.log("[COMBAT] Made player entity globally accessible via window.game.combat.playerEntity");
      }
      this.world.playerEntity = playerEntity;
      console.log("[COMBAT] Made player entity available directly via world.playerEntity");
      if (this.world && this.world.messageBus) {
        this.world.messageBus.publish("player.created", { entity: playerEntity });
        console.log("[COMBAT] Published player.created event");
      }
      console.log("[COMBAT] Successfully created player reference entity with ID:", playerEntity.id);
      return playerEntity;
    } catch (error) {
      console.error("[COMBAT] Error creating player reference entity:", error);
      console.error("[COMBAT] Stack trace:", error.stack);
      return null;
    }
  }
  /**
   * Update the player reference entity with the current spaceship position
   */
  updatePlayerReference(spaceship) {
    if (!this.world || !spaceship || !this.playerEntity) {
      if (this.world && spaceship && !this.playerEntity) {
        console.log("No player entity found, creating one...");
        this.createPlayerReferenceEntity(spaceship);
        return;
      }
      return;
    }
    const playerEntity = this.world.getEntity(this.playerEntity.id);
    if (!playerEntity) {
      console.warn("Player entity lost, recreating...");
      this.createPlayerReferenceEntity(spaceship);
      return;
    }
    const transform2 = playerEntity.getComponent("TransformComponent");
    if (transform2 && spaceship.mesh) {
      transform2.position.copy(spaceship.mesh.position);
      transform2.rotation.copy(spaceship.mesh.rotation);
      transform2.quaternion.copy(spaceship.mesh.quaternion);
      if (typeof transform2.setUpdated === "function") {
        transform2.setUpdated();
      }
    }
    const health = playerEntity.getComponent("HealthComponent");
    if (health && spaceship.health !== void 0) {
      if (spaceship.health > health.health) {
        health.health = spaceship.health;
      }
      if (spaceship.shield !== void 0 && spaceship.shield > health.shield) {
        health.shield = spaceship.shield;
      }
    }
  }
  /**
   * Sync the spaceship hull/shield with the player entity's HealthComponent
   */
  updateSpaceshipHealth(spaceship) {
    if (!this.playerEntity || !spaceship) return;
    const health = this.playerEntity.getComponent("HealthComponent");
    if (health) {
      if (health.health < spaceship.hull) {
        console.log(`Damage detected in health component: ${health.health} (was ${spaceship.hull})`);
        spaceship.hull = health.health;
      }
      if (health.shield < spaceship.shield) {
        console.log(`Shield damage detected in health component: ${health.shield} (was ${spaceship.shield})`);
        spaceship.shield = health.shield;
      }
      if (health.isDestroyed && !spaceship.isDestroyed) {
        console.log("Health component indicates player is destroyed - updating spaceship state");
        spaceship.isDestroyed = true;
        if (typeof spaceship.handleDestruction === "function") {
          spaceship.handleDestruction();
        }
      }
      if (health.health <= 0 && !spaceship.isDestroyed) {
        console.log("Player health is zero - marking spaceship as destroyed");
        spaceship.isDestroyed = true;
        if (typeof spaceship.handleDestruction === "function") {
          spaceship.handleDestruction();
        }
        if (window.game) {
          console.log("FORCING GAME OVER FROM COMBAT MODULE!");
          window.game.gameOver("You were pwned by a space alien!");
        }
      }
    }
  }
  /**
   * Initialize the world
   */
  initializeWorld() {
    try {
      console.log("[COMBAT] Calling world.initialize()...");
      this.world.initialize();
      console.log("[COMBAT] World initialization completed successfully");
    } catch (error) {
      console.error("[COMBAT] Error during world.initialize():", error);
      console.error("[COMBAT] Stack trace:", error.stack);
      console.log("[COMBAT] Continuing despite initialization error");
    }
  }
  /**
   * Mark world as initialized
   */
  setWorldInitialized() {
    this.worldInitialized = true;
  }
  /**
   * Set reference to this world in the scene for cross-component access
   */
  setSceneReference(scene) {
    if (scene) {
      scene.ecsWorld = this.world;
      console.log("[COMBAT] Set ECS world reference in scene for cross-system access");
    }
  }
  /**
   * Get the world instance
   */
  getWorld() {
    return this.world;
  }
  /**
   * Get the player entity
   */
  getPlayerEntity() {
    return this.playerEntity;
  }
  /**
   * Check if world is initialized
   */
  isWorldInitialized() {
    return this.worldInitialized;
  }
}
class System {
  constructor(world) {
    this.world = world;
    this.enabled = true;
    this.requiredComponents = [];
    this.priority = 0;
  }
  /**
   * Check if entity has all required components for this system
   * @param {Entity} entity The entity to check
   * @returns {boolean} True if entity can be processed by this system
   */
  checkEntity(entity) {
    return this.requiredComponents.every((componentType) => entity.hasComponent(componentType));
  }
  /**
   * Get all entities that match this system's requirements
   * @returns {Entity[]} Array of compatible entities
   */
  getEntities() {
    return this.world.getEntitiesWithComponents(this.requiredComponents);
  }
  /**
   * Update method called each frame
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (!this.enabled) return;
    const entities = this.getEntities();
    entities.forEach((entity) => {
      this.processEntity(entity, deltaTime);
    });
  }
  /**
   * Process a single entity
   * @param {Entity} entity The entity to process
   * @param {number} deltaTime Time since last update in seconds
   */
  processEntity(entity, deltaTime) {
  }
  /**
   * Initialize the system
   * Called once when the system is first registered
   */
  initialize() {
  }
  /**
   * Enable this system
   */
  enable() {
    this.enabled = true;
  }
  /**
   * Disable this system
   */
  disable() {
    this.enabled = false;
  }
}
class Component {
  constructor() {
    this.entity = null;
    this.enabled = true;
  }
  /**
   * Called when the component is attached to an entity
   * Override in derived components if needed
   */
  onAttached() {
  }
  /**
   * Called when the component is detached from an entity
   * Override in derived components if needed
   */
  onDetached() {
  }
  /**
   * Called when the component is enabled
   * Override in derived components if needed
   */
  onEnabled() {
  }
  /**
   * Called when the component is disabled
   * Override in derived components if needed
   */
  onDisabled() {
  }
  /**
   * Enable this component
   * @returns {Component} This component for chaining
   */
  enable() {
    if (!this.enabled) {
      this.enabled = true;
      this.onEnabled();
    }
    return this;
  }
  /**
   * Disable this component
   * @returns {Component} This component for chaining
   */
  disable() {
    if (this.enabled) {
      this.enabled = false;
      this.onDisabled();
    }
    return this;
  }
}
class HealthComponent extends Component {
  constructor(maxHealth = 100, maxShield = 0) {
    super();
    this.maxHealth = maxHealth;
    this.health = maxHealth;
    this.maxShield = maxShield;
    this.shield = maxShield;
    this.shieldRegenRate = 5;
    this.shieldRegenDelay = 3;
    this.timeSinceLastDamage = this.shieldRegenDelay;
    this.damageResistance = 0;
    this.isDestroyed = false;
    this.isInvulnerable = false;
  }
  // Add an onAttached method to subscribe to health sync events
  onAttached() {
    if (this.entity && this.entity.hasTag && this.entity.hasTag("player")) {
      if (this.entity.world && this.entity.world.messageBus) {
        this.entity.world.messageBus.subscribe("player.syncHealth", this.handleSyncHealth.bind(this));
        this.entity.world.messageBus.subscribe("player.undocked", this.handleSyncHealth.bind(this));
      } else if (window.mainMessageBus) {
        window.mainMessageBus.subscribe("player.syncHealth", this.handleSyncHealth.bind(this));
        window.mainMessageBus.subscribe("player.undocked", this.handleSyncHealth.bind(this));
      }
    }
  }
  // Handle the sync health event
  handleSyncHealth(message) {
    if (!this.entity || !this.entity.hasTag || !this.entity.hasTag("player")) {
      return;
    }
    const data = message.data || message;
    if (data.shield !== void 0) {
      this.shield;
      this.shield = data.shield;
    }
    if (data.maxShield !== void 0) {
      this.maxShield;
      this.maxShield = data.maxShield;
    }
    if (data.hull !== void 0) {
      this.health;
      this.health = data.hull;
    }
    if (data.maxHull !== void 0) {
      this.maxHealth;
      this.maxHealth = data.maxHull;
    }
  }
  /**
   * Apply damage to this entity
   * @param {number} amount Amount of damage to apply
   * @param {string} type Type of damage (e.g., 'projectile', 'collision', 'emp')
   * @param {object} source Source entity of the damage
   * @returns {object} Damage result with actual damage dealt
   */
  applyDamage(amount, type = "projectile", source = null) {
    if (this.isDestroyed || this.isInvulnerable) {
      return { damageApplied: 0, shieldDamage: 0, healthDamage: 0, destroyed: false };
    }
    const resistedAmount = amount * (1 - this.damageResistance);
    let shieldDamage = 0;
    let healthDamage = 0;
    this.timeSinceLastDamage = 0;
    if (this.shield > 0) {
      if (resistedAmount <= this.shield) {
        this.shield -= resistedAmount;
        shieldDamage = resistedAmount;
      } else {
        shieldDamage = this.shield;
        healthDamage = resistedAmount - this.shield;
        this.shield = 0;
        this.health -= healthDamage;
      }
    } else {
      this.health -= resistedAmount;
      healthDamage = resistedAmount;
    }
    if (this.health < 0) {
      this.health = 0;
    }
    if (this.health <= 0 && !this.isDestroyed) {
      this.isDestroyed = true;
      if (this.entity && this.entity.world) {
        this.entity.world.messageBus.publish("entity.destroyed", {
          entity: this.entity,
          source,
          damageType: type
        });
        if (this.entity.hasTag && this.entity.hasTag("player")) {
          if (this.entity && this.entity.world && this.entity.world.messageBus) {
            this.entity.world.messageBus.publish("game.over", {
              reason: "You were pwned by a space alien!",
              source: "health"
            });
          } else {
            __vitePreload(() => import("./core-CQR7b8gS.js"), true ? [] : void 0).then((module) => {
              const MessageBus2 = module.MessageBus;
              MessageBus2.triggerGameOver("You were pwned by a space alien!", "health");
            }).catch((err) => {
            });
          }
        }
      }
    }
    if (this.entity && this.entity.world) {
      this.entity.world.messageBus.publish("entity.damaged", {
        entity: this.entity,
        source,
        damageType: type,
        amount: resistedAmount,
        shieldDamage,
        healthDamage
      });
    }
    return {
      damageApplied: resistedAmount,
      shieldDamage,
      healthDamage,
      destroyed: this.isDestroyed
    };
  }
  /**
   * Heal the entity
   * @param {number} amount Amount to heal
   * @returns {number} Actual amount healed
   */
  heal(amount) {
    if (this.isDestroyed) return 0;
    const startHealth = this.health;
    this.health = Math.min(this.health + amount, this.maxHealth);
    const healedAmount = this.health - startHealth;
    if (healedAmount > 0 && this.entity && this.entity.world) {
      this.entity.world.messageBus.publish("entity.healed", {
        entity: this.entity,
        amount: healedAmount
      });
    }
    return healedAmount;
  }
  /**
   * Recharge the shield
   * @param {number} amount Amount to recharge
   * @returns {number} Actual amount recharged
   */
  rechargeShield(amount) {
    if (this.isDestroyed) return 0;
    const startShield = this.shield;
    this.shield = Math.min(this.shield + amount, this.maxShield);
    const rechargedAmount = this.shield - startShield;
    if (rechargedAmount > 0 && this.entity && this.entity.world) {
      this.entity.world.messageBus.publish("entity.shieldRecharged", {
        entity: this.entity,
        amount: rechargedAmount
      });
    }
    return rechargedAmount;
  }
  /**
   * Update shield and health regeneration
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (this.isDestroyed) return;
    this.timeSinceLastDamage += deltaTime;
    if (this.timeSinceLastDamage >= this.shieldRegenDelay && this.shield < this.maxShield) {
      const regenAmount = this.shieldRegenRate * deltaTime;
      this.rechargeShield(regenAmount);
    }
    if (this.entity && this.entity.hasTag("player") && this.health < this.maxHealth) {
      const healthRegenRate = this.maxHealth * 0.05;
      const healthRegenAmount = healthRegenRate * deltaTime;
      this.heal(healthRegenAmount);
    }
  }
  /**
   * Get health as a percentage (0-100)
   * @returns {number} Health percentage
   */
  getHealthPercentage() {
    return this.health / this.maxHealth * 100;
  }
  /**
   * Get shield as a percentage (0-100)
   * @returns {number} Shield percentage
   */
  getShieldPercentage() {
    return this.maxShield > 0 ? this.shield / this.maxShield * 100 : 0;
  }
  /**
   * Upgrade health capacity and fully heal
   * @param {number} multiplier Multiplier for health increase
   * @returns {object} New health stats
   */
  upgradeHealth(multiplier = 1.25) {
    const oldMax = this.maxHealth;
    this.maxHealth *= multiplier;
    this.health = this.maxHealth;
    if (this.entity && this.entity.world) {
      this.entity.world.messageBus.publish("health.upgraded", {
        entity: this.entity,
        oldMax,
        newMax: this.maxHealth
      });
    }
    return {
      maxHealth: this.maxHealth,
      healthBoost: this.maxHealth - oldMax
    };
  }
  /**
   * Upgrade shield capacity
   * @param {number} multiplier Multiplier for shield increase
   * @returns {object} New shield stats
   */
  upgradeShield(multiplier = 1.5) {
    const oldMax = this.maxShield;
    this.shield;
    this.maxShield = Math.ceil(this.maxShield * multiplier);
    this.shield = this.maxShield;
    if (this.entity && this.entity.world) {
      this.entity.world.messageBus.publish("shield.upgraded", {
        entity: this.entity,
        oldMax,
        newMax: this.maxShield
      });
    }
    return {
      maxShield: this.maxShield,
      shieldBoost: this.maxShield - oldMax
    };
  }
}
const healthComponent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HealthComponent
}, Symbol.toStringTag, { value: "Module" }));
class TransformComponent extends Component {
  constructor(position = new Vector3(), rotation = new Euler(), scale = new Vector3(1, 1, 1)) {
    super();
    this.position = position.clone();
    this.rotation = rotation.clone();
    this.scale = scale.clone();
    this.quaternion = new Quaternion().setFromEuler(this.rotation);
    this.matrix = new Matrix4();
    this.needsUpdate = true;
    this.prevPosition = this.position.clone();
    this.prevQuaternion = this.quaternion.clone();
  }
  /**
   * Set the position
   * @param {number} x X coordinate
   * @param {number} y Y coordinate
   * @param {number} z Z coordinate
   * @returns {TransformComponent} This component for chaining
   */
  setPosition(x, y, z) {
    this.position.set(x, y, z);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Set the rotation in Euler angles
   * @param {number} x X rotation in radians
   * @param {number} y Y rotation in radians
   * @param {number} z Z rotation in radians
   * @returns {TransformComponent} This component for chaining
   */
  setRotation(x, y, z) {
    this.rotation.set(x, y, z);
    this.quaternion.setFromEuler(this.rotation);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Set the rotation from a quaternion
   * @param {THREE.Quaternion} quaternion The quaternion
   * @returns {TransformComponent} This component for chaining
   */
  setQuaternion(quaternion) {
    this.quaternion.copy(quaternion);
    this.rotation.setFromQuaternion(this.quaternion);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Set the scale
   * @param {number} x X scale
   * @param {number} y Y scale
   * @param {number} z Z scale
   * @returns {TransformComponent} This component for chaining
   */
  setScale(x, y, z) {
    this.scale.set(x, y, z);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Look at a point
   * @param {THREE.Vector3} target The point to look at
   * @returns {TransformComponent} This component for chaining
   */
  lookAt(target) {
    const tempMatrix = new Matrix4();
    tempMatrix.lookAt(this.position, target, new Vector3(0, 1, 0));
    this.quaternion.setFromRotationMatrix(tempMatrix);
    this.rotation.setFromQuaternion(this.quaternion);
    this.needsUpdate = true;
    return this;
  }
  /**
   * Update the matrix from position, quaternion, and scale
   * @returns {THREE.Matrix4} The updated matrix
   */
  updateMatrix() {
    if (this.needsUpdate) {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.needsUpdate = false;
    }
    return this.matrix;
  }
  /**
   * Snapshot the current transform to previous for interpolation
   */
  snapshotPrevious() {
    this.prevPosition.copy(this.position);
    this.prevQuaternion.copy(this.quaternion);
  }
  /**
   * Get world position
   * @returns {THREE.Vector3} A new vector representing the world position
   */
  getWorldPosition() {
    return this.position.clone();
  }
  /**
   * Get forward direction vector
   * @returns {THREE.Vector3} A normalized vector pointing forward
   */
  getForwardVector() {
    const forward = new Vector3(0, 0, -1);
    forward.applyQuaternion(this.quaternion);
    return forward;
  }
  /**
   * Get right direction vector
   * @returns {THREE.Vector3} A normalized vector pointing right
   */
  getRightVector() {
    const right = new Vector3(1, 0, 0);
    right.applyQuaternion(this.quaternion);
    return right;
  }
  /**
   * Get up direction vector
   * @returns {THREE.Vector3} A normalized vector pointing up
   */
  getUpVector() {
    const up = new Vector3(0, 1, 0);
    up.applyQuaternion(this.quaternion);
    return up;
  }
}
const transform = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TransformComponent
}, Symbol.toStringTag, { value: "Module" }));
class RigidbodyComponent extends Component {
  constructor(mass = 1) {
    super();
    this.velocity = new Vector3();
    this.angularVelocity = new Vector3();
    this.mass = mass;
    this.drag = 0.01;
    this.angularDrag = 0.01;
    this.useGravity = false;
    this.isKinematic = false;
    this.freezeRotation = false;
    this.forces = new Vector3();
    this.torque = new Vector3();
    this.collisionRadius = 1;
    this.isTrigger = false;
  }
  /**
   * Reset forces applied this frame
   */
  resetForces() {
    this.forces.set(0, 0, 0);
    this.torque.set(0, 0, 0);
  }
  /**
   * Apply a force to the rigidbody
   * @param {THREE.Vector3} force Force vector to apply
   * @param {THREE.Vector3} point Point where force is applied (for torque)
   */
  applyForce(force, point = null) {
    if (this.isKinematic) return;
    this.forces.add(force);
    if (point) {
      const transformComponent = this.entity.getComponent("TransformComponent");
      if (transformComponent) {
        const relativePoint = point.clone().sub(transformComponent.position);
        const torque = relativePoint.cross(force);
        this.applyTorque(torque);
      }
    }
  }
  /**
   * Apply an impulse (immediate velocity change)
   * @param {THREE.Vector3} impulse Impulse vector
   */
  applyImpulse(impulse) {
    if (this.isKinematic) return;
    const velocityChange = impulse.clone().divideScalar(this.mass);
    this.velocity.add(velocityChange);
  }
  /**
   * Apply torque (rotational force)
   * @param {THREE.Vector3} torque Torque vector
   */
  applyTorque(torque) {
    if (this.isKinematic || this.freezeRotation) return;
    this.torque.add(torque);
  }
  /**
   * Set velocity directly
   * @param {THREE.Vector3} velocity New velocity vector
   */
  setVelocity(velocity) {
    this.velocity.copy(velocity);
  }
  /**
   * Set angular velocity directly
   * @param {THREE.Vector3} angularVelocity New angular velocity vector
   */
  setAngularVelocity(angularVelocity) {
    if (this.freezeRotation) return;
    this.angularVelocity.copy(angularVelocity);
  }
}
class MeshComponent extends Component {
  constructor(geometry, material) {
    super();
    if (geometry && geometry.isMesh || geometry && geometry.isGroup) {
      this.mesh = geometry;
    } else if (geometry && material) {
      this.mesh = new Mesh(geometry, material);
      if (geometry && typeof geometry.computeBoundingSphere === "function" && !geometry.boundingSphere) {
        geometry.computeBoundingSphere();
      }
    } else {
      console.warn("MeshComponent created with invalid geometry, using invisible default cube");
      const defaultGeom = new BoxGeometry(10, 10, 10);
      defaultGeom.computeBoundingSphere();
      const defaultMat = new MeshBasicMaterial({
        color: 16711680,
        transparent: true,
        opacity: 0,
        visible: false
      });
      this.mesh = new Mesh(defaultGeom, defaultMat);
      this.mesh.visible = false;
    }
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
  }
  /**
   * Called when component is attached to an entity
   */
  onAttached() {
    const transform2 = this.entity.getComponent("TransformComponent");
    if (transform2) {
      this.mesh.position.copy(transform2.position);
      this.mesh.quaternion.copy(transform2.quaternion);
      this.mesh.scale.copy(transform2.scale);
    }
  }
  /**
   * Called when component is detached from an entity
   */
  onDetached() {
    if (this.mesh.parent) {
      this.mesh.parent.remove(this.mesh);
    }
    if (this.mesh.geometry) {
      this.mesh.geometry.dispose();
    }
    if (this.mesh.material) {
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach((material) => {
          if (material.map) material.map.dispose();
          if (material.lightMap) material.lightMap.dispose();
          if (material.bumpMap) material.bumpMap.dispose();
          if (material.normalMap) material.normalMap.dispose();
          if (material.specularMap) material.specularMap.dispose();
          if (material.envMap) material.envMap.dispose();
          material.dispose();
        });
      } else {
        if (this.mesh.material.map) this.mesh.material.map.dispose();
        if (this.mesh.material.lightMap) this.mesh.material.lightMap.dispose();
        if (this.mesh.material.bumpMap) this.mesh.material.bumpMap.dispose();
        if (this.mesh.material.normalMap) this.mesh.material.normalMap.dispose();
        if (this.mesh.material.specularMap) this.mesh.material.specularMap.dispose();
        if (this.mesh.material.envMap) this.mesh.material.envMap.dispose();
        this.mesh.material.dispose();
      }
    }
  }
  /**
   * Set mesh visibility
   * @param {boolean} visible Whether the mesh is visible
   */
  setVisible(visible) {
    this.visible = visible;
    this.mesh.visible = visible;
  }
  /**
   * Check if mesh is visible
   * @returns {boolean} Whether the mesh is visible
   */
  isVisible() {
    return this.visible && this.mesh.visible;
  }
  /**
   * Set whether the mesh casts shadows
   * @param {boolean} castShadow Whether the mesh casts shadows
   */
  setCastShadow(castShadow) {
    this.castShadow = castShadow;
    this.mesh.castShadow = castShadow;
  }
  /**
   * Set whether the mesh receives shadows
   * @param {boolean} receiveShadow Whether the mesh receives shadows
   */
  setReceiveShadow(receiveShadow) {
    this.receiveShadow = receiveShadow;
    this.mesh.receiveShadow = receiveShadow;
  }
  /**
   * Change the mesh's material
   * @param {THREE.Material} material New material
   */
  setMaterial(material) {
    this.mesh.material = material;
  }
  /**
   * Change the mesh's geometry
   * @param {THREE.BufferGeometry} geometry New geometry
   */
  setGeometry(geometry) {
    this.mesh.geometry = geometry;
  }
  /**
   * Add the mesh to a scene
   * @param {THREE.Scene} scene Scene to add the mesh to
   */
  addToScene(scene) {
    scene.add(this.mesh);
  }
  /**
   * Update mesh transform from entity transform
   */
  updateFromTransform() {
    const transform2 = this.entity.getComponent("TransformComponent");
    if (transform2) {
      this.mesh.position.copy(transform2.position);
      this.mesh.quaternion.copy(transform2.quaternion);
      this.mesh.scale.copy(transform2.scale);
    }
  }
}
const typedArrayPools = {
  float32: [],
  int32: [],
  uint32: [],
  uint16: [],
  uint8: []
};
class FixedArray {
  /**
   * @param {number} size - Maximum size of the array
   */
  constructor(size) {
    this.data = new Array(size);
    this.length = 0;
    this.capacity = size;
  }
  /**
   * Add an item to the array
   * @param {*} item - Item to add
   * @returns {boolean} - True if item was added, false if array is full
   */
  push(item) {
    if (this.length < this.capacity) {
      this.data[this.length++] = item;
      return true;
    }
    return false;
  }
  /**
   * Remove and return the last item
   * @returns {*} - The last item or undefined if empty
   */
  pop() {
    if (this.length === 0) return void 0;
    const item = this.data[--this.length];
    this.data[this.length] = void 0;
    return item;
  }
  /**
   * Get item at index
   * @param {number} index - Index to retrieve
   * @returns {*} - Item at that index
   */
  get(index) {
    if (index < 0 || index >= this.length) return void 0;
    return this.data[index];
  }
  /**
   * Set item at index
   * @param {number} index - Index to set
   * @param {*} value - Value to set
   */
  set(index, value) {
    if (index < 0 || index >= this.capacity) return;
    if (index >= this.length) this.length = index + 1;
    this.data[index] = value;
  }
  /**
   * Remove item at index
   * @param {number} index - Index to remove
   * @returns {boolean} - True if removal was successful
   */
  removeAt(index) {
    if (index < 0 || index >= this.length) return false;
    for (let i = index; i < this.length - 1; i++) {
      this.data[i] = this.data[i + 1];
    }
    this.data[--this.length] = void 0;
    return true;
  }
  /**
   * Clear the array
   */
  clear() {
    for (let i = 0; i < this.length; i++) {
      this.data[i] = void 0;
    }
    this.length = 0;
  }
  /**
   * Iterate over each item
   * @param {Function} callback - Function to call for each item
   */
  forEach(callback) {
    for (let i = 0; i < this.length; i++) {
      callback(this.data[i], i, this);
    }
  }
  /**
   * Map array items to a new array
   * @param {Function} callback - Function to transform each item
   * @returns {Array} - New array with transformed items
   */
  map(callback) {
    const result = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      result[i] = callback(this.data[i], i, this);
    }
    return result;
  }
  /**
   * Filter items into a new array
   * @param {Function} callback - Predicate function to test each item
   * @returns {Array} - New array with items that passed the test
   */
  filter(callback) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      if (callback(this.data[i], i, this)) {
        result.push(this.data[i]);
      }
    }
    return result;
  }
}
const MemoryStats = {
  vectorPoolSize: 0,
  objectPoolSizes: {},
  typedArrayPoolSizes: {},
  /**
   * Update memory statistics
   */
  update() {
    if (window.vectorPool) {
      this.vectorPoolSize = window.vectorPool.pool.length;
    }
    if (window.objectPool) {
      for (const type in window.objectPool.pools) {
        this.objectPoolSizes[type] = window.objectPool.pools[type].objects.length;
      }
    }
    for (const type in typedArrayPools) {
      this.typedArrayPoolSizes[type] = typedArrayPools[type].length;
    }
  },
  /**
   * Get a formatted report of memory usage
   * @returns {string} - Formatted memory stats
   */
  getReport() {
    this.update();
    let report = "Memory Pool Stats:\n";
    report += `Vector Pool: ${this.vectorPoolSize} vectors
`;
    report += "Object Pools:\n";
    for (const type in this.objectPoolSizes) {
      report += `  ${type}: ${this.objectPoolSizes[type]} objects
`;
    }
    report += "Typed Array Pools:\n";
    for (const type in this.typedArrayPoolSizes) {
      report += `  ${type}: ${this.typedArrayPoolSizes[type]} arrays
`;
    }
    return report;
  },
  /**
   * Print memory stats to console
   */
  logReport() {
    console.log(this.getReport());
  }
};
window.MemoryStats = MemoryStats;
class CombatSystem extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = ["TransformComponent", "RigidbodyComponent"];
    this.priority = 50;
    this.projectiles = /* @__PURE__ */ new Set();
    this.damageDealt = 0;
    this.damageReceived = 0;
    this.cachedProjectiles = new FixedArray(100);
    this.cachedEnemies = new FixedArray(50);
    this.cachedPlayers = new FixedArray(5);
    this.hitPosition = new Vector3();
    this.effectPosition = new Vector3();
    this.setupEventListeners();
  }
  /**
   * Set up event listeners for combat-related events
   */
  setupEventListeners() {
    this.world.messageBus.subscribe("weapon.fired", this.handleProjectileCreated.bind(this));
    this.world.messageBus.subscribe("turret.fire", this.handleProjectileCreated.bind(this));
    this.world.messageBus.subscribe("missile.fired", this.handleProjectileCreated.bind(this));
    this.world.messageBus.subscribe("entity.damaged", this.handleEntityDamaged.bind(this));
  }
  /**
   * Update all entities relevant to combat
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (this.world && this.world.optimizedProjectiles && typeof this.world.optimizedProjectiles.update === "function") {
      this.world.optimizedProjectiles.update(deltaTime);
    }
    const entities = this.world.entityManager.getEntities();
    this.checkProjectileCollisions(entities);
    this.cleanupInvalidProjectiles();
  }
  /**
   * Remove projectiles that are no longer valid (missing components or destroyed)
   */
  cleanupInvalidProjectiles() {
    const validProjectileIds = /* @__PURE__ */ new Set();
    const projectiles = this.world.entityManager.getEntitiesByTag("projectile");
    const enemyProjectiles = this.world.entityManager.getEntitiesByTag("enemyProjectile");
    [...projectiles, ...enemyProjectiles].forEach((p) => {
      if (p && p.id) {
        validProjectileIds.add(p.id);
      }
    });
    for (const projectileId of this.projectiles) {
      if (!validProjectileIds.has(projectileId)) {
        console.log(`Removing invalid projectile ${projectileId} from tracking`);
        this.projectiles.delete(projectileId);
      }
    }
  }
  /**
   * Check projectiles for collision with entities
   * @param {Array} entities All entities in the world
   */
  checkProjectileCollisions(entities) {
    const projectiles = this.world.entityManager.getEntitiesByTag("projectile");
    const enemyProjectiles = this.world.entityManager.getEntitiesByTag("enemyProjectile");
    this.cachedProjectiles.clear();
    this.cachedEnemies.clear();
    this.cachedPlayers.clear();
    for (let i = 0; i < entities.length; i++) {
      const entity = entities[i];
      if (entity.hasTag("enemy") || entity.hasComponent("EnemyAIComponent")) {
        this.cachedEnemies.push(entity);
      } else if (entity.hasTag("player")) {
        this.cachedPlayers.push(entity);
      }
    }
    for (let i = 0; i < projectiles.length; i++) {
      this.cachedProjectiles.push(projectiles[i]);
    }
    for (let i = 0; i < enemyProjectiles.length; i++) {
      this.cachedProjectiles.push(enemyProjectiles[i]);
    }
    if (this.cachedProjectiles.length > 0) {
      console.log(`CombatSystem: Checking ${this.cachedProjectiles.length} projectiles for collisions`);
    }
    for (let i = 0; i < this.cachedProjectiles.length; i++) {
      const projectile = this.cachedProjectiles.get(i);
      try {
        if (!this.projectiles.has(projectile.id)) {
          this.projectiles.add(projectile.id);
        }
        const projectileTransform = projectile.getComponent(TransformComponent);
        const projectileRigidbody = projectile.getComponent(RigidbodyComponent);
        if (!projectileTransform || !projectileRigidbody) {
          console.log(`Projectile ${projectile.id} missing transform or rigidbody component`);
          continue;
        }
        const isPlayerProjectile = projectile._isPlayerProjectile || projectile.hasTag("projectile") || projectile.hasTag("playerProjectile");
        const isEnemyProjectile = projectile._isEnemyProjectile || projectile.hasTag("enemyProjectile");
        if (projectileRigidbody.velocity.lengthSq() < 0.1) continue;
        const targets = isPlayerProjectile ? this.cachedEnemies : isEnemyProjectile ? this.cachedPlayers : entities;
        const raycaster = new Raycaster();
        const projectilePosition = projectileTransform.position.clone();
        const projectileDirection = projectileRigidbody.velocity.clone().normalize();
        const rayOffset = projectileDirection.clone().multiplyScalar(-10);
        const rayOrigin = projectilePosition.clone().add(rayOffset);
        raycaster.set(rayOrigin, projectileDirection);
        raycaster.near = 0;
        raycaster.far = 50;
        console.log(`Raycaster for projectile ${projectile.id} - Origin: (${rayOrigin.x.toFixed(1)}, ${rayOrigin.y.toFixed(1)}, ${rayOrigin.z.toFixed(1)}), Direction: (${projectileDirection.x.toFixed(2)}, ${projectileDirection.y.toFixed(2)}, ${projectileDirection.z.toFixed(2)})`);
        let targetHit = false;
        for (let j = 0; j < targets.length; j++) {
          const target = targets.get ? targets.get(j) : targets[j];
          if (target.destroyed) continue;
          if (target.id === projectile.id) continue;
          const meshComponent = target.getComponent(MeshComponent);
          if (!meshComponent || !meshComponent.mesh) {
            console.log(`Target ${target.id} has no mesh component or mesh`);
            continue;
          }
          console.log(`Testing collision with target ${target.id}, mesh visible: ${meshComponent.mesh.visible}, mesh children: ${meshComponent.mesh.children ? meshComponent.mesh.children.length : 0}`);
          if (!meshComponent.mesh.visible) {
            console.log(`Mesh for ${target.id} is not visible, skipping`);
            continue;
          }
          const intersections = raycaster.intersectObject(meshComponent.mesh, true);
          if (intersections.length > 0) {
            const intersection = intersections[0];
            console.log(`MESH HIT! Projectile ${projectile.id} hit ${target.id} at distance ${intersection.distance.toFixed(2)}`);
            console.log(`Hit point: (${intersection.point.x.toFixed(1)}, ${intersection.point.y.toFixed(1)}, ${intersection.point.z.toFixed(1)})`);
            if (intersection.object) {
              console.log(`Hit specific mesh: ${intersection.object.name || "unnamed"}`);
            }
            this.hitPosition.copy(intersection.point);
            this.handleProjectileCollision(projectile, target);
            try {
              this.world.destroyEntity(projectile.id);
              this.projectiles.delete(projectile.id);
              targetHit = true;
            } catch (e) {
              console.error("Failed to destroy projectile after hit:", e);
            }
            break;
          } else {
            const targetTransform = target.getComponent(TransformComponent);
            if (targetTransform) {
              const distance = projectilePosition.distanceTo(targetTransform.position);
              console.log(`No intersection with ${target.id} at distance ${distance.toFixed(1)}`);
            }
          }
        }
        if (targetHit) continue;
      } catch (error) {
        console.error(`Error processing projectile ${projectile.id}:`, error);
      }
    }
  }
  /**
   * Handle a projectile collision with a target
   * @param {Entity} projectile Projectile entity
   * @param {Entity} target Target entity
   */
  handleProjectileCollision(projectile, target) {
    var _a, _b;
    let damage = 10;
    const source = (_a = projectile.userData) == null ? void 0 : _a.source;
    if (projectile.userData && projectile.userData.damage) {
      damage = projectile.userData.damage;
    } else if (projectile.sourceComponent) {
      damage = projectile.sourceComponent.damage;
    }
    const targetHealth = target.getComponent(HealthComponent);
    if (targetHealth) {
      const damageType = ((_b = projectile.userData) == null ? void 0 : _b.attackType) || "projectile";
      const damageResult = targetHealth.applyDamage(damage, damageType, source);
      this.createHitEffect(projectile, target, damageResult);
      if (target.hasTag("player")) {
        this.damageReceived += damageResult.damageApplied;
      } else if (target.hasTag("enemy")) {
        this.damageDealt += damageResult.damageApplied;
      }
      const projectileTransform = projectile.getComponent(TransformComponent);
      if (projectileTransform) {
        this.hitPosition.copy(projectileTransform.position);
      } else {
        this.hitPosition.set(0, 0, 0);
      }
      this.world.messageBus.publish("combat.hit", {
        projectile,
        target,
        damage: damageResult.damageApplied,
        shieldDamage: damageResult.shieldDamage,
        healthDamage: damageResult.healthDamage,
        destroyed: damageResult.destroyed,
        position: this.hitPosition
        // Pass direct reference for better performance
      });
    }
  }
  /**
   * Create a visual effect for a projectile hit
   * @param {Entity} projectile Projectile entity
   * @param {Entity} target Target entity
   * @param {object} damageResult Result of damage application
   */
  createHitEffect(projectile, target, damageResult) {
    const projectileTransform = projectile.getComponent(TransformComponent);
    if (!projectileTransform) return;
    let effectColor = 16733440;
    let effectSize = 1;
    if (damageResult.shieldDamage > 0) {
      effectColor = 3381759;
      effectSize = 1.5;
    }
    if (damageResult.healthDamage > 20) {
      effectColor = 16711680;
      effectSize = 2;
    }
    this.effectPosition.copy(projectileTransform.position);
    let hitEffect;
    const objectPoolAvailable = window.objectPool && window.objectPool.pools && window.objectPool.pools["hitEffect"];
    if (objectPoolAvailable) {
      hitEffect = window.objectPool.get("hitEffect", effectColor, effectSize);
    } else {
      hitEffect = this.createNewHitEffect(effectColor, effectSize);
    }
    if (hitEffect && hitEffect.mesh) {
      hitEffect.mesh.position.copy(this.effectPosition);
      if (!hitEffect.mesh.parent) {
        this.world.scene.add(hitEffect.mesh);
      }
      this.animateHitEffect(hitEffect, hitEffect.mesh, objectPoolAvailable);
    }
  }
  // Helper method to create a new hit effect - only used as fallback when object pool is unavailable
  createNewHitEffect(effectColor, effectSize) {
    let geometry;
    if (window.game && window.game.hitEffectGeometry) {
      geometry = window.game.hitEffectGeometry;
    } else if (!this.hitEffectGeometry) {
      this.hitEffectGeometry = new SphereGeometry(1, 8, 8);
      geometry = this.hitEffectGeometry;
    } else {
      geometry = this.hitEffectGeometry;
    }
    const material = new MeshBasicMaterial({
      color: effectColor,
      transparent: true,
      opacity: 0.8
    });
    const mesh = new Mesh(geometry, material);
    mesh.scale.set(effectSize, effectSize, effectSize);
    return { mesh, material };
  }
  /**
   * Animate a hit effect
   * @param {object} hitEffect The hit effect object
   * @param {THREE.Mesh} effectMesh The effect mesh
   * @param {boolean} useObjectPool Whether to return the object to pool after animation
   */
  animateHitEffect(hitEffect, effectMesh, useObjectPool = true) {
    let scale = 1;
    let opacity = 0.8;
    const animate = () => {
      scale += 0.1;
      opacity -= 0.05;
      if (effectMesh && effectMesh.scale) {
        effectMesh.scale.set(scale, scale, scale);
        if (hitEffect.material) {
          hitEffect.material.opacity = opacity;
        }
        if (opacity > 0) {
          requestAnimationFrame(animate);
        } else {
          if (effectMesh.parent) {
            effectMesh.parent.remove(effectMesh);
          }
          if (useObjectPool && window.objectPool && window.objectPool.pools["hitEffect"]) {
            window.objectPool.release("hitEffect", hitEffect);
          } else if (!useObjectPool) {
            if (hitEffect.material) {
              hitEffect.material.dispose();
            }
          }
        }
      }
    };
    animate();
  }
  /**
   * Handle projectile creation event
   * @param {object} message Event message
   */
  handleProjectileCreated(message) {
    if (message.entity && message.entity.id) {
      this.projectiles.add(message.entity.id);
    }
  }
  /**
   * Handle entity damaged event
   * @param {object} message Event message
   */
  handleEntityDamaged(message) {
    if (message.target) {
      if (message.target.hasTag("player")) {
        this.damageReceived += message.damage || 0;
      } else if (message.target.hasTag("enemy")) {
        this.damageDealt += message.damage || 0;
      }
    }
  }
  /**
   * Clean up when system is disabled
   */
  onDisabled() {
    this.world.messageBus.unsubscribe("weapon.fired", this.handleProjectileCreated);
    this.world.messageBus.unsubscribe("turret.fire", this.handleProjectileCreated);
    this.world.messageBus.unsubscribe("missile.fired", this.handleProjectileCreated);
    this.world.messageBus.unsubscribe("entity.damaged", this.handleEntityDamaged);
  }
}
class TrailComponent extends Component {
  /**
   * Creates a new plasma trail component
   * @param {Object} config Trail configuration
   */
  constructor(config = {}) {
    super();
    this.maxPoints = config.maxPoints || 60;
    this.pointDistance = config.pointDistance || 2;
    this.width = config.width || 15;
    this.color = config.color || 56831;
    this.coreColor = config.coreColor || 16777215;
    this.fadeTime = config.fadeTime || 0.8;
    this.transparent = config.transparent !== void 0 ? config.transparent : true;
    this.alphaTest = config.alphaTest || 0.01;
    this.blending = config.blending || AdditiveBlending;
    this.pulse = config.pulse !== void 0 ? config.pulse : true;
    this.pulseSpeed = config.pulseSpeed || 2;
    this.tapering = config.tapering !== void 0 ? config.tapering : true;
    this.glow = config.glow !== void 0 ? config.glow : true;
    this.thrustPower = 0;
    this.trailType = config.trailType || "main";
    this.points = [];
    this.times = [];
    this.widths = [];
    this.lastPosition = new Vector3();
    this.initialized = false;
    this.trailMesh = null;
    this.coreMesh = null;
    this.electricArcs = [];
    this.trailGeometry = null;
    this.trailMaterial = null;
    this.isActive = true;
    this.time = 0;
  }
  /**
   * Called when component is attached to an entity
   */
  onAttached() {
    if (!this.entity) return;
    const transform2 = this.entity.getComponent("TransformComponent");
    if (!transform2) {
      console.warn("TrailComponent requires a TransformComponent on the entity");
      return;
    }
    this.lastPosition.copy(transform2.position);
    this.initializeTrail();
  }
  /**
   * Initialize plasma trail visuals with dynamic geometry
   */
  initializeTrail() {
    const vertices = [];
    const uvs = [];
    for (let i = 0; i < this.maxPoints; i++) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      uvs.push(0, i / this.maxPoints);
      uvs.push(1, i / this.maxPoints);
    }
    const indices = [];
    for (let i = 0; i < this.maxPoints - 1; i++) {
      const a = i * 2;
      const b = i * 2 + 1;
      const c = i * 2 + 2;
      const d = i * 2 + 3;
      indices.push(a, b, c);
      indices.push(b, d, c);
    }
    this.trailGeometry = new BufferGeometry();
    this.trailGeometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.trailGeometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.trailGeometry.setIndex(indices);
    const alphas = new Float32Array(this.maxPoints * 2);
    const energyLevels = new Float32Array(this.maxPoints * 2);
    this.trailGeometry.setAttribute("alpha", new BufferAttribute(alphas, 1));
    this.trailGeometry.setAttribute("energy", new BufferAttribute(energyLevels, 1));
    this.trailMaterial = new ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        color: { value: new Color(this.color) },
        coreColor: { value: new Color(this.coreColor) },
        thrustPower: { value: 0 },
        opacity: { value: 1 }
      },
      vertexShader: `
                attribute float alpha;
                attribute float energy;
                varying float vAlpha;
                varying float vEnergy;
                varying vec2 vUv;
                
                void main() {
                    vAlpha = alpha;
                    vEnergy = energy;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform float time;
                uniform vec3 color;
                uniform vec3 coreColor;
                uniform float thrustPower;
                uniform float opacity;
                
                varying float vAlpha;
                varying float vEnergy;
                varying vec2 vUv;
                
                void main() {
                    // Create plasma effect with hot core
                    float coreIntensity = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    coreIntensity = pow(coreIntensity, 2.0);
                    
                    // Energy pulse effect
                    float pulse = sin(time * 4.0 + vUv.y * 10.0) * 0.2 + 0.8;
                    
                    // Mix core and outer colors
                    vec3 finalColor = mix(color, coreColor, coreIntensity * vEnergy);
                    
                    // Add electric arc effect
                    float arc = sin(vUv.y * 50.0 + time * 20.0) * 0.1;
                    finalColor += vec3(arc) * vEnergy;
                    
                    // Apply alpha and energy
                    float finalAlpha = vAlpha * coreIntensity * pulse * opacity * thrustPower;
                    
                    gl_FragColor = vec4(finalColor, finalAlpha);
                }
            `,
      transparent: true,
      blending: AdditiveBlending,
      side: DoubleSide,
      depthWrite: false
    });
    this.trailMesh = new Mesh(this.trailGeometry, this.trailMaterial);
    this.trailMesh.frustumCulled = false;
    const coreGeometry = new BufferGeometry();
    const corePositions = new Float32Array(this.maxPoints * 3);
    coreGeometry.setAttribute("position", new BufferAttribute(corePositions, 3));
    coreGeometry.setDrawRange(0, 0);
    const coreMaterial = new LineBasicMaterial({
      color: this.coreColor,
      linewidth: 2,
      transparent: true,
      opacity: 0.8,
      blending: AdditiveBlending
    });
    this.coreMesh = new Line(coreGeometry, coreMaterial);
    this.coreMesh.frustumCulled = false;
    this.initialized = true;
    if (this.entity && this.entity.world && this.entity.world.scene) {
      this.entity.world.scene.add(this.trailMesh);
      this.entity.world.scene.add(this.coreMesh);
    } else if (window.game && window.game.scene) {
      window.game.scene.add(this.trailMesh);
      window.game.scene.add(this.coreMesh);
    } else {
      console.warn("TrailComponent: No scene available to add trail mesh");
    }
  }
  /**
   * Called when component is detached from an entity
   */
  onDetached() {
    if (this.trailMesh && this.trailMesh.parent) {
      this.trailMesh.parent.remove(this.trailMesh);
    }
    if (this.coreMesh && this.coreMesh.parent) {
      this.coreMesh.parent.remove(this.coreMesh);
    }
    for (const arc of this.electricArcs) {
      if (arc.mesh && arc.mesh.parent) {
        arc.mesh.parent.remove(arc.mesh);
        if (arc.mesh.geometry) arc.mesh.geometry.dispose();
        if (arc.mesh.material) arc.mesh.material.dispose();
      }
    }
    this.electricArcs = [];
    if (this.trailGeometry) {
      this.trailGeometry.dispose();
    }
    if (this.trailMaterial) {
      this.trailMaterial.dispose();
    }
    if (this.coreMesh && this.coreMesh.geometry) {
      this.coreMesh.geometry.dispose();
    }
    if (this.coreMesh && this.coreMesh.material) {
      this.coreMesh.material.dispose();
    }
  }
  /**
   * Update the plasma trail
   * @param {number} deltaTime Time since last update in seconds
   * @param {number} thrustPower Current thrust power (0-1)
   */
  update(deltaTime, thrustPower = 0) {
    if (!this.initialized || !this.isActive || !this.entity) return;
    this.time += deltaTime;
    this.thrustPower = thrustPower;
    const transform2 = this.entity.getComponent("TransformComponent");
    if (!transform2) return;
    const distance = transform2.position.distanceTo(this.lastPosition);
    if (distance >= this.pointDistance || thrustPower > 0.1) {
      this.points.unshift(transform2.position.clone());
      this.times.unshift(performance.now());
      this.widths.unshift(this.width * (0.5 + thrustPower * 0.5));
      if (this.points.length > this.maxPoints) {
        this.points.pop();
        this.times.pop();
        this.widths.pop();
      }
      this.lastPosition.copy(transform2.position);
      this.updateTrailGeometry();
    }
    if (this.trailMaterial && this.trailMaterial.uniforms) {
      this.trailMaterial.uniforms.time.value = this.time;
      this.trailMaterial.uniforms.thrustPower.value = thrustPower;
    }
    this.updateTrailEffects(deltaTime);
  }
  /**
   * Update plasma trail ribbon geometry
   */
  updateTrailGeometry() {
    if (!this.trailGeometry || this.points.length < 2) return;
    const positions = this.trailGeometry.attributes.position.array;
    const alphas = this.trailGeometry.attributes.alpha.array;
    const energies = this.trailGeometry.attributes.energy.array;
    const transform2 = this.entity.getComponent("TransformComponent");
    if (!transform2) return;
    for (let i = 0; i < this.points.length; i++) {
      const point = this.points[i];
      const width = this.widths[i] || this.width;
      let perpVector;
      if (i < this.points.length - 1) {
        const nextPoint = this.points[i + 1];
        const direction = new Vector3().subVectors(point, nextPoint).normalize();
        perpVector = new Vector3().crossVectors(direction, new Vector3(0, 1, 0)).normalize();
      } else if (i > 0) {
        const prevPoint = this.points[i - 1];
        const direction = new Vector3().subVectors(prevPoint, point).normalize();
        perpVector = new Vector3().crossVectors(direction, new Vector3(0, 1, 0)).normalize();
      } else {
        perpVector = new Vector3(1, 0, 0);
      }
      const taperFactor = this.tapering ? 1 - i / this.points.length : 1;
      const currentWidth = width * taperFactor;
      const leftVertex = point.clone().add(perpVector.clone().multiplyScalar(currentWidth * 0.5));
      const rightVertex = point.clone().sub(perpVector.clone().multiplyScalar(currentWidth * 0.5));
      positions[i * 6] = leftVertex.x;
      positions[i * 6 + 1] = leftVertex.y;
      positions[i * 6 + 2] = leftVertex.z;
      positions[i * 6 + 3] = rightVertex.x;
      positions[i * 6 + 4] = rightVertex.y;
      positions[i * 6 + 5] = rightVertex.z;
      const now = performance.now();
      const age = (now - this.times[i]) / 1e3;
      const fadeRatio = Math.max(0, 1 - age / this.fadeTime);
      alphas[i * 2] = fadeRatio;
      alphas[i * 2 + 1] = fadeRatio;
      energies[i * 2] = fadeRatio * this.thrustPower;
      energies[i * 2 + 1] = fadeRatio * this.thrustPower;
    }
    if (this.coreMesh && this.coreMesh.geometry) {
      const corePositions = this.coreMesh.geometry.attributes.position.array;
      for (let i = 0; i < this.points.length; i++) {
        const point = this.points[i];
        corePositions[i * 3] = point.x;
        corePositions[i * 3 + 1] = point.y;
        corePositions[i * 3 + 2] = point.z;
      }
      this.coreMesh.geometry.attributes.position.needsUpdate = true;
      this.coreMesh.geometry.setDrawRange(0, this.points.length);
    }
    this.trailGeometry.attributes.position.needsUpdate = true;
    this.trailGeometry.attributes.alpha.needsUpdate = true;
    this.trailGeometry.attributes.energy.needsUpdate = true;
  }
  /**
   * Update plasma trail effects and animations
   */
  updateTrailEffects(deltaTime) {
    if (!this.trailGeometry || this.points.length === 0) return;
    if (Math.random() < 0.05 * this.thrustPower && this.points.length > 5) {
      this.createElectricArc();
    }
    for (let i = this.electricArcs.length - 1; i >= 0; i--) {
      const arc = this.electricArcs[i];
      arc.life -= deltaTime;
      if (arc.life <= 0) {
        if (arc.mesh && arc.mesh.parent) {
          arc.mesh.parent.remove(arc.mesh);
          if (arc.mesh.geometry) arc.mesh.geometry.dispose();
          if (arc.mesh.material) arc.mesh.material.dispose();
        }
        this.electricArcs.splice(i, 1);
      } else {
        if (arc.mesh && arc.mesh.material) {
          arc.mesh.material.opacity = arc.life / arc.maxLife;
        }
      }
    }
  }
  /**
   * Create an electric arc effect
   */
  createElectricArc() {
    var _a, _b, _c;
    if (this.points.length < 2) return;
    const startIdx = Math.floor(Math.random() * (this.points.length - 1));
    const endIdx = Math.min(startIdx + Math.floor(Math.random() * 5) + 1, this.points.length - 1);
    const startPoint = this.points[startIdx];
    const endPoint = this.points[endIdx];
    const arcPoints = [];
    const segments = 5;
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const point = new Vector3().lerpVectors(startPoint, endPoint, t);
      if (i > 0 && i < segments) {
        point.x += (Math.random() - 0.5) * 2;
        point.y += (Math.random() - 0.5) * 2;
        point.z += (Math.random() - 0.5) * 2;
      }
      arcPoints.push(point);
    }
    const arcGeometry = new BufferGeometry().setFromPoints(arcPoints);
    const arcMaterial = new LineBasicMaterial({
      color: 16777215,
      linewidth: 2,
      transparent: true,
      opacity: 0.8,
      blending: AdditiveBlending
    });
    const arcMesh = new Line(arcGeometry, arcMaterial);
    const scene = ((_b = (_a = this.entity) == null ? void 0 : _a.world) == null ? void 0 : _b.scene) || ((_c = window.game) == null ? void 0 : _c.scene);
    if (scene) {
      scene.add(arcMesh);
      this.electricArcs.push({
        mesh: arcMesh,
        life: 0.2,
        maxLife: 0.2
      });
    }
  }
  /**
   * Set trail active/inactive
   * @param {boolean} active Whether trail should be active
   */
  setActive(active) {
    this.isActive = active;
    if (this.trailMesh) {
      this.trailMesh.visible = active;
    }
  }
  /**
   * Clear all trail points
   */
  clear() {
    this.points = [];
    this.times = [];
    if (this.trailGeometry) {
      this.trailGeometry.setDrawRange(0, 0);
    }
  }
}
class EnemyAIComponent extends Component {
  constructor(config = {}) {
    super();
    this.faction = config.faction || "spectrals";
    this.type = config.type || "drone";
    this.detectionRange = config.detectionRange || 2500;
    this.damage = config.damage || 25;
    this.speed = config.speed || 1e3;
    this.playerFound = false;
    this.spiralAmplitude = config.spiralAmplitude || 150;
    this.spiralFrequency = config.spiralFrequency || 2;
    this.spiralPhase = Math.random() * Math.PI * 2;
    this.timeAlive = 0;
    this.lastDirection = new Vector3(0, 0, 1);
    this.isDroneLike = config.isDroneLike || false;
    this.separationInfluence = config.separationInfluence || 0.3;
    this.separationForce = new Vector3();
  }
  /**
   * Sets the separation force to influence movement behavior
   * @param {THREE.Vector3} force The separation force vector
   */
  setSeparationForce(force) {
    this.separationForce.copy(force);
  }
  /**
   * Update AI behavior - implements kamikaze attack pattern
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (!this.entity || !this.entity.world) return;
    this.timeAlive += deltaTime;
    let player = null;
    try {
      if (this.entity.world.playerEntity) {
        player = this.entity.world.playerEntity;
      }
    } catch (error) {
    }
    if (!player && window.game && window.game.combat && window.game.combat.playerEntity) {
      player = window.game.combat.playerEntity;
    }
    if (!player) {
      try {
        const playerEntities = this.entity.world.getEntitiesByTag("player");
        if (playerEntities && playerEntities.length > 0) {
          player = playerEntities[0];
        }
      } catch (error) {
      }
    }
    if (!player && this.entity.world.entityManager && this.entity.world.entityManager.entitiesByTag) {
      try {
        const playerEntities = this.entity.world.entityManager.entitiesByTag.get("player");
        if (playerEntities && (playerEntities.size > 0 || playerEntities.length > 0)) {
          player = Array.from(playerEntities)[0];
        }
      } catch (error) {
      }
    }
    if (!player && this.entity.world.entityManager && this.entity.world.entityManager.entities) {
      try {
        const allEntities = Array.from(this.entity.world.entityManager.entities.values());
        for (const entity of allEntities) {
          if (entity.hasTag && entity.hasTag("player") || entity.name === "player" || entity.id && entity.id.includes("player")) {
            player = entity;
            break;
          }
        }
      } catch (error) {
      }
    }
    if (!player && window.game && window.game.spaceship && window.game.spaceship.mesh) {
      player = {
        getComponent: (type) => {
          if (type === TransformComponent) {
            return {
              position: window.game.spaceship.mesh.position,
              rotation: window.game.spaceship.mesh.rotation,
              quaternion: window.game.spaceship.mesh.quaternion
            };
          }
          return null;
        }
      };
    }
    if (!player) {
      return;
    }
    const transform2 = this.entity.getComponent(TransformComponent);
    if (!transform2) {
      return;
    }
    const health = this.entity.getComponent(HealthComponent);
    if (health && health.isDestroyed) {
      return;
    }
    let playerTransform = player.getComponent ? player.getComponent(TransformComponent) : null;
    if (!playerTransform) {
      if (player.position) {
        playerTransform = player;
      } else {
        return;
      }
    }
    if (!this.playerFound) {
      this.playerFound = true;
    }
    const distanceToPlayer = transform2.position.distanceTo(playerTransform.position);
    const baseDirection = new Vector3().subVectors(
      playerTransform.position,
      transform2.position
    ).normalize();
    this.lastDirection.copy(baseDirection);
    if (this.faction === "spectrals" && this.type === "drone") {
      if (this.isDroneLike) {
        this.applyDroneLikeMovement(transform2, playerTransform, baseDirection, distanceToPlayer, deltaTime);
      } else {
        this.applySpectralDroneMovement(transform2, playerTransform, baseDirection, distanceToPlayer, deltaTime);
      }
    } else {
      transform2.position.add(baseDirection.multiplyScalar(this.speed * deltaTime));
      transform2.lookAt(playerTransform.position);
    }
    if (distanceToPlayer < 75) {
      const playerHealth = player.getComponent(HealthComponent);
      if (playerHealth) {
        playerHealth.applyDamage(this.damage, "collision", this.entity);
        if (window.game && window.game.spaceship) {
          const spaceship = window.game.spaceship;
          if (spaceship.shield > 0) {
            if (spaceship.shield >= this.damage) {
              spaceship.shield -= this.damage;
            } else {
              const remainingDamage = this.damage - spaceship.shield;
              spaceship.shield = 0;
              spaceship.hull -= remainingDamage;
            }
          } else {
            spaceship.hull -= this.damage;
          }
          if (spaceship.hull <= 0 && !spaceship.isDestroyed) {
            spaceship.hull = 0;
            spaceship.isDestroyed = true;
            if (window.game && window.game.gameOver) {
              window.game.gameOver("Your ship was destroyed by a kamikaze attack!");
            }
          }
        }
        if (this.entity.world && this.entity.world.messageBus) {
          this.entity.world.messageBus.publish("vfx.explosion", {
            position: transform2.position.clone(),
            scale: 1.5,
            // Larger explosion for impact
            duration: 2
          });
          this.entity.world.messageBus.publish("vfx.damageFlash", {
            intensity: 0.3
          });
        }
        if (window.game && window.game.audio) {
          window.game.audio.playSound("boink");
        }
        if (this.entity && this.entity.world) {
          const entityId = this.entity.id;
          const entityWorld = this.entity.world;
          entityWorld.messageBus.publish("entity.aboutToBeDestroyed", {
            entity: this.entity,
            reason: "kamikaze"
          });
          entityWorld.destroyEntity(entityId);
        }
      }
    }
  }
  /**
   * Apply drone-like movement pattern - more realistic drone behavior
   * @param {TransformComponent} transform This entity's transform
   * @param {TransformComponent} playerTransform Player's transform
   * @param {THREE.Vector3} baseDirection Base direction to player
   * @param {number} distanceToPlayer Distance to player
   * @param {number} deltaTime Delta time for frame
   */
  applyDroneLikeMovement(transform2, playerTransform, baseDirection, distanceToPlayer, deltaTime) {
    const up = new Vector3(0, 1, 0);
    const right = new Vector3().crossVectors(baseDirection, up).normalize();
    if (right.lengthSq() < 0.1) {
      right.set(1, 0, 0);
    }
    const properUp = new Vector3().crossVectors(right, baseDirection).normalize();
    let moveSpeed = this.speed;
    let finalDirection = new Vector3();
    if (distanceToPlayer > 1e3) {
      moveSpeed = this.speed * 1.2;
      const zigzag = Math.sin(this.timeAlive * 1.5) * 30;
      finalDirection.copy(baseDirection).multiplyScalar(moveSpeed).add(right.clone().multiplyScalar(zigzag));
    } else if (distanceToPlayer > 400) {
      const approachWeight = 0.6;
      const circleSpeed = this.speed * (1 - approachWeight);
      const entityIdSum = this.entity.id.split("").reduce((sum, char) => sum + char.charCodeAt(0), 0);
      const circleDir = entityIdSum % 2 === 0 ? 1 : -1;
      const strafeDir = right.clone().multiplyScalar(circleDir * circleSpeed);
      const approachDir = baseDirection.clone().multiplyScalar(this.speed * approachWeight);
      finalDirection.copy(approachDir).add(strafeDir);
      const bobAmount = Math.sin(this.timeAlive * 2) * 15;
      finalDirection.add(properUp.clone().multiplyScalar(bobAmount));
    } else {
      const evasiveTime = this.timeAlive * 3;
      const horizontalEvasion = Math.sin(evasiveTime) * Math.cos(evasiveTime * 1.3) * 80;
      const verticalEvasion = Math.cos(evasiveTime * 0.7) * Math.sin(evasiveTime * 1.1) * 60;
      const thrustPulse = 0.5 + 0.5 * (0.5 + 0.5 * Math.sin(evasiveTime * 0.5));
      finalDirection.copy(baseDirection).multiplyScalar(this.speed * thrustPulse).add(right.clone().multiplyScalar(horizontalEvasion)).add(properUp.clone().multiplyScalar(verticalEvasion));
    }
    if (this.separationForce && this.separationForce.lengthSq() > 0) {
      const separationDirection = this.separationForce.clone().normalize();
      const separationStrength = this.separationForce.length();
      const dynamicInfluence = this.separationInfluence * (0.5 + 0.5 * Math.min(1, separationStrength / 100));
      finalDirection.lerp(
        separationDirection.multiplyScalar(this.speed),
        dynamicInfluence
      );
    }
    transform2.position.add(finalDirection.multiplyScalar(deltaTime));
    const lookTarget = new Vector3().copy(transform2.position).add(finalDirection.clone().normalize().multiplyScalar(100));
    transform2.lookAt(lookTarget);
    const lateralMovement = new Vector3();
    lateralMovement.copy(finalDirection).projectOnVector(right);
    const lateralSpeed = lateralMovement.length() * (lateralMovement.dot(right) > 0 ? -1 : 1);
    const bankAngle = lateralSpeed / this.speed * 0.4;
    const forward = transform2.getForwardVector();
    const bankQuaternion = new Quaternion().setFromAxisAngle(forward, bankAngle);
    transform2.quaternion.multiply(bankQuaternion);
    transform2.rotation.setFromQuaternion(transform2.quaternion);
  }
  /**
   * Apply spectral drone movement pattern - spiral toward player
   * @param {TransformComponent} transform This entity's transform
   * @param {TransformComponent} playerTransform Player's transform
   * @param {THREE.Vector3} baseDirection Base direction to player
   * @param {number} distanceToPlayer Distance to player
   * @param {number} deltaTime Delta time for frame
   */
  applySpectralDroneMovement(transform2, playerTransform, baseDirection, distanceToPlayer, deltaTime) {
    const up = new Vector3(0, 1, 0);
    const right = new Vector3().crossVectors(baseDirection, up).normalize();
    if (right.lengthSq() < 0.1) {
      right.set(1, 0, 0);
    }
    const properUp = new Vector3().crossVectors(right, baseDirection).normalize();
    const time = this.timeAlive * this.spiralFrequency;
    let amplitude = this.spiralAmplitude;
    if (distanceToPlayer < 500) {
      amplitude = this.spiralAmplitude * (distanceToPlayer / 500);
    }
    const offsetX = Math.sin(time) * amplitude;
    const offsetY = Math.cos(time) * amplitude;
    const finalDirection = new Vector3().copy(baseDirection).multiplyScalar(this.speed).add(right.multiplyScalar(offsetX)).add(properUp.multiplyScalar(offsetY));
    if (this.separationForce && this.separationForce.lengthSq() > 0) {
      const separationDirection = this.separationForce.clone().normalize();
      const separationStrength = this.separationForce.length();
      const dynamicInfluence = this.separationInfluence * (0.5 + 0.5 * Math.min(1, separationStrength / 100));
      finalDirection.lerp(
        separationDirection.multiplyScalar(this.speed),
        dynamicInfluence
      );
    }
    transform2.position.add(finalDirection.multiplyScalar(deltaTime));
    const lookAheadTime = 0.2;
    const nextSpiral = time + this.spiralFrequency * lookAheadTime;
    const lookAheadOffsetX = Math.sin(nextSpiral) * amplitude;
    const lookAheadOffsetY = Math.cos(nextSpiral) * amplitude;
    const lookTarget = new Vector3().copy(transform2.position).add(baseDirection.multiplyScalar(100)).add(right.multiplyScalar(lookAheadOffsetX)).add(properUp.multiplyScalar(lookAheadOffsetY));
    transform2.lookAt(lookTarget);
    const tiltAngle = Math.atan2(offsetX, this.speed) * 0.5;
    const forward = transform2.getForwardVector();
    const tiltQuaternion = new Quaternion().setFromAxisAngle(forward, tiltAngle);
    transform2.quaternion.multiply(tiltQuaternion);
    transform2.rotation.setFromQuaternion(transform2.quaternion);
  }
}
class EnemyPoolManager {
  constructor(world, maxPoolSize = 20) {
    this.world = world;
    this.maxPoolSize = maxPoolSize;
    this.enemyPool = [];
    this.preallocateEnemyPool();
  }
  /**
   * Pre-allocate enemy pool to avoid runtime allocations
   */
  preallocateEnemyPool() {
    for (let i = 0; i < 10; i++) {
      const spectralEntity = this.createEnemyEntity();
      this.enemyPool.push(spectralEntity);
    }
    console.log(`Pre-allocated enemy pool with ${this.enemyPool.length} spectral drones`);
  }
  /**
   * Create a basic enemy entity (for pooling)
   * @returns {Entity} The created enemy entity
   */
  createEnemyEntity() {
    const entity = this.world.createEntity("enemy_spectral");
    entity.addTag("pooled");
    entity.addComponent(new TransformComponent());
    entity.addComponent(new MeshComponent());
    return entity;
  }
  /**
   * Get an enemy from the pool or create a new one if the pool is empty
   * @returns {Entity} An enemy entity
   */
  getEnemyFromPool() {
    if (this.enemyPool.length > 0) {
      const entity = this.enemyPool.pop();
      if (this.enemies && this.enemies.has(entity.id)) {
        console.warn(`CRITICAL ERROR: Entity ${entity.id} is in both the pool and active enemies!`);
        this.enemies.delete(entity.id);
        console.log(`Fixed inconsistency: Removed entity ${entity.id} from active enemies`);
      }
      for (let i = 0; i < this.enemyPool.length; i++) {
        if (this.enemyPool[i].id === entity.id) {
          console.warn(`CRITICAL ERROR: Duplicate of entity ${entity.id} found in enemy pool!`);
          this.enemyPool.splice(i, 1);
          console.log(`Fixed inconsistency: Removed duplicate entity ${entity.id} from enemy pool`);
          i--;
        }
      }
      console.log(`Getting entity ${entity.id} from pool. Current tags: [${entity.tags ? [...entity.tags] : "undefined"}]`);
      if (entity.clearTags && typeof entity.clearTags === "function") {
        entity.clearTags();
        console.log(`Cleared all tags from entity ${entity.id}`);
      } else {
        console.warn(`Entity ${entity.id} missing clearTags method`);
        if (entity.hasTag && entity.removeTag) {
          if (entity.hasTag("pooled")) {
            entity.removeTag("pooled");
          }
          if (entity.hasTag("enemy")) entity.removeTag("enemy");
          if (entity.hasTag("spectrals")) entity.removeTag("spectrals");
        }
      }
      if (entity._syncTagCache && typeof entity._syncTagCache === "function") {
        entity._syncTagCache();
        console.log(`Reset tag cache for entity ${entity.id}`);
      } else {
        if (entity._isEnemy !== void 0) entity._isEnemy = false;
        if (entity._isPooled !== void 0) entity._isPooled = false;
      }
      const enemyAI = entity.getComponent(EnemyAIComponent);
      if (enemyAI) {
        enemyAI.playerFound = false;
        enemyAI.timeAlive = 0;
        enemyAI.spiralPhase = Math.random() * Math.PI * 2;
        enemyAI.enabled = true;
      }
      console.log(`Entity ${entity.id} prepared for reuse. Current tags: [${entity.tags ? [...entity.tags] : "undefined"}]`);
      return entity;
    }
    const newEntity = this.createEnemyEntity();
    console.log(`Created new entity ${newEntity.id} because pool was empty`);
    return newEntity;
  }
  /**
   * Return an enemy to the pool
   * @param {Entity} entity Enemy entity
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  returnEnemyToPool(entity, enemies) {
    if (!entity) {
      console.warn("Attempt to return null/undefined entity to pool");
      return;
    }
    const entityId = entity.id;
    console.log(`Returning entity ${entityId} to pool. Has tags: [${entity.tags ? [...entity.tags] : "undefined"}]`);
    if (enemies && enemies.has(entityId)) {
      enemies.delete(entityId);
      console.log(`Removed entity ${entityId} from enemies tracking`);
    }
    if (entity.clearTags && typeof entity.clearTags === "function") {
      entity.clearTags();
      console.log(`Cleared all tags from entity ${entityId}`);
    } else {
      console.warn(`No clearTags method on entity ${entityId}, using manual tag removal`);
      if (entity.hasTag && entity.removeTag) {
        if (entity.hasTag("enemy")) entity.removeTag("enemy");
        if (entity.hasTag("spectrals")) entity.removeTag("spectrals");
        if (entity.hasTag("drone")) entity.removeTag("drone");
        if (entity.hasTag("frozen")) entity.removeTag("frozen");
      }
    }
    if (this.enemyPool.length < this.maxPoolSize) {
      const trailComponent = entity.getComponent(TrailComponent);
      if (trailComponent) {
        try {
          if (typeof trailComponent.onDetached === "function") {
            trailComponent.onDetached();
          }
          if (window.game && window.game.trailSystem) {
            window.game.trailSystem.unregisterTrail && window.game.trailSystem.unregisterTrail(entityId);
          }
          if (trailComponent.trailMesh && trailComponent.trailMesh.parent) {
            trailComponent.trailMesh.parent.remove(trailComponent.trailMesh);
          }
          if (trailComponent.trailMesh) {
            if (trailComponent.trailMesh.geometry) {
              trailComponent.trailMesh.geometry.dispose();
            }
            if (trailComponent.trailMesh.material) {
              trailComponent.trailMesh.material.dispose();
            }
          }
          entity.removeComponent(TrailComponent);
          console.log(`Removed and cleaned up TrailComponent from entity ${entityId}`);
        } catch (error) {
          console.error(`Error cleaning up trail for entity ${entityId}:`, error);
        }
      }
      const transform2 = entity.getComponent(TransformComponent);
      if (transform2) {
        transform2.position.set(0, 0, 0);
        transform2.rotation.set(0, 0, 0);
        transform2.scale.set(1, 1, 1);
      }
      const health = entity.getComponent(HealthComponent);
      if (health) {
        health.health = 0;
        health.isDestroyed = true;
      }
      const enemyAI = entity.getComponent(EnemyAIComponent);
      if (enemyAI) {
        enemyAI.enabled = false;
        enemyAI.playerFound = false;
        enemyAI.timeAlive = 0;
        enemyAI.spiralPhase = Math.random() * Math.PI * 2;
      }
      const meshComponent = entity.getComponent(MeshComponent);
      if (meshComponent && meshComponent.mesh) {
        try {
          if (meshComponent.mesh.parent) {
            meshComponent.mesh.parent.remove(meshComponent.mesh);
          }
          meshComponent.mesh.visible = false;
        } catch (error) {
          console.error(`Error cleaning up mesh for entity ${entityId}:`, error);
        }
      }
      const rigidbody = entity.getComponent(RigidbodyComponent);
      if (rigidbody) {
        rigidbody.isFrozen = true;
        if (rigidbody.velocity) {
          rigidbody.velocity.set(0, 0, 0);
        }
      }
      entity.addTag("pooled");
      console.log(`Entity ${entityId} marked as pooled`);
      console.log(`Final entity ${entityId} state - Tags: [${entity.tags ? [...entity.tags] : "none"}]`);
      this.enemyPool.push(entity);
      console.log(`Entity ${entityId} returned to pool. Pool size now ${this.enemyPool.length}`);
    } else {
      console.log(`Pool is full (${this.maxPoolSize}), destroying entity ${entityId} instead of pooling`);
      if (this.world && this.world.destroyEntity) {
        this.world.destroyEntity(entityId);
        console.log(`Entity ${entityId} fully destroyed`);
      } else {
        console.error(`Failed to destroy entity ${entityId} - world or destroyEntity method not available`);
      }
    }
  }
  /**
   * Run diagnostics on the enemy pool system to detect and fix inconsistencies
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  runPoolDiagnostics(enemies) {
    console.log("=== RUNNING ENEMY POOL DIAGNOSTICS ===");
    console.log(`Active enemies: ${enemies.size}, Pool size: ${this.enemyPool.length}`);
    let inconsistenciesFixed = 0;
    const poolEntityIds = /* @__PURE__ */ new Set();
    const duplicateIndices = [];
    for (let i = 0; i < this.enemyPool.length; i++) {
      const entity = this.enemyPool[i];
      if (!entity || !entity.id) {
        console.warn(`Invalid entity at index ${i} in enemy pool - removing`);
        duplicateIndices.push(i);
        inconsistenciesFixed++;
        continue;
      }
      if (poolEntityIds.has(entity.id)) {
        console.warn(`Duplicate entity ${entity.id} found in enemy pool at index ${i} - removing`);
        duplicateIndices.push(i);
        inconsistenciesFixed++;
      } else {
        poolEntityIds.add(entity.id);
      }
    }
    for (let i = duplicateIndices.length - 1; i >= 0; i--) {
      this.enemyPool.splice(duplicateIndices[i], 1);
    }
    const activePooledEntities = [];
    for (let i = 0; i < this.enemyPool.length; i++) {
      const entity = this.enemyPool[i];
      if (enemies.has(entity.id)) {
        console.error(`CRITICAL ERROR: Entity ${entity.id} is both active and in the pool!`);
        activePooledEntities.push(i);
        inconsistenciesFixed++;
      }
    }
    for (let i = activePooledEntities.length - 1; i >= 0; i--) {
      const index = activePooledEntities[i];
      const entityId = this.enemyPool[index].id;
      this.enemyPool.splice(index, 1);
      console.log(`Fixed critical inconsistency: Removed entity ${entityId} from pool since it's active`);
    }
    let enemyTaggedCount = 0;
    let pooledTaggedCount = 0;
    let inconsistentEntities = 0;
    if (this.world && this.world.entityManager && this.world.entityManager.entitiesByTag) {
      const enemyTaggedEntities = this.world.entityManager.entitiesByTag.get("enemy") || [];
      enemyTaggedCount = enemyTaggedEntities.length;
      const pooledTaggedEntities = this.world.entityManager.entitiesByTag.get("pooled") || [];
      pooledTaggedCount = pooledTaggedEntities.length;
      for (const entity of enemyTaggedEntities) {
        if (entity.hasTag("pooled")) {
          console.warn(`INCONSISTENT ENTITY ${entity.id}: Has both 'enemy' and 'pooled' tags`);
          inconsistentEntities++;
          const isInPool = this.enemyPool.some((e) => e.id === entity.id);
          if (isInPool) {
            entity.removeTag("enemy");
            console.log(`Fixed entity ${entity.id} by removing 'enemy' tag since it's in the pool`);
          } else {
            entity.removeTag("pooled");
            console.log(`Fixed entity ${entity.id} by removing 'pooled' tag since it's not in the pool`);
          }
          inconsistenciesFixed++;
        }
      }
      for (const entityId of enemies) {
        const entity = this.world.getEntity(entityId);
        if (entity && entity.hasTag("pooled")) {
          console.warn(`INCONSISTENT TRACKING: Entity ${entityId} is in active enemies but has 'pooled' tag`);
          const isInPool = this.enemyPool.some((e) => e.id === entityId);
          if (isInPool) {
            enemies.delete(entityId);
            console.log(`Fixed by removing entity ${entityId} from active enemies set since it's in the pool`);
          } else {
            entity.removeTag("pooled");
            console.log(`Fixed entity ${entityId} by removing 'pooled' tag since it's not in the pool`);
          }
          inconsistentEntities++;
          inconsistenciesFixed++;
        }
      }
      for (let i = 0; i < this.enemyPool.length; i++) {
        const entity = this.enemyPool[i];
        if (!entity) continue;
        let entityFixed = false;
        if (!entity.hasTag("pooled")) {
          console.warn(`INCONSISTENT POOL: Entity ${entity.id} in enemy pool but missing 'pooled' tag`);
          entity.addTag("pooled");
          console.log(`Fixed by adding 'pooled' tag to entity ${entity.id}`);
          entityFixed = true;
          inconsistenciesFixed++;
        }
        if (entity.hasTag("enemy")) {
          console.warn(`INCONSISTENT POOL: Entity ${entity.id} in enemy pool but has 'enemy' tag`);
          entity.removeTag("enemy");
          console.log(`Fixed by removing 'enemy' tag from entity ${entity.id}`);
          entityFixed = true;
          inconsistenciesFixed++;
        }
        if (entityFixed) {
          inconsistentEntities++;
        }
      }
    }
    console.log(`Diagnostic results: ${enemyTaggedCount} entities with 'enemy' tag, ${pooledTaggedCount} entities with 'pooled' tag`);
    console.log(`Fixed ${inconsistenciesFixed} inconsistencies across ${inconsistentEntities} entities`);
    console.log("=== DIAGNOSTICS COMPLETE ===");
  }
}
const BASE_ENEMY_CONFIG = {
  health: 20,
  damage: 15,
  speed: 700,
  spiralAmplitude: 150,
  spiralFrequency: 2
};
const ENEMY_TYPES = {
  SPECTRAL_DRONE: {
    faction: "spectrals",
    type: "drone",
    baseConfig: { ...BASE_ENEMY_CONFIG },
    visualVariants: 4,
    // 0: Normal, 1: Damaged, 2: Elite, 3: Shielded
    sizeVariation: { min: 0.8, max: 1.6 },
    baseSize: 80,
    speedVariation: { min: 0.7, max: 1.3 },
    amplitudeVariation: { min: 0.8, max: 1.2 },
    frequencyVariation: { min: 0.9, max: 1.1 },
    isDroneLike: true,
    collisionRadius: 50
  }
};
const ENEMY_COLOR_PALETTE = [
  { main: 52479, emissive: { r: 0, g: 0.533, b: 1 } },
  // Blue/cyan
  { main: 8939263, emissive: { r: 0.4, g: 0.2, b: 1 } },
  // Purple/blue
  { main: 65484, emissive: { r: 0, g: 0.733, b: 0.6 } },
  // Teal/green
  { main: 16724838, emissive: { r: 0.8, g: 0.067, b: 0.267 } },
  // Red/pink
  { main: 16755200, emissive: { r: 0.8, g: 0.533, b: 0 } },
  // Orange/gold
  { main: 6750003, emissive: { r: 0.267, g: 0.8, b: 0.067 } },
  // Lime/green
  { main: 16751103, emissive: { r: 0.8, g: 0.6, b: 0.8 } },
  // Pink/magenta
  { main: 16777011, emissive: { r: 0.8, g: 0.8, b: 0.067 } },
  // Yellow
  { main: 3368703, emissive: { r: 0.067, g: 0.267, b: 0.8 } },
  // Deep blue
  { main: 16724787, emissive: { r: 0.8, g: 0.067, b: 0.067 } }
  // Deep red
];
const VISUAL_VARIANTS = {
  NORMAL: {
    id: 0,
    name: "normal",
    emissiveIntensity: { min: 1, max: 1.5 },
    opacity: 1,
    additionalEffects: false
  },
  DAMAGED: {
    id: 1,
    name: "damaged",
    emissiveIntensity: { base: 0.5, flicker: 0.3 },
    // Flickering effect
    opacity: 0.85,
    colorMultiplier: 0.7,
    additionalEffects: false
  },
  ELITE: {
    id: 2,
    name: "elite",
    emissiveIntensity: { base: 2, pulse: 0.5 },
    // Pulsing effect
    opacity: 1,
    colorMultiplier: 1.2,
    additionalEffects: true,
    haloEffect: true
  },
  SHIELDED: {
    id: 3,
    name: "shielded",
    emissiveIntensity: 1.5,
    opacity: 1,
    shimmerEffect: true,
    shieldEffect: true,
    additionalEffects: false
  }
};
function getRandomEnemyColor() {
  const colorIndex = Math.floor(Math.random() * ENEMY_COLOR_PALETTE.length);
  return ENEMY_COLOR_PALETTE[colorIndex];
}
function getVisualVariant(variantId = 0) {
  const variants = Object.values(VISUAL_VARIANTS);
  const variant = variants.find((v) => v.id === variantId);
  return variant || VISUAL_VARIANTS.NORMAL;
}
function getRandomVisualVariant() {
  return Math.floor(Math.random() * 4);
}
class DifficultyProgression {
  constructor() {
    this.baseConfig = { ...BASE_ENEMY_CONFIG };
    this.currentConfig = { ...BASE_ENEMY_CONFIG };
    this.baseSpawnInterval = 3;
    this.currentSpawnInterval = 3;
  }
  /**
   * Update difficulty parameters based on external difficulty manager
   * @param {Object} world - The game world instance
   * @returns {boolean} Whether parameters were updated
   */
  updateParameters(world) {
    let updated = false;
    if (window.game && window.game.difficultyManager && window.game.difficultyManager.params) {
      const diffParams = window.game.difficultyManager.params;
      if (diffParams.enemyHealth !== void 0 && diffParams.enemyHealth !== this.currentConfig.health) {
        this.currentConfig.health = diffParams.enemyHealth;
        updated = true;
      }
      if (diffParams.enemyDamage !== void 0 && diffParams.enemyDamage !== this.currentConfig.damage) {
        this.currentConfig.damage = diffParams.enemyDamage;
        updated = true;
      }
      if (diffParams.enemySpeed !== void 0 && diffParams.enemySpeed !== this.currentConfig.speed) {
        this.currentConfig.speed = diffParams.enemySpeed;
        updated = true;
      }
      if (diffParams.spawnInterval !== void 0 && diffParams.spawnInterval !== this.currentSpawnInterval) {
        this.currentSpawnInterval = diffParams.spawnInterval;
        updated = true;
      }
      if (updated && Math.random() < 5e-3) {
        console.log(`Updated enemy parameters: Health=${this.currentConfig.health}, Damage=${this.currentConfig.damage}, Speed=${this.currentConfig.speed}, SpawnInterval=${this.currentSpawnInterval}`);
      }
    }
    return updated;
  }
  /**
   * Get current enemy configuration with difficulty scaling
   * @returns {Object} Current enemy configuration
   */
  getCurrentConfig() {
    return { ...this.currentConfig };
  }
  /**
   * Get current spawn interval
   * @returns {number} Current spawn interval in seconds
   */
  getCurrentSpawnInterval() {
    return this.currentSpawnInterval;
  }
  /**
   * Apply random variations to enemy parameters
   * @param {Object} baseConfig - Base configuration to vary
   * @returns {Object} Configuration with applied variations
   */
  applyVariations(baseConfig) {
    return {
      health: baseConfig.health,
      damage: baseConfig.damage,
      speed: baseConfig.speed * (0.7 + Math.random() * 0.6),
      // 70-130% of base speed
      spiralAmplitude: baseConfig.spiralAmplitude * (0.8 + Math.random() * 0.4),
      // 80-120% of base
      spiralFrequency: baseConfig.spiralFrequency * (0.9 + Math.random() * 0.2)
      // 90-110% of base
    };
  }
  /**
   * Reset difficulty to base values
   */
  reset() {
    this.currentConfig = { ...this.baseConfig };
    this.currentSpawnInterval = this.baseSpawnInterval;
  }
  /**
   * Set manual difficulty multiplier (for testing or special events)
   * @param {number} multiplier - Difficulty multiplier (1.0 = normal)
   */
  setDifficultyMultiplier(multiplier) {
    this.currentConfig.health = Math.round(this.baseConfig.health * multiplier);
    this.currentConfig.damage = Math.round(this.baseConfig.damage * multiplier);
    this.currentConfig.speed = Math.round(this.baseConfig.speed * multiplier);
    this.currentSpawnInterval = Math.max(0.5, this.baseSpawnInterval / multiplier);
  }
  /**
   * Get difficulty statistics
   * @returns {Object} Current difficulty statistics
   */
  getStats() {
    const healthMultiplier = this.currentConfig.health / this.baseConfig.health;
    const damageMultiplier = this.currentConfig.damage / this.baseConfig.damage;
    const speedMultiplier = this.currentConfig.speed / this.baseConfig.speed;
    const spawnRateMultiplier = this.baseSpawnInterval / this.currentSpawnInterval;
    return {
      healthMultiplier: healthMultiplier.toFixed(2),
      damageMultiplier: damageMultiplier.toFixed(2),
      speedMultiplier: speedMultiplier.toFixed(2),
      spawnRateMultiplier: spawnRateMultiplier.toFixed(2),
      currentHealth: this.currentConfig.health,
      currentDamage: this.currentConfig.damage,
      currentSpeed: this.currentConfig.speed,
      currentSpawnInterval: this.currentSpawnInterval
    };
  }
}
const FORMATION_PATTERNS = {
  SPHERE: {
    name: "sphere",
    description: "Spherical distribution around center point",
    defaultRadius: 2500,
    defaultCount: 12,
    generate: (center, count = 12, radius = 2500) => {
      const points = [];
      for (let i = 0; i < count; i++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = Math.random() * Math.PI * 2;
        const x = center.x + radius * Math.sin(phi) * Math.cos(theta);
        const y = center.y + radius * Math.sin(phi) * Math.sin(theta);
        const z = center.z + radius * Math.cos(phi);
        points.push(new Vector3(x, y, z));
      }
      return points;
    }
  },
  CIRCLE: {
    name: "circle",
    description: "Circular distribution around center point",
    defaultRadius: 3e3,
    defaultCount: 10,
    generate: (center, count = 10, radius = 3e3) => {
      const points = [];
      for (let i = 0; i < count; i++) {
        const angle = i / count * Math.PI * 2;
        const x = center.x + Math.cos(angle) * radius;
        const y = center.y + (Math.random() - 0.5) * 1e3;
        const z = center.z + Math.sin(angle) * radius;
        points.push(new Vector3(x, y, z));
      }
      return points;
    }
  },
  RING: {
    name: "ring",
    description: "Ring formation with inner and outer radius",
    defaultInnerRadius: 2e3,
    defaultOuterRadius: 3500,
    defaultCount: 8,
    generate: (center, count = 8, innerRadius = 2e3, outerRadius = 3500) => {
      const points = [];
      for (let i = 0; i < count; i++) {
        const angle = i / count * Math.PI * 2;
        const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
        const x = center.x + Math.cos(angle) * radius;
        const y = center.y + (Math.random() - 0.5) * 500;
        const z = center.z + Math.sin(angle) * radius;
        points.push(new Vector3(x, y, z));
      }
      return points;
    }
  },
  HEMISPHERE: {
    name: "hemisphere",
    description: "Hemisphere above/below center point",
    defaultRadius: 2800,
    defaultCount: 10,
    generate: (center, count = 10, radius = 2800, upper = true) => {
      const points = [];
      for (let i = 0; i < count; i++) {
        const phi = upper ? Math.random() * Math.PI / 2 : Math.PI / 2 + Math.random() * Math.PI / 2;
        const theta = Math.random() * Math.PI * 2;
        const x = center.x + radius * Math.sin(phi) * Math.cos(theta);
        const y = center.y + radius * Math.sin(phi) * Math.sin(theta);
        const z = center.z + radius * Math.cos(phi);
        points.push(new Vector3(x, y, z));
      }
      return points;
    }
  },
  GRID_3D: {
    name: "grid3d",
    description: "3D grid formation around center",
    defaultSpacing: 1e3,
    defaultSize: 3,
    generate: (center, size = 3, spacing = 1e3) => {
      const points = [];
      const offset = (size - 1) * spacing / 2;
      for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
          for (let z = 0; z < size; z++) {
            if (x === Math.floor(size / 2) && y === Math.floor(size / 2) && z === Math.floor(size / 2)) {
              continue;
            }
            const point = new Vector3(
              center.x + x * spacing - offset,
              center.y + y * spacing - offset,
              center.z + z * spacing - offset
            );
            points.push(point);
          }
        }
      }
      return points;
    }
  },
  RANDOM_CLOUD: {
    name: "randomcloud",
    description: "Random distribution within a bounding volume",
    defaultRadius: 3e3,
    defaultCount: 15,
    generate: (center, count = 15, radius = 3e3) => {
      const points = [];
      for (let i = 0; i < count; i++) {
        const u = Math.random();
        const v = Math.random();
        const w = Math.random();
        const r = radius * Math.cbrt(u);
        const theta = 2 * Math.PI * v;
        const phi = Math.acos(2 * w - 1);
        const x = center.x + r * Math.sin(phi) * Math.cos(theta);
        const y = center.y + r * Math.sin(phi) * Math.sin(theta);
        const z = center.z + r * Math.cos(phi);
        points.push(new Vector3(x, y, z));
      }
      return points;
    }
  }
};
const DEFAULT_FORMATION = FORMATION_PATTERNS.SPHERE;
class FormationBuilder {
  constructor(world) {
    this.world = world;
    this.spawnPoints = [];
    this.currentFormation = DEFAULT_FORMATION;
    this.lastPlayerPosition = null;
    this.regenerationDistance = 1e3;
  }
  /**
   * Find player position using multiple detection methods
   * @returns {THREE.Vector3|null} Player position or null if not found
   */
  findPlayerPosition() {
    let players = [];
    let playerPosition = null;
    try {
      if (this.world.entityManager && this.world.entityManager.getEntitiesByTag) {
        players = this.world.entityManager.getEntitiesByTag("player");
        if (players.length > 0) {
          const transform2 = players[0].getComponent(TransformComponent);
          if (transform2 && transform2.position) {
            playerPosition = transform2.position;
          }
        }
      }
    } catch (e) {
      console.log("Could not get player via entityManager:", e.message);
    }
    if (!playerPosition) {
      try {
        if (this.world.getEntitiesByTag) {
          players = this.world.getEntitiesByTag("player");
          if (players.length > 0) {
            const transform2 = players[0].getComponent(TransformComponent);
            if (transform2 && transform2.position) {
              playerPosition = transform2.position;
            }
          }
        }
      } catch (e) {
        console.log("Could not get player via world.getEntitiesByTag:", e.message);
      }
    }
    if (!playerPosition && window.game) {
      try {
        if (window.game.spaceship && window.game.spaceship.mesh && window.game.spaceship.mesh.position) {
          playerPosition = window.game.spaceship.mesh.position;
          console.log("Using spaceship mesh position for spawn points");
        }
      } catch (e) {
        console.log("Could not get player via window.game.spaceship:", e.message);
      }
    }
    return playerPosition;
  }
  /**
   * Generate spawn points using current formation pattern
   * @param {boolean} forceRegenerate - Force regeneration even if player hasn't moved far
   * @returns {Array<THREE.Vector3>} Array of spawn points
   */
  generateSpawnPoints(forceRegenerate = false) {
    const playerPosition = this.findPlayerPosition();
    if (!forceRegenerate && this.lastPlayerPosition && playerPosition) {
      const distance = this.lastPlayerPosition.distanceTo(playerPosition);
      if (distance < this.regenerationDistance && this.spawnPoints.length > 0) {
        return this.spawnPoints;
      }
    }
    this.spawnPoints = [];
    if (!playerPosition) {
      console.log("No player position found - generating default spawn points around origin");
      const center = new Vector3(0, 0, 0);
      this.spawnPoints = this.currentFormation.generate(
        center,
        this.currentFormation.defaultCount,
        this.currentFormation.defaultRadius
      );
    } else {
      const center = playerPosition.clone ? playerPosition.clone() : new Vector3(playerPosition.x, playerPosition.y, playerPosition.z);
      this.spawnPoints = this.currentFormation.generate(
        center,
        this.currentFormation.defaultCount,
        this.currentFormation.defaultRadius
      );
      this.lastPlayerPosition = center.clone();
      console.log(`Generated ${this.spawnPoints.length} spawn points using ${this.currentFormation.name} formation around player at position ${center.x.toFixed(0)}, ${center.y.toFixed(0)}, ${center.z.toFixed(0)}`);
    }
    return this.spawnPoints;
  }
  /**
   * Get a random spawn point
   * @returns {THREE.Vector3} Random spawn position
   */
  getRandomSpawnPoint() {
    if (this.spawnPoints.length === 0) {
      this.generateSpawnPoints();
    }
    if (this.spawnPoints.length > 0) {
      const index = Math.floor(Math.random() * this.spawnPoints.length);
      return this.spawnPoints[index].clone();
    } else {
      console.warn("No spawn points available, using fallback position");
      const angle = Math.random() * Math.PI * 2;
      const distance = 2e3;
      return new Vector3(
        Math.cos(angle) * distance,
        (Math.random() - 0.5) * 500,
        Math.sin(angle) * distance
      );
    }
  }
  /**
   * Set formation pattern
   * @param {string} patternName - Name of the formation pattern
   * @param {boolean} regenerate - Whether to regenerate spawn points immediately
   */
  setFormationPattern(patternName, regenerate = true) {
    const pattern = FORMATION_PATTERNS[patternName.toUpperCase()];
    if (pattern) {
      this.currentFormation = pattern;
      if (regenerate) {
        this.generateSpawnPoints(true);
      }
      console.log(`Formation pattern changed to: ${pattern.name}`);
    } else {
      console.warn(`Unknown formation pattern: ${patternName}`);
    }
  }
  /**
   * Get current formation info
   * @returns {Object} Current formation information
   */
  getCurrentFormation() {
    return {
      name: this.currentFormation.name,
      description: this.currentFormation.description,
      spawnPointCount: this.spawnPoints.length
    };
  }
  /**
   * Get spawn points in a specific formation around a position
   * @param {THREE.Vector3} center - Center position
   * @param {string} patternName - Formation pattern name
   * @param {number} count - Number of spawn points
   * @param {number} radius - Formation radius
   * @returns {Array<THREE.Vector3>} Array of spawn points
   */
  generateFormationAround(center, patternName, count = 12, radius = 2500) {
    const pattern = FORMATION_PATTERNS[patternName.toUpperCase()] || DEFAULT_FORMATION;
    return pattern.generate(center, count, radius);
  }
  /**
   * Clear all spawn points and force regeneration on next request
   */
  clearSpawnPoints() {
    this.spawnPoints = [];
    this.lastPlayerPosition = null;
  }
  /**
   * Get statistics about current spawn points
   * @returns {Object} Spawn point statistics
   */
  getSpawnPointStats() {
    if (this.spawnPoints.length === 0) {
      return { count: 0, pattern: "none" };
    }
    let totalDistance = 0;
    let center = new Vector3();
    for (const point of this.spawnPoints) {
      center.add(point);
    }
    center.divideScalar(this.spawnPoints.length);
    for (const point of this.spawnPoints) {
      totalDistance += center.distanceTo(point);
    }
    return {
      count: this.spawnPoints.length,
      pattern: this.currentFormation.name,
      averageDistance: Math.round(totalDistance / this.spawnPoints.length),
      centerPosition: {
        x: Math.round(center.x),
        y: Math.round(center.y),
        z: Math.round(center.z)
      }
    };
  }
}
class SpawnScheduler {
  constructor() {
    this.spawnTimer = 0;
    this.baseSpawnInterval = 3;
    this.currentSpawnInterval = 3;
    this.lastSpawnTime = Date.now();
    this.initialDelay = 10;
    this.initialDelayRemaining = this.initialDelay;
    this.hasInitialDelayPassed = false;
    this.spawnRateModifier = 1;
    this.minSpawnInterval = 0.5;
    this.maxSpawnInterval = 10;
    this.totalSpawnsRequested = 0;
    this.totalSpawnsSuccessful = 0;
    this.lastSpawnRequestTime = 0;
    this.averageSpawnInterval = this.baseSpawnInterval;
    this._lastProgressLogged = 0;
    console.log(`SpawnScheduler initialized with ${this.initialDelay}s initial delay`);
  }
  /**
   * Update the spawn timer and check if spawning is allowed
   * @param {number} deltaTime - Time since last update in seconds
   * @param {number} currentEnemyCount - Current number of active enemies
   * @param {number} maxEnemies - Maximum allowed enemies
   * @param {number} difficultySpawnInterval - Spawn interval from difficulty system
   * @returns {boolean} Whether spawning should occur
   */
  update(deltaTime, currentEnemyCount, maxEnemies, difficultySpawnInterval = null) {
    console.log(`[SPAWN_SCHEDULER] Update called with deltaTime: ${deltaTime.toFixed(3)}, enemies: ${currentEnemyCount}/${maxEnemies}`);
    if (!this.hasInitialDelayPassed) {
      this.initialDelayRemaining -= deltaTime;
      console.log(`[SPAWN_SCHEDULER] Initial delay active: ${this.initialDelayRemaining.toFixed(1)}s remaining`);
      const progress = Math.floor(this.initialDelay - this.initialDelayRemaining);
      if (progress > 0 && progress % 5 === 0 && progress !== this._lastProgressLogged) {
        const remainingTime = Math.ceil(this.initialDelayRemaining);
        console.log(`[SPAWN_SCHEDULER] Enemy spawn delay: ${remainingTime} seconds remaining (${progress}/${this.initialDelay}s elapsed)`);
        this._lastProgressLogged = progress;
      }
      if (this.initialDelayRemaining <= 0) {
        this.hasInitialDelayPassed = true;
        this.showSpawnNotification();
      } else {
        return false;
      }
    }
    if (difficultySpawnInterval !== null && difficultySpawnInterval !== this.currentSpawnInterval) {
      this.setSpawnInterval(difficultySpawnInterval);
    }
    this.spawnTimer += deltaTime;
    const effectiveInterval = this.getEffectiveSpawnInterval();
    const shouldSpawn = this.spawnTimer >= effectiveInterval && currentEnemyCount < maxEnemies;
    if (shouldSpawn) {
      this.recordSpawnRequest();
    }
    return shouldSpawn;
  }
  /**
   * Record a spawn request for statistics
   */
  recordSpawnRequest() {
    this.totalSpawnsRequested++;
    this.lastSpawnRequestTime = Date.now();
  }
  /**
   * Record a successful spawn and reset timer
   * @param {boolean} wasSuccessful - Whether the spawn was successful
   */
  recordSpawn(wasSuccessful = true) {
    if (wasSuccessful) {
      this.totalSpawnsSuccessful++;
      this.lastSpawnTime = Date.now();
      const actualInterval = this.spawnTimer;
      this.averageSpawnInterval = this.averageSpawnInterval * 0.9 + actualInterval * 0.1;
    }
    this.spawnTimer = 0;
  }
  /**
   * Get effective spawn interval with all modifiers applied
   * @returns {number} Effective spawn interval in seconds
   */
  getEffectiveSpawnInterval() {
    let interval = this.currentSpawnInterval * this.spawnRateModifier;
    interval = Math.max(this.minSpawnInterval, Math.min(this.maxSpawnInterval, interval));
    return interval;
  }
  /**
   * Set the base spawn interval
   * @param {number} interval - New spawn interval in seconds
   */
  setSpawnInterval(interval) {
    this.currentSpawnInterval = Math.max(this.minSpawnInterval, Math.min(this.maxSpawnInterval, interval));
  }
  /**
   * Set spawn rate modifier (1.0 = normal, 0.5 = half rate, 2.0 = double rate)
   * @param {number} modifier - Spawn rate modifier
   */
  setSpawnRateModifier(modifier) {
    this.spawnRateModifier = Math.max(0.1, modifier);
  }
  /**
   * Get time remaining until next spawn opportunity
   * @returns {number} Time in seconds until next spawn check
   */
  getTimeUntilNextSpawn() {
    if (!this.hasInitialDelayPassed) {
      return this.initialDelayRemaining;
    }
    const effectiveInterval = this.getEffectiveSpawnInterval();
    return Math.max(0, effectiveInterval - this.spawnTimer);
  }
  /**
   * Check if initial delay has passed
   * @returns {boolean} Whether initial delay has completed
   */
  isInitialDelayComplete() {
    return this.hasInitialDelayPassed;
  }
  /**
   * Get remaining initial delay time
   * @returns {number} Remaining initial delay in seconds
   */
  getRemainingInitialDelay() {
    return Math.max(0, this.initialDelayRemaining);
  }
  /**
   * Skip remaining initial delay (for testing or special events)
   */
  skipInitialDelay() {
    this.hasInitialDelayPassed = true;
    this.initialDelayRemaining = 0;
    console.log("Initial spawn delay skipped");
  }
  /**
   * Reset the scheduler to initial state
   */
  reset() {
    this.spawnTimer = 0;
    this.currentSpawnInterval = this.baseSpawnInterval;
    this.initialDelayRemaining = this.initialDelay;
    this.hasInitialDelayPassed = false;
    this.spawnRateModifier = 1;
    this.totalSpawnsRequested = 0;
    this.totalSpawnsSuccessful = 0;
    this.lastSpawnTime = Date.now();
    this.averageSpawnInterval = this.baseSpawnInterval;
    this._lastProgressLogged = 0;
    console.log("SpawnScheduler reset to initial state");
  }
  /**
   * Set new initial delay duration
   * @param {number} delaySeconds - Initial delay in seconds
   */
  setInitialDelay(delaySeconds) {
    this.initialDelay = Math.max(0, delaySeconds);
    if (!this.hasInitialDelayPassed) {
      this.initialDelayRemaining = this.initialDelay;
    }
  }
  /**
   * Get current scheduler statistics
   * @returns {Object} Scheduler statistics
   */
  getStatistics() {
    const now = Date.now();
    const timeSinceLastSpawn = (now - this.lastSpawnTime) / 1e3;
    const successRate = this.totalSpawnsRequested > 0 ? (this.totalSpawnsSuccessful / this.totalSpawnsRequested * 100).toFixed(1) : 0;
    return {
      currentSpawnInterval: this.currentSpawnInterval.toFixed(2),
      effectiveSpawnInterval: this.getEffectiveSpawnInterval().toFixed(2),
      spawnRateModifier: this.spawnRateModifier.toFixed(2),
      timeUntilNextSpawn: this.getTimeUntilNextSpawn().toFixed(1),
      timeSinceLastSpawn: timeSinceLastSpawn.toFixed(1),
      totalSpawnsRequested: this.totalSpawnsRequested,
      totalSpawnsSuccessful: this.totalSpawnsSuccessful,
      successRate: `${successRate}%`,
      averageSpawnInterval: this.averageSpawnInterval.toFixed(2),
      initialDelayComplete: this.hasInitialDelayPassed,
      remainingInitialDelay: this.hasInitialDelayPassed ? 0 : this.getRemainingInitialDelay().toFixed(1)
    };
  }
  /**
   * Pause spawning (sets spawn rate modifier to 0)
   */
  pauseSpawning() {
    this.spawnRateModifier = 0;
    console.log("Spawning paused");
  }
  /**
   * Resume spawning (resets spawn rate modifier to 1)
   */
  resumeSpawning() {
    this.spawnRateModifier = 1;
    console.log("Spawning resumed");
  }
  /**
   * Check if spawning is currently paused
   * @returns {boolean} Whether spawning is paused
   */
  isSpawningPaused() {
    return this.spawnRateModifier === 0;
  }
  /**
   * Show notification that spectral drones have been spotted
   */
  showSpawnNotification() {
    if (window.game && window.game.ui && window.game.ui.showNotification) {
      window.game.ui.showNotification("WARNING: Spectral drones have been spotted in the sector!", 5e3);
    } else if (window.mainMessageBus) {
      window.mainMessageBus.publish("ui.notification", {
        message: "WARNING: Spectral drones have been spotted in the sector!",
        duration: 5e3
      });
    }
  }
}
class SpectralDroneCreator {
  constructor(world) {
    this.world = world;
  }
  /**
   * Create a spectral drone entity at the given position
   * @param {THREE.Vector3} position Spawn position
   * @param {Object} poolManager Enemy pool manager
   * @param {Set} enemies Active enemies tracking set
   * @param {number} maxEnemies Maximum enemy count
   * @param {Object} enemyConfig Current enemy configuration
   * @returns {Entity|null} The created entity or null if failed
   */
  createSpectralDrone(position, poolManager, enemies, maxEnemies, enemyConfig) {
    console.log("Creating spectral drone...");
    if (enemies.size >= maxEnemies) {
      console.warn(`SPAWN BLOCKED: Already at maximum enemies (${enemies.size}/${maxEnemies})`);
      return null;
    }
    const entity = poolManager.getEnemyFromPool();
    if (!entity) {
      console.error("Failed to get entity from pool");
      return null;
    }
    if (enemies.has(entity.id)) {
      console.error(`Entity ${entity.id} is already in the active enemies list!`);
      return null;
    }
    this.cleanEntityState(entity);
    this.setupEntityComponents(entity, position, enemyConfig);
    enemies.add(entity.id);
    this.registerWithCombatSystem(entity);
    console.log(`Created spectral drone at position: x=${position.x.toFixed(0)}, y=${position.y.toFixed(0)}, z=${position.z.toFixed(0)}`);
    return entity;
  }
  /**
   * Clean entity state from pool
   * @param {Entity} entity Entity to clean
   */
  cleanEntityState(entity) {
    if (entity.tags && entity.tags.size > 0) {
      console.warn(`Entity ${entity.id} from pool still has tags: [${[...entity.tags]}]. Clearing all tags.`);
      if (entity.clearTags && typeof entity.clearTags === "function") {
        entity.clearTags();
      } else {
        entity.tags.clear();
        entity._isEnemy = false;
        entity._isPooled = false;
        entity._isPlayer = false;
        entity._isProjectile = false;
      }
    }
    entity.addTag("enemy");
    entity.addTag("spectrals");
  }
  /**
   * Setup all components for the entity
   * @param {Entity} entity Entity to setup
   * @param {THREE.Vector3} position Spawn position
   * @param {Object} enemyConfig Enemy configuration
   */
  setupEntityComponents(entity, position, enemyConfig) {
    const enemyType = ENEMY_TYPES.SPECTRAL_DRONE;
    const variations = this.generateEnemyVariations(enemyConfig, enemyType);
    this.setupTransformComponent(entity, position, enemyType, variations);
    this.setupHealthComponent(entity, enemyConfig);
    this.setupAIComponent(entity, enemyConfig, variations);
    this.setupPhysicsComponent(entity, enemyType);
  }
  /**
   * Generate enemy variations
   * @param {Object} enemyConfig Base enemy configuration
   * @param {Object} enemyType Enemy type definition
   * @returns {Object} Generated variations
   */
  generateEnemyVariations(enemyConfig, enemyType) {
    const sizeVariation = enemyType.sizeVariation.min + Math.random() * (enemyType.sizeVariation.max - enemyType.sizeVariation.min);
    const finalSize = enemyType.baseSize * sizeVariation;
    const rotationOffset = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    };
    return {
      amplitude: enemyConfig.spiralAmplitude * (enemyType.amplitudeVariation.min + Math.random() * (enemyType.amplitudeVariation.max - enemyType.amplitudeVariation.min)),
      frequency: enemyConfig.spiralFrequency * (enemyType.frequencyVariation.min + Math.random() * (enemyType.frequencyVariation.max - enemyType.frequencyVariation.min)),
      speed: enemyConfig.speed * (enemyType.speedVariation.min + Math.random() * (enemyType.speedVariation.max - enemyType.speedVariation.min)),
      size: finalSize,
      rotationOffset
    };
  }
  /**
   * Setup transform component
   */
  setupTransformComponent(entity, position, enemyType, variations) {
    let transform2 = entity.getComponent(TransformComponent);
    if (!transform2) {
      transform2 = new TransformComponent(position.clone());
      entity.addComponent(transform2);
    } else {
      transform2.position.copy(position);
    }
    transform2.scale.set(variations.size, variations.size, variations.size);
    transform2.rotation.x = variations.rotationOffset.x;
    transform2.rotation.y = variations.rotationOffset.y;
    transform2.rotation.z = variations.rotationOffset.z;
    transform2.needsUpdate = true;
  }
  /**
   * Setup health component
   */
  setupHealthComponent(entity, enemyConfig) {
    let health = entity.getComponent(HealthComponent);
    if (!health) {
      health = new HealthComponent(enemyConfig.health, 0);
      entity.addComponent(health);
    } else {
      health.maxHealth = enemyConfig.health;
      health.health = enemyConfig.health;
      health.isDestroyed = false;
    }
  }
  /**
   * Setup AI component
   */
  setupAIComponent(entity, enemyConfig, variations) {
    const enemyType = ENEMY_TYPES.SPECTRAL_DRONE;
    let enemyAI = entity.getComponent(EnemyAIComponent);
    if (!enemyAI) {
      const config = {
        faction: enemyType.faction,
        type: enemyType.type,
        health: enemyConfig.health,
        damage: enemyConfig.damage,
        speed: variations.speed,
        spiralAmplitude: variations.amplitude,
        spiralFrequency: variations.frequency,
        isDroneLike: enemyType.isDroneLike
      };
      enemyAI = new EnemyAIComponent(config);
      entity.addComponent(enemyAI);
    } else {
      enemyAI.faction = enemyType.faction;
      enemyAI.type = enemyType.type;
      enemyAI.damage = enemyConfig.damage;
      enemyAI.speed = variations.speed;
      enemyAI.spiralAmplitude = variations.amplitude;
      enemyAI.spiralFrequency = variations.frequency;
      enemyAI.isDroneLike = enemyType.isDroneLike;
      enemyAI.enabled = true;
    }
  }
  /**
   * Setup physics component
   */
  setupPhysicsComponent(entity, enemyType) {
    let rigidbody = entity.getComponent(RigidbodyComponent);
    if (!rigidbody) {
      rigidbody = new RigidbodyComponent(1);
      rigidbody.useGravity = false;
      rigidbody.drag = 0.1;
      rigidbody.shape = "sphere";
      rigidbody.collisionRadius = enemyType.collisionRadius;
      entity.addComponent(rigidbody);
    } else {
      rigidbody.isFrozen = false;
      rigidbody.velocity.set(0, 0, 0);
      rigidbody.collisionRadius = enemyType.collisionRadius;
    }
    const transform2 = entity.getComponent(TransformComponent);
    if (transform2 && rigidbody) {
      rigidbody.position = transform2.position.clone();
    }
  }
  /**
   * Register entity with combat system
   */
  registerWithCombatSystem(entity) {
    if (!entity.hasTag("enemy")) {
      console.warn(`CRITICAL ERROR: Entity ${entity.id} missing 'enemy' tag after setup!`);
      entity.addTag("enemy");
    }
    if (window.game && window.game.combat && window.game.combat.registerEnemy) {
      window.game.combat.registerEnemy(entity.id);
    }
  }
}
class MeshGeneration {
  constructor(world) {
    this.world = world;
    this.modelCache = {};
    this.currentEntity = null;
    this.loadModels();
  }
  /**
   * Pre-load all enemy models
   */
  loadModels() {
    const loader = new GLTFLoader();
    const modelPaths = ["assets/enemy.glb"];
    const tryLoadModel = (index) => {
      if (index >= modelPaths.length) {
        console.warn("Could not load enemy model from any path, will use fallback meshes");
        return;
      }
      const path = modelPaths[index];
      console.log(`Attempting to load enemy model from: ${path}`);
      loader.load(
        path,
        (gltf) => {
          console.log(`Enemy model loaded successfully from ${path}`);
          this.modelCache.enemyDrone = gltf.scene;
          this.applyGlobalModelEffects(this.modelCache.enemyDrone);
        },
        (xhr) => {
        },
        (error) => {
          console.log(`Failed to load from ${path}, trying next...`);
          tryLoadModel(index + 1);
        }
      );
    };
    tryLoadModel(0);
  }
  /**
   * Apply global transformations and material adjustments to loaded models
   * @param {THREE.Object3D} model The loaded model
   */
  applyGlobalModelEffects(model) {
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        if (child.material.emissive !== void 0) {
          child.material.emissive = new Color(35071);
          child.material.emissiveIntensity = 2;
        } else if (child.material.isMeshBasicMaterial) {
          child.material.color = new Color(43775);
        }
      }
    });
  }
  /**
   * Setup mesh component for entity
   * @param {Entity} entity Entity to setup
   */
  setupMeshComponent(entity) {
    this.currentEntity = entity;
    const mesh = this.createSpectralDroneMesh();
    this.currentEntity = null;
    this.cleanupOldMeshComponent(entity);
    let meshComponent;
    if (mesh.isGLTF) {
      meshComponent = new MeshComponent(mesh.model);
    } else {
      meshComponent = new MeshComponent(mesh.geometry, mesh.material);
    }
    entity.addComponent(meshComponent);
    meshComponent.setVisible(true);
    this.addMeshToScene(entity, meshComponent);
  }
  /**
   * Create spectral drone mesh
   * @returns {Object} Mesh object
   */
  createSpectralDroneMesh() {
    console.log("Creating spectral drone mesh...");
    if (!this.modelCache.enemyDrone) {
      return this.createFallbackMesh();
    }
    const model = this.modelCache.enemyDrone.clone();
    const visualVariant = this.currentEntity ? this.currentEntity.visualVariant || 0 : 0;
    this.applyVisualEffects(model, visualVariant);
    return { model, isGLTF: true };
  }
  /**
   * Create fallback mesh when GLB model isn't available
   * @returns {Object} Fallback mesh object
   */
  createFallbackMesh() {
    console.warn("Enemy model not loaded - creating stylized fallback enemy");
    const group = new Group();
    const bodyGeometry = new OctahedronGeometry(2, 0);
    const bodyMaterial = new MeshPhongMaterial({
      color: 65535,
      emissive: 35071,
      emissiveIntensity: 1.5,
      transparent: true,
      opacity: 0.9
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    group.add(body);
    const wingGeometry = new BoxGeometry(4, 0.2, 1);
    const wingMaterial = new MeshPhongMaterial({
      color: 8947967,
      emissive: 4474111,
      emissiveIntensity: 1
    });
    const wing1 = new Mesh(wingGeometry, wingMaterial);
    wing1.rotation.z = Math.PI / 6;
    group.add(wing1);
    const wing2 = new Mesh(wingGeometry, wingMaterial);
    wing2.rotation.z = -Math.PI / 6;
    group.add(wing2);
    group.scale.set(1.5, 1.5, 1.5);
    return group;
  }
  /**
   * Apply visual effects based on variant
   * @param {THREE.Object3D} model Model to apply effects to
   * @param {number} visualVariant Visual variant ID
   */
  applyVisualEffects(model, visualVariant) {
    const selectedColor = getRandomEnemyColor();
    const variantConfig = getVisualVariant(visualVariant);
    let emissiveIntensity = this.calculateEmissiveIntensity(variantConfig);
    let opacity = variantConfig.opacity;
    this.applyVariantColorEffects(selectedColor, variantConfig);
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        child.material = child.material.clone();
        child.material.color = new Color(selectedColor.main);
        child.material.emissive = new Color(selectedColor.emissive.r, selectedColor.emissive.g, selectedColor.emissive.b);
        child.material.emissiveIntensity = emissiveIntensity;
        if (opacity < 1) {
          child.material.transparent = true;
          child.material.opacity = opacity;
        }
        if (variantConfig.additionalEffects) {
          this.applyAdditionalEffects(child.material);
        }
      }
    });
    if (variantConfig.haloEffect) {
      this.addHaloEffect(model, selectedColor);
    }
    if (variantConfig.shieldEffect) {
      this.addShieldEffect(model);
    }
  }
  /**
   * Calculate emissive intensity based on variant
   */
  calculateEmissiveIntensity(variantConfig) {
    if (variantConfig.name === "damaged") {
      return variantConfig.emissiveIntensity.base + Math.sin(Date.now() * 0.01) * variantConfig.emissiveIntensity.flicker;
    } else if (variantConfig.name === "elite") {
      return variantConfig.emissiveIntensity.base + Math.sin(Date.now() * 3e-3) * variantConfig.emissiveIntensity.pulse;
    } else if (variantConfig.emissiveIntensity.min !== void 0) {
      return variantConfig.emissiveIntensity.min + Math.random() * (variantConfig.emissiveIntensity.max - variantConfig.emissiveIntensity.min);
    }
    return variantConfig.emissiveIntensity;
  }
  /**
   * Apply color effects based on variant
   */
  applyVariantColorEffects(selectedColor, variantConfig) {
    if (variantConfig.colorMultiplier) {
      selectedColor.emissive.r *= variantConfig.colorMultiplier;
      selectedColor.emissive.g *= variantConfig.colorMultiplier;
      selectedColor.emissive.b *= variantConfig.colorMultiplier;
    }
    if (variantConfig.shimmerEffect) {
      const shieldPhase = Date.now() * 1e-3;
      const shimmerValue = 0.8 + Math.sin(shieldPhase) * 0.2;
      selectedColor.emissive.r *= shimmerValue;
      selectedColor.emissive.g *= 1 + (1 - shimmerValue);
      selectedColor.emissive.b *= 1 + Math.cos(shieldPhase) * 0.2;
    }
  }
  /**
   * Apply additional material effects for elite enemies
   */
  applyAdditionalEffects(material) {
    if (material.shininess !== void 0) {
      material.shininess = 100;
    }
    if (material.envMapIntensity !== void 0) {
      material.envMapIntensity = 0.8;
    }
  }
  /**
   * Add halo effect for elite enemies
   */
  addHaloEffect(model, selectedColor) {
    try {
      const haloGeometry = new RingGeometry(1.2, 1.5, 16);
      const haloMaterial = new MeshBasicMaterial({
        color: selectedColor.main,
        transparent: true,
        opacity: 0.6,
        side: DoubleSide,
        blending: AdditiveBlending
      });
      const halo = new Mesh(haloGeometry, haloMaterial);
      halo.rotation.x = Math.PI / 2;
      model.add(halo);
      halo.userData.update = function(delta) {
        halo.rotation.z += delta * 0.5;
        const pulseScale = 1 + 0.2 * Math.sin(Date.now() * 2e-3);
        halo.scale.set(pulseScale, pulseScale, pulseScale);
      };
    } catch (error) {
      console.error("Failed to create elite halo effect:", error);
    }
  }
  /**
   * Add shield effect for shielded enemies
   */
  addShieldEffect(model) {
    try {
      const shieldGeometry = new SphereGeometry(1.1, 16, 12);
      const shieldMaterial = new MeshBasicMaterial({
        color: 11197951,
        transparent: true,
        opacity: 0.3,
        side: DoubleSide,
        blending: AdditiveBlending
      });
      const shield = new Mesh(shieldGeometry, shieldMaterial);
      model.add(shield);
      shield.userData.update = function(delta) {
        const pulseScale = 1 + 0.05 * Math.sin(Date.now() * 3e-3);
        shield.scale.set(pulseScale, pulseScale, pulseScale);
        shield.material.opacity = 0.2 + 0.1 * Math.sin(Date.now() * 2e-3);
      };
    } catch (error) {
      console.error("Failed to create shield effect:", error);
    }
  }
  /**
   * Clean up old mesh component
   */
  cleanupOldMeshComponent(entity) {
    let meshComponent = entity.getComponent(MeshComponent);
    if (meshComponent) {
      if (meshComponent.mesh && meshComponent.mesh.parent) {
        meshComponent.mesh.parent.remove(meshComponent.mesh);
      }
      if (meshComponent.mesh) {
        if (meshComponent.mesh.geometry) {
          meshComponent.mesh.geometry.dispose();
        }
        if (meshComponent.mesh.material) {
          if (Array.isArray(meshComponent.mesh.material)) {
            meshComponent.mesh.material.forEach((mat) => mat.dispose());
          } else {
            meshComponent.mesh.material.dispose();
          }
        }
      }
      entity.removeComponent(MeshComponent);
    }
  }
  /**
   * Add mesh to scene and sync with transform
   */
  addMeshToScene(entity, meshComponent) {
    if (this.world && this.world.scene && meshComponent.mesh) {
      if (!meshComponent.mesh.parent) {
        const prevGuard = window.__rendererGuard;
        window.__rendererGuard = true;
        try {
          this.world.scene.add(meshComponent.mesh);
        } finally {
          window.__rendererGuard = prevGuard;
        }
      }
      const transform2 = entity.getComponent("TransformComponent");
      if (transform2 && transform2.position) {
        meshComponent.mesh.position.copy(transform2.position);
        meshComponent.mesh.rotation.x = transform2.rotation.x || 0;
        meshComponent.mesh.rotation.y = transform2.rotation.y || 0;
        meshComponent.mesh.rotation.z = transform2.rotation.z || 0;
        meshComponent.mesh.scale.copy(transform2.scale);
        console.log(`Synced mesh position to (${transform2.position.x.toFixed(0)}, ${transform2.position.y.toFixed(0)}, ${transform2.position.z.toFixed(0)})`);
      }
    }
  }
}
class EnemyFactory {
  constructor(world) {
    this.world = world;
    this.spectralDroneCreator = new SpectralDroneCreator(world);
    this.meshGeneration = new MeshGeneration(world);
  }
  /**
   * Create a spectral drone entity at the given position
   * @param {THREE.Vector3} position - Spawn position
   * @param {Object} poolManager - Enemy pool manager
   * @param {Set} enemies - Active enemies tracking set
   * @param {number} maxEnemies - Maximum enemy count
   * @param {Object} enemyConfig - Current enemy configuration
   * @returns {Entity|null} The created entity or null if failed
   */
  createSpectralDrone(position, poolManager, enemies, maxEnemies, enemyConfig) {
    const entity = this.spectralDroneCreator.createSpectralDrone(position, poolManager, enemies, maxEnemies, enemyConfig);
    if (entity) {
      const visualVariant = getRandomVisualVariant();
      entity.visualVariant = visualVariant;
      this.meshGeneration.setupMeshComponent(entity);
    }
    return entity;
  }
}
class EnemySpawner {
  constructor(world) {
    this.world = world;
    this.difficultyProgression = new DifficultyProgression();
    this.formationBuilder = new FormationBuilder(world);
    this.spawnScheduler = new SpawnScheduler();
    this.enemyFactory = new EnemyFactory(world);
    this.spawnPoints = [];
    this.spawnTimer = 0;
    this.spawnInterval = 3;
    this.lastSpawnTime = Date.now();
    this.modelCache = {};
    this.baseEnemyConfig = {};
    this.enemyConfig = {};
    console.log("EnemySpawner initialized with modular architecture");
    this.logInitializationStatus();
  }
  /**
   * Log initialization status of all subsystems
   */
  logInitializationStatus() {
    console.log("Spawner subsystems: Difficulty, Formation, Scheduler (60s delay), Factory ready");
  }
  /**
   * Generate spawn points for enemies based on player position
   * Legacy method - now delegates to FormationBuilder
   */
  generateSpawnPoints() {
    this.spawnPoints = this.formationBuilder.generateSpawnPoints();
    console.log(`Generated ${this.spawnPoints.length} spawn points via FormationBuilder`);
  }
  /**
   * Get a random spawn point for enemies
   * Legacy method - now delegates to FormationBuilder
   * @returns {THREE.Vector3} Spawn position
   */
  getRandomSpawnPoint() {
    const point = this.formationBuilder.getRandomSpawnPoint();
    if (this.spawnPoints.length === 0) {
      this.spawnPoints = this.formationBuilder.spawnPoints.slice();
    }
    return point;
  }
  /**
   * Update difficulty parameters
   * Legacy method - now delegates to DifficultyProgression
   */
  updateDifficultyParameters() {
    const updated = this.difficultyProgression.updateParameters(this.world);
    if (updated) {
      const currentConfig = this.difficultyProgression.getCurrentConfig();
      this.enemyConfig = currentConfig;
      this.spawnInterval = this.difficultyProgression.getCurrentSpawnInterval();
    }
    return updated;
  }
  /**
   * Check the spawn timer and spawn enemies if needed
   * Main update method that coordinates all subsystems
   * @param {number} deltaTime - Time since last update
   * @param {Set} enemies - Reference to active enemies set
   * @param {number} maxEnemies - Maximum number of enemies allowed
   * @param {function} spawnFunction - Function to call to spawn an enemy
   * @returns {boolean} Whether an enemy was spawned
   */
  update(deltaTime, enemies, maxEnemies, spawnFunction) {
    console.log(`[ENEMY_SPAWNER] Update called with deltaTime: ${deltaTime.toFixed(3)}, enemies: ${enemies.size}/${maxEnemies}`);
    this.updateDifficultyParameters();
    const currentSpawnInterval = this.difficultyProgression.getCurrentSpawnInterval();
    console.log(`[ENEMY_SPAWNER] Calling scheduler.update with currentSpawnInterval: ${currentSpawnInterval}`);
    const shouldSpawn = this.spawnScheduler.update(
      deltaTime,
      enemies.size,
      maxEnemies,
      currentSpawnInterval
    );
    console.log(`[ENEMY_SPAWNER] Scheduler returned shouldSpawn: ${shouldSpawn}`);
    this.spawnTimer = this.spawnScheduler.spawnTimer;
    this.spawnInterval = currentSpawnInterval;
    if (shouldSpawn) {
      const spawnPoint = this.getRandomSpawnPoint();
      if (!spawnPoint) {
        console.error("Failed to get spawn point! Regenerating formation.");
        this.formationBuilder.generateSpawnPoints(true);
        this.spawnScheduler.recordSpawn(false);
        return false;
      }
      const result = spawnFunction(spawnPoint);
      this.spawnScheduler.recordSpawn(result);
      if (result) {
        this.lastSpawnTime = Date.now();
        return true;
      }
    }
    return false;
  }
  /**
   * Spawn a spectral drone at the given position
   * Main spawning method that delegates to EnemyFactory
   * @param {THREE.Vector3} position - Position to spawn at
   * @param {Object} poolManager - Enemy pool manager
   * @param {Set} enemies - Reference to active enemies set
   * @param {number} maxEnemies - Maximum number of enemies allowed
   * @returns {Entity} The created entity
   */
  spawnSpectralDrone(position, poolManager, enemies, maxEnemies) {
    console.log("Spawning spectral drone via EnemyFactory...");
    const enemyConfig = this.difficultyProgression.getCurrentConfig();
    const entity = this.enemyFactory.createSpectralDrone(
      position,
      poolManager,
      enemies,
      maxEnemies,
      enemyConfig
    );
    if (entity) {
      console.log(`Spectral drone spawned at (${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}). Count: ${enemies.size}/${maxEnemies}`);
    }
    return entity;
  }
  /**
   * Set formation pattern for spawn points
   * @param {string} patternName - Formation pattern name
   */
  setFormationPattern(patternName) {
    this.formationBuilder.setFormationPattern(patternName, true);
    this.spawnPoints = this.formationBuilder.spawnPoints.slice();
  }
  /**
   * Skip the initial spawn delay (for testing or special events)
   */
  skipInitialDelay() {
    console.log("[ENEMY_SPAWNER] Skipping initial spawn delay");
    this.spawnScheduler.skipInitialDelay();
  }
  /**
   * Pause or resume spawning
   * @param {boolean} paused - Whether to pause spawning
   */
  setSpawningPaused(paused) {
    if (paused) {
      this.spawnScheduler.pauseSpawning();
    } else {
      this.spawnScheduler.resumeSpawning();
    }
  }
  /**
   * Reset all spawner subsystems to initial state
   */
  reset() {
    this.difficultyProgression.reset();
    this.formationBuilder.clearSpawnPoints();
    this.spawnScheduler.reset();
    this.spawnPoints = [];
    this.spawnTimer = 0;
    this.spawnInterval = 3;
    this.lastSpawnTime = Date.now();
    console.log("EnemySpawner reset to initial state");
  }
  /**
   * Get comprehensive statistics from all subsystems
   * @returns {Object} Combined statistics
   */
  getStatistics() {
    return {
      scheduler: this.spawnScheduler.getStatistics(),
      difficulty: this.difficultyProgression.getStats(),
      formation: this.formationBuilder.getSpawnPointStats(),
      factory: {
        modelCacheLoaded: !!this.enemyFactory.modelCache.enemyDrone
      }
    };
  }
  /**
   * Get current enemy configuration
   * @returns {Object} Current enemy configuration
   */
  getCurrentEnemyConfig() {
    return this.difficultyProgression.getCurrentConfig();
  }
  /**
   * Check if initial spawn delay has passed
   * @returns {boolean} Whether spawning can begin
   */
  canSpawn() {
    return this.spawnScheduler.isInitialDelayComplete();
  }
  /**
   * Get time remaining until spawning can begin
   * @returns {number} Remaining delay time in seconds
   */
  getRemainingDelay() {
    return this.spawnScheduler.getRemainingInitialDelay();
  }
}
class EnemyLifecycle {
  constructor(world) {
    this.world = world;
  }
  /**
   * Validate enemy references to ensure all tracked enemies exist
   * This helps prevent "ghost" references that block new spawns
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  validateEnemyReferences(enemies) {
    const originalSize = enemies.size;
    const validEnemies = /* @__PURE__ */ new Set();
    for (const enemyId of enemies) {
      const entity = this.world.getEntity(enemyId);
      if (entity && entity.hasTag && entity.hasTag("enemy") && !entity.hasTag("pooled")) {
        validEnemies.add(enemyId);
      } else {
        if (!entity) {
          console.warn(`Removing invalid enemy reference: ${enemyId} - Entity does not exist`);
        } else if (!entity.hasTag) {
          console.warn(`Removing invalid enemy reference: ${enemyId} - Entity missing hasTag method`);
        } else if (!entity.hasTag("enemy")) {
          if (entity.tags && entity.tags.has && entity.tags.has("enemy")) {
            console.warn(`Entity ${enemyId} has inconsistent tag state: hasTag('enemy')=false but tag exists in Set`);
            if (entity._syncTagCache && typeof entity._syncTagCache === "function") {
              entity._syncTagCache();
              console.log(`Fixed tag cache for entity ${enemyId}`);
              if (entity.hasTag("enemy")) {
                console.log(`Entity ${enemyId} now properly recognizes 'enemy' tag, keeping in tracking`);
                validEnemies.add(enemyId);
                continue;
              }
            }
          }
          console.warn(`Removing invalid enemy reference: ${enemyId} - Entity missing 'enemy' tag. Tags: [${Array.from(entity.tags)}]`);
        } else if (entity.hasTag("pooled")) {
          console.warn(`Removing invalid enemy reference: ${enemyId} - Entity is pooled but still has 'enemy' tag`);
          if (entity.hasTag("enemy")) {
            console.log(`Fixing inconsistent tag state: entity ${enemyId} is pooled but still has 'enemy' tag`);
            entity.removeTag("enemy");
          }
        }
      }
    }
    enemies.clear();
    for (const id of validEnemies) {
      enemies.add(id);
    }
    let entitiesScanned = 0;
    try {
      if (this.world && this.world.entityManager) {
        let enemyEntities = [];
        if (this.world.entityManager.entitiesByTag && this.world.entityManager.entitiesByTag.get) {
          enemyEntities = this.world.entityManager.entitiesByTag.get("enemy") || [];
          entitiesScanned = enemyEntities.length;
          for (const enemy of enemyEntities) {
            if (!enemy) continue;
            if (enemy._syncTagCache && typeof enemy._syncTagCache === "function") {
              enemy._syncTagCache();
            }
            if (!enemy.hasTag("pooled")) {
              if (!enemies.has(enemy.id)) {
                console.log(`Found untracked enemy: ${enemy.id}, adding to tracking. Tags: [${[...enemy.tags]}]`);
                enemies.add(enemy.id);
              }
            } else {
              if (enemies.has(enemy.id)) {
                console.log(`Removing pooled enemy from tracking: ${enemy.id}`);
                enemies.delete(enemy.id);
              }
              if (enemy.hasTag("enemy")) {
                console.log(`Fixing inconsistent tag state: pooled entity ${enemy.id} still has 'enemy' tag`);
                enemy.removeTag("enemy");
              }
            }
          }
          this.validateEntityManagerTagMaps(enemies);
        }
      }
    } catch (error) {
      console.error("Error during entity scan:", error);
    }
    if (originalSize !== enemies.size) {
      console.log(`Enemy tracking corrected: ${originalSize} -> ${enemies.size} enemies tracked. Scanned ${entitiesScanned} entities.`);
    }
  }
  /**
   * Additional method to validate and fix EntityManager tag maps
   * This helps ensure entity tags are consistent with the EntityManager's tracking
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  validateEntityManagerTagMaps(enemies) {
    if (!this.world || !this.world.entityManager || !this.world.entityManager.entitiesByTag) {
      return;
    }
    try {
      const entitiesByTag = this.world.entityManager.entitiesByTag;
      if (entitiesByTag.has("enemy")) {
        const enemyMap = entitiesByTag.get("enemy");
        const invalidEntities = [];
        for (let i = 0; i < enemyMap.length; i++) {
          const entity = enemyMap[i];
          if (!entity) {
            invalidEntities.push(i);
            continue;
          }
          if (!entity.tags || !entity.tags.has("enemy")) {
            console.warn(`Entity ${entity.id} is in 'enemy' tag map but doesn't have the tag in its Set`);
            if (entity.addTag) {
              entity.addTag("enemy");
              console.log(`Added missing 'enemy' tag to entity ${entity.id}`);
            } else {
              invalidEntities.push(i);
            }
          }
          if (entity.hasTag && entity.hasTag("pooled") && entity.hasTag("enemy")) {
            console.warn(`Entity ${entity.id} has both 'pooled' and 'enemy' tags - removing 'enemy' tag`);
            entity.removeTag("enemy");
            invalidEntities.push(i);
          }
        }
        for (let i = invalidEntities.length - 1; i >= 0; i--) {
          const index = invalidEntities[i];
          enemyMap.splice(index, 1);
        }
        if (invalidEntities.length > 0) {
          console.log(`Fixed ${invalidEntities.length} inconsistencies in EntityManager 'enemy' tag map`);
        }
      }
    } catch (error) {
      console.error("Error validating EntityManager tag maps:", error);
    }
  }
  /**
   * Freeze all enemy entities in place
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  freezeAllEnemies(enemies) {
    const activeEnemies = Array.from(enemies).filter((enemyId) => {
      const enemy = this.world.getEntity(enemyId);
      return enemy && !enemy.hasTag("pooled");
    });
    console.log(`Freezing all ${activeEnemies.length} active enemies...`);
    for (const enemyId of activeEnemies) {
      const enemy = this.world.getEntity(enemyId);
      if (!enemy) {
        console.warn(`Enemy ${enemyId} not found when freezing - may have been destroyed`);
        continue;
      }
      const rigidbody = enemy.getComponent(RigidbodyComponent);
      if (rigidbody) {
        rigidbody.velocity.set(0, 0, 0);
        if (rigidbody.angularVelocity) {
          rigidbody.angularVelocity.set(0, 0, 0);
        }
        rigidbody.isFrozen = true;
      }
      const enemyAI = enemy.getComponent(EnemyAIComponent);
      if (enemyAI) {
        if (enemyAI.originalEnabledState === void 0) {
          enemyAI.originalEnabledState = enemyAI.enabled;
        }
        enemyAI.enabled = false;
      }
      enemy.addTag("frozen");
    }
    console.log("All enemies frozen successfully");
  }
  /**
   * Unfreeze all enemy entities and re-enable their AI
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  unfreezeAllEnemies(enemies) {
    const activeEnemies = Array.from(enemies).filter((enemyId) => {
      const enemy = this.world.getEntity(enemyId);
      return enemy && !enemy.hasTag("pooled");
    });
    console.log(`Unfreezing all ${activeEnemies.length} active enemies...`);
    for (const enemyId of activeEnemies) {
      const enemy = this.world.getEntity(enemyId);
      if (!enemy) {
        console.warn(`Enemy ${enemyId} not found when unfreezing - may have been destroyed`);
        continue;
      }
      const rigidbody = enemy.getComponent(RigidbodyComponent);
      if (rigidbody) {
        rigidbody.isFrozen = false;
      }
      const enemyAI = enemy.getComponent(EnemyAIComponent);
      if (enemyAI) {
        enemyAI.enabled = enemyAI.originalEnabledState !== void 0 ? enemyAI.originalEnabledState : true;
      }
      if (enemy.hasTag && enemy.hasTag("frozen")) {
        enemy.removeTag("frozen");
      }
    }
    console.log("All enemies unfrozen successfully");
  }
  /**
   * Force destroy excess enemies to enforce the enemy limit
   * @param {Set} enemies Reference to the active enemies set for tracking
   * @param {number} maxEnemies Maximum number of enemies allowed
   * @param {Function} returnEnemyToPool Function to return an enemy to the pool
   */
  enforceEnemyLimit(enemies, maxEnemies, returnEnemyToPool) {
    const enemyIds = [...enemies];
    const excessCount = enemies.size - maxEnemies;
    if (excessCount <= 0) return;
    console.log(`Enforcing enemy limit by removing ${excessCount} excess enemies`);
    for (let i = 0; i < excessCount && i < enemyIds.length; i++) {
      const entityId = enemyIds[i];
      const entity = this.world.getEntity(entityId);
      if (entity) {
        console.log(`Force destroying excess enemy ${entityId}`);
        enemies.delete(entityId);
        const health = entity.getComponent(HealthComponent);
        if (health) {
          health.health = 0;
          health.isDestroyed = true;
        }
        if (this.world && this.world.messageBus) {
          const transform2 = entity.getComponent(TransformComponent);
          if (transform2) {
            this.world.messageBus.publish("vfx.explosion", {
              position: transform2.position.clone(),
              scale: 1,
              duration: 1
            });
          }
        }
        returnEnemyToPool(entity);
      } else {
        enemies.delete(entityId);
      }
    }
    this.validateEnemyReferences(enemies);
  }
  /**
   * Clear all tracking Set
   * @param {Set} enemies Reference to the active enemies set for tracking
   */
  clearAllEnemies(enemies) {
    console.log(`Clearing all enemies. Current count: ${enemies.size}`);
    enemies.clear();
    console.log(`After clearing, enemy count: ${enemies.size}`);
  }
  /**
   * Process a single enemy entity's update
   * @param {Entity} entity Entity to process
   * @param {number} deltaTime Time since last update in seconds
   */
  processEntityUpdate(entity, deltaTime) {
    const enemyAI = entity.getComponent(EnemyAIComponent);
    if (!enemyAI) return;
    const transform2 = entity.getComponent(TransformComponent);
    if (!transform2) return;
    const meshComponent = entity.getComponent(MeshComponent);
    if (meshComponent && meshComponent.mesh) {
      meshComponent.mesh.visible = true;
      if (!meshComponent.mesh.parent && this.world.scene) {
        console.log(`Adding enemy mesh to scene`);
        this.world.scene.add(meshComponent.mesh);
        if (meshComponent.onAddedToScene) {
          meshComponent.onAddedToScene(this.world.scene);
        }
      }
      meshComponent.mesh.position.copy(transform2.position);
      meshComponent.mesh.quaternion.copy(transform2.quaternion);
      meshComponent.mesh.scale.copy(transform2.scale);
      if (entity.visualVariant === 2 || entity.visualVariant === 3) {
        meshComponent.mesh.traverse((child) => {
          if (child.userData && typeof child.userData.update === "function") {
            child.userData.update(deltaTime);
          }
        });
        if (entity.visualVariant === 2 && entity.eliteParticleTime === void 0) {
          entity.eliteParticleTime = 0;
        } else if (entity.visualVariant === 2) {
          entity.eliteParticleTime += deltaTime;
          if (entity.eliteParticleTime > 1.5) {
            entity.eliteParticleTime = 0;
            if (this.world && this.world.messageBus) {
              this.world.messageBus.publish("vfx.pulse", {
                position: transform2.position.clone(),
                color: 11206655,
                scale: 0.7,
                duration: 0.8
              });
            }
          }
        }
      }
      if (entity.visualVariant === 1 && meshComponent.mesh.material) {
        if (Array.isArray(meshComponent.mesh.material)) {
          for (const material of meshComponent.mesh.material) {
            material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
          }
        } else if (meshComponent.mesh.material.emissiveIntensity !== void 0) {
          meshComponent.mesh.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
        }
      }
    }
    enemyAI.update(deltaTime);
    const health = entity.getComponent(HealthComponent);
    if (health) {
      health.update(deltaTime);
    }
  }
}
class SeparationBehavior {
  constructor() {
    this.SEPARATION_FORCE_MAGNITUDE = 150;
    this.separationThresholdMultiplier = 2.5;
  }
  /**
   * Apply separation behavior to avoid overlapping with other enemies
   * @param {Entity} entity The entity to apply separation to
   * @param {number} deltaTime Time since last update in seconds
   * @param {Set} enemies Set of all enemy entities
   * @param {World} world Game world instance
   */
  applySeparationBehavior(entity, deltaTime, enemies, world) {
    const transform2 = entity.getComponent(TransformComponent);
    const rigidbody = entity.getComponent(RigidbodyComponent);
    const enemyAI = entity.getComponent(EnemyAIComponent);
    if (!transform2 || !rigidbody || !enemyAI || rigidbody.isFrozen) {
      return;
    }
    const separationForce = this.calculateSeparationForce(entity, transform2, rigidbody, enemies, world);
    if (separationForce.lengthSq() > 0.01) {
      enemyAI.setSeparationForce(separationForce);
      rigidbody.applyForce(separationForce);
    } else {
      enemyAI.setSeparationForce(new Vector3());
    }
  }
  /**
   * Calculate separation force to avoid nearby enemies
   * @param {Entity} entity The current entity
   * @param {TransformComponent} transform The entity's transform
   * @param {RigidbodyComponent} rigidbody The entity's rigidbody
   * @param {Set} enemies Set of all enemy entities
   * @param {World} world Game world instance
   * @returns {THREE.Vector3} The calculated separation force
   */
  calculateSeparationForce(entity, transform2, rigidbody, enemies, world) {
    const separationForce = new Vector3();
    const separationThreshold = rigidbody.collisionRadius * this.separationThresholdMultiplier;
    const nearbyEnemies = this.findNearbyEnemies(entity, transform2.position, separationThreshold, enemies, world);
    for (const neighborId of nearbyEnemies) {
      if (neighborId === entity.id) continue;
      const neighbor = world.getEntity(neighborId);
      if (!neighbor) continue;
      const neighborTransform = neighbor.getComponent(TransformComponent);
      if (!neighborTransform) continue;
      const awayVector = transform2.position.clone().sub(neighborTransform.position);
      const distance = awayVector.length();
      if (distance >= separationThreshold || distance === 0) continue;
      let strength = (separationThreshold - distance) / separationThreshold;
      awayVector.normalize();
      separationForce.add(awayVector.multiplyScalar(strength * this.SEPARATION_FORCE_MAGNITUDE));
    }
    return separationForce;
  }
  /**
   * Find nearby enemy entities within a certain radius
   * @param {Entity} entity The entity to find neighbors for
   * @param {THREE.Vector3} position The position to check from
   * @param {number} radius The radius to check within
   * @param {Set} enemies Set of all enemy entities
   * @param {World} world Game world instance
   * @returns {Set} Set of nearby enemy entity IDs
   */
  findNearbyEnemies(entity, position, radius, enemies, world) {
    const nearbyEnemies = /* @__PURE__ */ new Set();
    for (const enemyId of enemies) {
      if (enemyId === entity.id) continue;
      const enemyEntity = world.getEntity(enemyId);
      if (!enemyEntity || enemyEntity.hasTag("pooled")) continue;
      const enemyTransform = enemyEntity.getComponent(TransformComponent);
      if (!enemyTransform) continue;
      const distance = position.distanceTo(enemyTransform.position);
      if (distance < radius) {
        nearbyEnemies.add(enemyId);
      }
    }
    return nearbyEnemies;
  }
}
class DifficultyScaling {
  constructor() {
    this.lastLoggedHordeTime = 0;
    this.lastFullLoggedHordeTime = 0;
  }
  /**
   * Update enemy parameters based on difficulty scaling from game object
   * @param {Object} enemySystem Enemy system instance
   */
  updateDifficultyScaling(enemySystem) {
    if (window.game && window.game.isHordeActive) {
      this.applyHordeModeScaling(enemySystem);
      return;
    }
    if (window.game && window.game.difficultyManager && window.game.difficultyManager.params) {
      const diffParams = window.game.difficultyManager.params;
      if (diffParams.maxEnemies !== void 0 && enemySystem.maxEnemies !== diffParams.maxEnemies) {
        console.log(`Updating max enemies from ${enemySystem.maxEnemies} to ${diffParams.maxEnemies}`);
        enemySystem.maxEnemies = diffParams.maxEnemies;
      }
      if (diffParams.spawnInterval !== void 0 && enemySystem.spawnInterval !== diffParams.spawnInterval) {
        console.log(`Updating spawn interval from ${enemySystem.spawnInterval} to ${diffParams.spawnInterval}`);
        enemySystem.spawnInterval = diffParams.spawnInterval;
      }
    }
  }
  /**
   * Apply horde mode scaling based on survival time
   * @param {Object} enemySystem Enemy system instance
   */
  applyHordeModeScaling(enemySystem) {
    if (!window.game || window.game.hordeSurvivalTime === void 0) return;
    const survivalTime = window.game.hordeSurvivalTime / 1e3;
    if (Math.floor(survivalTime) % 10 === 0 && Math.floor(survivalTime) !== this.lastLoggedHordeTime) {
      this.lastLoggedHordeTime = Math.floor(survivalTime);
      console.log(`HORDE MODE: Scaling at ${survivalTime.toFixed(1)}s survival time`);
    }
    const minutesPassed = survivalTime / 60;
    const baseMaxEnemies = 50;
    let maxEnemiesScale;
    if (minutesPassed < 5) {
      maxEnemiesScale = baseMaxEnemies + minutesPassed * 10;
    } else {
      maxEnemiesScale = (baseMaxEnemies + 50) * Math.pow(1.2, minutesPassed - 5);
    }
    enemySystem.maxEnemies = Math.min(Math.floor(maxEnemiesScale), 300);
    const maxSpawnInterval = 6;
    const baseSpawnInterval = 1;
    enemySystem.spawnInterval = Math.min(
      baseSpawnInterval * Math.pow(1.05, minutesPassed * 2),
      maxSpawnInterval
    );
    if (enemySystem.spawner) {
      const baseHealth = 20;
      const baseDamage = 15;
      const baseSpeed = 700;
      const healthMultiplier = 1 + minutesPassed * 0.5;
      const damageMultiplier = 1 + minutesPassed * 0.3;
      const speedMultiplier = 1 + minutesPassed * 0.2;
      enemySystem.spawner.enemyConfig.health = Math.floor(baseHealth * healthMultiplier);
      enemySystem.spawner.enemyConfig.damage = Math.floor(baseDamage * damageMultiplier);
      enemySystem.spawner.enemyConfig.speed = baseSpeed * speedMultiplier;
      if (Math.floor(survivalTime) % 30 === 0 && Math.floor(survivalTime) !== this.lastFullLoggedHordeTime) {
        this.lastFullLoggedHordeTime = Math.floor(survivalTime);
        console.log(`HORDE MODE SCALING at ${Math.floor(survivalTime)}s:`);
        console.log(`  Max Enemies: ${enemySystem.maxEnemies}`);
        console.log(`  Spawn Interval: ${enemySystem.spawnInterval.toFixed(2)}s`);
        console.log(`  Enemy Health: ${enemySystem.spawner.enemyConfig.health}`);
        console.log(`  Enemy Damage: ${enemySystem.spawner.enemyConfig.damage}`);
        console.log(`  Enemy Speed: ${enemySystem.spawner.enemyConfig.speed.toFixed(1)}`);
      }
    }
  }
}
class DockingManager {
  constructor() {
    this.playerIsDocked = false;
  }
  /**
   * Set up event listeners for player docking/undocking events
   * @param {World} world Game world instance
   * @param {Function} onDocked Callback for when player docks
   * @param {Function} onUndocked Callback for when player undocks
   */
  setupEventListeners(world, onDocked, onUndocked) {
    world.messageBus.subscribe("player.docked", (message) => {
      this.handlePlayerDocked(message, onDocked);
    });
    world.messageBus.subscribe("player.undocked", (message) => {
      this.handlePlayerUndocked(message, onUndocked);
    });
    console.log("Enemy system: Event listeners set up for player docking/undocking");
  }
  /**
   * Handle player docked event
   * @param {object} message Event message
   * @param {Function} onDocked Callback for when player docks
   */
  handlePlayerDocked(message, onDocked) {
    console.log("Enemy system detected player docked - freezing enemies");
    this.playerIsDocked = true;
    onDocked();
  }
  /**
   * Handle player undocked event
   * @param {object} message Event message
   * @param {Function} onUndocked Callback for when player undocks
   */
  handlePlayerUndocked(message, onUndocked) {
    console.log("Enemy system detected player undocked - resuming enemy activities");
    this.playerIsDocked = false;
    onUndocked();
  }
  /**
   * Check and sync global docking state
   * @param {Function} onDocked Callback for when player docks
   * @param {Function} onUndocked Callback for when player undocks
   */
  syncGlobalDockingState(onDocked, onUndocked) {
    if (window.game && window.game.spaceship && window.game.spaceship.isDocked !== void 0) {
      if (this.playerIsDocked !== window.game.spaceship.isDocked) {
        console.log(`Enemy system syncing docked state from global: ${window.game.spaceship.isDocked}`);
        this.playerIsDocked = window.game.spaceship.isDocked;
        if (this.playerIsDocked) {
          onDocked();
        } else {
          onUndocked();
        }
      }
    }
  }
  /**
   * Check if player is currently docked
   * @returns {boolean} True if player is docked
   */
  isPlayerDocked() {
    return this.playerIsDocked;
  }
}
class SpawnMonitoring {
  constructor() {
    this.spawnMonitorInterval = null;
    this.lastSpawnTime = Date.now();
  }
  /**
   * Start monitoring the spawn system health
   * @param {Object} enemySystem Enemy system instance
   */
  startSpawnMonitoring(enemySystem) {
    this.spawnMonitorInterval = setInterval(() => {
      this.checkSpawnSystemHealth(enemySystem);
    }, 1e4);
    console.log("Spawn system monitoring started");
  }
  /**
   * Stop spawn monitoring
   */
  stopSpawnMonitoring() {
    if (this.spawnMonitorInterval) {
      clearInterval(this.spawnMonitorInterval);
      this.spawnMonitorInterval = null;
      console.log("Spawn monitoring stopped");
    }
  }
  /**
   * Check the health of the spawn system
   * @param {Object} enemySystem Enemy system instance
   */
  checkSpawnSystemHealth(enemySystem) {
    const now = Date.now();
    const timeSinceLastSpawn = (now - this.lastSpawnTime) / 1e3;
    console.log(`Spawn system health check: ${enemySystem.enemies.size}/${enemySystem.maxEnemies} enemies, ${timeSinceLastSpawn.toFixed(1)}s since last spawn`);
    if (timeSinceLastSpawn > enemySystem.spawnInterval * 3 && enemySystem.enemies.size < enemySystem.maxEnemies) {
      console.warn("Spawn system appears stuck! Performing recovery...");
      enemySystem.enemies.clear();
      enemySystem.spawner.generateSpawnPoints();
      enemySystem.spawnTimer = enemySystem.spawnInterval;
      enemySystem.lifecycle.validateEnemyReferences(enemySystem.enemies);
      console.log("Spawn system recovery completed");
    }
  }
  /**
   * Update last spawn time
   */
  updateLastSpawnTime() {
    this.lastSpawnTime = Date.now();
  }
  /**
   * Perform failsafe checks and recovery
   * @param {Object} enemySystem Enemy system instance
   */
  performFailsafeCheck(enemySystem) {
    if (enemySystem.enemies.size === 0 && enemySystem.spawnTimer > enemySystem.spawnInterval * 2) {
      console.warn("FAILSAFE: No enemies detected for extended period. Resetting spawn system.");
      enemySystem.enemies.clear();
      enemySystem.spawner.generateSpawnPoints();
      enemySystem.spawnTimer = enemySystem.spawnInterval;
    }
  }
}
class EnemySystem extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = ["EnemyAIComponent", "TransformComponent"];
    this.priority = 40;
    this.enemies = /* @__PURE__ */ new Set();
    this.maxEnemies = 10;
    this.spawnTimer = 0;
    this.spawnInterval = 3;
    this.lastSpawnTime = Date.now();
    this.poolManager = new EnemyPoolManager(world);
    this.spawner = new EnemySpawner(world);
    this.lifecycle = new EnemyLifecycle(world);
    this.separationBehavior = new SeparationBehavior();
    this.difficultyScaling = new DifficultyScaling();
    this.dockingManager = new DockingManager();
    this.spawnMonitoring = new SpawnMonitoring();
    this.enemiesDestroyed = 0;
    this.setupEventListeners();
    this.lifecycle.clearAllEnemies(this.enemies);
    this.lifecycle.validateEnemyReferences(this.enemies);
    this.spawnMonitoring.startSpawnMonitoring(this);
    if (typeof window !== "undefined") {
      window.skipEnemyDelay = () => {
        this.spawner.skipInitialDelay();
      };
    }
  }
  /**
   * Set up event listeners for enemy-related events
   */
  setupEventListeners() {
    this.world.messageBus.subscribe("entity.destroyed", this.handleEntityDestroyed.bind(this));
    this.dockingManager.setupEventListeners(
      this.world,
      () => this.lifecycle.freezeAllEnemies(this.enemies),
      () => this.lifecycle.unfreezeAllEnemies(this.enemies)
    );
  }
  /**
   * Update all enemy entities
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    this.dockingManager.syncGlobalDockingState(
      () => this.lifecycle.freezeAllEnemies(this.enemies),
      () => this.lifecycle.unfreezeAllEnemies(this.enemies)
    );
    if (this.dockingManager.isPlayerDocked()) {
      return;
    }
    const introActive = window.game && window.game.introSequenceActive;
    if (introActive) {
      return;
    }
    super.update(deltaTime);
    if (!this._lastDiagnosticTime) {
      this._lastDiagnosticTime = 0;
    }
    this._lastDiagnosticTime += deltaTime;
    if (this._lastDiagnosticTime >= 3) {
      this.poolManager.runPoolDiagnostics(this.enemies);
      this._lastDiagnosticTime = 0;
    }
    this.lifecycle.validateEnemyReferences(this.enemies);
    this.difficultyScaling.updateDifficultyScaling(this);
    if (this.enemies.size > this.maxEnemies) {
      this.lifecycle.enforceEnemyLimit(
        this.enemies,
        this.maxEnemies,
        (entity) => this.poolManager.returnEnemyToPool(entity, this.enemies)
      );
    }
    this.spawner.update(deltaTime, this.enemies, this.maxEnemies, (spawnPoint) => {
      return this.spawnSpectralDrone(spawnPoint);
    });
    this.spawnMonitoring.performFailsafeCheck(this);
  }
  /**
   * Process a single enemy entity
   * @param {Entity} entity Entity to process
   * @param {number} deltaTime Time since last update in seconds
   */
  processEntity(entity, deltaTime) {
    this.lifecycle.processEntityUpdate(entity, deltaTime);
    this.separationBehavior.applySeparationBehavior(entity, deltaTime, this.enemies, this.world);
  }
  /**
   * Handle entity destroyed event
   * @param {object} message Event message
   */
  handleEntityDestroyed(message) {
    const entity = message.entity;
    if (!entity) {
      return;
    }
    const entityId = entity.id;
    const isTrackedEnemy = this.enemies.has(entityId);
    if (entity.hasTag && entity.hasTag("enemy") || isTrackedEnemy) {
      if (isTrackedEnemy) {
        this.enemies.delete(entityId);
      }
      const trailComponent = entity.getComponent(TrailComponent);
      if (trailComponent) {
        try {
          if (typeof trailComponent.onDetached === "function") {
            trailComponent.onDetached();
          }
          if (window.game && window.game.trailSystem) {
            window.game.trailSystem.unregisterTrail && window.game.trailSystem.unregisterTrail(entityId);
          }
          if (trailComponent.trailMesh && trailComponent.trailMesh.parent) {
            trailComponent.trailMesh.parent.remove(trailComponent.trailMesh);
          }
          if (trailComponent.trailMesh) {
            if (trailComponent.trailMesh.geometry) {
              trailComponent.trailMesh.geometry.dispose();
            }
            if (trailComponent.trailMesh.material) {
              trailComponent.trailMesh.material.dispose();
            }
          }
          entity.removeComponent("TrailComponent");
        } catch (error) {
        }
      }
      const meshComponent = entity.getComponent(MeshComponent);
      if (meshComponent && meshComponent.mesh) {
        try {
          if (meshComponent.mesh.parent) {
            meshComponent.mesh.parent.remove(meshComponent.mesh);
          }
        } catch (error) {
        }
      }
      this.enemiesDestroyed++;
      if (entity.hasTag && entity.hasTag("enemy")) {
        entity.removeTag("enemy");
      }
      let isInPool = false;
      for (let i = 0; i < this.poolManager.enemyPool.length; i++) {
        if (this.poolManager.enemyPool[i] && this.poolManager.enemyPool[i].id === entityId) {
          this.poolManager.enemyPool.splice(i, 1);
          isInPool = true;
          break;
        }
      }
      if (!isInPool) {
        this.poolManager.returnEnemyToPool(entity, this.enemies);
      }
      if (this.enemiesDestroyed % 5 === 0) {
        this.spawner.generateSpawnPoints();
      }
      if (this.enemies.size === 0) {
        this.spawnTimer = Math.max(this.spawnTimer, this.spawnInterval * 0.8);
        this.spawnMonitoring.updateLastSpawnTime();
      }
      this.lifecycle.validateEnemyReferences(this.enemies);
    }
  }
  /**
   * Called when the system is disabled
   */
  onDisabled() {
    this.spawnMonitoring.stopSpawnMonitoring();
    this.enemies.clear();
  }
  /**
   * Spawns a spectral drone at the given position - convenience method
   * @param {THREE.Vector3} position The position to spawn at
   * @returns {Entity} The created entity
   */
  spawnSpectralDrone(position) {
    return this.spawner.spawnSpectralDrone(position, this.poolManager, this.enemies, this.maxEnemies);
  }
  /**
   * Freeze all enemy entities in place - wrapper for lifecycle method
   */
  freezeAllEnemies() {
    this.lifecycle.freezeAllEnemies(this.enemies);
  }
  /**
   * Unfreeze all enemy entities and re-enable their AI - wrapper for lifecycle method
   */
  unfreezeAllEnemies() {
    this.lifecycle.unfreezeAllEnemies(this.enemies);
  }
}
class RenderSystem extends System {
  constructor(world, scene, camera, renderer) {
    super(world);
    this.requiredComponents = ["TransformComponent", "MeshComponent"];
    this.priority = 100;
    this.scene = scene;
    this.camera = camera;
    this.renderer = null;
    this.meshEntities = /* @__PURE__ */ new Map();
    this.frustum = new Frustum();
    this.projScreenMatrix = new Matrix4();
    this.world.messageBus.subscribe("entity.created", this.onEntityCreated.bind(this));
    this.world.messageBus.subscribe("entity.destroyed", this.onEntityDestroyed.bind(this));
    this.world.messageBus.subscribe("component.added", this.onComponentAdded.bind(this));
    console.log("RenderSystem initialized - handling mesh updates only, no rendering");
  }
  /**
   * Handle component added event
   * @param {object} message Event message
   */
  onComponentAdded(message) {
    const entity = message.data.entity;
    const componentType = message.data.componentType;
    if (componentType !== "MeshComponent" && componentType !== "TransformComponent") {
      return;
    }
    if (this.meshEntities.has(entity.id)) {
      return;
    }
    console.log(`RenderSystem: Component ${componentType} added to entity ${entity.id}`);
    if (entity.getComponent("TransformComponent") && entity.getComponent("MeshComponent")) {
      console.log(`Entity ${entity.id} now has all required components, adding to scene`);
      this.addEntityToScene(entity);
    }
  }
  /**
   * Initialize the rendering system
   */
  initialize() {
    if (!this.scene || !this.camera) {
      console.error("RenderSystem missing required Three.js scene or camera references");
      return;
    }
    const entities = this.world.getEntitiesWithComponents(["TransformComponent", "MeshComponent"]);
    entities.forEach((entity) => {
      this.addEntityToScene(entity);
    });
  }
  /**
   * Handle entity created event
   * @param {object} message Event message
   */
  onEntityCreated(message) {
    const entity = message.data.entity;
    console.log(`RenderSystem received entity.created event for entity ${entity.id}`);
    console.log(`Entity ${entity.id} components:`, Array.from(entity.components.keys()).join(", "));
    const transform2 = entity.getComponent("TransformComponent");
    const mesh = entity.getComponent("MeshComponent");
    if (transform2 && mesh) {
      console.log(`Entity ${entity.id} has required components, adding to scene`);
      this.addEntityToScene(entity);
    } else {
      console.log(`Entity ${entity.id} missing required components (has transform: ${!!transform2}, has mesh: ${!!mesh}), will check later`);
      const checkComponentsAdded = (msg) => {
        var _a;
        if (((_a = msg.data.entity) == null ? void 0 : _a.id) !== entity.id) return;
        console.log(`Entity ${entity.id} got component ${msg.data.componentType}`);
        const transform3 = entity.getComponent("TransformComponent");
        const mesh2 = entity.getComponent("MeshComponent");
        if (transform3 && mesh2) {
          console.log(`Entity ${entity.id} now has required components, adding to scene`);
          this.addEntityToScene(entity);
          this.world.messageBus.unsubscribe("component.added", checkComponentsAdded);
        }
      };
      this.world.messageBus.subscribe("component.added", checkComponentsAdded);
    }
  }
  /**
   * Handle entity destroyed event
   * @param {object} message Event message
   */
  onEntityDestroyed(message) {
    const entity = message.data.entity;
    if (this.meshEntities.has(entity.id)) {
      this.removeEntityFromScene(entity);
    }
  }
  /**
   * Add entity mesh to scene
   * @param {Entity} entity Entity to add
   */
  addEntityToScene(entity) {
    const meshComponent = entity.getComponent("MeshComponent");
    console.log(`Entity ${entity.id} components for scene addition:`, Array.from(entity.components.keys()).join(", "));
    if (!meshComponent || !meshComponent.mesh) {
      console.warn(`Entity ${entity.id} has no valid mesh to add to scene`);
      if (meshComponent && !meshComponent.mesh) {
        console.warn(`Entity ${entity.id} has MeshComponent but mesh property is ${meshComponent.mesh}`);
      }
      return;
    }
    if (meshComponent.mesh.geometry) {
      if (!meshComponent.mesh.geometry.boundingSphere && typeof meshComponent.mesh.geometry.computeBoundingSphere === "function") {
        meshComponent.mesh.geometry.computeBoundingSphere();
      }
    } else if (meshComponent.mesh.isGroup) {
      console.log(`Entity ${entity.id} uses a THREE.Group - skipping bounding sphere computation`);
    }
    if (!this.scene) {
      console.error(`Cannot add entity ${entity.id} mesh to scene - scene reference is missing`);
      return;
    }
    this.scene.add(meshComponent.mesh);
    meshComponent.mesh.visible = true;
    const transform2 = entity.getComponent("TransformComponent");
    if (transform2) {
      meshComponent.mesh.position.copy(transform2.position);
      meshComponent.mesh.quaternion.copy(transform2.quaternion);
      meshComponent.mesh.scale.copy(transform2.scale);
    }
    console.log(`Added entity ${entity.id} mesh to scene - position: ${meshComponent.mesh.position.x.toFixed(0)},${meshComponent.mesh.position.y.toFixed(0)},${meshComponent.mesh.position.z.toFixed(0)}`);
    this.meshEntities.set(entity.id, entity);
  }
  /**
   * Remove entity mesh from scene
   * @param {Entity} entity Entity to remove
   */
  removeEntityFromScene(entity) {
    const meshComponent = entity.getComponent("MeshComponent");
    if (meshComponent.mesh && meshComponent.mesh.parent) {
      this.scene.remove(meshComponent.mesh);
    }
    this.meshEntities.delete(entity.id);
  }
  /**
   * Update camera frustum for culling
   */
  updateFrustum() {
    if (!this.camera) return;
    try {
      if (!this.camera.projectionMatrix || !this.camera.matrixWorldInverse) {
        console.warn("Camera matrices not initialized");
        return;
      }
      this.projScreenMatrix = new Matrix4();
      this.projScreenMatrix.multiplyMatrices(
        this.camera.projectionMatrix,
        this.camera.matrixWorldInverse
      );
      this.frustum = new Frustum();
      this.frustum.setFromProjectionMatrix(this.projScreenMatrix);
    } catch (error) {
      console.error("Error updating frustum:", error);
      window.DEBUG_MODE = true;
    }
  }
  /**
   * Check if a position is visible in the camera frustum
   * @param {THREE.Vector3} position Position to check
   * @param {number} radius Bounding sphere radius
   * @returns {boolean} True if visible
   */
  isVisible(position, radius) {
    window.DEBUG_MODE = true;
    return true;
  }
  /**
   * Update all mesh transforms from entity transforms
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    this.updateFrustum();
    if (window.DEBUG_MODE && this.world.time % 5 < deltaTime) {
      this.scanForMissingEntities();
    }
    for (const entity of this.meshEntities.values()) {
      const transform2 = entity.getComponent("TransformComponent");
      const meshComponent = entity.getComponent("MeshComponent");
      if (!transform2 || !meshComponent || !meshComponent.mesh) continue;
      if (!meshComponent.mesh.parent && this.scene) {
        console.log(`RenderSystem: Adding missing mesh for entity ${entity.id} to scene`);
        this.scene.add(meshComponent.mesh);
      }
      meshComponent.mesh.position.copy(transform2.position);
      meshComponent.mesh.quaternion.copy(transform2.quaternion);
      meshComponent.mesh.scale.copy(transform2.scale);
      transform2.needsUpdate = false;
      if (window.DEBUG_MODE) {
        meshComponent.mesh.visible = true;
        continue;
      }
      if (meshComponent.visible) {
        let radius = 500;
        if (meshComponent.mesh.isGroup) {
          radius = 500;
        } else if (meshComponent.mesh.geometry) {
          if (meshComponent.mesh.geometry.boundingSphere) {
            radius = meshComponent.mesh.geometry.boundingSphere.radius;
          } else if (typeof meshComponent.mesh.geometry.computeBoundingSphere === "function") {
            meshComponent.mesh.geometry.computeBoundingSphere();
            if (meshComponent.mesh.geometry.boundingSphere) {
              radius = meshComponent.mesh.geometry.boundingSphere.radius;
            }
          }
        }
        const isInView = this.isVisible(transform2.position, radius);
        meshComponent.mesh.visible = isInView;
      } else {
        meshComponent.mesh.visible = false;
      }
    }
    if (window.DEBUG_MODE && this.world.time % 5 < deltaTime) {
      console.log(`RenderSystem: ${this.meshEntities.size} entities being managed`);
    }
  }
  /**
   * Scan for entities that should be tracked but aren't
   */
  scanForMissingEntities() {
    const entities = this.world.getEntitiesWithComponents(["TransformComponent", "MeshComponent"]);
    let missingCount = 0;
    entities.forEach((entity) => {
      if (!this.meshEntities.has(entity.id)) {
        console.log(`RenderSystem: Found untracked entity ${entity.id} with mesh, adding to scene`);
        this.addEntityToScene(entity);
        missingCount++;
      }
    });
    if (missingCount > 0) {
      console.log(`RenderSystem: Added ${missingCount} missing entities to tracking`);
    }
  }
  /**
   * Clean up resources when system is destroyed
   */
  onDestroyed() {
    this.projScreenMatrix = null;
    this.frustum = null;
    for (const entity of this.meshEntities.values()) {
      this.removeEntityFromScene(entity);
    }
    this.meshEntities.clear();
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    if (this.world && this.world.messageBus) {
      this.world.messageBus.unsubscribe("entity.created", this.onEntityCreated.bind(this));
      this.world.messageBus.unsubscribe("entity.destroyed", this.onEntityDestroyed.bind(this));
      this.world.messageBus.unsubscribe("component.added", this.onComponentAdded.bind(this));
    }
  }
}
class CollisionSystem extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = ["TransformComponent", "RigidbodyComponent"];
    this.priority = 20;
    this.cells = /* @__PURE__ */ new Map();
    this.cellSize = 2e3;
    this.processedCollisions = /* @__PURE__ */ new Set();
    this.entityCells = /* @__PURE__ */ new Map();
    this.potentialColliders = new FixedArray(200);
    this.cellsToCheck = new FixedArray(27);
    this.tempVec1 = new Vector3();
    this.tempVec2 = new Vector3();
    this.collisionNormal = new Vector3();
    this.relativeVelocity = new Vector3();
  }
  /**
   * Process all entities for collisions
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    this.cells.clear();
    this.processedCollisions.clear();
    this.entityCells.clear();
    const entities = this.getEntities();
    for (let i = 0; i < entities.length; i++) {
      this._insertIntoGrid(entities[i]);
    }
    for (let i = 0; i < entities.length; i++) {
      this._checkCollisionsOptimized(entities[i], deltaTime);
    }
  }
  /**
   * Insert entity into spatial partitioning grid
   * @param {Entity} entity Entity to insert
   * @private
   */
  _insertIntoGrid(entity) {
    const transform2 = entity.getComponent("TransformComponent");
    const rigidbody = entity.getComponent("RigidbodyComponent");
    if (!transform2 || !rigidbody) return;
    const cellX = Math.floor(transform2.position.x / this.cellSize);
    const cellY = Math.floor(transform2.position.y / this.cellSize);
    const cellZ = Math.floor(transform2.position.z / this.cellSize);
    const cellKey = `${cellX},${cellY},${cellZ}`;
    if (!this.cells.has(cellKey)) {
      this.cells.set(cellKey, []);
    }
    this.cells.get(cellKey).push(entity);
    if (!this.entityCells.has(entity.id)) {
      this.entityCells.set(entity.id, /* @__PURE__ */ new Set());
    }
    this.entityCells.get(entity.id).add(cellKey);
    const radius = rigidbody.collisionRadius;
    const isProjectile = entity.hasTag("playerProjectile") || entity.hasTag("particleProjectile");
    const overlapFactor = isProjectile ? 5 : 1;
    const cellRadius = Math.ceil(radius * overlapFactor / this.cellSize);
    if (isProjectile || cellRadius > 0) {
      const velocity = rigidbody.velocity || { length: () => 0 };
      const speedFactor = velocity.length ? Math.min(3, Math.ceil(velocity.length() / 1e3)) : 1;
      for (let dx = -cellRadius; dx <= cellRadius; dx++) {
        for (let dy = -cellRadius; dy <= cellRadius; dy++) {
          for (let dz = -cellRadius; dz <= cellRadius; dz++) {
            if (dx === 0 && dy === 0 && dz === 0) continue;
            if (isProjectile && speedFactor > 1) {
              const dotProduct = dx * Math.sign(velocity.x || 0) + dy * Math.sign(velocity.y || 0) + dz * Math.sign(velocity.z || 0);
              if (dotProduct < 0) continue;
            }
            const neighborKey = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
            if (!this.cells.has(neighborKey)) {
              this.cells.set(neighborKey, []);
            }
            this.cells.get(neighborKey).push(entity);
            this.entityCells.get(entity.id).add(neighborKey);
          }
        }
      }
    }
  }
  /**
   * Check for collisions with optimized spatial partitioning
   * @param {Entity} entity Entity to check
   * @param {number} deltaTime Time since last update in seconds
   * @private
   */
  _checkCollisionsOptimized(entity, deltaTime) {
    const transform2 = entity.getComponent("TransformComponent");
    const rigidbody = entity.getComponent("RigidbodyComponent");
    if (!transform2 || !rigidbody || !this.entityCells.has(entity.id)) {
      return;
    }
    const entityCellKeys = this.entityCells.get(entity.id);
    this.potentialColliders.clear();
    entityCellKeys.forEach((cellKey) => {
      const cellEntities = this.cells.get(cellKey);
      if (!cellEntities) return;
      for (let i = 0; i < cellEntities.length; i++) {
        const otherEntity = cellEntities[i];
        if (otherEntity === entity) continue;
        const pairId = entity.id < otherEntity.id ? `${entity.id}:${otherEntity.id}` : `${otherEntity.id}:${entity.id}`;
        if (this.processedCollisions.has(pairId)) continue;
        this.potentialColliders.push(otherEntity);
        this.processedCollisions.add(pairId);
      }
    });
    for (let i = 0; i < this.potentialColliders.length; i++) {
      const otherEntity = this.potentialColliders.get(i);
      const otherTransform = otherEntity.getComponent("TransformComponent");
      const otherRigidbody = otherEntity.getComponent("RigidbodyComponent");
      if (!otherTransform || !otherRigidbody) continue;
      if (this._checkSphereCollision(
        transform2.position,
        rigidbody.collisionRadius,
        otherTransform.position,
        otherRigidbody.collisionRadius
      )) {
        if (rigidbody.isTrigger || otherRigidbody.isTrigger) {
          this._handleTrigger(entity, otherEntity);
        } else {
          this._resolveCollision(
            entity,
            otherEntity,
            transform2,
            rigidbody,
            otherTransform,
            otherRigidbody
          );
        }
      }
    }
  }
  /**
   * Check for sphere-sphere collision
   * @param {THREE.Vector3} posA Position A
   * @param {number} radiusA Radius A
   * @param {THREE.Vector3} posB Position B
   * @param {number} radiusB Radius B
   * @returns {boolean} True if collision detected
   * @private
   */
  _checkSphereCollision(posA, radiusA, posB, radiusB) {
    const dx = posA.x - posB.x;
    const dy = posA.y - posB.y;
    const dz = posA.z - posB.z;
    const distanceSquared = dx * dx + dy * dy + dz * dz;
    const radiusSum = radiusA + radiusB;
    return distanceSquared <= radiusSum * radiusSum;
  }
  /**
   * Handle a trigger collision (no physics response)
   * @param {Entity} entity Entity A
   * @param {Entity} otherEntity Entity B
   * @private
   */
  _handleTrigger(entity, otherEntity) {
    let playerProjectile = null;
    let enemyProjectile = null;
    let enemyEntity = null;
    let playerEntity = null;
    const entityIsPlayerProjectile = entity._isPlayerProjectile || entity.hasTag("playerProjectile") || entity.hasTag("particleProjectile");
    const otherIsEnemy = otherEntity._isEnemy || otherEntity.hasTag("enemy") || otherEntity.hasComponent("EnemyComponent") || otherEntity.hasComponent("EnemyAIComponent");
    if (entityIsPlayerProjectile && otherIsEnemy) {
      playerProjectile = entity;
      enemyEntity = otherEntity;
    } else {
      const otherIsPlayerProjectile = otherEntity._isPlayerProjectile || otherEntity.hasTag("playerProjectile") || otherEntity.hasTag("particleProjectile");
      const entityIsEnemy = entity._isEnemy || entity.hasTag("enemy") || entity.hasComponent("EnemyComponent") || entity.hasComponent("EnemyAIComponent");
      if (otherIsPlayerProjectile && entityIsEnemy) {
        playerProjectile = otherEntity;
        enemyEntity = entity;
      }
    }
    const entityIsEnemyProjectile = entity._isEnemyProjectile || entity.hasTag("enemyProjectile");
    const otherIsPlayer = otherEntity._isPlayer || otherEntity.hasTag("player");
    if (entityIsEnemyProjectile && otherIsPlayer) {
      enemyProjectile = entity;
      playerEntity = otherEntity;
    } else {
      const otherIsEnemyProjectile = otherEntity._isEnemyProjectile || otherEntity.hasTag("enemyProjectile");
      const entityIsPlayer = entity._isPlayer || entity.hasTag("player");
      if (otherIsEnemyProjectile && entityIsPlayer) {
        enemyProjectile = otherEntity;
        playerEntity = entity;
      }
    }
    if (playerProjectile && enemyEntity) {
      console.log(`DIRECT HIT: Player projectile ${playerProjectile.id} hit enemy ${enemyEntity.id}`);
      if (enemyEntity.hasTag("pooled")) {
        console.warn(`Skipping hit on pooled enemy ${enemyEntity.id}`);
        return;
      }
      const projectileTransform = playerProjectile.getComponent("TransformComponent");
      const enemyTransform = enemyEntity.getComponent("TransformComponent");
      if (projectileTransform && enemyTransform) {
        const distance = projectileTransform.position.distanceTo(enemyTransform.position);
        console.log(`Hit details: Distance=${distance.toFixed(1)}, ProjectilePos=${projectileTransform.position.x.toFixed(0)},${projectileTransform.position.y.toFixed(0)},${projectileTransform.position.z.toFixed(0)}, EnemyPos=${enemyTransform.position.x.toFixed(0)},${enemyTransform.position.y.toFixed(0)},${enemyTransform.position.z.toFixed(0)}`);
      }
      const health = enemyEntity.getComponent("HealthComponent");
      if (health) {
        const damage = 1e3;
        console.log(`CRITICAL HIT: Applying ${damage} damage to enemy ${enemyEntity.id}`);
        health.applyDamage(damage, "particle", playerProjectile);
        if (!health.isDestroyed) {
          console.error("ERROR: Enemy not destroyed after particle hit! Sending entity.destroyed event...");
          health.isDestroyed = true;
          health.health = 0;
          this.world.messageBus.publish("entity.destroyed", {
            entity: enemyEntity,
            source: playerProjectile,
            damageType: "particle"
          });
        } else {
          console.log("ENEMY DESTROYED CONFIRMED! Health reached zero and isDestroyed=true");
        }
      }
      let position = null;
      try {
        position = playerProjectile.getComponent("TransformComponent").position.clone();
      } catch (error) {
        try {
          position = enemyEntity.getComponent("TransformComponent").position.clone();
        } catch (innerError) {
          position = new Vector3(0, 0, 0);
        }
      }
      this.world.messageBus.publish("collision.trigger", {
        entityA: playerProjectile,
        entityB: enemyEntity,
        projectileHit: true
      });
      this.world.messageBus.publish("projectile.hit", {
        projectile: playerProjectile,
        target: enemyEntity,
        position
      });
      this.world.destroyEntity(playerProjectile.id);
    } else if (enemyProjectile && playerEntity) {
      console.log(`ENEMY HIT: Enemy projectile ${enemyProjectile.id} hit player ${playerEntity.id}`);
      const health = playerEntity.getComponent("HealthComponent");
      if (health) {
        const damage = 10;
        console.log(`Applying ${damage} damage to player`);
        health.applyDamage(damage, "enemyProjectile", enemyProjectile);
      }
      let position = null;
      try {
        position = enemyProjectile.getComponent("TransformComponent").position.clone();
      } catch (error) {
        try {
          position = playerEntity.getComponent("TransformComponent").position.clone();
        } catch (innerError) {
          position = new Vector3(0, 0, 0);
        }
      }
      this.world.messageBus.publish("collision.trigger", {
        entityA: enemyProjectile,
        entityB: playerEntity,
        projectileHit: true
      });
      this.world.messageBus.publish("projectile.hit", {
        projectile: enemyProjectile,
        target: playerEntity,
        position
      });
      this.world.destroyEntity(enemyProjectile.id);
    } else {
      this.world.messageBus.publish("collision.trigger", {
        entityA: entity,
        entityB: otherEntity
      });
    }
  }
  /**
   * Resolve a physical collision with impulse-based physics
   * @private
   */
  _resolveCollision(entityA, entityB, transformA, rigidbodyA, transformB, rigidbodyB) {
    this.collisionNormal.copy(transformA.position).sub(transformB.position).normalize();
    this.relativeVelocity.copy(rigidbodyA.velocity).sub(rigidbodyB.velocity);
    const velocityAlongNormal = this.relativeVelocity.dot(this.collisionNormal);
    if (velocityAlongNormal > 0) return;
    const invMassA = rigidbodyA.isKinematic ? 0 : 1 / rigidbodyA.mass;
    const invMassB = rigidbodyB.isKinematic ? 0 : 1 / rigidbodyB.mass;
    const impulseScalar = -1.3 * velocityAlongNormal / (invMassA + invMassB);
    this.tempVec1.copy(this.collisionNormal).multiplyScalar(impulseScalar * invMassA);
    this.tempVec2.copy(this.collisionNormal).multiplyScalar(impulseScalar * invMassB);
    rigidbodyA.velocity.sub(this.tempVec1);
    rigidbodyB.velocity.add(this.tempVec2);
    const percent = 0.2;
    const slop = 0.01;
    const distanceSquared = transformA.position.distanceToSquared(transformB.position);
    const radiusSum = rigidbodyA.collisionRadius + rigidbodyB.collisionRadius;
    const penetration = radiusSum - Math.sqrt(distanceSquared);
    if (penetration > slop) {
      const correction = Math.max(penetration - slop, 0) / (invMassA + invMassB) * percent;
      this.tempVec1.copy(this.collisionNormal).multiplyScalar(correction * invMassA);
      this.tempVec2.copy(this.collisionNormal).multiplyScalar(correction * invMassB);
      transformA.position.sub(this.tempVec1);
      transformB.position.add(this.tempVec2);
    }
  }
}
class VisualEffectsSystem extends System {
  constructor(world) {
    super(world);
    this.priority = 70;
    this.activeEffects = /* @__PURE__ */ new Map();
    this.effectCounter = 0;
    this.setupEventListeners();
    console.log("VisualEffectsSystem initialized");
  }
  /**
   * Set up event listeners for visual effect events
   */
  setupEventListeners() {
    this.world.messageBus.subscribe("vfx.explosion", this.handleExplosionRequest.bind(this));
    this.world.messageBus.subscribe("vfx.damageFlash", this.handleDamageFlashRequest.bind(this));
  }
  /**
   * Update all active visual effects
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    for (const [id, effect] of this.activeEffects.entries()) {
      if (!effect.update(deltaTime)) {
        this.removeEffect(id);
      }
    }
  }
  /**
   * Handle request to create an explosion effect
   * @param {object} message The explosion request message
   */
  handleExplosionRequest(message) {
    if (!message || !message.data || !message.data.position) {
      console.error("Invalid explosion effect request", message);
      return;
    }
    const position = message.data.position;
    const scale = message.data.scale || 1;
    const duration = message.data.duration || 2;
    this.createExplosionEffect(position, scale, duration);
    if (window.game && window.game.audio) {
      window.game.audio.playSound("boink");
    }
  }
  /**
   * Handle request to create a damage flash effect
   * @param {object} message The damage flash request message
   */
  handleDamageFlashRequest(message) {
    const intensity = message && message.data && message.data.intensity ? message.data.intensity : 0.3;
    this.createDamageFlashEffect(intensity);
  }
  /**
   * Create an explosion effect at the specified position
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} scale Size scale for the explosion (1.0 = normal)
   * @param {number} duration Duration in seconds
   * @returns {number} Effect ID
   */
  createExplosionEffect(position, scale = 1, duration = 2) {
    if (!this.world.scene) {
      console.error("No scene available for explosion effect");
      return -1;
    }
    const container = new Group();
    container.position.copy(position);
    container.scale.set(scale, scale, scale);
    const particleCount = Math.floor(20 * scale);
    const particles = [];
    const usePooling = window.objectPool && window.objectPool.pools && window.objectPool.pools["explosionParticle"];
    for (let i = 0; i < particleCount; i++) {
      let particle;
      const size = Math.random() * 2 + 1;
      if (usePooling) {
        particle = window.objectPool.get("explosionParticle");
        if (particle) {
          const radius = Math.random() * 10;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const particlePos = new Vector3(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
          particle.reset(particlePos, size, 16733440);
          particle.velocity.copy(particlePos).normalize().multiplyScalar(
            Math.random() * 2 + 1
          );
          container.add(particle.mesh);
          particles.push(particle);
        }
      } else {
        const geometry = window.game && window.game.explosionGeometry ? window.game.explosionGeometry : new SphereGeometry(size, 8, 8);
        const material = window.game && window.game.explosionMaterial ? window.game.explosionMaterial.clone() : new MeshBasicMaterial({
          color: 16733440,
          transparent: true,
          opacity: 0.8
        });
        const particleMesh = new Mesh(geometry, material);
        const radius = Math.random() * 10;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        particleMesh.position.set(
          radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.sin(phi) * Math.sin(theta),
          radius * Math.cos(phi)
        );
        particleMesh.userData.velocity = particleMesh.position.clone().normalize().multiplyScalar(
          Math.random() * 2 + 1
        );
        container.add(particleMesh);
        particles.push({
          mesh: particleMesh,
          material,
          velocity: particleMesh.userData.velocity
        });
      }
    }
    this.world.scene.add(container);
    const effectId = this.effectCounter++;
    const effect = {
      id: effectId,
      type: "explosion",
      container,
      particles,
      duration,
      elapsed: 0,
      usePooling,
      update: (dt) => {
        effect.elapsed += dt;
        if (effect.elapsed >= effect.duration) {
          if (effect.usePooling) {
            effect.particles.forEach((particle) => {
              window.objectPool.release("explosionParticle", particle);
            });
          }
          this.world.scene.remove(container);
          return false;
        }
        const progress = effect.elapsed / effect.duration;
        effect.particles.forEach((particle) => {
          if (effect.usePooling) {
            particle.mesh.position.add(
              particle.velocity.clone().multiplyScalar(dt)
            );
            particle.material.opacity = 0.8 * (1 - progress);
            particle.mesh.scale.multiplyScalar(0.99);
          } else {
            particle.mesh.position.add(
              particle.velocity.clone().multiplyScalar(dt)
            );
            particle.material.opacity = 0.8 * (1 - progress);
            particle.mesh.scale.multiplyScalar(0.99);
          }
        });
        return true;
      }
    };
    this.activeEffects.set(effectId, effect);
    return effectId;
  }
  /**
   * Create a damage flash effect on screen
   * @param {number} intensity Flash intensity (0-1)
   * @returns {number} Effect ID
   */
  createDamageFlashEffect(intensity = 0.3) {
    const flash = document.createElement("div");
    flash.style.position = "fixed";
    flash.style.top = "0";
    flash.style.left = "0";
    flash.style.width = "100%";
    flash.style.height = "100%";
    flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
    flash.style.pointerEvents = "none";
    flash.style.zIndex = "1000";
    flash.style.opacity = "1";
    flash.style.transition = "opacity 0.2s ease-out";
    document.body.appendChild(flash);
    const effectId = this.effectCounter++;
    const effect = {
      id: effectId,
      type: "damageFlash",
      element: flash,
      duration: 0.3,
      // Fixed duration for damage flash
      elapsed: 0,
      update: (dt) => {
        effect.elapsed += dt;
        if (effect.elapsed >= effect.duration) {
          if (document.body.contains(flash)) {
            document.body.removeChild(flash);
          }
          return false;
        }
        const progress = effect.elapsed / effect.duration;
        flash.style.opacity = (1 - progress).toString();
        return true;
      }
    };
    this.activeEffects.set(effectId, effect);
    return effectId;
  }
  /**
   * Remove an effect and clean up its resources
   * @param {number} effectId ID of the effect to remove
   */
  removeEffect(effectId) {
    const effect = this.activeEffects.get(effectId);
    if (!effect) return;
    if (effect.type === "explosion") {
      if (effect.container && this.world.scene) {
        this.world.scene.remove(effect.container);
      }
    } else if (effect.type === "damageFlash") {
      if (effect.element && document.body.contains(effect.element)) {
        document.body.removeChild(effect.element);
      }
    }
    this.activeEffects.delete(effectId);
  }
  /**
   * Clean up all effects when system is disabled
   */
  onDisabled() {
    for (const effectId of this.activeEffects.keys()) {
      this.removeEffect(effectId);
    }
    this.activeEffects.clear();
  }
}
class TrailSystem extends System {
  /**
   * Create a new trail system
   */
  constructor(world) {
    super(world);
    this.requiredComponents = ["TrailComponent", "TransformComponent"];
    this.priority = 60;
    this.trails = /* @__PURE__ */ new Map();
    console.log("Trail system initialized");
  }
  /**
   * Register a trail with the system
   * @param {string} entityId ID of the entity
   * @param {TrailComponent} trailComponent Trail component to register
   */
  registerTrail(entityId, trailComponent) {
    this.trails.set(entityId, trailComponent);
    console.log(`Registered trail for entity ${entityId}`);
  }
  /**
   * Unregister a trail from the system
   * @param {string} entityId ID of the entity
   */
  unregisterTrail(entityId) {
    this.trails.delete(entityId);
  }
  /**
   * Process a single entity with a trail component
   * @param {Entity} entity Entity to process
   * @param {number} deltaTime Time since last update in seconds
   */
  processEntity(entity, deltaTime) {
    const trail = entity.getComponent("TrailComponent");
    if (!trail) return;
    trail.update(deltaTime);
  }
  /**
   * Update all trails
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    super.update(deltaTime);
    for (const [entityId, trail] of this.trails.entries()) {
      if (trail && !trail.entity) {
        const entity = this.world.getEntity(entityId);
        if (entity) {
          const transform2 = entity.getComponent("TransformComponent");
          if (transform2) {
            trail.update(deltaTime);
          }
        }
      }
    }
  }
  /**
   * Clean up when system is disabled
   */
  onDisabled() {
    for (const trail of this.trails.values()) {
      if (trail && trail.onDetached) {
        trail.onDetached();
      }
    }
    this.trails.clear();
  }
}
class DeployableLaserSystem extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = ["DeployableLaserComponent", "TransformComponent", "MeshComponent"];
    this.player = null;
    this.activeBeams = /* @__PURE__ */ new Map();
    this.world.messageBus.subscribe("player.created", this.handlePlayerCreated.bind(this));
  }
  /**
   * Initialize the system
   */
  initialize() {
    console.log("Deployable Laser System initialized");
  }
  /**
   * Handle player creation
   * @param {Object} data Event data
   */
  handlePlayerCreated(data) {
    this.player = data.entity;
  }
  /**
   * Update all deployable lasers
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    const laserEntities = this.world.getEntitiesWithComponents(this.requiredComponents);
    const targetEntities = this.world.getEntitiesByTag("enemy");
    for (const laserEntity of laserEntities) {
      const laserComponent = laserEntity.getComponent("DeployableLaserComponent");
      const transform2 = laserEntity.getComponent("TransformComponent");
      if (laserComponent.fireCooldown > 0) {
        laserComponent.fireCooldown -= deltaTime;
      }
      if (!laserComponent.targetEntityId || !this.isValidTarget(laserComponent.targetEntityId)) {
        this.findTarget(laserEntity, laserComponent, transform2, targetEntities);
      }
      if (laserComponent.targetEntityId && laserComponent.canFire()) {
        this.fireAtTarget(laserEntity, laserComponent);
      }
      this.updateBeamVisuals(laserEntity.id, deltaTime);
    }
  }
  /**
   * Find a valid target for the laser
   * @param {Entity} laserEntity The laser entity
   * @param {Object} laserComponent The laser component
   * @param {Object} transform The transform component
   * @param {Entity[]} potentialTargets List of potential targets
   */
  findTarget(laserEntity, laserComponent, transform2, potentialTargets) {
    const laserPosition = transform2.position;
    let closestTarget = null;
    let closestDistance = Infinity;
    for (const target of potentialTargets) {
      const healthComponent2 = target.getComponent("HealthComponent");
      if (!healthComponent2 || healthComponent2.isDestroyed) {
        continue;
      }
      const targetTransform = target.getComponent("TransformComponent");
      if (!targetTransform) continue;
      const distance = targetTransform.position.distanceTo(laserPosition);
      if (distance <= laserComponent.range && distance < closestDistance) {
        closestTarget = target;
        closestDistance = distance;
      }
    }
    laserComponent.targetEntityId = closestTarget ? closestTarget.id : null;
  }
  /**
   * Check if a target is still valid
   * @param {string} targetId The target entity ID
   * @returns {boolean} Whether the target is valid
   */
  isValidTarget(targetId) {
    const entity = this.world.getEntity(targetId);
    if (!entity) return false;
    const healthComponent2 = entity.getComponent("HealthComponent");
    if (!healthComponent2 || healthComponent2.isDestroyed) return false;
    return true;
  }
  /**
   * Fire the laser at the current target
   * @param {Entity} laserEntity The laser entity
   * @param {Object} laserComponent The laser component
   */
  fireAtTarget(laserEntity, laserComponent) {
    const targetEntity = this.world.getEntity(laserComponent.targetEntityId);
    if (!targetEntity) {
      laserComponent.targetEntityId = null;
      return;
    }
    const hit = Math.random() <= laserComponent.accuracy;
    if (hit) {
      const healthComponent2 = targetEntity.getComponent("HealthComponent");
      if (healthComponent2) {
        const entityId = targetEntity.id;
        const entityType = targetEntity.hasTag("enemy") ? "enemy" : "unknown";
        try {
          const damageAmount = Math.max(healthComponent2.health + healthComponent2.shield, 1e3);
          healthComponent2.applyDamage(damageAmount);
          healthComponent2.isDestroyed = true;
          this.world.messageBus.publish("entity.damaged", {
            entity: targetEntity,
            entityId,
            entityType,
            damage: damageAmount,
            sourceId: laserEntity.id,
            sourceType: "deployableLaser"
          });
          this.world.messageBus.publish("entity.destroyed", {
            entity: targetEntity,
            entityId,
            entityType,
            sourceId: laserEntity.id,
            sourceType: "deployableLaser"
          });
          if (this.world && this.world.destroyEntity) {
            const meshComponent = targetEntity.getComponent("MeshComponent");
            if (meshComponent && meshComponent.mesh) {
              this.world.scene.remove(meshComponent.mesh);
            }
            setTimeout(() => {
              try {
                this.world.destroyEntity(targetEntity);
              } catch (error) {
                console.error("Error destroying entity:", error);
              }
            }, 10);
          }
          console.log(`Deployable laser ${laserEntity.id} hit and destroyed target ${targetEntity.id}`);
        } catch (error) {
          console.error("Error applying damage:", error);
        }
      }
    } else {
      console.log(`Deployable laser ${laserEntity.id} missed target ${targetEntity.id}`);
    }
    try {
      this.createFireVisual(laserEntity, targetEntity, hit);
    } catch (error) {
      console.error("Error creating visual effect:", error);
    }
    laserComponent.resetCooldown();
  }
  /**
   * Create visual beam effect for firing
   * @param {Entity} laserEntity The laser entity
   * @param {Entity} targetEntity The target entity
   * @param {boolean} hit Whether the shot hit
   */
  createFireVisual(laserEntity, targetEntity, hit) {
    try {
      const laserComponent = laserEntity.getComponent("DeployableLaserComponent");
      const laserTransform = laserEntity.getComponent("TransformComponent");
      const targetTransform = targetEntity.getComponent("TransformComponent");
      const meshComponent = laserEntity.getComponent("MeshComponent");
      if (!laserTransform || !targetTransform) {
        console.error("Missing required transform component for visual effect");
        return;
      }
      const targetPos = targetTransform.position.clone();
      const basePos = laserTransform.position.clone();
      const scale = 20;
      const emitterPositions = [
        new Vector3(basePos.x + 3.5 * scale, basePos.y + 3.5 * scale, basePos.z),
        new Vector3(basePos.x - 3.5 * scale, basePos.y + 3.5 * scale, basePos.z),
        new Vector3(basePos.x, basePos.y - 3.5 * scale, basePos.z + 3.5 * scale),
        new Vector3(basePos.x, basePos.y + 3.5 * scale, basePos.z - 3.5 * scale)
      ];
      let closestEmitter = null;
      let minDistance = Infinity;
      for (const emitterPos of emitterPositions) {
        const dist = emitterPos.distanceTo(targetPos);
        if (dist < minDistance) {
          minDistance = dist;
          closestEmitter = emitterPos;
        }
      }
      const start = closestEmitter;
      const end = targetPos;
      const direction = new Vector3().subVectors(end, start).normalize();
      const distance = start.distanceTo(end);
      const beamWidth = 5;
      const beamGeometry = new CylinderGeometry(beamWidth, beamWidth, distance, 12);
      beamGeometry.rotateX(Math.PI / 2);
      beamGeometry.translate(0, 0, distance / 2);
      const beamMaterial = new MeshBasicMaterial({
        color: 16711731,
        transparent: true,
        opacity: 0.8,
        emissive: 16711680,
        emissiveIntensity: 1
      });
      const beam = new Mesh(beamGeometry, beamMaterial);
      beam.position.copy(start);
      beam.lookAt(end);
      this.world.scene.add(beam);
      this.activeBeams.set(laserEntity.id, {
        mesh: beam,
        lifetime: 0.2,
        hit
      });
      if (hit) {
        this.world.messageBus.publish("vfx.explosion", {
          position: end,
          scale: 1.5,
          // Make it a bit larger than standard
          color: 16724787
        });
      }
    } catch (error) {
      console.error("Error creating laser visual effect:", error);
    }
  }
  /**
   * Update and clean up beam visuals
   * @param {string} entityId The laser entity ID
   * @param {number} deltaTime Time since last update
   */
  updateBeamVisuals(entityId, deltaTime) {
    if (this.activeBeams.has(entityId)) {
      const beamData = this.activeBeams.get(entityId);
      if (!beamData || !beamData.mesh) {
        this.activeBeams.delete(entityId);
        return;
      }
      beamData.lifetime -= deltaTime;
      if (beamData.lifetime <= 0) {
        try {
          this.world.scene.remove(beamData.mesh);
          if (beamData.mesh.geometry) beamData.mesh.geometry.dispose();
          if (beamData.mesh.material) beamData.mesh.material.dispose();
          this.activeBeams.delete(entityId);
        } catch (error) {
          console.error("Error removing beam visual:", error);
          this.activeBeams.delete(entityId);
        }
      } else {
        beamData.mesh.material.opacity = beamData.lifetime / 0.2 * 0.7;
      }
    }
  }
}
class DeploymentSystem extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = ["PickupableComponent", "TransformComponent"];
    this.player = null;
    this.pickupRange = 50;
    this.isDeploymentReady = false;
    this.deploymentType = null;
    this.world.messageBus.subscribe("player.created", this.handlePlayerCreated.bind(this));
    this.world.messageBus.subscribe("input.deployLaser", this.handleDeployLaserRequest.bind(this));
    this.world.messageBus.subscribe("input.pickupInteract", this.handlePickupRequest.bind(this));
  }
  /**
   * Initialize the system
   */
  initialize() {
    console.log("Deployment System initialized");
    if (!this.player) {
      if (window.game && window.game.combat && window.game.combat.playerEntity) {
        console.log("Found player entity in window.game.combat.playerEntity");
        this.player = window.game.combat.playerEntity;
      } else if (this.world.playerEntity) {
        console.log("Found player entity in world.playerEntity");
        this.player = this.world.playerEntity;
      } else {
        const playersWithTag = this.world.getEntitiesByTag("player");
        if (playersWithTag && playersWithTag.length > 0) {
          console.log("Found player entity by tag");
          this.player = playersWithTag[0];
        }
      }
    }
    if (this.player) {
      console.log(`Deployment System found player entity with ID: ${this.player.id}`);
    } else {
      console.warn("Deployment System could not find player entity during initialization");
    }
  }
  /**
   * Handle player creation
   * @param {Object} data Event data
   */
  handlePlayerCreated(data) {
    this.player = data.entity;
  }
  /**
   * Update the system
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (!this.player) {
      if (window.game && window.game.combat && window.game.combat.playerEntity) {
        this.player = window.game.combat.playerEntity;
        console.log("Found player entity in window.game.combat.playerEntity");
      } else if (this.world.playerEntity) {
        this.player = this.world.playerEntity;
        console.log("Found player entity in world.playerEntity");
      } else {
        const playersWithTag = this.world.getEntitiesByTag("player");
        if (playersWithTag && playersWithTag.length > 0) {
          this.player = playersWithTag[0];
          console.log("Found player entity by tag");
        }
      }
    }
    const pickupables = this.world.getEntitiesWithComponents(this.requiredComponents);
    if (this.player) {
      const playerTransform = this.player.getComponent("TransformComponent");
      if (playerTransform) {
        for (const entity of pickupables) {
          if (!entity.userData) {
            entity.userData = {};
          }
          const pickupable = entity.getComponent("PickupableComponent");
          const transform2 = entity.getComponent("TransformComponent");
          const distance = playerTransform.position.distanceTo(transform2.position);
          if (distance <= pickupable.pickupRange) {
            if (!entity.userData.isHighlighted) {
              entity.userData.isHighlighted = true;
              this.world.messageBus.publish("pickup.available", {
                entity,
                type: pickupable.type
              });
            }
          } else if (entity.userData.isHighlighted) {
            entity.userData.isHighlighted = false;
            this.world.messageBus.publish("pickup.unavailable", {
              entity
            });
          }
        }
      }
    }
  }
  /**
   * Handle request to deploy a laser turret
   * @param {Object} data Event data
   */
  handleDeployLaserRequest(data) {
    try {
      if (!this.player) {
        if (window.game && window.game.combat && window.game.combat.playerEntity) {
          this.player = window.game.combat.playerEntity;
          console.log("Found player entity in window.game.combat.playerEntity");
        } else if (this.world.playerEntity) {
          this.player = this.world.playerEntity;
          console.log("Found player entity in world.playerEntity");
        } else {
          const playersWithTag = this.world.getEntitiesByTag("player");
          if (playersWithTag && playersWithTag.length > 0) {
            this.player = playersWithTag[0];
            console.log("Found player entity by tag");
          }
        }
        if (!this.player) {
          console.error("Cannot deploy laser: player entity not found");
          return;
        }
      }
      if (!window.game || !window.game.spaceship) {
        console.error("Cannot deploy laser: game or spaceship not found");
        return;
      }
      const spaceship = window.game.spaceship;
      if (!spaceship.deployableLaserCount || spaceship.deployableLaserCount <= 0) {
        console.log("No deployable lasers available");
        this.world.messageBus.publish("ui.notification", {
          message: "No deployable lasers available",
          type: "warning",
          duration: 2
        });
        return;
      }
      const playerTransform = this.player.getComponent("TransformComponent");
      if (!playerTransform) {
        console.error("Cannot deploy laser: player transform not found");
        return;
      }
      const laserEntity = this.createDeployableLaser(
        playerTransform.position.clone(),
        this.player.id
      );
      if (laserEntity) {
        spaceship.deployableLaserCount--;
        this.world.messageBus.publish("ui.notification", {
          message: "Laser turret deployed",
          type: "success",
          duration: 2
        });
        this.world.messageBus.publish("laser.deployed", {
          entity: laserEntity,
          position: playerTransform.position.clone()
        });
        console.log(`Deployed laser turret at ${playerTransform.position.x}, ${playerTransform.position.y}, ${playerTransform.position.z}`);
      }
    } catch (error) {
      console.error("Error deploying laser turret:", error);
    }
  }
  /**
   * Handle request to pick up an item
   * @param {Object} data Event data
   */
  handlePickupRequest(data) {
    if (!this.player) {
      if (window.game && window.game.combat && window.game.combat.playerEntity) {
        this.player = window.game.combat.playerEntity;
        console.log("Found player entity in window.game.combat.playerEntity");
      } else if (this.world.playerEntity) {
        this.player = this.world.playerEntity;
        console.log("Found player entity in world.playerEntity");
      } else {
        const playersWithTag = this.world.getEntitiesByTag("player");
        if (playersWithTag && playersWithTag.length > 0) {
          this.player = playersWithTag[0];
          console.log("Found player entity by tag");
        }
      }
      if (!this.player) {
        console.error("Cannot pickup: player entity not found");
        return;
      }
    }
    const playerTransform = this.player.getComponent("TransformComponent");
    if (!playerTransform) {
      console.error("Cannot pickup: player transform not found");
      return;
    }
    const pickupables = this.world.getEntitiesWithComponents(this.requiredComponents);
    let closestEntity = null;
    let closestDistance = Infinity;
    for (const entity of pickupables) {
      const pickupable = entity.getComponent("PickupableComponent");
      if (!pickupable.canBePickedUp) continue;
      const transform2 = entity.getComponent("TransformComponent");
      const distance = playerTransform.position.distanceTo(transform2.position);
      if (distance <= pickupable.pickupRange && distance < closestDistance) {
        closestEntity = entity;
        closestDistance = distance;
      }
    }
    if (closestEntity) {
      this.pickupEntity(closestEntity);
    } else {
      console.log("No pickupable entities in range");
    }
  }
  /**
   * Pick up an entity
   * @param {Entity} entity The entity to pick up
   */
  pickupEntity(entity) {
    const pickupable = entity.getComponent("PickupableComponent");
    if (pickupable.type === "deployableLaser") {
      if (window.game && window.game.spaceship) {
        if (typeof window.game.spaceship.deployableLaserCount === "undefined") {
          window.game.spaceship.deployableLaserCount = 0;
        }
        window.game.spaceship.deployableLaserCount++;
        this.world.messageBus.publish("ui.notification", {
          message: "Laser turret retrieved",
          type: "success",
          duration: 2
        });
        this.world.messageBus.publish("laser.pickedup", {
          entity
        });
        this.world.destroyEntity(entity);
        console.log("Picked up deployable laser");
      } else {
        console.error("Cannot pick up laser: game or spaceship not found");
      }
    } else {
      console.log(`Picked up ${pickupable.type} but no handler defined`);
    }
  }
  /**
   * Create a deployable laser entity
   * @param {THREE.Vector3} position The position to deploy at
   * @param {string} ownerId The ID of the owner entity
   * @returns {Entity} The created entity
   */
  createDeployableLaser(position, ownerId) {
    try {
      const entity = this.world.createEntity(`deployable_laser_${Date.now()}`);
      entity.userData = {
        isHighlighted: false,
        _isEnemy: false,
        isDeployableLaser: true
      };
      entity.addTag("deployableLaser");
      entity.addTag("friendly");
      entity.addTag("NOT_ENEMY");
      try {
        const TransformComponent2 = this.player.getComponent("TransformComponent").constructor;
        const transform2 = new TransformComponent2(position);
        entity.addComponent(transform2);
      } catch (error) {
        console.error("Error adding transform component:", error);
        this.world.destroyEntity(entity);
        return null;
      }
      const scale = 20;
      const coreGeometry = new SphereGeometry(4 * scale, 24, 24);
      const coreMaterial = new MeshPhongMaterial({
        color: 3355456,
        specular: 3368703,
        shininess: 50,
        emissive: 2236979,
        emissiveIntensity: 0.3
      });
      const core = new Mesh(coreGeometry, coreMaterial);
      const energyGeometry = new SphereGeometry(2.5 * scale, 32, 32);
      const energyMaterial = new MeshPhongMaterial({
        color: 16724787,
        specular: 16777215,
        shininess: 30,
        emissive: 16711680,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.9
      });
      const energySphere = new Mesh(energyGeometry, energyMaterial);
      const emitterGeometry = new SphereGeometry(0.8 * scale, 16, 16);
      const emitterMaterial = new MeshPhongMaterial({
        color: 16763904,
        specular: 16777215,
        shininess: 100,
        emissive: 16755200,
        emissiveIntensity: 0.7
      });
      const emitters = [];
      const emitterPositions = [
        new Vector3(3.5 * scale, 3.5 * scale, 0),
        new Vector3(-3.5 * scale, 3.5 * scale, 0),
        new Vector3(0, -3.5 * scale, 3.5 * scale),
        new Vector3(0, 3.5 * scale, -3.5 * scale)
      ];
      for (let i = 0; i < emitterPositions.length; i++) {
        const emitter = new Mesh(emitterGeometry, emitterMaterial);
        emitter.position.copy(emitterPositions[i]);
        emitters.push(emitter);
      }
      const ring1Geometry = new TorusGeometry(5 * scale, 0.4 * scale, 16, 48);
      const ring2Geometry = new TorusGeometry(5.5 * scale, 0.4 * scale, 16, 48);
      const ringMaterial = new MeshPhongMaterial({
        color: 3368635,
        specular: 6724095,
        shininess: 50,
        emissive: 3368703,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      const ring1 = new Mesh(ring1Geometry, ringMaterial);
      const ring2 = new Mesh(ring2Geometry, ringMaterial);
      ring1.rotation.x = Math.PI / 2;
      ring2.rotation.y = Math.PI / 2;
      const animate = () => {
        if (ring1 && ring2) {
          ring1.rotation.z += 5e-3;
          ring2.rotation.z -= 3e-3;
          for (let i = 0; i < emitters.length; i++) {
            const time = Date.now() * 1e-3;
            const radius = 3.5 * scale;
            const speed = 0.5 + i * 0.1;
            emitters[i].position.x = Math.cos(time * speed) * radius * (i % 2 ? 1 : 0.8);
            emitters[i].position.y = Math.sin(time * speed) * radius * (i % 3 ? 0.9 : 1);
            emitters[i].position.z = Math.cos(time * speed + Math.PI / 2) * radius * (i % 2 ? 0.8 : 1);
          }
          requestAnimationFrame(animate);
        }
      };
      requestAnimationFrame(animate);
      const group = new Group();
      group.add(core);
      group.add(energySphere);
      emitters.forEach((emitter) => group.add(emitter));
      group.add(ring1);
      group.add(ring2);
      try {
        let MeshComponent2;
        if (window.game && window.game.combat) {
          const entitiesWithMesh = this.world.getEntitiesWithComponents(["MeshComponent"]);
          if (entitiesWithMesh && entitiesWithMesh.length > 0) {
            MeshComponent2 = entitiesWithMesh[0].getComponent("MeshComponent").constructor;
          }
        }
        if (!MeshComponent2) {
          MeshComponent2 = function(mesh2) {
            this.type = "MeshComponent";
            this.mesh = mesh2;
          };
          MeshComponent2.prototype.dispose = function() {
            if (this.mesh) {
              if (this.mesh.geometry) this.mesh.geometry.dispose();
              if (this.mesh.material) this.mesh.material.dispose();
            }
          };
        }
        const mesh = new MeshComponent2(group);
        entity.addComponent(mesh);
        this.world.scene.add(group);
      } catch (error) {
        console.error("Error adding mesh component:", error);
        this.world.destroyEntity(entity);
        return null;
      }
      try {
        const DeployableLaserComponent = function(range, fireRate, accuracy) {
          this.type = "DeployableLaserComponent";
          this.range = range || 1e3;
          this.fireRate = fireRate || 3;
          this.accuracy = accuracy || 0.5;
          this.fireCooldown = 0;
          this.targetEntityId = null;
          this.laserColor = 16711731;
          this.laserWidth = 0.5;
          this.ownerId = null;
          this.isDeployed = true;
        };
        DeployableLaserComponent.prototype.resetCooldown = function() {
          this.fireCooldown = this.fireRate;
        };
        DeployableLaserComponent.prototype.canFire = function() {
          return this.fireCooldown <= 0;
        };
        const laserComponent = new DeployableLaserComponent(1e3, 3, 0.5);
        laserComponent.ownerId = ownerId;
        entity.addComponent(laserComponent);
      } catch (error) {
        console.error("Error adding deployable laser component:", error);
        this.world.destroyEntity(entity);
        return null;
      }
      try {
        const PickupableComponent = function(type, pickupRange) {
          this.type = "PickupableComponent";
          this.itemType = type || "deployableLaser";
          this.pickupRange = pickupRange || 50;
          this.canBePickedUp = true;
        };
        const pickupable = new PickupableComponent("deployableLaser", 50);
        entity.addComponent(pickupable);
      } catch (error) {
        console.error("Error adding pickupable component:", error);
        this.world.destroyEntity(entity);
        return null;
      }
      console.log(`Created deployable laser entity: ${entity.id}`);
      return entity;
    } catch (error) {
      console.error("Error creating deployable laser entity:", error);
      return null;
    }
  }
}
class ExplosionHandler extends System {
  constructor(world) {
    super(world);
    this.requiredComponents = [];
    this.priority = 80;
    this.setupEventListeners();
    console.log("ExplosionHandler initialized - listening for combat events");
  }
  /**
   * Set up event listeners for combat events
   */
  setupEventListeners() {
    this.world.messageBus.subscribe("entity.destroyed", this.handleEntityDestroyed.bind(this));
    this.world.messageBus.subscribe("projectile.hit", this.handleProjectileHit.bind(this));
    this.world.messageBus.subscribe("combat.hit", this.handleCombatHit.bind(this));
  }
  /**
   * Handle entity destroyed event
   * @param {object} message Event message
   */
  handleEntityDestroyed(message) {
    const entity = message.entity;
    if (!entity) return;
    const isEnemy = entity.hasTag && entity.hasTag("enemy");
    const isPlayer = entity.hasTag && entity.hasTag("player");
    if (!isEnemy && !isPlayer) return;
    const transform2 = entity.getComponent && entity.getComponent("TransformComponent");
    if (!transform2 || !transform2.position) return;
    const position = transform2.position.clone();
    this.createExplosion(position, isEnemy ? 2e3 : 2500, isEnemy ? 2.5 : 3);
  }
  /**
   * Handle projectile hit event
   * @param {object} message Event message
   */
  handleProjectileHit(message) {
    const { projectile, target, position } = message;
    if (!position) return;
    this.createExplosion(position, 800, 0.8);
  }
  /**
   * Handle combat hit event
   * @param {object} message Event message
   */
  handleCombatHit(message) {
    const { target, position, destroyed } = message;
    if (!destroyed) return;
    if (!position) return;
    this.createExplosion(position, 2500, 3);
  }
  /**
   * Create an explosion effect at the given position
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} duration Duration in milliseconds
   * @param {number} scale Scale of the explosion
   */
  createExplosion(position, duration = 1e3, scale = 1) {
    try {
      if (window.game && window.game.combat && window.game.combat.createExplosionEffect) {
        const explosion = window.game.combat.createExplosionEffect(position, duration, true);
        if (explosion && explosion.scale) {
          explosion.scale.setScalar(scale);
        }
        return;
      }
      if (window.game && window.game.combatManager && window.game.combatManager.effectsManager) {
        const effectsManager = window.game.combatManager.effectsManager;
        if (effectsManager.createExplosionEffect) {
          const poolManager = window.game.combatManager.poolManager;
          const explosion = effectsManager.explosionEffects.createExplosionEffect(
            position,
            duration,
            true,
            poolManager,
            (obj) => {
              if (window.game && window.game.scene) {
                window.game.scene.add(obj);
              }
            }
          );
          if (explosion && explosion.scale) {
            explosion.scale.setScalar(scale);
          }
          return;
        }
      }
      if (window.objectPool && window.objectPool.getExplosion) {
        const explosion = window.objectPool.getExplosion();
        if (explosion) {
          explosion.position.copy(position);
          explosion.scale.setScalar(scale);
          explosion.visible = true;
          if (window.game && window.game.scene) {
            window.game.scene.add(explosion);
            console.log("Created explosion via object pool");
            setTimeout(() => {
              if (explosion.parent) {
                explosion.parent.remove(explosion);
              }
              if (window.objectPool && window.objectPool.releaseExplosion) {
                window.objectPool.releaseExplosion(explosion);
              }
            }, duration);
          }
        }
        return;
      }
      this.createSimpleExplosion(position, duration, scale);
    } catch (error) {
      console.error("Error creating explosion effect:", error);
    }
  }
  /**
   * Create a simple explosion effect as fallback
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} duration Duration in milliseconds
   * @param {number} scale Scale of the explosion
   */
  createSimpleExplosion(position, duration = 1e3, scale = 1) {
    if (!window.game || !window.game.scene) return;
    const geometry = new SphereGeometry(10 * scale, 16, 16);
    const material = new MeshBasicMaterial({
      color: 16737792,
      transparent: true,
      opacity: 0.8,
      emissive: 16737792,
      emissiveIntensity: 2
    });
    const explosion = new Mesh(geometry, material);
    explosion.position.copy(position);
    window.game.scene.add(explosion);
    console.log("Created simple fallback explosion");
    const startTime = Date.now();
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = elapsed / duration;
      if (progress >= 1) {
        if (explosion.parent) {
          explosion.parent.remove(explosion);
        }
        geometry.dispose();
        material.dispose();
        return;
      }
      const expansionScale = 1 + progress * 4;
      explosion.scale.setScalar(expansionScale * scale);
      material.opacity = 0.8 * (1 - progress);
      requestAnimationFrame(animate);
    };
    animate();
  }
  /**
   * Update method (required by System base class)
   * @param {number} deltaTime Time since last update
   */
  update(deltaTime) {
  }
  /**
   * Clean up when system is disabled
   */
  onDisabled() {
    this.world.messageBus.unsubscribe("entity.destroyed", this.handleEntityDestroyed.bind(this));
    this.world.messageBus.unsubscribe("projectile.hit", this.handleProjectileHit.bind(this));
    this.world.messageBus.unsubscribe("combat.hit", this.handleCombatHit.bind(this));
    console.log("ExplosionHandler disabled");
  }
}
class SystemRegistrar {
  constructor() {
    this.registeredSystems = {};
  }
  /**
   * Register all combat systems with the ECS world in the correct order
   * CRITICAL: This order must be preserved to maintain existing behavior
   */
  async registerAllSystems(world, scene) {
    console.log("[COMBAT] Registering combat systems with ECS world...");
    try {
      this.registeredSystems.combatSystem = new CombatSystem(world);
      world.registerSystem(this.registeredSystems.combatSystem);
      this.registeredSystems.enemySystem = new EnemySystem(world);
      world.registerSystem(this.registeredSystems.enemySystem);
      if (window.game) {
        window.game.ecsWorld = window.game.ecsWorld || {};
        window.game.ecsWorld.enemySystem = this.registeredSystems.enemySystem;
        console.log("[COMBAT] Made enemy system globally available via window.game.ecsWorld.enemySystem");
      }
      this.registeredSystems.trailSystem = new TrailSystem(world);
      world.registerSystem(this.registeredSystems.trailSystem);
      try {
        this.registeredSystems.deployableLaserSystem = new DeployableLaserSystem(world);
        world.registerSystem(this.registeredSystems.deployableLaserSystem);
      } catch (error) {
        console.warn("[COMBAT] Failed to register DeployableLaserSystem:", error);
      }
      try {
        this.registeredSystems.deploymentSystem = new DeploymentSystem(world);
        world.registerSystem(this.registeredSystems.deploymentSystem);
      } catch (error) {
        console.warn("[COMBAT] Failed to register DeploymentSystem:", error);
      }
      if (window.game) {
        window.game.trailSystem = this.registeredSystems.trailSystem;
        console.log("[COMBAT] Registered trail system with window.game for global access");
      }
      try {
        const { InstancedRenderer } = await __vitePreload(async () => {
          const { InstancedRenderer: InstancedRenderer2 } = await import("./InstancedRenderer-BF_LO-uX.js");
          return { InstancedRenderer: InstancedRenderer2 };
        }, true ? __vite__mapDeps([0,1,2]) : void 0);
        this.registeredSystems.instancedRenderer = new InstancedRenderer(world, scene);
        world.registerSystem(this.registeredSystems.instancedRenderer);
        console.log("[COMBAT] InstancedRenderer registered");
      } catch (e) {
        console.warn("[COMBAT] InstancedRenderer not available:", e);
      }
      const camera = scene.camera;
      if (!camera) {
        console.error("[COMBAT] No camera found on scene, enemies may not be visible");
      }
      console.log(`[COMBAT] Camera reference for RenderSystem: ${camera ? "Available" : "Missing"}`);
      this.registeredSystems.renderSystem = new RenderSystem(world, scene, camera);
      world.registerSystem(this.registeredSystems.renderSystem);
      console.log("[COMBAT] Registering CollisionSystem with the world...");
      this.registeredSystems.collisionSystem = new CollisionSystem(world);
      world.registerSystem(this.registeredSystems.collisionSystem);
      console.log("[COMBAT] CollisionSystem registered");
      console.log("[COMBAT] Registering VisualEffectsSystem with the world...");
      this.registeredSystems.visualEffectsSystem = new VisualEffectsSystem(world);
      world.registerSystem(this.registeredSystems.visualEffectsSystem);
      console.log("[COMBAT] VisualEffectsSystem registered");
      console.log("[COMBAT] Registering ExplosionHandler with the world...");
      this.registeredSystems.explosionHandler = new ExplosionHandler(world);
      world.registerSystem(this.registeredSystems.explosionHandler);
      console.log("[COMBAT] ExplosionHandler registered");
      console.log("[COMBAT] All combat systems registered successfully");
      return this.registeredSystems;
    } catch (error) {
      console.error("[COMBAT] Error during system registration:", error);
      console.error("[COMBAT] Stack trace:", error.stack);
      throw error;
    }
  }
  /**
   * Get a specific system by name
   */
  getSystem(systemName) {
    return this.registeredSystems[systemName];
  }
  /**
   * Get all registered systems
   */
  getAllSystems() {
    return this.registeredSystems;
  }
  /**
   * Enable or disable all systems
   */
  setSystemsEnabled(enabled) {
    const systems = ["enemySystem", "combatSystem"];
    for (const systemName of systems) {
      const system = this.registeredSystems[systemName];
      if (!system) continue;
      if (typeof system.setEnabled === "function") {
        system.setEnabled(enabled);
      } else {
        system.enabled = enabled;
      }
    }
    console.log(`Combat systems ${enabled ? "enabled" : "disabled"}`);
  }
  /**
   * Import and register a system dynamically
   * @param {string} path The path to the system module
   * @param {string} className The name of the system class
   * @param {Object} world The ECS world
   * @param {Object} scene The scene (optional)
   * @returns {Object} The system instance
   */
  async importAndRegisterSystem(path, className, world, scene = null) {
    try {
      const module = await import(
        /* @vite-ignore */
        path
      );
      if (!module[className]) {
        console.error(`[COMBAT] System class ${className} not found in module ${path}`);
        return null;
      }
      const SystemClass = module[className];
      let system;
      if (className === "TrailSystem" || className === "VisualEffectsSystem" || className === "RenderSystem") {
        system = new SystemClass(world, scene);
      } else {
        system = new SystemClass(world);
      }
      world.registerSystem(system);
      this.registeredSystems[className.toLowerCase()] = system;
      return system;
    } catch (error) {
      console.error(`[COMBAT] Error importing system ${className} from ${path}:`, error);
      return null;
    }
  }
}
class EventManager {
  constructor() {
    this.subscriptions = [];
  }
  /**
   * Set up all event subscriptions and message bus interactions
   */
  setupEventHandlers(world, playerEntity) {
    if (!world || !world.messageBus) {
      console.warn("[EVENTS] No world or messageBus available for event setup");
      return;
    }
    const transformSubscription = world.messageBus.subscribe("transform.updated", (msg) => {
      const entity = msg.data && msg.data.entity;
      if (entity && world.onEntityTransformUpdated) {
        world.onEntityTransformUpdated(entity);
      }
    });
    this.subscriptions.push(transformSubscription);
    if (playerEntity) {
      const playerCreatedSubscription = world.messageBus.subscribe("player.created", (msg) => {
        console.log("[EVENTS] Player created event received:", msg.data);
      });
      this.subscriptions.push(playerCreatedSubscription);
    }
    console.log("[EVENTS] Event handlers set up successfully");
  }
  /**
   * Publish an event about player entity creation
   */
  publishPlayerCreated(world, playerEntity) {
    if (world && world.messageBus && playerEntity) {
      world.messageBus.publish("player.created", { entity: playerEntity });
      console.log("[EVENTS] Published player.created event");
    }
  }
  /**
   * Publish an event about enemy destruction
   */
  publishEnemyDestroyed(world, entityId, source, position) {
    if (world && world.messageBus) {
      world.messageBus.publish("enemy.destroyed", {
        entityId,
        source,
        position: position ? position.clone() : null
      });
      console.log(`[EVENTS] Published enemy.destroyed event for entity ${entityId}`);
    }
  }
  /**
   * Notify EnemySystem directly about enemy destruction
   */
  notifyEnemySystemDestruction(enemy, reason = "projectile") {
    if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
      console.log(`[EVENTS] Notifying EnemySystem directly about enemy ${enemy.id} destruction`);
      try {
        const enemySystem = window.game.ecsWorld.enemySystem;
        if (typeof enemySystem.handleEntityDestroyed === "function") {
          enemySystem.handleEntityDestroyed({
            entity: enemy,
            reason
          });
        }
      } catch (syncError) {
        console.error("[EVENTS] Error syncing with EnemySystem:", syncError);
      }
    }
  }
  /**
   * Clean up all event subscriptions
   */
  cleanup() {
    for (const subscription of this.subscriptions) {
      if (subscription && typeof subscription.unsubscribe === "function") {
        subscription.unsubscribe();
      }
    }
    this.subscriptions = [];
    console.log("[EVENTS] Event subscriptions cleaned up");
  }
  /**
   * Set up general game event handlers
   */
  setupGameEventHandlers() {
    console.log("[EVENTS] Game event handlers set up");
  }
  /**
   * Publish a general combat event
   */
  publishCombatEvent(world, eventType, data) {
    if (world && world.messageBus) {
      world.messageBus.publish(`combat.${eventType}`, data);
      console.log(`[EVENTS] Published combat.${eventType} event`);
    }
  }
  /**
   * Subscribe to a specific event type
   */
  subscribe(world, eventType, handler) {
    if (world && world.messageBus) {
      const subscription = world.messageBus.subscribe(eventType, handler);
      this.subscriptions.push(subscription);
      return subscription;
    }
    return null;
  }
  /**
   * Unsubscribe from a specific subscription
   */
  unsubscribe(subscription) {
    if (subscription && typeof subscription.unsubscribe === "function") {
      subscription.unsubscribe();
      const index = this.subscriptions.indexOf(subscription);
      if (index > -1) {
        this.subscriptions.splice(index, 1);
      }
    }
  }
}
class ExplosionEffects {
  constructor() {
    this.activeTracers = [];
  }
  /**
   * Create an explosion effect at the given position
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} duration Duration of the explosion in milliseconds
   * @param {boolean} isVisible Whether the explosion should be visible
   * @param {Object} poolManager Pool manager for getting explosion objects
   * @param {Function} addToScene Function to add objects to scene
   */
  createExplosionEffect(position, duration = 1e3, isVisible = true, poolManager = null, addToScene = null) {
    try {
      let explosion = null;
      if (poolManager && poolManager.getExplosion) {
        explosion = poolManager.getExplosion(position, duration);
      }
      if (!explosion) {
        const geometry = new SphereGeometry(30, 16, 16);
        const material = new MeshBasicMaterial({
          color: 16737792,
          transparent: true,
          opacity: 0.9,
          emissive: 16724736,
          emissiveIntensity: 2,
          blending: AdditiveBlending
        });
        explosion = new Mesh(geometry, material);
        explosion.position.copy(position);
        if (addToScene) {
          addToScene(explosion);
        } else if (window.game && window.game.scene) {
          window.game.scene.add(explosion);
        }
        const startTime = Date.now();
        const animate = () => {
          const elapsed = Date.now() - startTime;
          const progress = elapsed / duration;
          if (progress >= 1 || !explosion.parent) {
            if (explosion.parent) {
              explosion.parent.remove(explosion);
            }
            geometry.dispose();
            material.dispose();
            return;
          }
          const expansionScale = 1 + progress * 3;
          explosion.scale.setScalar(expansionScale);
          material.opacity = 0.9 * (1 - progress);
          requestAnimationFrame(animate);
        };
        animate();
      }
      if (window.game && window.game.audio) {
        window.game.audio.playSound("boink");
      }
      return explosion;
    } catch (error) {
      console.error("Error creating explosion effect:", error);
      return null;
    }
  }
  /**
   * Create an instant plasma beam with hot glow
   * @param {THREE.Vector3} startPos Starting position of the beam
   * @param {THREE.Vector3} endPos End position of the beam (hit point or max range)
   * @param {boolean} isHit Whether this beam hit a target
   * @param {number} fadeTime Time in seconds for the beam to fade
   * @param {Function} addToScene Function to add objects to scene
   */
  createInstantTracer(startPos, endPos, isHit = false, fadeTime = 0.5, addToScene = null) {
    const distance = startPos.distanceTo(endPos);
    const beamGroup = new Group();
    const coreGeometry = new CylinderGeometry(1.5, 1.5, distance, 12);
    const coreMaterial = new MeshBasicMaterial({
      color: 16777130,
      // Hot yellow-white
      transparent: true,
      opacity: 1,
      blending: AdditiveBlending
    });
    const coreMesh = new Mesh(coreGeometry, coreMaterial);
    const innerGlowGeometry = new CylinderGeometry(3, 3, distance, 8);
    const innerGlowMaterial = new MeshBasicMaterial({
      color: isHit ? 16755200 : 16746496,
      // Orange for hits, red-orange for misses
      transparent: true,
      opacity: 0.6,
      blending: AdditiveBlending
    });
    const innerGlowMesh = new Mesh(innerGlowGeometry, innerGlowMaterial);
    const outerGlowGeometry = new CylinderGeometry(5, 5, distance, 6);
    const outerGlowMaterial = new MeshBasicMaterial({
      color: isHit ? 65535 : 35071,
      // Cyan for hits, blue for misses
      transparent: true,
      opacity: 0.3,
      blending: AdditiveBlending
    });
    const outerGlowMesh = new Mesh(outerGlowGeometry, outerGlowMaterial);
    beamGroup.add(coreMesh);
    beamGroup.add(innerGlowMesh);
    beamGroup.add(outerGlowMesh);
    const midpoint = new Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
    beamGroup.position.copy(midpoint);
    const direction = new Vector3().subVectors(endPos, startPos).normalize();
    const quaternion = new Quaternion();
    quaternion.setFromUnitVectors(new Vector3(0, 1, 0), direction);
    beamGroup.quaternion.copy(quaternion);
    if (addToScene) {
      addToScene(beamGroup);
    }
    beamGroup.userData = {
      startTime: performance.now(),
      fadeTime: fadeTime * 1e3,
      beamLength: distance,
      startPos: startPos.clone(),
      endPos: endPos.clone(),
      direction: direction.clone(),
      coreMesh,
      innerGlowMesh,
      outerGlowMesh,
      initialCoreOpacity: 1,
      initialInnerOpacity: 0.6,
      initialOuterOpacity: 0.3,
      isDissolving: false
    };
    this.activeTracers.push(beamGroup);
    return beamGroup;
  }
  /**
   * Update active tracer beams - fade them out from start to end
   * @param {number} deltaTime Time since last update
   * @param {Function} removeFromScene Function to remove objects from scene
   */
  updateTracers(deltaTime, removeFromScene = null) {
    if (!this.activeTracers || this.activeTracers.length === 0) return;
    const currentTime = performance.now();
    const tracersToRemove = [];
    for (let i = this.activeTracers.length - 1; i >= 0; i--) {
      const beamGroup = this.activeTracers[i];
      const userData = beamGroup.userData;
      if (!userData) continue;
      const elapsed = currentTime - userData.startTime;
      const fadeProgress = Math.min(elapsed / userData.fadeTime, 1);
      if (fadeProgress >= 1) {
        if (removeFromScene) {
          removeFromScene(beamGroup);
        }
        tracersToRemove.push(i);
      } else {
        const dissolveDistance = userData.beamLength * fadeProgress;
        const newStartOffset = userData.direction.clone().multiplyScalar(dissolveDistance);
        const newStartPos = userData.startPos.clone().add(newStartOffset);
        const newLength = userData.beamLength * (1 - fadeProgress);
        if (newLength > 0.1) {
          userData.coreMesh.geometry.dispose();
          userData.innerGlowMesh.geometry.dispose();
          userData.outerGlowMesh.geometry.dispose();
          userData.coreMesh.geometry = new CylinderGeometry(1.5, 1.5, newLength, 12);
          userData.innerGlowMesh.geometry = new CylinderGeometry(3, 3, newLength, 8);
          userData.outerGlowMesh.geometry = new CylinderGeometry(5, 5, newLength, 6);
          const newMidpoint = new Vector3().addVectors(newStartPos, userData.endPos).multiplyScalar(0.5);
          beamGroup.position.copy(newMidpoint);
          const opacityFactor = Math.pow(1 - fadeProgress, 0.3);
          userData.coreMesh.material.opacity = userData.initialCoreOpacity * opacityFactor;
          userData.innerGlowMesh.material.opacity = userData.initialInnerOpacity * opacityFactor;
          userData.outerGlowMesh.material.opacity = userData.initialOuterOpacity * opacityFactor;
        }
      }
    }
    for (const index of tracersToRemove) {
      this.activeTracers.splice(index, 1);
    }
  }
  /**
   * Clean up explosion effects resources
   */
  dispose() {
    this.activeTracers = [];
  }
}
class MaterialManager {
  constructor(scene) {
    this.scene = scene;
    this.initializeTemplateMaterials();
  }
  /**
   * Initialize template materials to prevent shader compilation stutter during first fire
   */
  initializeTemplateMaterials() {
    console.log("Initializing template materials for combat effects");
    this.projectileMaterial = new MeshStandardMaterial({
      color: 16711680,
      emissive: 16711680,
      emissiveIntensity: 10,
      // Vibrant laser
      metalness: 0.5,
      roughness: 0.5
    });
    this.projectileGlowMaterial = new MeshBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.5,
      // Softer glow
      blending: AdditiveBlending
    });
    this.trailParticleMaterial = new MeshBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.9,
      blending: AdditiveBlending
    });
    this.muzzleFlashMaterial = new MeshBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.8,
      // Brighter flash
      blending: AdditiveBlending,
      side: DoubleSide,
      depthWrite: false,
      wireframe: false
    });
    this.tracerLineMaterial = new LineBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.8,
      // More visible aiming line
      blending: AdditiveBlending
    });
    this.pointLightMaterial = new MeshBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.9,
      blending: AdditiveBlending,
      depthWrite: false
    });
    this.explosionParticleMaterial = new PointsMaterial({
      color: 16724736,
      // Red-orange for impact
      size: 15,
      // Slightly larger impact particles
      transparent: true,
      opacity: 1,
      blending: AdditiveBlending
    });
    this.precompileShaders();
  }
  /**
   * Pre-compile shaders to prevent stutter during combat
   */
  precompileShaders() {
    const dummyGeometry = new BoxGeometry(0.1, 0.1, 0.1);
    const sphereGeometry = new SphereGeometry(0.1, 8, 8);
    const cylinderGeometry = new CylinderGeometry(0.1, 0.2, 1, 8, 1);
    const pointsPositions = new Float32Array(30);
    for (let i = 0; i < 30; i++) {
      pointsPositions[i] = Math.random() - 0.5;
    }
    const pointsGeometry = new BufferGeometry();
    pointsGeometry.setAttribute("position", new BufferAttribute(pointsPositions, 3));
    const dummyProjectile = new Mesh(sphereGeometry, this.projectileMaterial);
    const dummyGlow = new Mesh(sphereGeometry, this.projectileGlowMaterial);
    const dummyTrail = new Mesh(sphereGeometry, this.trailParticleMaterial);
    const dummyFlash = new Mesh(cylinderGeometry, this.muzzleFlashMaterial);
    const dummyTracer = new Line(
      new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, 1)
      ]),
      this.tracerLineMaterial
    );
    const dummyExplosion = new Points(pointsGeometry, this.explosionParticleMaterial);
    const dummyTrailContainer = new Object3D();
    for (let i = 0; i < 5; i++) {
      const trailParticle = new Mesh(sphereGeometry, this.trailParticleMaterial.clone());
      trailParticle.position.z = -i * 0.2;
      dummyTrailContainer.add(trailParticle);
    }
    const tempScene = new Scene();
    tempScene.add(dummyProjectile);
    tempScene.add(dummyGlow);
    tempScene.add(dummyTrail);
    tempScene.add(dummyFlash);
    tempScene.add(dummyTracer);
    tempScene.add(dummyTrailContainer);
    tempScene.add(dummyExplosion);
    const addToScene = this._getAddToSceneFunction();
    const removeFromScene = this._getRemoveFromSceneFunction();
    addToScene(dummyProjectile);
    addToScene(dummyGlow);
    addToScene(dummyTrail);
    addToScene(dummyFlash);
    addToScene(dummyTracer);
    addToScene(dummyTrailContainer);
    addToScene(dummyExplosion);
    if (window.renderer) {
      console.log("Forcing shader compilation with renderer.compile()");
      window.renderer.compile(tempScene, this.scene.camera || { isCamera: true, matrixWorldInverse: new Matrix4() });
      window.renderer.compile(this.scene, this.scene.camera || { isCamera: true, matrixWorldInverse: new Matrix4() });
    } else if (window.game && window.game.renderer && window.game.renderer.renderer) {
      console.log("Forcing shader compilation with game.renderer.renderer.compile()");
      window.game.renderer.renderer.compile(tempScene, this.scene.camera || window.game.camera || { isCamera: true, matrixWorldInverse: new Matrix4() });
      window.game.renderer.renderer.compile(this.scene, this.scene.camera || window.game.camera || { isCamera: true, matrixWorldInverse: new Matrix4() });
    } else {
      console.warn("No renderer available for shader pre-compilation");
    }
    setTimeout(() => {
      removeFromScene(dummyProjectile);
      removeFromScene(dummyGlow);
      removeFromScene(dummyTrail);
      removeFromScene(dummyFlash);
      removeFromScene(dummyTracer);
      removeFromScene(dummyTrailContainer);
      removeFromScene(dummyExplosion);
      dummyGeometry.dispose();
      sphereGeometry.dispose();
      cylinderGeometry.dispose();
      pointsGeometry.dispose();
      dummyTrailContainer.children.forEach((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      console.log("Template materials initialized and dummy objects removed");
    }, 500);
  }
  /**
   * Get material by type
   */
  getMaterial(type) {
    switch (type) {
      case "projectile":
        return this.projectileMaterial;
      case "projectileGlow":
        return this.projectileGlowMaterial;
      case "trailParticle":
        return this.trailParticleMaterial;
      case "muzzleFlash":
        return this.muzzleFlashMaterial;
      case "tracerLine":
        return this.tracerLineMaterial;
      case "pointLight":
        return this.pointLightMaterial;
      case "explosionParticle":
        return this.explosionParticleMaterial;
      default:
        return null;
    }
  }
  /**
   * Helper to get add to scene function
   */
  _getAddToSceneFunction() {
    const renderer = window.game && window.game.renderer ? window.game.renderer : null;
    if (renderer && typeof renderer._withGuard === "function") {
      return (object) => renderer._withGuard(() => renderer.add(object));
    } else if (this.scene && typeof this.scene.add === "function") {
      return (object) => this.scene.add(object);
    }
    return () => {
    };
  }
  /**
   * Helper to get remove from scene function
   */
  _getRemoveFromSceneFunction() {
    const renderer = window.game && window.game.renderer ? window.game.renderer : null;
    if (renderer && typeof renderer._withGuard === "function") {
      return (object) => renderer._withGuard(() => this.scene.remove(object));
    } else if (this.scene && typeof this.scene.remove === "function") {
      return (object) => this.scene.remove(object);
    }
    return () => {
    };
  }
  /**
   * Clean up material resources
   */
  dispose() {
    if (this.projectileMaterial) this.projectileMaterial.dispose();
    if (this.projectileGlowMaterial) this.projectileGlowMaterial.dispose();
    if (this.trailParticleMaterial) this.trailParticleMaterial.dispose();
    if (this.muzzleFlashMaterial) this.muzzleFlashMaterial.dispose();
    if (this.tracerLineMaterial) this.tracerLineMaterial.dispose();
    if (this.pointLightMaterial) this.pointLightMaterial.dispose();
    if (this.explosionParticleMaterial) this.explosionParticleMaterial.dispose();
    console.log("Material resources disposed");
  }
}
class GeometryManager {
  constructor() {
    this.precreateGeometries();
  }
  /**
   * Pre-create geometries that will be reused across projectiles and effects
   * This prevents geometry creation during combat which can cause stutters
   */
  precreateGeometries() {
    console.log("Pre-creating geometries for combat effects");
    if (!window.game) window.game = {};
    window.game.projectileGeometry = new CylinderGeometry(0.15, 0.15, 10, 8);
    window.game.projectileGlowGeometry = new SphereGeometry(0.8, 12, 12);
    window.game.muzzleFlashGeometry = new CylinderGeometry(0.5, 2, 15, 12, 1, true);
    window.game.muzzleFlashGeometry.rotateX(Math.PI / 2);
    window.game.muzzleFlashGeometry.translate(0, 0, 15 / 2);
    window.game.trailParticleGeometries = [];
    const numPoints = 20;
    for (let i = 0; i < numPoints; i++) {
      const ratio = i / numPoints;
      const size = 0.5 * (1 - ratio);
      window.game.trailParticleGeometries[i] = new SphereGeometry(size, 8, 8);
    }
    window.game.tracerGeometry = new BufferGeometry();
    const points = [0, 0, 0, 0, 0, 1];
    window.game.tracerGeometry.setAttribute("position", new Float32BufferAttribute(points, 3));
    console.log("Combat geometries pre-created successfully");
  }
  /**
   * Store references to template materials on window.game
   * @param {Object} materialManager - The material manager instance
   */
  storeMaterialReferences(materialManager) {
    window.game.projectileMaterial = materialManager.projectileMaterial;
    window.game.projectileGlowMaterial = materialManager.projectileGlowMaterial;
    window.game.trailParticleMaterial = materialManager.trailParticleMaterial;
    window.game.muzzleFlashMaterial = materialManager.muzzleFlashMaterial;
    window.game.tracerLineMaterial = materialManager.tracerLineMaterial;
    window.game.explosionParticleMaterial = materialManager.explosionParticleMaterial;
  }
  /**
   * Clean up geometry resources
   */
  dispose() {
    if (window.game) {
      if (window.game.projectileGeometry) window.game.projectileGeometry.dispose();
      if (window.game.projectileGlowGeometry) window.game.projectileGlowGeometry.dispose();
      if (window.game.muzzleFlashGeometry) window.game.muzzleFlashGeometry.dispose();
      if (window.game.trailParticleGeometries) {
        window.game.trailParticleGeometries.forEach((geom) => geom.dispose());
      }
      if (window.game.tracerGeometry) window.game.tracerGeometry.dispose();
    }
    console.log("Geometry resources disposed");
  }
}
class ProjectileEffects {
  constructor() {
  }
  /**
   * Create a laser burst effect that travels forward with the projectile
   * @param {THREE.Vector3} position Position for the effect
   * @param {THREE.Vector3} direction Direction the effect should travel
   * @param {Object} poolManager Pool manager for getting muzzle flash objects
   */
  createMuzzleFlash(position, direction, poolManager) {
    if (!poolManager) {
      console.warn("No pool manager available for muzzle flash");
      return null;
    }
    const muzzleFlash = poolManager.getMuzzleFlash();
    muzzleFlash.position.copy(position);
    const lookAtPosition = position.clone().add(direction.clone().normalize().multiplyScalar(10));
    muzzleFlash.lookAt(lookAtPosition);
    muzzleFlash.userData.initialPosition = position.clone();
    muzzleFlash.userData.direction = direction.clone();
    const flashLight = muzzleFlash.userData.flashLight;
    if (flashLight) {
      flashLight.position.copy(position);
      flashLight.intensity = 200;
    }
    return muzzleFlash;
  }
  /**
   * Add a dynamic particle trail to a projectile (Simplified for Lasers)
   * @param {THREE.Mesh} projectile The projectile mesh
   * @param {THREE.Vector3} direction Direction of travel
   * @param {Object} poolManager Pool manager for getting trail components
   */
  addProjectileTrail(projectile, direction, poolManager) {
    const numPoints = 4;
    const trailLength = 4;
    const particleLifetime = 150;
    if (!poolManager) {
      console.warn("PoolManager not available for projectile trail.");
      return;
    }
    const trailContainer = poolManager.getTrailContainer();
    if (!trailContainer) {
      console.warn("Failed to get trail container from pool.");
      return;
    }
    projectile.add(trailContainer);
    const trailParticles = [];
    trailContainer.userData.particles = trailParticles;
    trailContainer.userData.isTrailActive = true;
    for (let i = 0; i < numPoints; i++) {
      const ratio = i / (numPoints - 1);
      const particle = poolManager.getTrailParticle(i % window.game.trailParticleGeometries.length);
      if (!particle) {
        console.warn(`Failed to get trail particle ${i} from pool.`);
        continue;
      }
      const offset = direction.clone().multiplyScalar(-ratio * trailLength - 2);
      particle.position.copy(offset);
      particle.userData.creationTime = performance.now();
      particle.userData.initialOpacity = particle.material.opacity;
      particle.userData.initialScale = particle.scale.x;
      trailContainer.add(particle);
      trailParticles.push(particle);
    }
    projectile.userData.trail = trailContainer;
    const animateTrail = () => {
      if (!projectile.parent || !trailContainer.userData.isTrailActive) {
        trailContainer.userData.isTrailActive = false;
        return;
      }
      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const particle = trailParticles[i];
        const elapsed = performance.now() - particle.userData.creationTime;
        const progress = Math.min(elapsed / particleLifetime, 1);
        if (progress >= 1) {
          poolManager.releaseTrailParticle(particle);
          trailParticles.splice(i, 1);
          if (particle.parent) particle.parent.remove(particle);
        } else {
          particle.material.opacity = particle.userData.initialOpacity * (1 - progress);
          const currentScale = particle.userData.initialScale * (1 - progress);
          particle.scale.set(currentScale, currentScale, currentScale);
        }
      }
      if (trailParticles.length === 0) {
        trailContainer.userData.isTrailActive = false;
        return;
      }
      requestAnimationFrame(animateTrail);
    };
    animateTrail();
  }
  /**
   * New method to visualize projectile trajectory
   * @param {THREE.Vector3} startPosition Starting position of the aiming line
   * @param {THREE.Vector3} direction Direction the line should point
   * @param {number} distance Distance of the aiming line
   * @param {Object} poolManager Pool manager for getting tracer objects
   */
  createAimingTracer(startPosition, direction, distance = 3e3, poolManager) {
    if (!poolManager) {
      console.warn("No pool manager available for aiming tracer");
      return null;
    }
    const tracer = poolManager.getTracer();
    const endPosition = startPosition.clone().add(direction.clone().multiplyScalar(distance));
    const positions = tracer.geometry.attributes.position.array;
    positions[0] = startPosition.x;
    positions[1] = startPosition.y;
    positions[2] = startPosition.z;
    positions[3] = endPosition.x;
    positions[4] = endPosition.y;
    positions[5] = endPosition.z;
    tracer.geometry.attributes.position.needsUpdate = true;
    return tracer;
  }
}
class EffectsManager {
  constructor(scene) {
    this.scene = scene;
    this.materialManager = new MaterialManager(scene);
    this.geometryManager = new GeometryManager();
    this.explosionEffects = new ExplosionEffects();
    this.projectileEffects = new ProjectileEffects();
    this.geometryManager.storeMaterialReferences(this.materialManager);
  }
  /**
   * Create an explosion effect at the given position
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} duration Duration of the explosion in milliseconds
   * @param {boolean} isVisible Whether the explosion should be visible
   */
  createExplosionEffect(position, duration = 1e3, isVisible = true, poolManager = null) {
    return this.explosionEffects.createExplosionEffect(position, duration, isVisible, poolManager, this._addToScene.bind(this));
  }
  /**
   * Create an instant plasma beam with hot glow
   * @param {THREE.Vector3} startPos Starting position of the beam
   * @param {THREE.Vector3} endPos End position of the beam (hit point or max range)
   * @param {boolean} isHit Whether this beam hit a target
   * @param {number} fadeTime Time in seconds for the beam to fade
   */
  createInstantTracer(startPos, endPos, isHit = false, fadeTime = 0.5) {
    return this.explosionEffects.createInstantTracer(startPos, endPos, isHit, fadeTime, this._addToScene.bind(this));
  }
  /**
   * Update active tracer beams - fade them out from start to end
   * @param {number} deltaTime Time since last update
   */
  updateTracers(deltaTime) {
    this.explosionEffects.updateTracers(deltaTime, this._removeFromScene.bind(this));
  }
  /**
   * Create a laser burst effect that travels forward with the projectile
   * @param {THREE.Vector3} position Position for the effect
   * @param {THREE.Vector3} direction Direction the effect should travel
   */
  createMuzzleFlash(position, direction, poolManager) {
    return this.projectileEffects.createMuzzleFlash(position, direction, poolManager);
  }
  /**
   * Add a dynamic particle trail to a projectile (Simplified for Lasers)
   * @param {THREE.Mesh} projectile The projectile mesh
   * @param {THREE.Vector3} direction Direction of travel
   * @param {Object} poolManager Pool manager for getting trail components
   */
  addProjectileTrail(projectile, direction, poolManager) {
    this.projectileEffects.addProjectileTrail(projectile, direction, poolManager);
  }
  /**
   * New method to visualize projectile trajectory
   */
  createAimingTracer(startPosition, direction, distance = 3e3, poolManager) {
    return this.projectileEffects.createAimingTracer(startPosition, direction, distance, poolManager);
  }
  /**
   * Get material by type
   */
  getMaterial(type) {
    return this.materialManager.getMaterial(type);
  }
  // --- Renderer facade helpers to centralize scene mutations ---
  _addToScene(object) {
    const renderer = window.game && window.game.renderer ? window.game.renderer : null;
    if (renderer && typeof renderer._withGuard === "function") {
      renderer._withGuard(() => renderer.add(object));
    } else if (this.scene && typeof this.scene.add === "function") {
      this.scene.add(object);
    }
  }
  _removeFromScene(object) {
    const renderer = window.game && window.game.renderer ? window.game.renderer : null;
    if (renderer && typeof renderer._withGuard === "function") {
      renderer._withGuard(() => this.scene.remove(object));
    } else if (this.scene && typeof this.scene.remove === "function") {
      this.scene.remove(object);
    }
  }
  /**
   * Clean up all effects resources
   */
  dispose() {
    this.explosionEffects.dispose();
    this.materialManager.dispose();
    this.geometryManager.dispose();
    console.log("Effects resources disposed");
  }
}
class AISpawnerManager {
  constructor() {
    this.registeredEnemyIds = /* @__PURE__ */ new Set();
  }
  /**
   * Configure enemy system after world is set up
   */
  configureEnemySystem(enemySystem) {
    var _a;
    if (!enemySystem) {
      console.warn("[AI_SPAWNER] No enemy system provided for configuration");
      return;
    }
    if (typeof ((_a = enemySystem.lifecycle) == null ? void 0 : _a.validateEnemyReferences) === "function") {
      enemySystem.lifecycle.validateEnemyReferences(enemySystem.enemies);
    }
    if (enemySystem.enemies && enemySystem.enemies.size > enemySystem.maxEnemies) {
      console.warn(`[AI_SPAWNER] Found ${enemySystem.enemies.size} enemies exceeding limit of ${enemySystem.maxEnemies} during setup`);
      if (typeof enemySystem.enforceEnemyLimit === "function") {
        enemySystem.enforceEnemyLimit();
      }
    }
    if (enemySystem.spawner && typeof enemySystem.spawner.generateSpawnPoints === "function") {
      enemySystem.spawner.generateSpawnPoints();
    }
    console.log(`[AI_SPAWNER] Configured enemy system: Max enemies ${enemySystem.maxEnemies || "unknown"}`);
  }
  /**
   * Register an enemy entity for synchronization with EnemySystem
   * @param {string} enemyId ID of the enemy entity
   */
  registerEnemy(enemyId) {
    this.registeredEnemyIds.add(enemyId);
    console.log(`AI_SPAWNER: Registered enemy ${enemyId} for tracking (total: ${this.registeredEnemyIds.size})`);
  }
  /**
   * Unregister an enemy entity
   * @param {string} enemyId ID of the enemy entity
   */
  unregisterEnemy(enemyId) {
    if (this.registeredEnemyIds.has(enemyId)) {
      this.registeredEnemyIds.delete(enemyId);
      console.log(`AI_SPAWNER: Unregistered enemy ${enemyId} (remaining: ${this.registeredEnemyIds.size})`);
    }
  }
  /**
   * Handle enemy destruction with proper cleanup
   * @param {Object} enemy The enemy entity
   * @param {string} reason Reason for destruction
   */
  handleEnemyDestruction(enemy, reason = "combat") {
    if (!enemy) return;
    console.log(`[AI_SPAWNER] Handling enemy ${enemy.id} destruction (reason: ${reason})`);
    this.unregisterEnemy(enemy.id);
    if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
      const enemySystem = window.game.ecsWorld.enemySystem;
      if (typeof enemySystem.returnEnemyToPool === "function") {
        console.log(`[AI_SPAWNER] Using EnemySystem.returnEnemyToPool for enemy ${enemy.id}`);
        enemySystem.returnEnemyToPool(enemy);
      }
      if (typeof enemySystem.validateEnemyReferences === "function") {
        enemySystem.validateEnemyReferences();
      }
    }
  }
  /**
   * Get the count of registered enemies
   */
  getEnemyCount() {
    return this.registeredEnemyIds.size;
  }
  /**
   * Get all registered enemy IDs
   */
  getRegisteredEnemyIds() {
    return Array.from(this.registeredEnemyIds);
  }
  /**
   * Clear all registered enemies
   */
  clearAllEnemies() {
    const enemyCount = this.registeredEnemyIds.size;
    this.registeredEnemyIds.clear();
    console.log(`[AI_SPAWNER] Cleared ${enemyCount} registered enemies`);
  }
  /**
   * Set up spawner parameters
   */
  configureSpawner(spawnerConfig = {}) {
    const defaultConfig = {
      maxEnemies: 10,
      spawnRate: 0.1,
      spawnDistance: 1e3,
      despawnDistance: 2e3
    };
    const config = { ...defaultConfig, ...spawnerConfig };
    console.log(`[AI_SPAWNER] Spawner configured with:`, config);
    return config;
  }
  /**
   * Handle AI behavior updates
   */
  updateAI(deltaTime, playerPosition) {
  }
  /**
   * Handle spawning logic
   */
  updateSpawning(deltaTime, playerPosition, enemySystem) {
    if (!enemySystem) return;
    const currentEnemyCount = this.registeredEnemyIds.size;
    const maxEnemies = enemySystem.maxEnemies || 10;
    if (currentEnemyCount < maxEnemies) {
      console.log(`[AI_SPAWNER] Current enemies: ${currentEnemyCount}/${maxEnemies}`);
    }
  }
  /**
   * Validate enemy states and clean up orphaned entities
   */
  validateEnemyStates(world) {
    if (!world) return;
    const orphanedIds = [];
    for (const enemyId of this.registeredEnemyIds) {
      const entity = world.getEntity(enemyId);
      if (!entity) {
        orphanedIds.push(enemyId);
      }
    }
    for (const orphanedId of orphanedIds) {
      console.log(`[AI_SPAWNER] Cleaning up orphaned enemy ID: ${orphanedId}`);
      this.registeredEnemyIds.delete(orphanedId);
    }
    if (orphanedIds.length > 0) {
      console.log(`[AI_SPAWNER] Cleaned up ${orphanedIds.length} orphaned enemy references`);
    }
  }
  /**
   * Emergency cleanup of all AI and spawner resources
   */
  emergencyCleanup() {
    var _a;
    console.log(`[AI_SPAWNER] Emergency cleanup initiated for ${this.registeredEnemyIds.size} enemies`);
    if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
      const enemySystem = window.game.ecsWorld.enemySystem;
      for (const enemyId of this.registeredEnemyIds) {
        try {
          const entity = (_a = enemySystem.world) == null ? void 0 : _a.getEntity(enemyId);
          if (entity && typeof enemySystem.returnEnemyToPool === "function") {
            enemySystem.returnEnemyToPool(entity);
          }
        } catch (error) {
          console.error(`[AI_SPAWNER] Error during emergency cleanup of enemy ${enemyId}:`, error);
        }
      }
    }
    this.clearAllEnemies();
    console.log("[AI_SPAWNER] Emergency cleanup completed");
  }
  /**
   * Get spawner statistics
   */
  getSpawnerStats() {
    return {
      registeredEnemies: this.registeredEnemyIds.size,
      enemyIds: Array.from(this.registeredEnemyIds)
    };
  }
  /**
   * Set spawner enabled state
   */
  setSpawnerEnabled(enabled) {
    if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
      const enemySystem = window.game.ecsWorld.enemySystem;
      if (typeof enemySystem.setEnabled === "function") {
        enemySystem.setEnabled(enabled);
      } else {
        enemySystem.enabled = enabled;
      }
      console.log(`[AI_SPAWNER] Enemy spawner ${enabled ? "enabled" : "disabled"}`);
    }
  }
  /**
   * Force spawn point regeneration
   */
  regenerateSpawnPoints() {
    if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
      const enemySystem = window.game.ecsWorld.enemySystem;
      if (enemySystem.spawner && typeof enemySystem.spawner.generateSpawnPoints === "function") {
        enemySystem.spawner.generateSpawnPoints();
        console.log("[AI_SPAWNER] Forced spawn point regeneration");
      }
    }
  }
}
class CombatLogic {
  constructor(effectsManager, eventManager, aiSpawnerManager) {
    this.effectsManager = effectsManager;
    this.eventManager = eventManager;
    this.aiSpawnerManager = aiSpawnerManager;
  }
  /**
   * Fire the particle cannon with raycast-based enemy collision detection
   */
  fireParticleCannon(scene, spaceship, world, playerEntity, projectileDamage, lastFireTime, cooldown) {
    if (!spaceship || !spaceship.mesh) return { success: false, newLastFireTime: lastFireTime };
    const currentTime = performance.now();
    if (currentTime - lastFireTime < cooldown) {
      return { success: false, newLastFireTime: lastFireTime };
    }
    console.log("*** COMBAT MODULE: Firing pulse cannon with railgun effect ***");
    const shipPosition = spaceship.mesh.position.clone();
    const camera = scene.camera;
    if (!camera) {
      console.error("Camera not available for aiming");
      return { success: false, newLastFireTime: lastFireTime };
    }
    const raycaster = new Raycaster();
    const screenCenter = new Vector2(0, 0);
    raycaster.setFromCamera(screenCenter, camera);
    const direction = raycaster.ray.direction.clone().normalize();
    const maxRange = 5e3;
    console.log(`Projectile direction (using camera ray): ${direction.x.toFixed(2)}, ${direction.y.toFixed(2)}, ${direction.z.toFixed(2)}`);
    const weaponPositions = this.calculateWeaponPositions(shipPosition, direction);
    if (window.game && window.game.audio) {
      console.log("Playing ASMR projectile sound for particle cannon");
      window.game.audio.playSound("projectile");
    }
    const { leftHitPoint, rightHitPoint, leftHitEnemy, rightHitEnemy } = this.checkEnemyCollisions(world, raycaster, shipPosition, playerEntity, projectileDamage);
    const leftEndPoint = leftHitPoint || weaponPositions.leftWeaponPosition.clone().add(direction.clone().multiplyScalar(maxRange));
    this.effectsManager.createInstantTracer(weaponPositions.leftWeaponPosition, leftEndPoint, leftHitEnemy, 0.4);
    const rightEndPoint = rightHitPoint || weaponPositions.rightWeaponPosition.clone().add(direction.clone().multiplyScalar(maxRange));
    this.effectsManager.createInstantTracer(weaponPositions.rightWeaponPosition, rightEndPoint, rightHitEnemy, 0.4);
    if (leftHitPoint && leftHitEnemy) {
      this.effectsManager.createExplosionEffect(leftHitPoint, 0.5);
    }
    if (rightHitPoint && rightHitEnemy && rightHitPoint.distanceTo(leftHitPoint || rightHitPoint) > 10) {
      this.effectsManager.createExplosionEffect(rightHitPoint, 0.5);
    }
    return { success: true, newLastFireTime: currentTime };
  }
  /**
   * Calculate weapon port positions for dual projectiles
   */
  calculateWeaponPositions(shipPosition, direction) {
    const right = new Vector3().crossVectors(direction, new Vector3(0, 1, 0)).normalize();
    const leftOffset = new Vector3().copy(right).multiplyScalar(-1.5);
    const rightOffset = new Vector3().copy(right).multiplyScalar(1.5);
    const weaponForwardOffset = new Vector3().copy(direction).multiplyScalar(25);
    const leftWeaponPosition = new Vector3().copy(shipPosition).add(leftOffset).add(weaponForwardOffset);
    const rightWeaponPosition = new Vector3().copy(shipPosition).add(rightOffset).add(weaponForwardOffset);
    return { leftWeaponPosition, rightWeaponPosition };
  }
  /**
   * Check for enemy collisions using raycasting
   */
  checkEnemyCollisions(world, raycaster, shipPosition, playerEntity, projectileDamage) {
    let leftHitPoint = null;
    let rightHitPoint = null;
    let leftHitEnemy = false;
    let rightHitEnemy = false;
    console.log("DIRECT ENEMY CHECK: Searching for enemies to destroy");
    if (world && world.entityManager) {
      const enemies = this.findEnemies(world);
      for (const enemy of enemies) {
        if (!enemy) continue;
        const hitResult = this.checkSingleEnemyCollision(enemy, raycaster, shipPosition, playerEntity, projectileDamage);
        if (hitResult.hit) {
          if (!leftHitEnemy) {
            leftHitPoint = hitResult.hitPoint;
            leftHitEnemy = true;
          } else if (!rightHitEnemy) {
            rightHitPoint = hitResult.hitPoint;
            rightHitEnemy = true;
          }
        }
      }
    } else {
      console.log("No world or entityManager available for enemy check");
    }
    return { leftHitPoint, rightHitPoint, leftHitEnemy, rightHitEnemy };
  }
  /**
   * Find enemies in the world
   */
  findEnemies(world) {
    let enemies = [];
    try {
      if (world.entityManager.entitiesByTag && world.entityManager.entitiesByTag.get("enemy")) {
        enemies = world.entityManager.entitiesByTag.get("enemy");
        console.log(`Found ${enemies.length} enemies via tag map`);
      } else {
        console.log("No enemy tag map, checking all entities");
        const allEntities = Array.from(world.entityManager.entities.values());
        for (const entity of allEntities) {
          if (entity.hasTag && entity.hasTag("enemy")) {
            enemies.push(entity);
          } else if (entity.hasComponent && entity.hasComponent("EnemyAIComponent")) {
            enemies.push(entity);
          }
        }
        console.log(`Found ${enemies.length} enemies by checking all entities`);
      }
    } catch (error) {
      console.error("Error finding enemies:", error);
    }
    return enemies;
  }
  /**
   * Check collision with a single enemy
   */
  checkSingleEnemyCollision(enemy, raycaster, shipPosition, playerEntity, projectileDamage) {
    try {
      let enemyPosition = null;
      const enemyTransform = enemy.getComponent("TransformComponent");
      if (enemyTransform) {
        enemyPosition = enemyTransform.position;
      } else {
        console.log("Enemy missing transform component");
        return { hit: false };
      }
      const enemyMeshComponent = enemy.getComponent("MeshComponent");
      if (!enemyMeshComponent || !enemyMeshComponent.mesh) {
        console.log(`Enemy ${enemy.id} has no mesh component or mesh`);
        return { hit: false };
      }
      console.log(`Testing ray intersection with enemy ${enemy.id}:`);
      console.log(`- Position: (${enemyPosition.x.toFixed(1)}, ${enemyPosition.y.toFixed(1)}, ${enemyPosition.z.toFixed(1)})`);
      console.log(`- Mesh visible: ${enemyMeshComponent.mesh.visible}`);
      console.log(`- Mesh children: ${enemyMeshComponent.mesh.children ? enemyMeshComponent.mesh.children.length : 0}`);
      const distanceToEnemy = shipPosition.distanceTo(enemyPosition);
      console.log(`- Distance to enemy: ${distanceToEnemy.toFixed(1)}`);
      if (!enemyMeshComponent.mesh.visible) {
        console.log(`Mesh for enemy ${enemy.id} is not visible, skipping`);
        return { hit: false };
      }
      const intersections = raycaster.intersectObject(enemyMeshComponent.mesh, true);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        console.log(`*** MESH HIT on enemy ${enemy.id}! ***`);
        console.log(`- Hit distance: ${intersection.distance.toFixed(2)}`);
        console.log(`- Hit point: (${intersection.point.x.toFixed(1)}, ${intersection.point.y.toFixed(1)}, ${intersection.point.z.toFixed(1)})`);
        if (intersection.object) {
          console.log(`- Hit specific object: ${intersection.object.name || "unnamed"}`);
        }
        if (intersection.face) {
          console.log(`- Hit face normal: (${intersection.face.normal.x.toFixed(2)}, ${intersection.face.normal.y.toFixed(2)}, ${intersection.face.normal.z.toFixed(2)})`);
        }
        this.handleEnemyDamage(enemy, enemyPosition, projectileDamage, playerEntity);
        return { hit: true, hitPoint: intersection.point };
      } else {
        console.log(`Ray missed enemy ${enemy.id} - no mesh intersection`);
        return { hit: false };
      }
    } catch (error) {
      console.error("Error checking enemy collision:", error);
      return { hit: false };
    }
  }
  /**
   * Handle enemy damage and destruction
   */
  handleEnemyDamage(enemy, enemyPosition, projectileDamage, playerEntity) {
    var _a, _b;
    const health = enemy.getComponent("HealthComponent");
    if (health) {
      console.log("Applying damage to enemy");
      health.applyDamage(projectileDamage, "particle", playerEntity);
      if (health.health <= 0) {
        console.log("Enemy health depleted, destroying entity");
        health.isDestroyed = true;
        if (enemyPosition) {
          this.effectsManager.createExplosionEffect(enemyPosition.clone());
          if (window.game && window.game.audio) {
            window.game.audio.playSound("boink");
          }
        }
        this.aiSpawnerManager.handleEnemyDestruction(enemy, "projectile");
        this.eventManager.notifyEnemySystemDestruction(enemy, "projectile");
        this.eventManager.publishEnemyDestroyed(enemy.world || ((_a = window.game) == null ? void 0 : _a.ecsWorld), enemy.id, "playerProjectile", enemyPosition);
        try {
          if (window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem) {
            const enemySystem = window.game.ecsWorld.enemySystem;
            if (typeof enemySystem.returnEnemyToPool === "function") {
              console.log(`Using EnemySystem.returnEnemyToPool for enemy ${enemy.id}`);
              enemySystem.returnEnemyToPool(enemy);
            }
            if (typeof enemySystem.validateEnemyReferences === "function") {
              enemySystem.validateEnemyReferences();
            }
          } else {
            const world = enemy.world || ((_b = window.game) == null ? void 0 : _b.ecsWorld);
            if (world && typeof world.destroyEntity === "function") {
              world.destroyEntity(enemy.id);
              console.log("Enemy destroyed via world.destroyEntity");
            }
          }
        } catch (e) {
          console.error("Failed to destroy enemy:", e);
        }
      } else {
        console.log(`Enemy hit but survived with ${health.health}/${health.maxHealth} health remaining`);
      }
    }
  }
}
class ObjectPool {
  /**
   * Create a new ObjectPool
   * @param {Function} createFn - Factory function to create new instances
   * @param {Function} resetFn - Function to reset an object to its initial state
   * @param {number} initialSize - Initial size of the pool
   * @param {number} expandSize - Number of objects to add when the pool is empty
   */
  constructor(createFn, resetFn, initialSize = 20, expandSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.expandSize = expandSize;
    this.pool = [];
    this.active = /* @__PURE__ */ new Set();
    this._hits = 0;
    this._misses = 0;
    this.expand(initialSize);
    console.log(`ObjectPool created with ${initialSize} objects`);
  }
  /**
   * Get an object from the pool or create a new one if the pool is empty
   * @returns {Object} An object from the pool
   */
  get() {
    let object;
    if (this.pool.length === 0) {
      console.log(`Pool empty, expanding by ${this.expandSize} objects`);
      this.expand(this.expandSize);
      this._misses++;
    }
    object = this.pool.pop();
    this._hits++;
    this.active.add(object);
    if (window.__perf) {
      const prev = window.__perf.pools || { hits: 0, misses: 0 };
      window.__perf.pools = {
        hits: (prev.hits || 0) + 1,
        misses: prev.misses || 0
      };
    }
    return object;
  }
  /**
   * Return an object to the pool
   * @param {Object} object - Object to return to the pool
   */
  release(object) {
    if (!this.active.has(object)) {
      return;
    }
    this.resetFn(object);
    this.active.delete(object);
    this.pool.push(object);
  }
  /**
   * Expand the pool by creating new objects
   * @param {number} count - Number of objects to add to the pool
   */
  expand(count) {
    for (let i = 0; i < count; i++) {
      const object = this.createFn();
      this.pool.push(object);
    }
    if (window.__perf) {
      const prev = window.__perf.pools || { hits: 0, misses: 0 };
      window.__perf.pools = {
        hits: prev.hits || 0,
        misses: (prev.misses || 0) + count
      };
    }
  }
  /**
   * Get the number of available objects in the pool
   * @returns {number} Count of available objects
   */
  availableCount() {
    return this.pool.length;
  }
  /**
   * Get the number of active objects from this pool
   * @returns {number} Count of active objects
   */
  activeCount() {
    return this.active.size;
  }
  /**
   * Release all active objects back to the pool
   */
  releaseAll() {
    const activeObjects = Array.from(this.active);
    for (const object of activeObjects) {
      this.release(object);
    }
  }
  /**
   * Clear the pool and dispose all objects
   * @param {Function} disposeFn - Function to dispose an object
   */
  dispose(disposeFn) {
    if (disposeFn) {
      for (const object of this.active) {
        disposeFn(object);
      }
      for (const object of this.pool) {
        disposeFn(object);
      }
    }
    this.active.clear();
    this.pool = [];
  }
}
class LaserProjectilePool {
  /**
   * Create a new LaserProjectilePool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePool();
  }
  /**
   * Initialize the laser projectile pool
   */
  initializePool() {
    this.pool = new ObjectPool(
      // Create function
      () => this.createLaserProjectile(),
      // Reset function
      (projectile) => this.resetLaserProjectile(projectile),
      30,
      // Initial size - lasers are common
      10
      // Expand size
    );
  }
  /**
   * Create a new laser projectile
   * @returns {THREE.Mesh} A laser projectile mesh
   */
  createLaserProjectile() {
    const projectile = new Mesh(
      this.sharedAssets.projectileGeometry,
      this.sharedAssets.projectileMaterial.clone()
    );
    const glowMesh = new Mesh(
      this.sharedAssets.projectileGlowGeometry,
      this.sharedAssets.projectileGlowMaterial.clone()
    );
    projectile.material.color.setHex(65535);
    projectile.material.emissive.setHex(17476);
    glowMesh.material.color.setHex(65535);
    glowMesh.material.opacity = 0.8;
    glowMesh.scale.set(1.5, 1.5, 1.5);
    projectile.add(glowMesh);
    projectile.userData = {
      isProjectile: true,
      projectileType: "laser",
      active: false,
      pooled: true,
      glowMesh,
      speed: 2e3,
      // High speed for lasers
      damage: 25,
      penetration: true,
      // Lasers can penetrate
      energyDrain: 15
    };
    return projectile;
  }
  /**
   * Reset a laser projectile to initial state
   * @param {THREE.Mesh} projectile - The projectile to reset
   */
  resetLaserProjectile(projectile) {
    projectile.position.set(0, 0, 0);
    projectile.rotation.set(0, 0, 0);
    projectile.scale.set(1, 1, 1);
    projectile.visible = false;
    projectile.material.color.setHex(65535);
    projectile.material.emissive.setHex(17476);
    projectile.material.opacity = 1;
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.opacity = 0.8;
      projectile.userData.glowMesh.scale.set(1.5, 1.5, 1.5);
    }
    projectile.userData.active = false;
    projectile.userData.creationTime = 0;
    projectile.userData.entityId = null;
    projectile.userData.trail = null;
    projectile.userData.trailParticles = null;
    projectile.userData.target = null;
    projectile.userData.firedBy = null;
  }
  /**
   * Get a laser projectile from the pool
   * @returns {THREE.Mesh} A laser projectile mesh
   */
  get() {
    const projectile = this.pool.get();
    projectile.visible = true;
    projectile.userData.active = true;
    projectile.userData.creationTime = performance.now();
    if (!projectile.parent) {
      this._addToScene(projectile);
    }
    return projectile;
  }
  /**
   * Release a laser projectile back to the pool
   * @param {THREE.Mesh} projectile - The projectile to release
   */
  release(projectile) {
    if (!projectile || !projectile.userData || !projectile.userData.isProjectile || projectile.userData.projectileType !== "laser") {
      return;
    }
    if (projectile.parent) {
      this._removeFromParent(projectile);
    }
    this.pool.release(projectile);
  }
  /**
   * Get count of available projectiles in pool
   * @returns {number} Available count
   */
  availableCount() {
    return this.pool.availableCount();
  }
  /**
   * Get count of active projectiles
   * @returns {number} Active count
   */
  activeCount() {
    return this.pool.activeCount();
  }
  /**
   * Get all active laser projectiles
   * @returns {Set} Set of active projectiles
   */
  getActive() {
    return this.pool.active;
  }
  /**
   * Dispose the laser projectile pool
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.pool.dispose((projectile) => {
      if (projectile.parent) {
        this._removeFromParent(projectile);
      }
      if (projectile.material) {
        projectile.material.dispose();
      }
      if (projectile.userData.glowMesh && projectile.userData.glowMesh.material) {
        projectile.userData.glowMesh.material.dispose();
      }
      if (disposeFn) {
        disposeFn(projectile);
      }
    });
  }
}
class MissileProjectilePool {
  /**
   * Create a new MissileProjectilePool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePool();
  }
  /**
   * Initialize the missile projectile pool
   */
  initializePool() {
    this.pool = new ObjectPool(
      // Create function
      () => this.createMissileProjectile(),
      // Reset function
      (projectile) => this.resetMissileProjectile(projectile),
      20,
      // Initial size - missiles less common than lasers
      8
      // Expand size
    );
  }
  /**
   * Create a new missile projectile
   * @returns {THREE.Mesh} A missile projectile mesh
   */
  createMissileProjectile() {
    const projectile = new Mesh(
      this.sharedAssets.projectileGeometry,
      this.sharedAssets.projectileMaterial.clone()
    );
    const glowMesh = new Mesh(
      this.sharedAssets.projectileGlowGeometry,
      this.sharedAssets.projectileGlowMaterial.clone()
    );
    projectile.material.color.setHex(16729088);
    projectile.material.emissive.setHex(4460800);
    glowMesh.material.color.setHex(16737792);
    glowMesh.material.opacity = 0.7;
    glowMesh.scale.set(1.2, 1.2, 2);
    projectile.scale.set(1.3, 1.3, 1.8);
    projectile.add(glowMesh);
    projectile.userData = {
      isProjectile: true,
      projectileType: "missile",
      active: false,
      pooled: true,
      glowMesh,
      speed: 800,
      // Slower than lasers but guided
      damage: 75,
      aoeRadius: 100,
      // Area of effect damage
      guidance: true,
      // Can track targets
      fuelTime: 5e3,
      // 5 seconds of fuel
      explosionRadius: 120
    };
    return projectile;
  }
  /**
   * Reset a missile projectile to initial state
   * @param {THREE.Mesh} projectile - The projectile to reset
   */
  resetMissileProjectile(projectile) {
    projectile.position.set(0, 0, 0);
    projectile.rotation.set(0, 0, 0);
    projectile.scale.set(1.3, 1.3, 1.8);
    projectile.visible = false;
    projectile.material.color.setHex(16729088);
    projectile.material.emissive.setHex(4460800);
    projectile.material.opacity = 1;
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.opacity = 0.7;
      projectile.userData.glowMesh.scale.set(1.2, 1.2, 2);
    }
    projectile.userData.active = false;
    projectile.userData.creationTime = 0;
    projectile.userData.entityId = null;
    projectile.userData.trail = null;
    projectile.userData.trailParticles = null;
    projectile.userData.target = null;
    projectile.userData.firedBy = null;
    projectile.userData.fuelRemaining = projectile.userData.fuelTime;
    projectile.userData.guidanceActive = true;
    projectile.userData.hasExploded = false;
  }
  /**
   * Get a missile projectile from the pool
   * @returns {THREE.Mesh} A missile projectile mesh
   */
  get() {
    const projectile = this.pool.get();
    projectile.visible = true;
    projectile.userData.active = true;
    projectile.userData.creationTime = performance.now();
    projectile.userData.fuelRemaining = projectile.userData.fuelTime;
    projectile.userData.guidanceActive = true;
    projectile.userData.hasExploded = false;
    if (!projectile.parent) {
      this._addToScene(projectile);
    }
    return projectile;
  }
  /**
   * Release a missile projectile back to the pool
   * @param {THREE.Mesh} projectile - The projectile to release
   */
  release(projectile) {
    if (!projectile || !projectile.userData || !projectile.userData.isProjectile || projectile.userData.projectileType !== "missile") {
      return;
    }
    if (projectile.parent) {
      this._removeFromParent(projectile);
    }
    this.pool.release(projectile);
  }
  /**
   * Update missile-specific behavior (fuel consumption, guidance)
   * @param {THREE.Mesh} projectile - The missile to update
   * @param {number} deltaTime - Time since last update
   */
  updateMissile(projectile, deltaTime) {
    if (!projectile.userData.active) return;
    projectile.userData.fuelRemaining -= deltaTime;
    if (projectile.userData.fuelRemaining <= 0) {
      projectile.userData.guidanceActive = false;
      if (projectile.userData.glowMesh) {
        projectile.userData.glowMesh.material.opacity *= 0.95;
      }
    }
    if (projectile.userData.glowMesh && projectile.userData.fuelRemaining > 0) {
      const fuelRatio = projectile.userData.fuelRemaining / projectile.userData.fuelTime;
      projectile.userData.glowMesh.material.opacity = 0.7 * fuelRatio;
    }
  }
  /**
   * Get count of available projectiles in pool
   * @returns {number} Available count
   */
  availableCount() {
    return this.pool.availableCount();
  }
  /**
   * Get count of active projectiles
   * @returns {number} Active count
   */
  activeCount() {
    return this.pool.activeCount();
  }
  /**
   * Get all active missile projectiles
   * @returns {Set} Set of active projectiles
   */
  getActive() {
    return this.pool.active;
  }
  /**
   * Dispose the missile projectile pool
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.pool.dispose((projectile) => {
      if (projectile.parent) {
        this._removeFromParent(projectile);
      }
      if (projectile.material) {
        projectile.material.dispose();
      }
      if (projectile.userData.glowMesh && projectile.userData.glowMesh.material) {
        projectile.userData.glowMesh.material.dispose();
      }
      if (disposeFn) {
        disposeFn(projectile);
      }
    });
  }
}
class PlasmaProjectilePool {
  /**
   * Create a new PlasmaProjectilePool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePool();
  }
  /**
   * Initialize the plasma projectile pool
   */
  initializePool() {
    this.pool = new ObjectPool(
      // Create function
      () => this.createPlasmaProjectile(),
      // Reset function
      (projectile) => this.resetPlasmaProjectile(projectile),
      25,
      // Initial size - medium usage
      8
      // Expand size
    );
  }
  /**
   * Create a new plasma projectile
   * @returns {THREE.Mesh} A plasma projectile mesh
   */
  createPlasmaProjectile() {
    const projectile = new Mesh(
      this.sharedAssets.projectileGeometry,
      this.sharedAssets.projectileMaterial.clone()
    );
    const glowMesh = new Mesh(
      this.sharedAssets.projectileGlowGeometry,
      this.sharedAssets.projectileGlowMaterial.clone()
    );
    projectile.material.color.setHex(8913151);
    projectile.material.emissive.setHex(4456584);
    glowMesh.material.color.setHex(11141375);
    glowMesh.material.opacity = 0.9;
    glowMesh.scale.set(1.3, 1.3, 1.3);
    projectile.scale.set(1.1, 1.1, 1.2);
    projectile.add(glowMesh);
    projectile.userData = {
      isProjectile: true,
      projectileType: "plasma",
      active: false,
      pooled: true,
      glowMesh,
      speed: 1200,
      // Medium speed
      damage: 40,
      empEffect: true,
      // Electromagnetic pulse
      energyDrain: 20,
      pulsePhase: 0,
      // For pulsing animation
      chargeLevel: 1
    };
    return projectile;
  }
  /**
   * Reset a plasma projectile to initial state
   * @param {THREE.Mesh} projectile - The projectile to reset
   */
  resetPlasmaProjectile(projectile) {
    projectile.position.set(0, 0, 0);
    projectile.rotation.set(0, 0, 0);
    projectile.scale.set(1.1, 1.1, 1.2);
    projectile.visible = false;
    projectile.material.color.setHex(8913151);
    projectile.material.emissive.setHex(4456584);
    projectile.material.opacity = 1;
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.opacity = 0.9;
      projectile.userData.glowMesh.scale.set(1.3, 1.3, 1.3);
    }
    projectile.userData.active = false;
    projectile.userData.creationTime = 0;
    projectile.userData.entityId = null;
    projectile.userData.trail = null;
    projectile.userData.trailParticles = null;
    projectile.userData.target = null;
    projectile.userData.firedBy = null;
    projectile.userData.pulsePhase = 0;
    projectile.userData.chargeLevel = 1;
  }
  /**
   * Get a plasma projectile from the pool
   * @returns {THREE.Mesh} A plasma projectile mesh
   */
  get() {
    const projectile = this.pool.get();
    projectile.visible = true;
    projectile.userData.active = true;
    projectile.userData.creationTime = performance.now();
    projectile.userData.pulsePhase = 0;
    projectile.userData.chargeLevel = 1;
    if (!projectile.parent) {
      this._addToScene(projectile);
    }
    return projectile;
  }
  /**
   * Release a plasma projectile back to the pool
   * @param {THREE.Mesh} projectile - The projectile to release
   */
  release(projectile) {
    if (!projectile || !projectile.userData || !projectile.userData.isProjectile || projectile.userData.projectileType !== "plasma") {
      return;
    }
    if (projectile.parent) {
      this._removeFromParent(projectile);
    }
    this.pool.release(projectile);
  }
  /**
   * Update plasma-specific behavior (pulsing, charge decay)
   * @param {THREE.Mesh} projectile - The plasma to update
   * @param {number} deltaTime - Time since last update
   */
  updatePlasma(projectile, deltaTime) {
    if (!projectile.userData.active) return;
    const time = performance.now() * 1e-3;
    projectile.userData.pulsePhase = time * 4;
    const age = time * 1e3 - projectile.userData.creationTime;
    const maxAge = 3e3;
    projectile.userData.chargeLevel = Math.max(0, 1 - age / maxAge);
    if (projectile.userData.glowMesh) {
      const pulse = 0.5 + 0.5 * Math.sin(projectile.userData.pulsePhase);
      const chargeModifier = projectile.userData.chargeLevel;
      projectile.userData.glowMesh.material.opacity = 0.9 * pulse * chargeModifier;
      const scale = 1.3 + 0.2 * pulse * chargeModifier;
      projectile.userData.glowMesh.scale.set(scale, scale, scale);
    }
    if (projectile.material) {
      const fadeIntensity = 0.5 + 0.5 * projectile.userData.chargeLevel;
      projectile.material.opacity = fadeIntensity;
    }
  }
  /**
   * Get count of available projectiles in pool
   * @returns {number} Available count
   */
  availableCount() {
    return this.pool.availableCount();
  }
  /**
   * Get count of active projectiles
   * @returns {number} Active count
   */
  activeCount() {
    return this.pool.activeCount();
  }
  /**
   * Get all active plasma projectiles
   * @returns {Set} Set of active projectiles
   */
  getActive() {
    return this.pool.active;
  }
  /**
   * Dispose the plasma projectile pool
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.pool.dispose((projectile) => {
      if (projectile.parent) {
        this._removeFromParent(projectile);
      }
      if (projectile.material) {
        projectile.material.dispose();
      }
      if (projectile.userData.glowMesh && projectile.userData.glowMesh.material) {
        projectile.userData.glowMesh.material.dispose();
      }
      if (disposeFn) {
        disposeFn(projectile);
      }
    });
  }
}
class BulletProjectilePool {
  /**
   * Create a new BulletProjectilePool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePool();
  }
  /**
   * Initialize the bullet projectile pool
   */
  initializePool() {
    this.pool = new ObjectPool(
      // Create function
      () => this.createBulletProjectile(),
      // Reset function
      (projectile) => this.resetBulletProjectile(projectile),
      40,
      // Initial size - bullets very common
      15
      // Expand size
    );
  }
  /**
   * Create a new bullet projectile
   * @returns {THREE.Mesh} A bullet projectile mesh
   */
  createBulletProjectile() {
    const projectile = new Mesh(
      this.sharedAssets.projectileGeometry,
      this.sharedAssets.projectileMaterial.clone()
    );
    const glowMesh = new Mesh(
      this.sharedAssets.projectileGlowGeometry,
      this.sharedAssets.projectileGlowMaterial.clone()
    );
    projectile.material.color.setHex(16768256);
    projectile.material.emissive.setHex(3351040);
    projectile.material.metalness = 0.8;
    projectile.material.roughness = 0.2;
    glowMesh.material.color.setHex(16772676);
    glowMesh.material.opacity = 0.4;
    glowMesh.scale.set(0.8, 0.8, 0.8);
    projectile.scale.set(0.7, 0.7, 1.5);
    projectile.add(glowMesh);
    projectile.userData = {
      isProjectile: true,
      projectileType: "bullet",
      active: false,
      pooled: true,
      glowMesh,
      speed: 2500,
      // Very high speed
      damage: 15,
      kinetic: true,
      // Physical impact
      energyDrain: 2,
      // Very low energy cost
      penetration: false,
      ricochet: true
      // Can ricochet off surfaces
    };
    return projectile;
  }
  /**
   * Reset a bullet projectile to initial state
   * @param {THREE.Mesh} projectile - The projectile to reset
   */
  resetBulletProjectile(projectile) {
    projectile.position.set(0, 0, 0);
    projectile.rotation.set(0, 0, 0);
    projectile.scale.set(0.7, 0.7, 1.5);
    projectile.visible = false;
    projectile.material.color.setHex(16768256);
    projectile.material.emissive.setHex(3351040);
    projectile.material.opacity = 1;
    projectile.material.metalness = 0.8;
    projectile.material.roughness = 0.2;
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.opacity = 0.4;
      projectile.userData.glowMesh.scale.set(0.8, 0.8, 0.8);
    }
    projectile.userData.active = false;
    projectile.userData.creationTime = 0;
    projectile.userData.entityId = null;
    projectile.userData.trail = null;
    projectile.userData.trailParticles = null;
    projectile.userData.target = null;
    projectile.userData.firedBy = null;
    projectile.userData.ricochetCount = 0;
    projectile.userData.spinRate = Math.random() * 0.1 + 0.05;
  }
  /**
   * Get a bullet projectile from the pool
   * @returns {THREE.Mesh} A bullet projectile mesh
   */
  get() {
    const projectile = this.pool.get();
    projectile.visible = true;
    projectile.userData.active = true;
    projectile.userData.creationTime = performance.now();
    projectile.userData.ricochetCount = 0;
    projectile.userData.spinRate = Math.random() * 0.1 + 0.05;
    if (!projectile.parent) {
      this._addToScene(projectile);
    }
    return projectile;
  }
  /**
   * Release a bullet projectile back to the pool
   * @param {THREE.Mesh} projectile - The projectile to release
   */
  release(projectile) {
    if (!projectile || !projectile.userData || !projectile.userData.isProjectile || projectile.userData.projectileType !== "bullet") {
      return;
    }
    if (projectile.parent) {
      this._removeFromParent(projectile);
    }
    this.pool.release(projectile);
  }
  /**
   * Update bullet-specific behavior (spinning, ricochet effects)
   * @param {THREE.Mesh} projectile - The bullet to update
   * @param {number} deltaTime - Time since last update
   */
  updateBullet(projectile, deltaTime) {
    if (!projectile.userData.active) return;
    projectile.rotation.z += projectile.userData.spinRate * deltaTime * 0.01;
    const age = performance.now() - projectile.userData.creationTime;
    const maxAge = 2e3;
    const ageFactor = Math.max(0, 1 - age / maxAge);
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.opacity = 0.4 * ageFactor;
    }
    if (projectile.material) {
      projectile.material.metalness = 0.8 * ageFactor;
    }
  }
  /**
   * Handle bullet ricochet logic
   * @param {THREE.Mesh} projectile - The bullet that ricocheted
   * @param {THREE.Vector3} newDirection - New direction after ricochet
   * @returns {boolean} True if ricochet was successful, false if bullet should be destroyed
   */
  handleRicochet(projectile, newDirection) {
    if (!projectile.userData.ricochet) return false;
    projectile.userData.ricochetCount++;
    if (projectile.userData.ricochetCount > 3) {
      return false;
    }
    const damageReduction = 0.7;
    const speedReduction = 0.8;
    projectile.userData.damage *= damageReduction;
    projectile.userData.speed *= speedReduction;
    if (projectile.userData.glowMesh) {
      projectile.userData.glowMesh.material.color.setHex(16746496);
      projectile.userData.glowMesh.material.opacity = 0.8;
    }
    return true;
  }
  /**
   * Get count of available projectiles in pool
   * @returns {number} Available count
   */
  availableCount() {
    return this.pool.availableCount();
  }
  /**
   * Get count of active projectiles
   * @returns {number} Active count
   */
  activeCount() {
    return this.pool.activeCount();
  }
  /**
   * Get all active bullet projectiles
   * @returns {Set} Set of active projectiles
   */
  getActive() {
    return this.pool.active;
  }
  /**
   * Dispose the bullet projectile pool
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.pool.dispose((projectile) => {
      if (projectile.parent) {
        this._removeFromParent(projectile);
      }
      if (projectile.material) {
        projectile.material.dispose();
      }
      if (projectile.userData.glowMesh && projectile.userData.glowMesh.material) {
        projectile.userData.glowMesh.material.dispose();
      }
      if (disposeFn) {
        disposeFn(projectile);
      }
    });
  }
}
class TrailEffectsPool {
  /**
   * Create a new TrailEffectsPool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePools();
  }
  /**
   * Initialize trail container and particle pools
   */
  initializePools() {
    this.trailContainerPool = new ObjectPool(
      // Create function
      () => this.createTrailContainer(),
      // Reset function
      (trailContainer) => this.resetTrailContainer(trailContainer),
      30,
      // Initial size
      10
      // Expand size
    );
    this.trailParticlePool = new ObjectPool(
      // Create function
      () => this.createTrailParticle(),
      // Reset function
      (particle) => this.resetTrailParticle(particle),
      600,
      // Initial size (20 trails * 30 particles per trail)
      100
      // Expand size
    );
  }
  /**
   * Create a new trail container
   * @returns {THREE.Object3D} A trail container
   */
  createTrailContainer() {
    const trailContainer = new Object3D();
    trailContainer.userData = {
      isTrail: true,
      active: false,
      pooled: true,
      particles: [],
      maxParticles: 30,
      particleLifetime: 1e3,
      // 1 second
      emissionRate: 50
      // particles per second
    };
    return trailContainer;
  }
  /**
   * Reset a trail container to initial state
   * @param {THREE.Object3D} trailContainer - The container to reset
   */
  resetTrailContainer(trailContainer) {
    trailContainer.position.set(0, 0, 0);
    trailContainer.rotation.set(0, 0, 0);
    trailContainer.visible = false;
    trailContainer.userData.active = false;
    trailContainer.userData.parentProjectile = null;
    trailContainer.userData.lastEmissionTime = 0;
    trailContainer.userData.particles = [];
  }
  /**
   * Create a new trail particle
   * @returns {THREE.Mesh} A trail particle mesh
   */
  createTrailParticle() {
    const particle = new Mesh(
      this.sharedAssets.trailParticleGeometries[0],
      this.sharedAssets.trailParticleMaterial.clone()
    );
    particle.userData = {
      isTrailParticle: true,
      active: false,
      pooled: true,
      sizeIndex: 0,
      initialOffset: new Vector3(),
      birthTime: 0,
      lifetime: 1e3,
      velocity: new Vector3()
    };
    return particle;
  }
  /**
   * Reset a trail particle to initial state
   * @param {THREE.Mesh} particle - The particle to reset
   */
  resetTrailParticle(particle) {
    particle.position.set(0, 0, 0);
    particle.visible = false;
    particle.material.opacity = 0.9;
    particle.userData.active = false;
    particle.userData.sizeIndex = 0;
    particle.userData.initialOffset.set(0, 0, 0);
    particle.userData.initialOpacity = 0.9;
    particle.userData.birthTime = 0;
    particle.userData.velocity.set(0, 0, 0);
  }
  /**
   * Get a trail container from the pool
   * @returns {THREE.Object3D} A trail container
   */
  getTrailContainer() {
    const trailContainer = this.trailContainerPool.get();
    trailContainer.visible = true;
    trailContainer.userData.active = true;
    trailContainer.userData.lastEmissionTime = performance.now();
    return trailContainer;
  }
  /**
   * Get a trail particle from the pool
   * @param {number} sizeIndex - Index of the size to use
   * @returns {THREE.Mesh} A trail particle mesh
   */
  getTrailParticle(sizeIndex = 0) {
    const particle = this.trailParticlePool.get();
    particle.visible = true;
    particle.userData.active = true;
    particle.userData.sizeIndex = sizeIndex;
    particle.userData.birthTime = performance.now();
    if (sizeIndex >= 0 && sizeIndex < this.sharedAssets.trailParticleGeometries.length) {
      particle.geometry = this.sharedAssets.trailParticleGeometries[sizeIndex];
    }
    return particle;
  }
  /**
   * Create a trail for a projectile
   * @param {THREE.Mesh} projectile - The projectile to attach trail to
   * @param {object} options - Trail configuration options
   * @returns {THREE.Object3D} The trail container
   */
  createTrailForProjectile(projectile, options = {}) {
    const trail = this.getTrailContainer();
    const defaultOptions = {
      maxParticles: 30,
      particleLifetime: 1e3,
      emissionRate: 50,
      color: 16777215,
      opacity: 0.9
    };
    const config = { ...defaultOptions, ...options };
    if (projectile.userData.projectileType) {
      switch (projectile.userData.projectileType) {
        case "laser":
          config.color = 65535;
          config.particleLifetime = 500;
          config.emissionRate = 80;
          break;
        case "missile":
          config.color = 16737792;
          config.particleLifetime = 1500;
          config.emissionRate = 60;
          config.maxParticles = 40;
          break;
        case "plasma":
          config.color = 11141375;
          config.particleLifetime = 800;
          config.emissionRate = 70;
          break;
        case "bullet":
          config.color = 16772676;
          config.particleLifetime = 300;
          config.emissionRate = 30;
          config.maxParticles = 15;
          break;
      }
    }
    trail.userData.maxParticles = config.maxParticles;
    trail.userData.particleLifetime = config.particleLifetime;
    trail.userData.emissionRate = config.emissionRate;
    trail.userData.trailColor = config.color;
    trail.userData.trailOpacity = config.opacity;
    trail.userData.parentProjectile = projectile;
    projectile.add(trail);
    projectile.userData.trail = trail;
    return trail;
  }
  /**
   * Update all active trail effects
   * @param {number} deltaTime - Time since last update
   */
  updateTrails(deltaTime) {
    const currentTime = performance.now();
    for (const trail of this.trailContainerPool.active) {
      this.updateTrailContainer(trail, deltaTime, currentTime);
    }
    for (const particle of this.trailParticlePool.active) {
      this.updateTrailParticle(particle, deltaTime, currentTime);
    }
  }
  /**
   * Update a single trail container
   * @param {THREE.Object3D} trail - The trail to update
   * @param {number} deltaTime - Time since last update
   * @param {number} currentTime - Current timestamp
   */
  updateTrailContainer(trail, deltaTime, currentTime) {
    if (!trail.userData.active) return;
    const projectile = trail.userData.parentProjectile;
    if (projectile && projectile.userData.active) {
      const timeSinceLastEmission = currentTime - trail.userData.lastEmissionTime;
      const emissionInterval = 1e3 / trail.userData.emissionRate;
      if (timeSinceLastEmission >= emissionInterval && trail.userData.particles.length < trail.userData.maxParticles) {
        this.emitTrailParticle(trail);
        trail.userData.lastEmissionTime = currentTime;
      }
    }
  }
  /**
   * Update a single trail particle
   * @param {THREE.Mesh} particle - The particle to update
   * @param {number} deltaTime - Time since last update
   * @param {number} currentTime - Current timestamp
   */
  updateTrailParticle(particle, deltaTime, currentTime) {
    if (!particle.userData.active) return;
    const age = currentTime - particle.userData.birthTime;
    const lifeProgress = age / particle.userData.lifetime;
    if (lifeProgress >= 1) {
      this.releaseTrailParticle(particle);
      return;
    }
    const opacity = particle.userData.initialOpacity * (1 - lifeProgress);
    particle.material.opacity = opacity;
    const scale = 1 - lifeProgress * 0.5;
    particle.scale.set(scale, scale, scale);
    if (particle.userData.velocity.length() > 0) {
      particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime * 1e-3));
    }
  }
  /**
   * Emit a new trail particle
   * @param {THREE.Object3D} trail - The trail container
   */
  emitTrailParticle(trail) {
    const sizeIndex = Math.floor(Math.random() * this.sharedAssets.trailParticleGeometries.length);
    const particle = this.getTrailParticle(sizeIndex);
    const randomOffset = new Vector3(
      (Math.random() - 0.5) * 20,
      (Math.random() - 0.5) * 20,
      (Math.random() - 0.5) * 20
    );
    particle.position.copy(randomOffset);
    particle.material.color.setHex(trail.userData.trailColor || 16777215);
    particle.userData.initialOpacity = trail.userData.trailOpacity || 0.9;
    particle.userData.lifetime = trail.userData.particleLifetime || 1e3;
    particle.userData.velocity.set(
      (Math.random() - 0.5) * 50,
      (Math.random() - 0.5) * 50,
      (Math.random() - 0.5) * 50
    );
    trail.add(particle);
    trail.userData.particles.push(particle);
  }
  /**
   * Release a trail container back to the pool
   * @param {THREE.Object3D} trail - The trail container to release
   */
  releaseTrail(trail) {
    if (!trail || !trail.userData || !trail.userData.isTrail) {
      return;
    }
    if (trail.userData.particles) {
      for (const particle of trail.userData.particles) {
        if (particle) {
          trail.remove(particle);
          this.releaseTrailParticle(particle);
        }
      }
    }
    trail.userData.particles = [];
    this.trailContainerPool.release(trail);
  }
  /**
   * Release a trail particle back to the pool
   * @param {THREE.Mesh} particle - The trail particle to release
   */
  releaseTrailParticle(particle) {
    if (!particle || !particle.userData || !particle.userData.isTrailParticle) {
      return;
    }
    if (particle.parent) {
      particle.parent.remove(particle);
    }
    this.trailParticlePool.release(particle);
  }
  /**
   * Get count statistics for debugging
   * @returns {object} Pool statistics
   */
  getStats() {
    return {
      trailContainers: {
        available: this.trailContainerPool.availableCount(),
        active: this.trailContainerPool.activeCount()
      },
      trailParticles: {
        available: this.trailParticlePool.availableCount(),
        active: this.trailParticlePool.activeCount()
      }
    };
  }
  /**
   * Dispose the trail effects pools
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.trailContainerPool.dispose((trail) => {
      if (trail.parent) {
        this._removeFromParent(trail);
      }
      if (disposeFn) {
        disposeFn(trail);
      }
    });
    this.trailParticlePool.dispose((particle) => {
      if (particle.parent) {
        this._removeFromParent(particle);
      }
      if (particle.material) {
        particle.material.dispose();
      }
      if (disposeFn) {
        disposeFn(particle);
      }
    });
  }
}
class ExplosionFactory {
  constructor(sharedAssets) {
    this.sharedAssets = sharedAssets;
  }
  /**
   * Create a new explosion effect
   * @returns {THREE.Points} An explosion particle system
   */
  createExplosion() {
    const particleCount = 200;
    const geometry = new BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      positions[i3] = (Math.random() - 0.5) * 100;
      positions[i3 + 1] = (Math.random() - 0.5) * 100;
      positions[i3 + 2] = (Math.random() - 0.5) * 100;
    }
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const material = this.sharedAssets.explosionParticleMaterial.clone();
    const explosion = new Points(geometry, material);
    explosion.userData = {
      isExplosion: true,
      effectType: "explosion",
      active: false,
      pooled: true,
      startTime: 0,
      duration: 1e3,
      // Default duration
      particleCount,
      initialPositions: positions.slice()
      // Store initial positions
    };
    return explosion;
  }
  /**
   * Reset explosion to initial state
   * @param {THREE.Points} explosion - The explosion to reset
   */
  resetExplosion(explosion) {
    explosion.position.set(0, 0, 0);
    explosion.visible = false;
    explosion.material.opacity = 1;
    explosion.material.color.setHex(16737792);
    explosion.userData.active = false;
    explosion.userData.startTime = 0;
    explosion.userData.duration = 1e3;
    const positions = explosion.geometry.attributes.position.array;
    const initialPositions = explosion.userData.initialPositions;
    for (let i = 0; i < positions.length; i++) {
      positions[i] = initialPositions[i];
    }
    explosion.geometry.attributes.position.needsUpdate = true;
  }
  /**
   * Update all active explosions
   * @param {Array} activeExplosions - Array of active explosion objects
   * @param {Function} releaseCallback - Function to call when explosion should be released
   */
  updateExplosions(activeExplosions, releaseCallback) {
    for (const explosion of activeExplosions) {
      const elapsed = Date.now() - explosion.userData.startTime;
      const duration = explosion.userData.duration;
      const progress = elapsed / duration;
      if (progress >= 1) {
        releaseCallback(explosion);
      } else {
        const positions = explosion.geometry.attributes.position.array;
        const initialPositions = explosion.userData.initialPositions;
        const particleCount = explosion.userData.particleCount;
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const expansionFactor = 1 + progress * 5;
          positions[i3] = initialPositions[i3] * expansionFactor;
          positions[i3 + 1] = initialPositions[i3 + 1] * expansionFactor;
          positions[i3 + 2] = initialPositions[i3 + 2] * expansionFactor;
        }
        explosion.geometry.attributes.position.needsUpdate = true;
        explosion.material.opacity = 1 - progress;
      }
    }
  }
}
class SparkFactory {
  constructor(sharedAssets) {
    this.sharedAssets = sharedAssets;
  }
  /**
   * Create a spark effect for impacts
   * @returns {THREE.Points} A spark particle system
   */
  createSparkEffect() {
    const particleCount = 50;
    const geometry = new BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const angle = Math.random() * Math.PI * 2;
      const elevation = Math.random() * Math.PI * 0.3;
      const distance = Math.random() * 50 + 10;
      positions[i3] = Math.cos(angle) * Math.cos(elevation) * distance;
      positions[i3 + 1] = Math.sin(elevation) * distance;
      positions[i3 + 2] = Math.sin(angle) * Math.cos(elevation) * distance;
    }
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const material = this.sharedAssets.explosionParticleMaterial.clone();
    material.color.setHex(16772608);
    material.size = 2;
    const spark = new Points(geometry, material);
    spark.userData = {
      isSpark: true,
      effectType: "spark",
      active: false,
      pooled: true,
      startTime: 0,
      duration: 500,
      // Short duration for sparks
      particleCount,
      initialPositions: positions.slice()
    };
    return spark;
  }
  /**
   * Reset spark effect to initial state
   * @param {THREE.Points} spark - The spark effect to reset
   */
  resetSparkEffect(spark) {
    spark.position.set(0, 0, 0);
    spark.visible = false;
    spark.material.opacity = 1;
    spark.material.color.setHex(16772608);
    spark.userData.active = false;
    spark.userData.startTime = 0;
    spark.userData.duration = 500;
    const positions = spark.geometry.attributes.position.array;
    const initialPositions = spark.userData.initialPositions;
    for (let i = 0; i < positions.length; i++) {
      positions[i] = initialPositions[i];
    }
    spark.geometry.attributes.position.needsUpdate = true;
  }
  /**
   * Update all active spark effects
   * @param {Array} activeSparks - Array of active spark objects
   * @param {Function} releaseCallback - Function to call when spark should be released
   */
  updateSparks(activeSparks, releaseCallback) {
    for (const spark of activeSparks) {
      const elapsed = Date.now() - spark.userData.startTime;
      const duration = spark.userData.duration;
      const progress = elapsed / duration;
      if (progress >= 1) {
        releaseCallback(spark);
      } else {
        const positions = spark.geometry.attributes.position.array;
        const initialPositions = spark.userData.initialPositions;
        const particleCount = spark.userData.particleCount;
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const extension = 1 + progress * 3;
          positions[i3] = initialPositions[i3] * extension;
          positions[i3 + 1] = initialPositions[i3 + 1] * extension;
          positions[i3 + 2] = initialPositions[i3 + 2] * extension;
        }
        spark.geometry.attributes.position.needsUpdate = true;
        spark.material.opacity = 1 - progress;
      }
    }
  }
}
class DebrisFactory {
  constructor() {
  }
  /**
   * Create debris effect for impacts
   * @returns {THREE.Group} A debris group
   */
  createDebrisEffect() {
    const debris = new Group();
    const pieceCount = 8;
    for (let i = 0; i < pieceCount; i++) {
      const geometry = new BoxGeometry(2, 2, 2);
      const material = new MeshBasicMaterial({
        color: 6710886,
        transparent: true,
        opacity: 0.8
      });
      const piece = new Mesh(geometry, material);
      piece.position.set(
        (Math.random() - 0.5) * 20,
        (Math.random() - 0.5) * 20,
        (Math.random() - 0.5) * 20
      );
      piece.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
      piece.userData = {
        initialPosition: piece.position.clone(),
        initialRotation: piece.rotation.clone(),
        velocity: new Vector3(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        ),
        angularVelocity: new Vector3(
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1
        )
      };
      debris.add(piece);
    }
    debris.userData = {
      isDebris: true,
      effectType: "debris",
      active: false,
      pooled: true,
      startTime: 0,
      duration: 2e3,
      // 2 seconds for debris
      pieces: debris.children
    };
    return debris;
  }
  /**
   * Reset debris effect to initial state
   * @param {THREE.Group} debris - The debris effect to reset
   */
  resetDebrisEffect(debris) {
    debris.position.set(0, 0, 0);
    debris.visible = false;
    debris.userData.active = false;
    debris.userData.startTime = 0;
    debris.userData.duration = 2e3;
    for (const piece of debris.children) {
      piece.position.copy(piece.userData.initialPosition);
      piece.rotation.copy(piece.userData.initialRotation);
      piece.material.opacity = 0.8;
      piece.scale.set(1, 1, 1);
    }
  }
  /**
   * Update all active debris effects
   * @param {Array} activeDebris - Array of active debris objects
   * @param {Function} releaseCallback - Function to call when debris should be released
   */
  updateDebris(activeDebris, releaseCallback) {
    for (const debris of activeDebris) {
      const elapsed = Date.now() - debris.userData.startTime;
      const duration = debris.userData.duration;
      const progress = elapsed / duration;
      if (progress >= 1) {
        releaseCallback(debris);
      } else {
        for (const piece of debris.children) {
          piece.position.add(
            piece.userData.velocity.clone().multiplyScalar(1e-3 * 16)
            // Approximate 60fps deltaTime
          );
          piece.rotation.x += piece.userData.angularVelocity.x * 16 * 0.01;
          piece.rotation.y += piece.userData.angularVelocity.y * 16 * 0.01;
          piece.rotation.z += piece.userData.angularVelocity.z * 16 * 0.01;
          piece.material.opacity = 0.8 * (1 - progress);
          const scale = 1 - progress * 0.5;
          piece.scale.set(scale, scale, scale);
        }
      }
    }
  }
}
class ImpactTypeHandler {
  constructor() {
  }
  /**
   * Create an impact effect based on projectile type
   * @param {THREE.Vector3} position - Impact position
   * @param {string} projectileType - Type of projectile that impacted
   * @param {object} options - Effect options
   * @param {object} pools - Object containing the different effect pools
   * @returns {object} Created effects
   */
  createImpactEffect(position, projectileType = "bullet", options = {}, pools = {}) {
    const effects = {};
    const { explosionPool, sparkPool, debrisPool } = pools;
    switch (projectileType) {
      case "missile":
        if (explosionPool) {
          effects.explosion = this._getExplosion(explosionPool, position, 1500);
          effects.explosion.material.color.setHex(16729088);
          effects.explosion.scale.set(2, 2, 2);
        }
        break;
      case "laser":
        if (sparkPool) {
          effects.spark = this._getSparkEffect(sparkPool, position, 300);
          effects.spark.material.color.setHex(65535);
        }
        break;
      case "plasma":
        if (explosionPool) {
          effects.explosion = this._getExplosion(explosionPool, position, 800);
          effects.explosion.material.color.setHex(8913151);
        }
        if (sparkPool) {
          effects.spark = this._getSparkEffect(sparkPool, position, 400);
          effects.spark.material.color.setHex(11141375);
        }
        break;
      case "bullet":
      default:
        if (sparkPool) {
          effects.spark = this._getSparkEffect(sparkPool, position, 200);
        }
        if (debrisPool) {
          effects.debris = this._getDebrisEffect(debrisPool, position, 1500);
        }
        break;
    }
    return effects;
  }
  /**
   * Helper method to get explosion from pool
   * @private
   */
  _getExplosion(explosionPool, position, duration) {
    const explosion = explosionPool.get();
    explosion.position.copy(position);
    explosion.visible = true;
    explosion.userData.active = true;
    explosion.userData.startTime = Date.now();
    explosion.userData.duration = duration;
    return explosion;
  }
  /**
   * Helper method to get spark effect from pool
   * @private
   */
  _getSparkEffect(sparkPool, position, duration) {
    const spark = sparkPool.get();
    spark.position.copy(position);
    spark.visible = true;
    spark.userData.active = true;
    spark.userData.startTime = Date.now();
    spark.userData.duration = duration;
    return spark;
  }
  /**
   * Helper method to get debris effect from pool
   * @private
   */
  _getDebrisEffect(debrisPool, position, duration) {
    const debris = debrisPool.get();
    debris.position.copy(position);
    debris.visible = true;
    debris.userData.active = true;
    debris.userData.startTime = Date.now();
    debris.userData.duration = duration;
    return debris;
  }
}
class ImpactEffectsPool {
  /**
   * Create a new ImpactEffectsPool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.explosionFactory = new ExplosionFactory(sharedAssets);
    this.sparkFactory = new SparkFactory(sharedAssets);
    this.debrisFactory = new DebrisFactory();
    this.impactTypeHandler = new ImpactTypeHandler();
    this.initializePools();
  }
  /**
   * Initialize impact effect pools
   */
  initializePools() {
    this.explosionPool = new ObjectPool(
      // Create function
      () => this.createExplosion(),
      // Reset function
      (explosion) => this.resetExplosion(explosion),
      10,
      // Initial size
      5
      // Expand size
    );
    this.sparkPool = new ObjectPool(
      // Create function
      () => this.createSparkEffect(),
      // Reset function
      (spark) => this.resetSparkEffect(spark),
      20,
      // Initial size
      8
      // Expand size
    );
    this.debrisPool = new ObjectPool(
      // Create function
      () => this.createDebrisEffect(),
      // Reset function
      (debris) => this.resetDebrisEffect(debris),
      15,
      // Initial size
      6
      // Expand size
    );
  }
  /**
   * Create a new explosion effect
   * @returns {THREE.Points} An explosion particle system
   */
  createExplosion() {
    return this.explosionFactory.createExplosion();
  }
  /**
   * Reset explosion to initial state
   * @param {THREE.Points} explosion - The explosion to reset
   */
  resetExplosion(explosion) {
    this.explosionFactory.resetExplosion(explosion);
  }
  /**
   * Create a spark effect for impacts
   * @returns {THREE.Points} A spark particle system
   */
  createSparkEffect() {
    return this.sparkFactory.createSparkEffect();
  }
  /**
   * Reset spark effect to initial state
   * @param {THREE.Points} spark - The spark effect to reset
   */
  resetSparkEffect(spark) {
    this.sparkFactory.resetSparkEffect(spark);
  }
  /**
   * Create debris effect for impacts
   * @returns {THREE.Group} A debris group
   */
  createDebrisEffect() {
    return this.debrisFactory.createDebrisEffect();
  }
  /**
   * Reset debris effect to initial state
   * @param {THREE.Group} debris - The debris effect to reset
   */
  resetDebrisEffect(debris) {
    this.debrisFactory.resetDebrisEffect(debris);
  }
  /**
   * Create an impact effect based on projectile type
   * @param {THREE.Vector3} position - Impact position
   * @param {string} projectileType - Type of projectile that impacted
   * @param {object} options - Effect options
   * @returns {object} Created effects
   */
  createImpactEffect(position, projectileType = "bullet", options = {}) {
    const pools = {
      explosionPool: this.explosionPool,
      sparkPool: this.sparkPool,
      debrisPool: this.debrisPool
    };
    const effects = this.impactTypeHandler.createImpactEffect(position, projectileType, options, pools);
    Object.values(effects).forEach((effect) => {
      if (effect && !effect.parent) {
        this._addToScene(effect);
      }
    });
    return effects;
  }
  /**
   * Get an explosion effect from the pool
   * @param {THREE.Vector3} position - Position for the explosion
   * @param {number} duration - Duration of the explosion in milliseconds
   * @returns {THREE.Points} An explosion effect
   */
  getExplosion(position, duration = 1e3) {
    const explosion = this.explosionPool.get();
    explosion.position.copy(position);
    explosion.visible = true;
    explosion.userData.active = true;
    explosion.userData.startTime = Date.now();
    explosion.userData.duration = duration;
    if (!explosion.parent) {
      this._addToScene(explosion);
    }
    return explosion;
  }
  /**
   * Get a spark effect from the pool
   * @param {THREE.Vector3} position - Position for the spark effect
   * @param {number} duration - Duration of the effect in milliseconds
   * @returns {THREE.Points} A spark effect
   */
  getSparkEffect(position, duration = 500) {
    const spark = this.sparkPool.get();
    spark.position.copy(position);
    spark.visible = true;
    spark.userData.active = true;
    spark.userData.startTime = Date.now();
    spark.userData.duration = duration;
    if (!spark.parent) {
      this._addToScene(spark);
    }
    return spark;
  }
  /**
   * Get a debris effect from the pool
   * @param {THREE.Vector3} position - Position for the debris effect
   * @param {number} duration - Duration of the effect in milliseconds
   * @returns {THREE.Group} A debris effect
   */
  getDebrisEffect(position, duration = 2e3) {
    const debris = this.debrisPool.get();
    debris.position.copy(position);
    debris.visible = true;
    debris.userData.active = true;
    debris.userData.startTime = Date.now();
    debris.userData.duration = duration;
    if (!debris.parent) {
      this._addToScene(debris);
    }
    return debris;
  }
  /**
   * Update all active impact effects
   * @param {number} deltaTime - Time since last update
   */
  updateEffects(deltaTime) {
    this.updateExplosions(deltaTime);
    this.updateSparks(deltaTime);
    this.updateDebris(deltaTime);
  }
  /**
   * Update all active explosions
   * @param {number} deltaTime - Time since last update
   */
  updateExplosions(deltaTime) {
    this.explosionFactory.updateExplosions(this.explosionPool.active, (explosion) => this.releaseExplosion(explosion));
  }
  /**
   * Update all active spark effects
   * @param {number} deltaTime - Time since last update
   */
  updateSparks(deltaTime) {
    this.sparkFactory.updateSparks(this.sparkPool.active, (spark) => this.releaseSparkEffect(spark));
  }
  /**
   * Update all active debris effects
   * @param {number} deltaTime - Time since last update
   */
  updateDebris(deltaTime) {
    this.debrisFactory.updateDebris(this.debrisPool.active, (debris) => this.releaseDebrisEffect(debris));
  }
  /**
   * Release effects back to pools
   */
  releaseExplosion(explosion) {
    if (explosion.parent) {
      this._removeFromParent(explosion);
    }
    this.explosionPool.release(explosion);
  }
  releaseSparkEffect(spark) {
    if (spark.parent) {
      this._removeFromParent(spark);
    }
    this.sparkPool.release(spark);
  }
  releaseDebrisEffect(debris) {
    if (debris.parent) {
      this._removeFromParent(debris);
    }
    this.debrisPool.release(debris);
  }
  /**
   * Dispose all impact effect pools
   */
  dispose() {
    this.explosionPool.dispose((explosion) => {
      if (explosion.parent) this._removeFromParent(explosion);
      if (explosion.material) explosion.material.dispose();
      if (explosion.geometry) explosion.geometry.dispose();
    });
    this.sparkPool.dispose((spark) => {
      if (spark.parent) this._removeFromParent(spark);
      if (spark.material) spark.material.dispose();
      if (spark.geometry) spark.geometry.dispose();
    });
    this.debrisPool.dispose((debris) => {
      if (debris.parent) this._removeFromParent(debris);
      for (const piece of debris.children) {
        if (piece.material) piece.material.dispose();
        if (piece.geometry) piece.geometry.dispose();
      }
    });
  }
}
class MuzzleFlashPool {
  /**
   * Create a new MuzzleFlashPool
   * @param {object} sharedAssets - Shared geometries and materials
   * @param {function} addToScene - Function to add objects to scene
   * @param {function} removeFromParent - Function to remove objects from parent
   */
  constructor(sharedAssets, addToScene, removeFromParent) {
    this.sharedAssets = sharedAssets;
    this._addToScene = addToScene;
    this._removeFromParent = removeFromParent;
    this.initializePool();
  }
  /**
   * Initialize the muzzle flash pool
   */
  initializePool() {
    this.pool = new ObjectPool(
      // Create function
      () => this.createMuzzleFlash(),
      // Reset function
      (muzzleFlash) => this.resetMuzzleFlash(muzzleFlash),
      20,
      // Initial size
      5
      // Expand size
    );
  }
  /**
   * Create a new muzzle flash effect
   * @returns {THREE.Mesh} A muzzle flash mesh
   */
  createMuzzleFlash() {
    const muzzleFlash = new Mesh(
      this.sharedAssets.muzzleFlashGeometry,
      this.sharedAssets.muzzleFlashMaterial.clone()
    );
    muzzleFlash.userData = {
      isMuzzleFlash: true,
      effectType: "muzzleFlash",
      active: false,
      pooled: true,
      startTime: 0,
      flashLight: null,
      weaponType: "generic",
      burstDuration: 70,
      // Default burst duration
      initialPosition: new Vector3(),
      direction: new Vector3()
    };
    const flashLight = new PointLight(65535, 200, 10, 2);
    flashLight.visible = false;
    this._addToScene(flashLight);
    muzzleFlash.userData.flashLight = flashLight;
    return muzzleFlash;
  }
  /**
   * Reset a muzzle flash to initial state
   * @param {THREE.Mesh} muzzleFlash - The muzzle flash to reset
   */
  resetMuzzleFlash(muzzleFlash) {
    muzzleFlash.position.set(0, 0, 0);
    muzzleFlash.rotation.set(0, 0, 0);
    muzzleFlash.scale.set(1, 1, 1);
    muzzleFlash.visible = false;
    muzzleFlash.material.opacity = 0.7;
    muzzleFlash.material.color.setHex(65535);
    const flashLight = muzzleFlash.userData.flashLight;
    if (flashLight) {
      flashLight.position.set(0, 0, 0);
      flashLight.intensity = 200;
      flashLight.color.setHex(65535);
      flashLight.visible = false;
    }
    muzzleFlash.userData.active = false;
    muzzleFlash.userData.startTime = 0;
    muzzleFlash.userData.weaponType = "generic";
    muzzleFlash.userData.burstDuration = 70;
    muzzleFlash.userData.initialPosition.set(0, 0, 0);
    muzzleFlash.userData.direction.set(0, 0, 1);
  }
  /**
   * Get a muzzle flash from the pool
   * @param {string} weaponType - Type of weapon firing
   * @param {THREE.Vector3} position - Position of the muzzle
   * @param {THREE.Vector3} direction - Direction of firing
   * @returns {THREE.Mesh} A muzzle flash mesh
   */
  getMuzzleFlash(weaponType = "generic", position = null, direction = null) {
    const muzzleFlash = this.pool.get();
    muzzleFlash.visible = true;
    muzzleFlash.userData.active = true;
    muzzleFlash.userData.startTime = performance.now();
    muzzleFlash.userData.weaponType = weaponType;
    if (position) {
      muzzleFlash.position.copy(position);
      muzzleFlash.userData.initialPosition.copy(position);
    }
    if (direction) {
      muzzleFlash.userData.direction.copy(direction).normalize();
      muzzleFlash.lookAt(position.clone().add(direction));
    }
    this.configureFlashForWeapon(muzzleFlash, weaponType);
    const flashLight = muzzleFlash.userData.flashLight;
    if (flashLight) {
      flashLight.position.copy(muzzleFlash.position);
      flashLight.visible = true;
      this.configureLightForWeapon(flashLight, weaponType);
    }
    if (!muzzleFlash.parent) {
      this._addToScene(muzzleFlash);
    }
    return muzzleFlash;
  }
  /**
   * Configure muzzle flash appearance based on weapon type
   * @param {THREE.Mesh} muzzleFlash - The muzzle flash to configure
   * @param {string} weaponType - Type of weapon
   */
  configureFlashForWeapon(muzzleFlash, weaponType) {
    switch (weaponType) {
      case "laser":
        muzzleFlash.material.color.setHex(65535);
        muzzleFlash.scale.set(0.8, 0.8, 1.5);
        muzzleFlash.userData.burstDuration = 50;
        break;
      case "missile":
        muzzleFlash.material.color.setHex(16729088);
        muzzleFlash.scale.set(1.5, 1.5, 2);
        muzzleFlash.userData.burstDuration = 120;
        break;
      case "plasma":
        muzzleFlash.material.color.setHex(8913151);
        muzzleFlash.scale.set(1.2, 1.2, 1.8);
        muzzleFlash.userData.burstDuration = 80;
        break;
      case "bullet":
        muzzleFlash.material.color.setHex(16755200);
        muzzleFlash.scale.set(0.6, 0.6, 1);
        muzzleFlash.userData.burstDuration = 40;
        break;
      default:
        muzzleFlash.material.color.setHex(16777215);
        muzzleFlash.scale.set(1, 1, 1);
        muzzleFlash.userData.burstDuration = 70;
        break;
    }
    muzzleFlash.material.opacity = 0.7;
  }
  /**
   * Configure point light based on weapon type
   * @param {THREE.PointLight} light - The light to configure
   * @param {string} weaponType - Type of weapon
   */
  configureLightForWeapon(light, weaponType) {
    switch (weaponType) {
      case "laser":
        light.color.setHex(65535);
        light.intensity = 150;
        light.distance = 8;
        break;
      case "missile":
        light.color.setHex(16737792);
        light.intensity = 300;
        light.distance = 15;
        break;
      case "plasma":
        light.color.setHex(11141375);
        light.intensity = 250;
        light.distance = 12;
        break;
      case "bullet":
        light.color.setHex(16768256);
        light.intensity = 100;
        light.distance = 6;
        break;
      default:
        light.color.setHex(16777215);
        light.intensity = 200;
        light.distance = 10;
        break;
    }
  }
  /**
   * Update all active muzzle flashes
   * @param {number} deltaTime - Time since last update
   */
  updateMuzzleFlashes(deltaTime) {
    for (const muzzleFlash of this.pool.active) {
      const elapsed = performance.now() - muzzleFlash.userData.startTime;
      const burstDuration = muzzleFlash.userData.burstDuration;
      const progress = elapsed / burstDuration;
      if (progress >= 1) {
        this.release(muzzleFlash);
      } else {
        this.updateMuzzleFlashAnimation(muzzleFlash, progress, deltaTime);
      }
    }
  }
  /**
   * Update individual muzzle flash animation
   * @param {THREE.Mesh} muzzleFlash - The muzzle flash to update
   * @param {number} progress - Animation progress (0-1)
   * @param {number} deltaTime - Time since last update
   */
  updateMuzzleFlashAnimation(muzzleFlash, progress, deltaTime) {
    const travelProgress = Math.min(progress * 2.5, 1);
    const travelDistance = 300;
    if (muzzleFlash.userData.initialPosition && muzzleFlash.userData.direction) {
      const newPosition = muzzleFlash.userData.initialPosition.clone().add(
        muzzleFlash.userData.direction.clone().multiplyScalar(travelDistance * travelProgress)
      );
      muzzleFlash.position.copy(newPosition);
      if (muzzleFlash.userData.flashLight) {
        muzzleFlash.userData.flashLight.position.copy(newPosition);
      }
    }
    muzzleFlash.material.opacity = 0.7 * (1 - progress);
    if (muzzleFlash.userData.flashLight) {
      const baseIntensity = this.getBaseLightIntensity(muzzleFlash.userData.weaponType);
      muzzleFlash.userData.flashLight.intensity = baseIntensity * (1 - progress * 3);
    }
    const stretchFactor = 1 + progress * 1.5;
    const currentScale = muzzleFlash.scale.clone();
    muzzleFlash.scale.set(currentScale.x, currentScale.y, currentScale.z * stretchFactor);
    const flicker = 0.9 + 0.1 * Math.sin(performance.now() * 0.02);
    muzzleFlash.material.opacity *= flicker;
  }
  /**
   * Get base light intensity for weapon type
   * @param {string} weaponType - Type of weapon
   * @returns {number} Base intensity
   */
  getBaseLightIntensity(weaponType) {
    switch (weaponType) {
      case "laser":
        return 150;
      case "missile":
        return 300;
      case "plasma":
        return 250;
      case "bullet":
        return 100;
      default:
        return 200;
    }
  }
  /**
   * Release a muzzle flash back to the pool
   * @param {THREE.Mesh} muzzleFlash - The muzzle flash to release
   */
  release(muzzleFlash) {
    if (!muzzleFlash || !muzzleFlash.userData || !muzzleFlash.userData.isMuzzleFlash) {
      return;
    }
    const flashLight = muzzleFlash.userData.flashLight;
    if (flashLight) {
      flashLight.visible = false;
    }
    if (muzzleFlash.parent) {
      this._removeFromParent(muzzleFlash);
    }
    this.pool.release(muzzleFlash);
  }
  /**
   * Get count of available muzzle flashes in pool
   * @returns {number} Available count
   */
  availableCount() {
    return this.pool.availableCount();
  }
  /**
   * Get count of active muzzle flashes
   * @returns {number} Active count
   */
  activeCount() {
    return this.pool.activeCount();
  }
  /**
   * Get all active muzzle flashes
   * @returns {Set} Set of active muzzle flashes
   */
  getActive() {
    return this.pool.active;
  }
  /**
   * Dispose the muzzle flash pool
   * @param {function} disposeFn - Custom dispose function
   */
  dispose(disposeFn) {
    this.pool.dispose((muzzleFlash) => {
      if (muzzleFlash.parent) {
        this._removeFromParent(muzzleFlash);
      }
      if (muzzleFlash.userData.flashLight) {
        if (muzzleFlash.userData.flashLight.parent) {
          muzzleFlash.userData.flashLight.parent.remove(muzzleFlash.userData.flashLight);
        }
      }
      if (muzzleFlash.material) {
        muzzleFlash.material.dispose();
      }
      if (disposeFn) {
        disposeFn(muzzleFlash);
      }
    });
  }
}
class ProjectilePoolManager {
  constructor(scene, sharedAssets) {
    this.scene = scene;
    this.sharedAssets = sharedAssets;
    Object.assign(this, sharedAssets);
    this.populateWindowGameWithSharedAssets();
    this.initializePools();
    console.log("ProjectilePoolManager initialized using pre-warmed shared assets and specialized pools");
  }
  populateWindowGameWithSharedAssets() {
    if (!window.game) window.game = {};
    Object.assign(window.game, this.sharedAssets);
  }
  initializePools() {
    const addToScene = (object) => this._addToScene(object);
    const removeFromParent = (object) => this._removeFromParent(object);
    this.laserPool = new LaserProjectilePool(this.sharedAssets, addToScene, removeFromParent);
    this.missilePool = new MissileProjectilePool(this.sharedAssets, addToScene, removeFromParent);
    this.plasmaPool = new PlasmaProjectilePool(this.sharedAssets, addToScene, removeFromParent);
    this.bulletPool = new BulletProjectilePool(this.sharedAssets, addToScene, removeFromParent);
    this.trailEffects = new TrailEffectsPool(this.sharedAssets, addToScene, removeFromParent);
    this.impactEffects = new ImpactEffectsPool(this.sharedAssets, addToScene, removeFromParent);
    this.muzzleFlashEffects = new MuzzleFlashPool(this.sharedAssets, addToScene, removeFromParent);
    this.initializeTracerPool();
    this.createLegacyProjectilePool();
  }
  initializeTracerPool() {
    this.tracerPool = new ObjectPool(
      () => {
        const tracer = new Line(this.tracerGeometry.clone(), this.tracerLineMaterial.clone());
        tracer.userData = { isTracer: true, active: false, pooled: true, startTime: 0 };
        return tracer;
      },
      (tracer) => {
        tracer.position.set(0, 0, 0);
        tracer.visible = false;
        tracer.material.opacity = 0.6;
        tracer.userData.active = false;
        tracer.userData.startTime = 0;
      },
      20,
      5
    );
  }
  createLegacyProjectilePool() {
    this.projectilePool = {
      get: () => this.bulletPool.get(),
      release: (projectile) => {
        const type = projectile.userData && projectile.userData.projectileType || "bullet";
        this.releaseProjectile(projectile, type);
      },
      active: /* @__PURE__ */ new Set(),
      availableCount: () => this.bulletPool.availableCount(),
      activeCount: () => this.getAllActiveProjectiles().size
    };
  }
  // Factory Pattern - Get projectile by type
  getProjectile(type = "bullet") {
    switch (type.toLowerCase()) {
      case "laser":
        return this.laserPool.get();
      case "missile":
        return this.missilePool.get();
      case "plasma":
        return this.plasmaPool.get();
      case "bullet":
      default:
        return this.bulletPool.get();
    }
  }
  // Effect factory methods
  getMuzzleFlash(weaponType = "generic", position = null, direction = null) {
    return this.muzzleFlashEffects.getMuzzleFlash(weaponType, position, direction);
  }
  getTrailContainer() {
    return this.trailEffects.getTrailContainer();
  }
  getTrailParticle(sizeIndex = 0) {
    return this.trailEffects.getTrailParticle(sizeIndex);
  }
  getTracer() {
    const tracer = this.tracerPool.get();
    tracer.visible = true;
    tracer.userData.active = true;
    tracer.userData.startTime = performance.now();
    if (!tracer.parent) this._addToScene(tracer);
    return tracer;
  }
  getExplosion(position, duration = 1e3) {
    return this.impactEffects.getExplosion(position, duration);
  }
  createImpactEffect(position, projectileType = "bullet", options = {}) {
    return this.impactEffects.createImpactEffect(position, projectileType, options);
  }
  createTrailForProjectile(projectile, options = {}) {
    return this.trailEffects.createTrailForProjectile(projectile, options);
  }
  // Release methods - delegate to appropriate pools
  releaseProjectile(projectile, type = null) {
    if (!projectile || !projectile.userData || !projectile.userData.isProjectile) return;
    const projectileType = type || projectile.userData.projectileType || "bullet";
    if (projectile.userData.trail) {
      this.releaseTrail(projectile.userData.trail);
      projectile.remove(projectile.userData.trail);
      projectile.userData.trail = null;
      projectile.userData.trailParticles = null;
    }
    switch (projectileType.toLowerCase()) {
      case "laser":
        this.laserPool.release(projectile);
        break;
      case "missile":
        this.missilePool.release(projectile);
        break;
      case "plasma":
        this.plasmaPool.release(projectile);
        break;
      case "bullet":
      default:
        this.bulletPool.release(projectile);
        break;
    }
  }
  releaseMuzzleFlash(muzzleFlash) {
    this.muzzleFlashEffects.release(muzzleFlash);
  }
  releaseTrail(trail) {
    this.trailEffects.releaseTrail(trail);
  }
  releaseTrailParticle(particle) {
    this.trailEffects.releaseTrailParticle(particle);
  }
  releaseExplosion(explosion) {
    this.impactEffects.releaseExplosion(explosion);
  }
  releaseTracer(tracer) {
    if (!tracer || !tracer.userData || !tracer.userData.isTracer) return;
    if (tracer.parent) this._removeFromParent(tracer);
    this.tracerPool.release(tracer);
  }
  // Get all active projectiles from all pools
  getAllActiveProjectiles() {
    const allActive = /* @__PURE__ */ new Set();
    [this.laserPool, this.missilePool, this.plasmaPool, this.bulletPool].forEach((pool) => {
      pool.getActive().forEach((p) => allActive.add(p));
    });
    this.projectilePool.active = allActive;
    return allActive;
  }
  // Update all active objects from the pools
  update(deltaTime) {
    this.missilePool.getActive().forEach((missile) => this.missilePool.updateMissile(missile, deltaTime));
    this.plasmaPool.getActive().forEach((plasma) => this.plasmaPool.updatePlasma(plasma, deltaTime));
    this.bulletPool.getActive().forEach((bullet) => this.bulletPool.updateBullet(bullet, deltaTime));
    this.muzzleFlashEffects.updateMuzzleFlashes(deltaTime);
    this.trailEffects.updateTrails(deltaTime);
    this.impactEffects.updateEffects(deltaTime);
    this.updateTracers(deltaTime);
  }
  updateTracers(deltaTime) {
    for (const tracer of this.tracerPool.active) {
      const opacity = Math.max(0, tracer.material.opacity - 1.5 * 0.016);
      if (opacity <= 0) {
        this.releaseTracer(tracer);
      } else {
        tracer.material.opacity = opacity;
      }
    }
  }
  // Dispose all pools and shared assets
  dispose() {
    [this.projectileGeometry, this.projectileGlowGeometry, this.muzzleFlashGeometry, this.tracerGeometry].forEach((geo) => geo && geo.dispose());
    if (this.trailParticleGeometries) {
      this.trailParticleGeometries.forEach((geo) => geo && geo.dispose());
    }
    [
      this.projectileMaterial,
      this.projectileGlowMaterial,
      this.trailParticleMaterial,
      this.muzzleFlashMaterial,
      this.tracerLineMaterial
    ].forEach((mat) => mat && mat.dispose());
    [this.laserPool, this.missilePool, this.plasmaPool, this.bulletPool].forEach((pool) => pool && pool.dispose());
    [this.trailEffects, this.impactEffects, this.muzzleFlashEffects].forEach((pool) => pool && pool.dispose());
    if (this.tracerPool) {
      this.tracerPool.dispose((tracer) => {
        if (tracer.parent) this._removeFromParent(tracer);
        if (tracer.material) tracer.material.dispose();
      });
    }
    console.log("ProjectilePoolManager disposed all pools and shared assets");
  }
  // Renderer facade helpers
  _getRenderer() {
    return window.game && window.game.renderer || null;
  }
  _addToScene(object) {
    const renderer = this._getRenderer();
    if (renderer && renderer._withGuard) {
      renderer._withGuard(() => renderer.add(object));
    } else if (this.scene && this.scene.add) {
      this.scene.add(object);
    }
  }
  _removeFromScene(object) {
    const renderer = this._getRenderer();
    if (renderer && renderer._withGuard) {
      renderer._withGuard(() => this.scene.remove(object));
    } else if (this.scene && this.scene.remove) {
      this.scene.remove(object);
    }
  }
  _removeFromParent(object) {
    if (!object || !object.parent) return;
    if (object.parent === this.scene) {
      this._removeFromScene(object);
    } else if (object.parent.remove) {
      object.parent.remove(object);
    }
  }
}
class Combat {
  constructor(scene, spaceship) {
    this.scene = scene;
    this.spaceship = spaceship;
    this.projectiles = [];
    this.projectileLifetime = 2e3;
    this.fireRate = 3;
    this.projectileSpeed = 3e4;
    this.lastFireTime = 0;
    this.aimingSpread = 0.05;
    this.isFiring = false;
    this.cooldown = 1e3 / this.fireRate;
    this.projectileDamage = 20;
    this.worldSetup = new WorldSetup();
    this.systemRegistrar = new SystemRegistrar();
    this.eventManager = new EventManager();
    this.effectsManager = new EffectsManager(scene);
    this.aiSpawnerManager = new AISpawnerManager();
    this.combatLogic = new CombatLogic(this.effectsManager, this.eventManager, this.aiSpawnerManager);
    this.poolManager = new ProjectilePoolManager(scene, {
      projectileMaterial: this.effectsManager.getMaterial("projectile"),
      projectileGlowMaterial: this.effectsManager.getMaterial("projectileGlow"),
      trailParticleMaterial: this.effectsManager.getMaterial("trailParticle"),
      muzzleFlashMaterial: this.effectsManager.getMaterial("muzzleFlash"),
      tracerLineMaterial: this.effectsManager.getMaterial("tracerLine"),
      explosionParticleMaterial: this.effectsManager.getMaterial("explosionParticle"),
      projectileGeometry: window.game.projectileGeometry,
      projectileGlowGeometry: window.game.projectileGlowGeometry,
      muzzleFlashGeometry: window.game.muzzleFlashGeometry,
      trailParticleGeometries: window.game.trailParticleGeometries,
      tracerGeometry: window.game.tracerGeometry
    });
    this.initializeECSWorld();
  }
  // Material and geometry initialization moved to EffectsManager
  /**
   * Initialize the ECS world asynchronously
   * This is called from the constructor and runs in the background
   */
  async initializeECSWorld() {
    try {
      this.world = await this.worldSetup.initializeECSWorld(this.scene, this.spaceship);
      await this.setupECSWorld();
    } catch (error) {
    }
  }
  /**
   * Set up the ECS world and register combat systems
   */
  async setupECSWorld() {
    if (this.worldSetup.isWorldInitialized()) {
      return;
    }
    try {
      const systems = await this.systemRegistrar.registerAllSystems(this.world, this.scene);
      Object.assign(this, systems);
      this.eventManager.setupEventHandlers(this.world, this.worldSetup.getPlayerEntity());
      this.worldSetup.setSceneReference(this.scene);
      this.worldSetup.initializeWorld();
      this.playerEntity = await this.worldSetup.createPlayerReferenceEntity(this.spaceship);
      if (this.enemySystem) {
        this.aiSpawnerManager.configureEnemySystem(this.enemySystem);
      }
      this.worldSetup.setWorldInitialized();
    } catch (error) {
    }
  }
  // Player entity creation moved to WorldSetup module
  /**
   * Update all projectiles and handle firing logic
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime) {
    if (!this.scene || !this.spaceship) return;
    const introActive = window.game && window.game.introSequenceActive;
    this.updatePlayerReference();
    this.updateSpaceshipHealth();
    this.updateProjectiles(deltaTime);
    this.effectsManager.updateTracers(deltaTime);
    if (this.poolManager) {
      this.poolManager.update(deltaTime);
    }
    if (this.isFiring && !this.spaceship.isDocked) {
      this.fireParticleCannon();
    }
    if (this.world && !introActive) {
      this.world.update(deltaTime);
    } else if (this.world && introActive) {
      if (this.world.systems) {
        for (const system of this.world.systems) {
          if (system.constructor.name !== "EnemySystem" && system.constructor.name !== "EnemyAISystem") {
            system.update(deltaTime);
          }
        }
      }
    } else if (!this.world) ;
  }
  /**
   * Update the player reference entity with the current spaceship position
   */
  updatePlayerReference() {
    this.worldSetup.updatePlayerReference(this.spaceship);
  }
  /**
   * Sync the spaceship hull/shield with the player entity's HealthComponent
   */
  updateSpaceshipHealth() {
    this.worldSetup.updateSpaceshipHealth(this.spaceship);
  }
  /**
   * Update all projectile positions
   * @param {number} deltaTime Time since last update in seconds
   */
  updateProjectiles(deltaTime) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const projectile = this.projectiles[i];
      projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
      if (projectile.userData && projectile.userData.entityId && this.world) {
        const entity = this.world.getEntity(projectile.userData.entityId);
        if (entity) {
          if (typeof entity.update === "function") {
            entity.update(deltaTime);
          } else {
            const transform2 = entity.getComponent("TransformComponent");
            if (transform2) {
              transform2.position.copy(projectile.position);
              transform2.needsUpdate = true;
            }
            const rigidbody = entity.getComponent("RigidbodyComponent");
            if (rigidbody) {
              rigidbody.velocity.copy(projectile.velocity);
            }
          }
        }
      }
      if (performance.now() - projectile.userData.creationTime > this.projectileLifetime) {
        if (projectile.userData && projectile.userData.entityId && this.world) {
          try {
            this.world.destroyEntity(projectile.userData.entityId);
          } catch (error) {
          }
        }
        this.poolManager.releaseProjectile(projectile);
        this.projectiles.splice(i, 1);
      }
    }
  }
  /**
   * Set firing state for the particle cannon
   * @param {boolean} isFiring Whether the cannon should be firing
   */
  setFiring(isFiring) {
    this.isFiring = isFiring;
  }
  /**
   * Create an explosion effect at the given position
   * @param {THREE.Vector3} position Position for the explosion
   * @param {number} duration Duration of the explosion in milliseconds
   * @param {boolean} isVisible Whether the explosion should be visible
   */
  createExplosionEffect(position, duration = 1e3, isVisible = true) {
    return this.effectsManager.createExplosionEffect(position, duration, isVisible, this.poolManager);
  }
  // Tracer update logic moved to EffectsManager
  /**
   * Register an enemy entity for synchronization with EnemySystem
   * @param {string} enemyId ID of the enemy entity
   */
  registerEnemy(enemyId) {
    this.aiSpawnerManager.registerEnemy(enemyId);
  }
  /**
   * Unregister an enemy entity
   * @param {string} enemyId ID of the enemy entity
   */
  unregisterEnemy(enemyId) {
    this.aiSpawnerManager.unregisterEnemy(enemyId);
  }
  /**
   * Fire the particle cannon, creating two projectiles
   */
  fireParticleCannon() {
    const result = this.combatLogic.fireParticleCannon(
      this.scene,
      this.spaceship,
      this.world,
      this.playerEntity,
      this.projectileDamage,
      this.lastFireTime,
      this.cooldown
    );
    this.lastFireTime = result.newLastFireTime;
    return result.success;
  }
  /**
   * Create a single projectile
   * @param {THREE.Vector3} position Spawn position
   * @param {THREE.Vector3} direction Direction vector
   */
  createProjectile(position, direction) {
    const projectile = this.poolManager.getProjectile();
    projectile.position.copy(position);
    projectile.visible = true;
    const cylinderDefaultDirection = new Vector3(0, 1, 0);
    const quaternion = new Quaternion();
    quaternion.setFromUnitVectors(cylinderDefaultDirection, direction);
    projectile.quaternion.copy(quaternion);
    projectile.velocity = direction.clone().multiplyScalar(this.projectileSpeed);
    projectile.userData.isPlayerProjectile = true;
    projectile.userData.sourceId = "player";
    projectile.userData.damage = this.projectileDamage;
    this.effectsManager.addProjectileTrail(projectile, direction, this.poolManager);
    if (!projectile.parent) {
      this.scene.add(projectile);
    }
    projectile.userData.creationTime = performance.now();
    this.projectiles.push(projectile);
    if (this.world && this.world.optimizedProjectiles) {
      try {
        this.world.optimizedProjectiles.register(projectile);
      } catch {
      }
    }
    return projectile;
  }
  /**
   * Enable or disable all combat systems
   * @param {boolean} enabled Whether combat systems should be enabled
   */
  setEnabled(enabled) {
    if (!enabled) {
      this.clearAllProjectiles();
    }
    this.systemRegistrar.setSystemsEnabled(enabled);
  }
  // Instant tracer creation moved to EffectsManager
  // Projectile trail logic moved to EffectsManager
  /**
   * Clear all active projectiles
   */
  clearAllProjectiles() {
    for (const projectile of this.projectiles) {
      if (this.world && this.world.optimizedProjectiles) {
        try {
          this.world.optimizedProjectiles.unregister(projectile);
        } catch {
        }
      }
      if (projectile.userData && projectile.userData.entityId && this.world) {
        try {
          this.world.destroyEntity(projectile.userData.entityId);
        } catch (error) {
          console.error("Error removing projectile entity:", error);
        }
      }
      this.poolManager.releaseProjectile(projectile);
    }
    this.projectiles = [];
  }
  // Aiming tracer creation moved to EffectsManager
  createAimingTracer(startPosition, direction, distance = 3e3) {
    return this.effectsManager.createAimingTracer(startPosition, direction, distance, this.poolManager);
  }
  /**
   * Create a laser burst effect that travels forward with the projectile
   * @param {THREE.Vector3} position Position for the effect
   * @param {THREE.Vector3} direction Direction the effect should travel
   */
  createMuzzleFlash(position, direction) {
    return this.effectsManager.createMuzzleFlash(position, direction, this.poolManager);
  }
  /**
   * Dispose Combat module resources
   * Clean up all pools, geometries, and other resources
   */
  dispose() {
    this.clearAllProjectiles();
    if (this.poolManager) {
      this.poolManager.dispose();
      this.poolManager = null;
    }
    if (this.effectsManager) {
      this.effectsManager.dispose();
    }
    if (this.eventManager) {
      this.eventManager.cleanup();
    }
    if (this.aiSpawnerManager) {
      this.aiSpawnerManager.emergencyCleanup();
    }
    this.disposed = true;
  }
  // Renderer facade helpers moved to EffectsManager
  /**
   * Import and register a system
   * @param {string} path The path to the system module
   * @param {string} className The name of the system class
   * @returns {Object} The system instance
   */
  async importAndRegisterSystem(path, className) {
    return this.systemRegistrar.importAndRegisterSystem(path, className, this.world, this.scene);
  }
}
const combat = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Combat
}, Symbol.toStringTag, { value: "Module" }));
function getAbsolutePath(relativePath) {
  console.log(`Original path: ${relativePath}`);
  if (window.location.hostname !== "localhost" && window.location.hostname !== "127.0.0.1") {
    const basePath = window.location.pathname.split("/").slice(0, -1).join("/");
    const cleanPath = relativePath.startsWith("/") ? relativePath.substring(1) : relativePath;
    const fullPath = `${basePath}/${cleanPath}`;
    console.log(`Adjusted path for hosted environment: ${fullPath}`);
    return fullPath;
  }
  console.log(`Using original path for local environment: ${relativePath}`);
  return relativePath;
}
class LightingManager {
  constructor(scene) {
    this.scene = scene;
    this.ambientLight = null;
    this.directionalLight = null;
    this.fillLight = null;
    this.hemisphereLight = null;
    this.ambientPointLight = null;
  }
  setupLighting() {
    this.ambientLight = new AmbientLight(4210768, 1);
    this.scene.add(this.ambientLight);
    this.directionalLight = new DirectionalLight(16777184, 2);
    this.directionalLight.position.set(1, 0.5, 1).normalize();
    this.directionalLight.castShadow = true;
    this.directionalLight.shadow.mapSize.width = 2048;
    this.directionalLight.shadow.mapSize.height = 2048;
    this.directionalLight.shadow.camera.near = 0.5;
    this.directionalLight.shadow.camera.far = 500;
    this.directionalLight.shadow.bias = -5e-4;
    this.scene.add(this.directionalLight);
    this.fillLight = new DirectionalLight(11193599, 0.3);
    this.fillLight.position.set(-1, -0.3, -1).normalize();
    this.scene.add(this.fillLight);
    this.hemisphereLight = new HemisphereLight(6316176, 1052704, 0.4);
    this.scene.add(this.hemisphereLight);
    this.ambientPointLight = new PointLight(16777215, 1.2, 1200, 2);
    this.ambientPointLight.position.set(0, 500, 0);
    this.scene.add(this.ambientPointLight);
  }
  /**
   * Adjust scene lighting based on current ray type
   * Standard god rays need more ambient light to prevent planets from being too dark
   */
  adjustLightingForRayType(useClaudeRays) {
    if (!this.ambientLight) return;
    if (useClaudeRays) {
      this.ambientLight.intensity = 1;
    } else {
      this.ambientLight.intensity = 1.8;
    }
  }
  dispose() {
  }
}
function createVolumetricLightShader() {
  const godRayShader = {
    uniforms: {
      tDiffuse: { value: null },
      lightPosition: { value: new Vector2(0.5, 0.5) },
      intensity: { value: 0.45 },
      // Increased from 0.3
      decay: { value: 0.94 },
      // Adjusted from 0.95 for better distance
      density: { value: 0.6 },
      // Increased from 0.5
      weight: { value: 0.5 },
      // Increased from 0.4
      samples: { value: 100 },
      // Sample count - higher = better quality but slower
      sunColor: { value: new Color(16775920) },
      // Sun color
      sunDistance: { value: 0.5 },
      // Distance to sun (0-1 normalized)
      sunVisibility: { value: 1 },
      // Whether sun is in front of camera (0-1)
      scattering: { value: 0.4 },
      // Increased from 0.3
      attenuationMultiplier: { value: 3.5 }
      // Reduced from 5.0 to allow rays to travel further
    },
    vertexShader: `
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
    fragmentShader: `
            precision highp float;
            
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 lightPosition;
            uniform float intensity;
            uniform float decay;
            uniform float density;
            uniform float weight;
            uniform int samples;
            uniform vec3 sunColor;
            uniform float sunDistance;
            uniform float sunVisibility;
            uniform float scattering;
            uniform float attenuationMultiplier;
            
            const int MAX_SAMPLES = 150;
            
            float illuminationDecay(float rayProgress, float dist) {
                // rayProgress: 0.0 to a1.0 (how far along the ray)
                // dist: normalized distance to sun (0 = close, 1 = far)
                
                // Base decay from exponential falloff
                float baseFalloff = pow(decay, rayProgress * 100.0);
                
                // More decay the further the sun is 
                float distanceAttenuation = 1.0 - (dist * dist * attenuationMultiplier);
                distanceAttenuation = max(0.0, distanceAttenuation);
                
                // Apply visibility factor
                float visibilityFactor = sunVisibility;
                
                return baseFalloff * distanceAttenuation * visibilityFactor;
            }
            
            void main() {
                // Get the texture color (original scene)
                vec4 sceneColor = texture2D(tDiffuse, vUv);
                
                // Calculate ray direction from pixel to light source
                vec2 rayVector = (vUv - lightPosition);
                float rayLength = length(rayVector);
                vec2 rayDirection = normalize(rayVector);
                
                // Skip calculation if ray is too long (reduces artifacts far from sun)
                if (rayLength > 1.0) {
                    gl_FragColor = sceneColor;
                    return;
                }
                
                // Angle factor (rays stronger when looking near sun)
                float angleFactor = 1.0 - rayLength;
                angleFactor = pow(angleFactor, 0.8); // Adjust the power for ray spread
                
                // Calculate ray sampling parameters
                vec2 sampleStep = -rayDirection * min(density, 1.0) / float(samples);
                
                // Use a tighter sampling box around the light source
                // This creates more defined rays and reduces artifacts
                float rayProgress = max(0.0, (1.0 - rayLength * 2.0)); // Start closer to light source
                vec2 samplePosition = vUv - sampleStep * rayProgress * 10.0; // Start closer to current position
                
                // Clamp sample count for performance
                int sampleCount = min(samples, MAX_SAMPLES);
                
                // Start with current scene color
                vec4 finalColor = sceneColor;
                
                // Calculate scattering factor based on distance and angle
                float scatterFactor = scattering * angleFactor * (1.0 - sunDistance * 0.5);
                
                // Sample the light path
                // Use a fixed loop to avoid gradient instruction warnings
                for (int i = 0; i < MAX_SAMPLES; i++) {
                    // Early exit condition without break (to avoid varying iteration)
                    float shouldSample = step(float(i), float(sampleCount) - 0.5);
                    
                    // Move along the ray
                    samplePosition += sampleStep;
                    
                    // Sample at the current position
                    // Note: texture2D in a loop with uniform iteration is fine
                    vec4 sampledColor = texture2D(tDiffuse, samplePosition);
                    
                    // Calculate illumination decay factor
                    float decayFactor = illuminationDecay(float(i) / float(sampleCount), sunDistance);
                    
                    // Create the ray sample with attenuation
                    vec4 raySample = sampledColor * decayFactor * weight * shouldSample;
                    
                    // Apply sun color to the ray (tinted by scene color)
                    raySample.rgb *= mix(sunColor, sampledColor.rgb, 0.3);
                    
                    // Apply scattering effect - brightens areas around sun
                    float scatterAmount = step(float(i), float(sampleCount) / 3.0 - 0.5);
                    raySample.rgb += sunColor * scatterFactor * decayFactor * 0.2 * 
                                     (1.0 - float(i) / max(float(sampleCount) / 3.0, 1.0)) * scatterAmount * shouldSample;
                    
                    // Add to accumulated color
                    finalColor += raySample;
                }
                
                // Apply master intensity factor
                finalColor *= mix(1.0, intensity, sunVisibility);
                
                // Preserve original scene color with a blend factor
                finalColor = mix(sceneColor, finalColor, min(0.95, intensity * sunVisibility));
                
                gl_FragColor = finalColor;
            }
        `
  };
  const shaderPass = new ShaderPass(godRayShader);
  shaderPass.renderToScreen = false;
  return shaderPass;
}
function createClaudeRayShader() {
  const claudeRayShader = {
    uniforms: {
      tDiffuse: { value: null },
      lightPosition: { value: new Vector2(0.5, 0.5) },
      exposure: { value: 0.4 },
      // Reduced from 0.6
      decay: { value: 0.93 },
      density: { value: 0.8 },
      // Reduced from 0.96
      weight: { value: 0.25 },
      // Reduced from 0.4
      lightColor: { value: new Color(16775920) }
      // Matches sun directional light
    },
    vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
    fragmentShader: `
            precision highp float;
            
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 lightPosition;
            uniform float exposure;
            uniform float decay;
            uniform float density;
            uniform float weight;
            uniform vec3 lightColor;
            
            const int NUM_SAMPLES = 24; // Reduced from 30 for better balance of quality and performance
            
            void main() {
                // Get the texture color
                vec4 color = texture2D(tDiffuse, vUv);
                
                // Ray direction
                vec2 texCoord = vUv;
                vec2 deltaTextCoord = (texCoord - lightPosition) * density / float(NUM_SAMPLES);
                
                // Start illumination decay at 1.0
                float illuminationDecay = 1.0;
                
                // Sample the light path with a fixed number of steps
                for(int i = 0; i < NUM_SAMPLES; i++) {
                    // Move along the ray
                    texCoord -= deltaTextCoord;
                    
                    // Sample at the current position
                    vec4 sampleColor = texture2D(tDiffuse, texCoord);
                    
                    // Apply decay and weight
                    sampleColor *= illuminationDecay * weight;
                    
                    // Apply light color
                    sampleColor.rgb *= lightColor;
                    
                    // Add to the final color
                    color += sampleColor;
                    
                    // Reduce illumination for the next sample
                    illuminationDecay *= decay;
                }
                
                // Apply exposure
                color *= exposure;
                
                // Output the final color
                gl_FragColor = color;
            }
        `
  };
  const shaderPass = new ShaderPass(claudeRayShader);
  shaderPass.renderToScreen = false;
  return shaderPass;
}
class PostProcessingManager {
  constructor(renderer, scene, camera) {
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.composer = null;
    this.bloomPass = null;
    this.filmPass = null;
    this.colorCorrectionPass = null;
    this.vignettePass = null;
    this.claudeRayPass = null;
    this.godRayPass = null;
    this.useBasicRendering = false;
    this.volumetricLightEnabled = true;
    this.useClaudeRays = false;
  }
  setupPostProcessing() {
    try {
      this.composer = new EffectComposer(this.renderer);
      const renderPass = new RenderPass(this.scene, this.camera);
      this.composer.addPass(renderPass);
      this.setupGodRayEffects();
      this.setupBloomPass();
      this.setupFXAAPass();
      this.setupColorCorrectionPass();
      this.setupFilmPass();
      this.setupVignettePass();
      console.log("Post-processing setup complete");
    } catch (error) {
      console.error("Error setting up post-processing:", error);
      console.log("Continuing with basic rendering without post-processing");
      this.useBasicRendering = true;
    }
  }
  setupBloomPass() {
    try {
      this.bloomPass = new UnrealBloomPass(
        new Vector2(window.innerWidth, window.innerHeight),
        0.2,
        // strength (further reduced from 0.3)
        0.2,
        // radius (further reduced from 0.3)
        0.95
        // threshold (further increased from 0.9 to only affect the very brightest parts)
      );
      this.composer.addPass(this.bloomPass);
    } catch (error) {
      console.warn("Error setting up UnrealBloomPass:", error);
    }
  }
  setupFXAAPass() {
    try {
      const fxaaPass = new ShaderPass(FXAAShader);
      if (fxaaPass.material && fxaaPass.material.uniforms && fxaaPass.material.uniforms.resolution) {
        const pixelRatio = this.renderer.getPixelRatio();
        fxaaPass.material.uniforms.resolution.value.x = 1 / (window.innerWidth * pixelRatio);
        fxaaPass.material.uniforms.resolution.value.y = 1 / (window.innerHeight * pixelRatio);
        this.composer.addPass(fxaaPass);
      } else {
        console.warn("FXAAShader uniforms not as expected, skipping pass");
      }
    } catch (error) {
      console.warn("Error setting up FXAAShader:", error);
    }
  }
  setupColorCorrectionPass() {
    try {
      this.colorCorrectionPass = new ShaderPass(ColorCorrectionShader);
      if (this.colorCorrectionPass.uniforms && this.colorCorrectionPass.uniforms.powRGB && this.colorCorrectionPass.uniforms.mulRGB) {
        this.colorCorrectionPass.uniforms.powRGB.value = new Vector3(1.1, 1.1, 1.2);
        this.colorCorrectionPass.uniforms.mulRGB.value = new Vector3(1.2, 1.1, 1);
        this.composer.addPass(this.colorCorrectionPass);
      } else {
        console.warn("ColorCorrectionShader uniforms not as expected, skipping pass");
      }
    } catch (error) {
      console.warn("Error setting up ColorCorrectionShader:", error);
    }
  }
  setupFilmPass() {
    try {
      this.filmPass = new ShaderPass(FilmShader);
      if (this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity && this.filmPass.uniforms.grayscale) {
        this.filmPass.uniforms.nIntensity.value = 0.08;
        this.filmPass.uniforms.sIntensity.value = 0.03;
        this.filmPass.uniforms.grayscale.value = 0;
        this.composer.addPass(this.filmPass);
      } else {
        console.warn("FilmShader uniforms not as expected, skipping pass");
      }
    } catch (error) {
      console.warn("Error setting up FilmShader:", error);
    }
  }
  setupVignettePass() {
    try {
      this.vignettePass = new ShaderPass(VignetteShader);
      if (this.vignettePass.uniforms && this.vignettePass.uniforms.offset && this.vignettePass.uniforms.darkness) {
        this.vignettePass.uniforms.offset.value = 0.95;
        this.vignettePass.uniforms.darkness.value = 1.6;
        this.composer.addPass(this.vignettePass);
      } else {
        console.warn("VignetteShader uniforms not as expected, skipping pass");
      }
    } catch (error) {
      console.warn("Error setting up VignetteShader:", error);
    }
  }
  /**
   * Setup for volumetric lighting (god rays) effects
   * Handles both the new realistic godray effect and the original "Claude Rays"
   */
  setupGodRayEffects() {
    try {
      this.volumetricLightEnabled = true;
      this.useClaudeRays = false;
      this.claudeRayPass = createClaudeRayShader();
      this.claudeRayPass.enabled = this.volumetricLightEnabled && this.useClaudeRays;
      this.composer.addPass(this.claudeRayPass);
      console.log("Claude Rays effect created (disabled by default)");
      this.godRayPass = createVolumetricLightShader();
      this.godRayPass.enabled = this.volumetricLightEnabled && !this.useClaudeRays;
      this.composer.addPass(this.godRayPass);
      console.log("New volumetric light ray effect added to post-processing chain");
    } catch (error) {
      console.warn("Error setting up volumetric light shaders:", error);
    }
  }
  // Allow dynamic adjustment of post-processing settings
  adjustBloom(strength, radius, threshold) {
    if (this.bloomPass) {
      this.bloomPass.strength = strength !== void 0 ? strength : this.bloomPass.strength;
      this.bloomPass.radius = radius !== void 0 ? radius : this.bloomPass.radius;
      this.bloomPass.threshold = threshold !== void 0 ? threshold : this.bloomPass.threshold;
    }
  }
  // Update for dynamic visual effects
  update(deltaTime) {
    if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.time && this.filmPass.uniforms.time.value !== void 0) {
      try {
        this.filmPass.uniforms.time.value += deltaTime;
      } catch (error) {
        console.warn("Error updating film pass time:", error);
      }
    }
  }
  handleResize() {
    if (this.composer) {
      this.composer.setSize(window.innerWidth, window.innerHeight);
      try {
        const pixelRatio = this.renderer.getPixelRatio();
        const fxaaPass = this.composer.passes.find(
          (pass) => pass.material && pass.material.uniforms && pass.material.uniforms.resolution && pass.material.uniforms.resolution.value
        );
        if (fxaaPass) {
          fxaaPass.material.uniforms.resolution.value.x = 1 / (window.innerWidth * pixelRatio);
          fxaaPass.material.uniforms.resolution.value.y = 1 / (window.innerHeight * pixelRatio);
        }
      } catch (error) {
        console.warn("Error updating FXAA resolution:", error);
      }
    }
  }
  render() {
    if (this.composer && !this.useBasicRendering) {
      this.composer.render();
    } else {
      this.renderer.render(this.scene, this.camera);
    }
  }
  dispose() {
    if (this.composer) {
      this.composer.passes.forEach((pass) => {
        if (pass.dispose) pass.dispose();
        if (pass.material) {
          pass.material.dispose();
        }
      });
    }
  }
}
class SceneApiManager {
  constructor(scene) {
    this.scene = scene;
    this.setupSceneGuard();
  }
  setupSceneGuard() {
    if (typeof window !== "undefined") {
      window.__rendererGuard = false;
    }
    const originalAdd = this.scene.add.bind(this.scene);
    const originalRemove = this.scene.remove.bind(this.scene);
    this.scene.add = (...args) => {
      if (!window.__rendererGuard && window && window.DEBUG_MODE) {
        console.warn("[RendererFacade] Direct scene.add detected outside renderer facade");
      }
      return originalAdd(...args);
    };
    this.scene.remove = (...args) => {
      if (!window.__rendererGuard && window && window.DEBUG_MODE) {
        console.warn("[RendererFacade] Direct scene.remove detected outside renderer facade");
      }
      return originalRemove(...args);
    };
  }
  // Add an object to the scene through guarded path
  add(object) {
    return this._withGuard(() => this.scene.add(object));
  }
  // Facade API for views
  addView(entityId, viewDef) {
  }
  removeView(entityId) {
  }
  updateView(entityId, props) {
  }
  _withGuard(fn) {
    const prev = window.__rendererGuard;
    window.__rendererGuard = true;
    try {
      return fn();
    } finally {
      window.__rendererGuard = prev;
    }
  }
  /**
   * Helper method to find the sun object in the scene
   * @returns {THREE.Object3D|null} The sun object or null if not found
   */
  findSunObject() {
    let sun = null;
    sun = this.scene.getObjectByName("sun");
    if (!sun) {
      this.scene.traverse((object) => {
        if (object.name === "sun") {
          sun = object;
        }
      });
    }
    return sun;
  }
  // Interpolate ECS meshes before compositing
  interpolateMeshes(alpha) {
    const world = this.scene && this.scene.ecsWorld ? this.scene.ecsWorld : null;
    if (!world || !world.entityManager) return;
    try {
      const entities = world.getEntitiesWithComponents(["TransformComponent", "MeshComponent"]);
      for (const entity of entities) {
        const t = entity.getComponent("TransformComponent");
        const m = entity.getComponent("MeshComponent");
        if (!t || !m || !m.mesh) continue;
        const q = new Quaternion().copy(t.prevQuaternion).slerp(t.quaternion, alpha);
        const p = new Vector3().copy(t.prevPosition).lerp(t.position, alpha);
        m.mesh.position.copy(p);
        m.mesh.quaternion.copy(q);
      }
    } catch {
    }
  }
}
class RenderHelpers {
  constructor(scene) {
    this.scene = scene;
    this.instancedMeshes = /* @__PURE__ */ new Map();
    this._frameDrawCalls = 0;
    this._frameVisibleInstances = 0;
    this.renderAlpha = 0;
  }
  /**
   * Create an instanced mesh for efficient rendering of many similar objects
   * @param {string} key Unique identifier for this instanced mesh type
   * @param {THREE.BufferGeometry} geometry The geometry to instance
   * @param {THREE.Material} material The material to use
   * @param {number} maxCount Maximum number of instances
   * @returns {THREE.InstancedMesh} The created instanced mesh
   */
  createInstancedMesh(key, geometry, material, maxCount) {
    const instancedMesh = new InstancedMesh(geometry, material, maxCount);
    instancedMesh.count = 0;
    instancedMesh.frustumCulled = true;
    this.scene.add(instancedMesh);
    this.instancedMeshes.set(key, {
      mesh: instancedMesh,
      count: 0,
      maxCount,
      dummy: new Object3D()
      // Reusable temporary Object3D for matrix calculations
    });
    return instancedMesh;
  }
  /**
   * Add or update an instance in an instanced mesh
   * @param {string} key The instanced mesh identifier
   * @param {number} index Index of the instance to update (or next available)
   * @param {THREE.Vector3} position Position of the instance
   * @param {THREE.Quaternion} quaternion Rotation of the instance
   * @param {THREE.Vector3} scale Scale of the instance
   * @returns {number} The index of the instance
   */
  updateInstance(key, index, position, quaternion, scale) {
    const instance = this.instancedMeshes.get(key);
    if (!instance) return -1;
    const idx = index !== void 0 ? index : instance.count;
    if (idx >= instance.count) {
      if (idx >= instance.maxCount) return -1;
      instance.count = idx + 1;
    }
    instance.dummy.position.copy(position);
    if (quaternion) instance.dummy.quaternion.copy(quaternion);
    if (scale) instance.dummy.scale.copy(scale);
    instance.dummy.updateMatrix();
    instance.mesh.setMatrixAt(idx, instance.dummy.matrix);
    instance.mesh.instanceMatrix.needsUpdate = true;
    return idx;
  }
  /**
   * Update instanced meshes
   */
  updateInstancedMeshes() {
    for (const [key, instance] of this.instancedMeshes.entries()) {
      if (instance.mesh.instanceMatrix.needsUpdate) {
        instance.mesh.instanceMatrix.needsUpdate = false;
      }
    }
  }
  /**
   * Remove an instance from an instanced mesh
   * @param {string} key The instanced mesh identifier
   * @param {number} index Index of the instance to remove
   */
  removeInstance(key, index) {
    const instance = this.instancedMeshes.get(key);
    if (!instance || index >= instance.count) return;
    if (index < instance.count - 1) {
      const matrix = new Matrix4();
      instance.mesh.getMatrixAt(instance.count - 1, matrix);
      instance.mesh.setMatrixAt(index, matrix);
    }
    instance.count--;
    instance.mesh.count = instance.count;
    instance.mesh.instanceMatrix.needsUpdate = true;
  }
  /**
   * Update performance counters and render stats
   */
  updatePerformanceCounters(renderer) {
    this._frameDrawCalls = 0;
    this._frameVisibleInstances = 0;
    try {
      for (const [, inst] of this.instancedMeshes) {
        if (inst && inst.mesh) {
          this._frameVisibleInstances += inst.mesh.count || 0;
        }
      }
    } catch {
    }
    const ctx = renderer.info;
    const startCalls = ctx.render.calls;
    return startCalls;
  }
  /**
   * Finalize performance counters after rendering
   */
  finalizePerformanceCounters(renderer, startCalls) {
    const endCalls = renderer.info.render.calls;
    this._frameDrawCalls = Math.max(0, endCalls - startCalls);
    if (window.__perf) {
      window.__perf.drawCalls = endCalls;
      window.__perf.visibleInstances = this._frameVisibleInstances;
    }
  }
  /**
   * Properly dispose of Three.js resources to prevent memory leaks
   */
  dispose() {
    console.log("Disposing instanced meshes...");
    this.instancedMeshes.forEach((instance) => {
      if (instance.mesh) {
        if (instance.mesh.geometry) instance.mesh.geometry.dispose();
        if (instance.mesh.material) {
          if (Array.isArray(instance.mesh.material)) {
            instance.mesh.material.forEach((material) => material.dispose());
          } else {
            instance.mesh.material.dispose();
          }
        }
        this.scene.remove(instance.mesh);
      }
    });
    this.instancedMeshes.clear();
  }
  /**
   * Helper method to dispose of materials and their textures
   * @param {THREE.Material} material The material to dispose
   */
  disposeMaterial(material) {
    for (const propertyName in material) {
      const property = material[propertyName];
      if (property && property.isTexture) {
        property.dispose();
      }
    }
    material.dispose();
  }
}
class VolumetricLightingManager {
  constructor(postProcessingManager, sceneApiManager, camera) {
    this.postProcessingManager = postProcessingManager;
    this.sceneApiManager = sceneApiManager;
    this.camera = camera;
  }
  /**
   * Update volumetric light ray position if sun is present
   */
  update() {
    if (this.postProcessingManager.volumetricLightEnabled) {
      if (this.postProcessingManager.useClaudeRays) {
        this.updateClaudeRayPosition();
      } else {
        this.updateVolumetricLightPosition();
      }
    }
  }
  /**
   * Update the light position for Claude Rays
   */
  updateClaudeRayPosition() {
    try {
      if (!this.postProcessingManager.claudeRayPass || !this.postProcessingManager.claudeRayPass.uniforms || !this.postProcessingManager.claudeRayPass.uniforms.lightPosition) {
        return;
      }
      if (!this.camera) {
        return;
      }
      let sun = this.sceneApiManager.findSunObject();
      if (sun) {
        const sunWorldPos = new Vector3();
        sun.getWorldPosition(sunWorldPos);
        const screenVector = sunWorldPos.clone();
        screenVector.project(this.camera);
        const x = (screenVector.x + 1) / 2;
        const y = (screenVector.y + 1) / 2;
        this.postProcessingManager.claudeRayPass.uniforms.lightPosition.value.set(x, y);
      } else {
        this.postProcessingManager.claudeRayPass.uniforms.lightPosition.value.set(0.5, 0.5);
      }
    } catch (error) {
      console.warn("Error updating Claude Ray position:", error);
      if (this.postProcessingManager.claudeRayPass && this.postProcessingManager.claudeRayPass.uniforms && this.postProcessingManager.claudeRayPass.uniforms.lightPosition) {
        this.postProcessingManager.claudeRayPass.uniforms.lightPosition.value.set(0.5, 0.5);
      }
    }
  }
  /**
   * Update the light position for volumetric rays
   */
  updateVolumetricLightPosition() {
    try {
      if (!this.postProcessingManager.godRayPass || !this.postProcessingManager.godRayPass.uniforms || !this.postProcessingManager.godRayPass.uniforms.lightPosition) {
        return;
      }
      if (!this.camera) {
        return;
      }
      let sun = this.sceneApiManager.findSunObject();
      if (sun) {
        const sunWorldPos = new Vector3();
        sun.getWorldPosition(sunWorldPos);
        const screenVector = sunWorldPos.clone();
        screenVector.project(this.camera);
        const x = (screenVector.x + 1) / 2;
        const y = (screenVector.y + 1) / 2;
        const camToSunDistance = this.camera.position.distanceTo(sunWorldPos);
        this.postProcessingManager.godRayPass.uniforms.lightPosition.value.set(x, y);
        const maxDistance = 13e4;
        const normalizedDistance = Math.min(1, camToSunDistance / maxDistance);
        this.postProcessingManager.godRayPass.uniforms.sunDistance.value = normalizedDistance;
        const camDirection = new Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
        const sunDirection = new Vector3().subVectors(sunWorldPos, this.camera.position).normalize();
        const dotProduct = camDirection.dot(sunDirection);
        this.postProcessingManager.godRayPass.uniforms.sunVisibility.value = Math.max(0, dotProduct);
      } else {
        this.postProcessingManager.godRayPass.uniforms.lightPosition.value.set(0.5, 0.5);
        this.postProcessingManager.godRayPass.uniforms.sunDistance.value = 1;
        this.postProcessingManager.godRayPass.uniforms.sunVisibility.value = 0;
      }
    } catch (error) {
      console.warn("Error updating volumetric light position:", error);
      if (this.postProcessingManager.godRayPass && this.postProcessingManager.godRayPass.uniforms) {
        if (this.postProcessingManager.godRayPass.uniforms.lightPosition) {
          this.postProcessingManager.godRayPass.uniforms.lightPosition.value.set(0.5, 0.5);
        }
        if (this.postProcessingManager.godRayPass.uniforms.sunDistance) {
          this.postProcessingManager.godRayPass.uniforms.sunDistance.value = 1;
        }
        if (this.postProcessingManager.godRayPass.uniforms.sunVisibility) {
          this.postProcessingManager.godRayPass.uniforms.sunVisibility.value = 0;
        }
      }
    }
  }
  /**
   * Toggle the type of volumetric lighting effect
   * @param {boolean} useClaudeRays - If true, use original Claude Rays; if false, use new god rays
   */
  setRayType(useClaudeRays) {
    this.postProcessingManager.useClaudeRays = useClaudeRays;
    if (this.postProcessingManager.claudeRayPass) {
      this.postProcessingManager.claudeRayPass.enabled = this.postProcessingManager.volumetricLightEnabled && this.postProcessingManager.useClaudeRays;
    }
    if (this.postProcessingManager.godRayPass) {
      this.postProcessingManager.godRayPass.enabled = this.postProcessingManager.volumetricLightEnabled && !this.postProcessingManager.useClaudeRays;
    }
    console.log(`Using ${this.postProcessingManager.useClaudeRays ? "Claude Rays" : "Volumetric God Rays"} effect`);
  }
  /**
   * Toggle volumetric light rays effect (master toggle)
   * @param {boolean} enabled Whether to enable or disable all ray effects
   */
  setVolumetricLightEnabled(enabled) {
    this.postProcessingManager.volumetricLightEnabled = enabled;
    if (this.postProcessingManager.useClaudeRays && this.postProcessingManager.claudeRayPass) {
      this.postProcessingManager.claudeRayPass.enabled = enabled;
    } else if (this.postProcessingManager.godRayPass) {
      this.postProcessingManager.godRayPass.enabled = enabled;
    }
    console.log(`Volumetric lighting ${enabled ? "enabled" : "disabled"}`);
  }
  /**
   * Update volumetric light parameters for the new god ray shader
   * @param {Object} params Parameters to update
   */
  updateVolumetricLightParams(params = {}) {
    if (!this.postProcessingManager.godRayPass || !this.postProcessingManager.godRayPass.uniforms) return;
    const uniforms = this.postProcessingManager.godRayPass.uniforms;
    if (params.intensity !== void 0) uniforms.intensity.value = params.intensity;
    if (params.decay !== void 0) uniforms.decay.value = params.decay;
    if (params.density !== void 0) uniforms.density.value = params.density;
    if (params.weight !== void 0) uniforms.weight.value = params.weight;
    if (params.samples !== void 0) uniforms.samples.value = params.samples;
    if (params.sunColor !== void 0) uniforms.sunColor.value = new Color(params.sunColor);
    if (params.scattering !== void 0) uniforms.scattering.value = params.scattering;
    if (params.attenuationMultiplier !== void 0) uniforms.attenuationMultiplier.value = params.attenuationMultiplier;
  }
  /**
   * Update Claude Ray parameters
   * @param {Object} params Parameters to update
   */
  updateClaudeRayParams(params = {}) {
    if (!this.postProcessingManager.claudeRayPass || !this.postProcessingManager.claudeRayPass.uniforms) return;
    const uniforms = this.postProcessingManager.claudeRayPass.uniforms;
    if (params.exposure !== void 0) uniforms.exposure.value = params.exposure;
    if (params.decay !== void 0) uniforms.decay.value = params.decay;
    if (params.density !== void 0) uniforms.density.value = params.density;
    if (params.weight !== void 0) uniforms.weight.value = params.weight;
    if (params.lightColor !== void 0) uniforms.lightColor.value = new Color(params.lightColor);
  }
  /**
   * Set overall volumetric light ray intensity with a single parameter
   * @param {number} intensity Value from 0-1 controlling overall ray intensity
   */
  setVolumetricLightIntensity(intensity) {
    if (this.postProcessingManager.useClaudeRays) {
      if (!this.postProcessingManager.claudeRayPass || !this.postProcessingManager.claudeRayPass.uniforms) return;
      intensity = Math.max(0, Math.min(1, intensity));
      const exposure = 0.2 + intensity * 0.4;
      const weight = 0.15 + intensity * 0.25;
      const density = 0.7 + intensity * 0.3;
      this.updateClaudeRayParams({
        exposure,
        weight,
        density
      });
    } else {
      if (!this.postProcessingManager.godRayPass || !this.postProcessingManager.godRayPass.uniforms) return;
      intensity = Math.max(0, Math.min(1, intensity));
      this.updateVolumetricLightParams({
        intensity: 0.3 + intensity * 0.4,
        // Increased base intensity
        weight: 0.35 + intensity * 0.3,
        // Increased from 0.3 + intensity * 0.2
        density: 0.45 + intensity * 0.25,
        // Increased from 0.4 + intensity * 0.2
        scattering: 0.25 + intensity * 0.25
        // Increased from 0.2 + intensity * 0.2
      });
    }
    console.log(`Volumetric light intensity set to ${intensity.toFixed(2)}`);
  }
}
class Renderer {
  constructor() {
    console.log("Initializing enhanced renderer...");
    if (!WebGL.isWebGL2Available()) {
      const warning = WebGL.getWebGL2ErrorMessage();
      document.body.appendChild(warning);
      console.error("WebGL 2 is required but not available.");
      throw new Error("WebGL 2 not available");
    } else {
      console.log("WebGL 2 is available.");
    }
    this.scene = new Scene();
    this.camera = new PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 4e5);
    this.renderer = new WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
      logarithmicDepthBuffer: true,
      // Better for space scenes with huge distance ranges
      stencil: true
      // Explicitly enable stencil buffer (default changed to false in r163)
    });
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    this.renderer.useLegacyLights = false;
    this.renderer.toneMapping = ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1;
    this.setupRenderer();
    this.lightingManager = new LightingManager(this.scene);
    this.postProcessingManager = new PostProcessingManager(this.renderer, this.scene, this.camera);
    this.sceneApiManager = new SceneApiManager(this.scene);
    this.renderHelpers = new RenderHelpers(this.scene);
    this.volumetricLightingManager = new VolumetricLightingManager(this.postProcessingManager, this.sceneApiManager, this.camera);
    this.lightingManager.setupLighting();
    this.postProcessingManager.setupPostProcessing();
    this.setupResizeHandler();
    this.renderAlpha = 0;
    console.log("Enhanced renderer initialized successfully");
  }
  setupRenderer() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setClearColor(0);
    document.body.appendChild(this.renderer.domElement);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.camera.position.z = 10;
    this.camera.far = 4e5;
    this.camera.updateProjectionMatrix();
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    this.renderer.shadowMap.autoUpdate = true;
  }
  // Post-processing setup is now handled by PostProcessingManager
  // Volumetric lighting setup is now handled by PostProcessingManager and VolumetricLightingManager
  // Lighting setup is now handled by LightingManager
  setupResizeHandler() {
    window.addEventListener("resize", () => {
      this.handleResize();
    });
  }
  // Explicitly define getter methods for scene and camera
  getScene() {
    return this.scene;
  }
  getCamera() {
    return this.camera;
  }
  // Resize handler method
  handleResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    if (this.composer) {
      this.composer.setSize(window.innerWidth, window.innerHeight);
      try {
        const pixelRatio = this.renderer.getPixelRatio();
        const fxaaPass = this.composer.passes.find(
          (pass) => pass.material && pass.material.uniforms && pass.material.uniforms.resolution && pass.material.uniforms.resolution.value
        );
        if (fxaaPass) {
          fxaaPass.material.uniforms.resolution.value.x = 1 / (window.innerWidth * pixelRatio);
          fxaaPass.material.uniforms.resolution.value.y = 1 / (window.innerHeight * pixelRatio);
        }
      } catch (error) {
        console.warn("Error updating FXAA resolution:", error);
      }
    }
  }
  // Add an object to the scene through guarded path
  add(object) {
    return this._withGuard(() => this.scene.add(object));
  }
  // Allow dynamic adjustment of post-processing settings
  adjustBloom(strength, radius, threshold) {
    if (this.bloomPass) {
      this.bloomPass.strength = strength !== void 0 ? strength : this.bloomPass.strength;
      this.bloomPass.radius = radius !== void 0 ? radius : this.bloomPass.radius;
      this.bloomPass.threshold = threshold !== void 0 ? threshold : this.bloomPass.threshold;
    }
  }
  // Update for dynamic visual effects
  update(deltaTime) {
    if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.time && this.filmPass.uniforms.time.value !== void 0) {
      try {
        this.filmPass.uniforms.time.value += deltaTime;
      } catch (error) {
        console.warn("Error updating film pass time:", error);
      }
    }
    if (this.volumetricLightEnabled) {
      if (this.useClaudeRays) {
        this.updateClaudeRayPosition();
      } else {
        this.updateVolumetricLightPosition();
      }
    }
    this.updateInstancedMeshes();
  }
  // Volumetric lighting position updates are now handled by VolumetricLightingManager
  // Volumetric lighting position updates are now handled by VolumetricLightingManager
  // Sun object finding is now handled by SceneApiManager
  // Override the render method to use the composer if available, otherwise fallback to basic rendering
  render() {
    const startCalls = this.renderHelpers.updatePerformanceCounters(this.renderer);
    this.postProcessingManager.render();
    this.renderHelpers.finalizePerformanceCounters(this.renderer, startCalls);
  }
  // Interpolate ECS meshes before compositing
  interpolateMeshes(alpha) {
    this.renderAlpha = alpha;
    this.sceneApiManager.interpolateMeshes(alpha);
  }
  // Facade API for views - delegated to SceneApiManager
  addView(entityId, viewDef) {
    this.sceneApiManager.addView(entityId, viewDef);
  }
  removeView(entityId) {
    this.sceneApiManager.removeView(entityId);
  }
  _withGuard(fn) {
    return this.sceneApiManager._withGuard(fn);
  }
  updateView(entityId, props) {
    this.sceneApiManager.updateView(entityId, props);
  }
  /**
   * Create an instanced mesh for efficient rendering of many similar objects
   */
  createInstancedMesh(key, geometry, material, maxCount) {
    return this.renderHelpers.createInstancedMesh(key, geometry, material, maxCount);
  }
  /**
   * Add or update an instance in an instanced mesh
   */
  updateInstance(key, index, position, quaternion, scale) {
    return this.renderHelpers.updateInstance(key, index, position, quaternion, scale);
  }
  /**
   * Update instanced meshes
   */
  updateInstancedMeshes() {
    this.renderHelpers.updateInstancedMeshes();
  }
  /**
   * Remove an instance from an instanced mesh
   */
  removeInstance(key, index) {
    this.renderHelpers.removeInstance(key, index);
  }
  /**
   * Properly dispose of Three.js resources to prevent memory leaks
   */
  dispose() {
    console.log("Disposing renderer resources...");
    window.removeEventListener("resize", this.handleResize);
    this.postProcessingManager.dispose();
    this.lightingManager.dispose();
    this.renderHelpers.dispose();
    this.scene.traverse((object) => {
      if (object.geometry) object.geometry.dispose();
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => this.renderHelpers.disposeMaterial(material));
        } else {
          this.renderHelpers.disposeMaterial(object.material);
        }
      }
    });
    this.renderer.dispose();
    console.log("Renderer resources disposed");
  }
  // Material disposal is now handled by RenderHelpers
  // Shader creation is now handled by shaders.js module
  // Shader creation is now handled by shaders.js module
  /**
   * Toggle the type of volumetric lighting effect
   */
  setRayType(useClaudeRays) {
    this.volumetricLightingManager.setRayType(useClaudeRays);
    this.lightingManager.adjustLightingForRayType(useClaudeRays);
  }
  // Lighting adjustment is now handled by LightingManager
  /**
   * Toggle volumetric light rays effect (master toggle)
   */
  setVolumetricLightEnabled(enabled) {
    this.volumetricLightingManager.setVolumetricLightEnabled(enabled);
  }
  /**
   * Update volumetric light parameters for the new god ray shader
   */
  updateVolumetricLightParams(params = {}) {
    this.volumetricLightingManager.updateVolumetricLightParams(params);
  }
  /**
   * Update Claude Ray parameters
   */
  updateClaudeRayParams(params = {}) {
    this.volumetricLightingManager.updateClaudeRayParams(params);
  }
  /**
   * Set overall volumetric light ray intensity with a single parameter
   */
  setVolumetricLightIntensity(intensity) {
    this.volumetricLightingManager.setVolumetricLightIntensity(intensity);
  }
}
class TrailEffects {
  constructor(scene, mesh) {
    this.scene = scene;
    this.mesh = mesh;
    this.thrusterEffects = [];
    this.time = 0;
    this.createThrusterEffects();
  }
  createThrusterEffects() {
    const createExhaustBeam = (position, direction, config) => {
      const { baseRadius, length, color, glowColor, type } = config;
      const group = new Group();
      const segments = 8;
      const beams = [];
      for (let i = 0; i < segments; i++) {
        const t = i / segments;
        const topRadius = baseRadius * (1 - t * 0.7);
        const bottomRadius = baseRadius * (1 - (t + 1 / segments) * 0.7);
        const segmentLength = length / segments;
        const geometry = new CylinderGeometry(
          topRadius,
          bottomRadius,
          segmentLength,
          12,
          // More segments for smoother look
          1,
          false
        );
        const material = new MeshBasicMaterial({
          color: new Color(color).lerp(new Color(glowColor), t),
          transparent: true,
          opacity: 1 - t * 0.3,
          // High opacity
          blending: AdditiveBlending,
          side: DoubleSide,
          depthTest: false
          // Always render on top
        });
        const beam = new Mesh(geometry, material);
        if (direction.z !== 0) {
          geometry.rotateX(Math.PI / 2);
          beam.position.z = direction.z * (i * segmentLength + segmentLength / 2);
        } else if (direction.x !== 0) {
          geometry.rotateZ(Math.PI / 2);
          beam.position.x = direction.x * (i * segmentLength + segmentLength / 2);
        }
        beams.push({ mesh: beam, material });
        group.add(beam);
      }
      group.position.copy(position);
      group.visible = false;
      this.mesh.add(group);
      return { group, beams, type };
    };
    this.thrusterEffects.push(createExhaustBeam(
      new Vector3(0, 0, 1.2),
      // Back of ship (ship scale is 2.0)
      new Vector3(0, 0, 1),
      // Points backward
      {
        baseRadius: 0.25,
        // Scaled for ship size
        length: 2.5,
        // Good length for exhaust
        color: 16755200,
        // Orange core
        glowColor: 35071,
        // Blue edges
        type: "main"
      }
    ));
    this.thrusterEffects.push(createExhaustBeam(
      new Vector3(0.7, 0, 0.2),
      // Right side of ship
      new Vector3(1, 0, 0),
      // Shoots right (away from ship)
      {
        baseRadius: 0.15,
        length: 1,
        // Shorter exhaust
        color: 16755200,
        glowColor: 43775,
        type: "right_thruster"
        // RIGHT thruster
      }
    ));
    this.thrusterEffects.push(createExhaustBeam(
      new Vector3(-0.7, 0, 0.2),
      // Left side of ship
      new Vector3(-1, 0, 0),
      // Shoots left (away from ship)
      {
        baseRadius: 0.15,
        length: 1,
        // Shorter exhaust
        color: 16755200,
        glowColor: 43775,
        type: "left_thruster"
        // LEFT thruster
      }
    ));
    this.thrusterEffects.push(createExhaustBeam(
      new Vector3(0, 0, -1.2),
      // Front of ship
      new Vector3(0, 0, -1),
      // Points forward
      {
        baseRadius: 0.2,
        length: 1.8,
        color: 16746496,
        glowColor: 16729088,
        type: "reverse"
      }
    ));
  }
  updateParticles(thrust, velocity) {
    this.time += 0.016;
    const intent = window.inputIntent || 0;
    const leftPressed = thrust.left || (intent & 4) !== 0;
    const rightPressed = thrust.right || (intent & 8) !== 0;
    this.thrusterEffects.forEach((effect) => {
      const { group, beams, type } = effect;
      let shouldShow = false;
      let intensity = 0;
      switch (type) {
        case "main":
          shouldShow = thrust.forward || velocity.length() > 1;
          intensity = thrust.forward ? thrust.boost ? 1.5 : 1 : 0.5;
          break;
        case "right_thruster":
          shouldShow = leftPressed;
          intensity = thrust.boost ? 1.5 : 1.2;
          break;
        case "left_thruster":
          shouldShow = rightPressed;
          intensity = thrust.boost ? 1.5 : 1.2;
          break;
        case "reverse":
          shouldShow = thrust.backward;
          intensity = thrust.boost ? 1.3 : 1;
          break;
      }
      group.visible = shouldShow;
      if (shouldShow && beams) {
        beams.forEach((beam, index) => {
          const t = index / beams.length;
          const flicker = 0.95 + Math.sin(this.time * 10 + index) * 0.05;
          beam.material.opacity = Math.max(0.7, (1 - t * 0.2) * intensity * flicker);
          beam.mesh.scale.x = beam.mesh.scale.y = 1 + Math.sin(this.time * 8 + index) * 0.05;
          beam.mesh.scale.z = 1 + intensity * 0.3;
        });
      }
    });
  }
  updateTrailVisibility(isMoving, thrust, velocity) {
    const mainEffect = this.thrusterEffects.find((e) => e.type === "main");
    if (mainEffect) {
      const shouldShow = thrust.forward || isMoving && velocity.length() > 2;
      mainEffect.group.visible = shouldShow;
    }
  }
  dispose() {
    this.thrusterEffects.forEach((effect) => {
      if (effect.group) {
        if (effect.group.parent) {
          effect.group.parent.remove(effect.group);
        }
        effect.group.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      }
    });
    this.thrusterEffects = [];
  }
}
class ShipModel {
  constructor(scene, shipScale = 2) {
    this.scene = scene;
    this.shipScale = shipScale;
    this.mesh = null;
    this.thrusters = [];
    this.leftCannon = null;
    this.rightCannon = null;
    this.leftEmitter = null;
    this.rightEmitter = null;
    this.miningLaser = null;
  }
  /**
   * Create the complete spaceship 3D model
   * @returns {THREE.Group} The spaceship mesh group
   */
  createSpaceship() {
    this.mesh = new Group();
    this.mesh.scale.set(this.shipScale, this.shipScale, this.shipScale);
    this.mesh.position.set(0, 2e3, 0);
    const bodyGroup = new Group();
    const cylinderGeometry = new CylinderGeometry(0.4, 0.5, 1.8, 12);
    const bodyMaterial = new MeshPhongMaterial({
      color: 16777215,
      // White base
      specular: 16766720,
      // Gold specular highlights
      shininess: 100,
      emissive: 2236962,
      emissiveIntensity: 0.1
    });
    const bodyCylinder = new Mesh(cylinderGeometry, bodyMaterial);
    bodyCylinder.rotation.x = Math.PI / 2;
    bodyGroup.add(bodyCylinder);
    const noseGeometry = new ConeGeometry(0.4, 0.8, 12);
    const noseCone = new Mesh(noseGeometry, bodyMaterial);
    noseCone.position.set(0, 0, -1.2);
    noseCone.rotation.x = -Math.PI / 2;
    bodyGroup.add(noseCone);
    this.mesh.add(bodyGroup);
    this._createCockpit();
    this._createCannons();
    this._createEmitters();
    this.miningLaser = this.leftEmitter;
    this._createWings();
    this._createGoldAccents();
    this._createThrusters();
    this.scene.add(this.mesh);
    return this.mesh;
  }
  /**
   * Create the cockpit glass dome
   */
  _createCockpit() {
    const cockpitGeometry = new SphereGeometry(0.35, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const cockpitMaterial = new MeshPhongMaterial({
      color: 8965375,
      specular: 16777215,
      shininess: 100,
      transparent: true,
      opacity: 0.7,
      emissive: 26367,
      emissiveIntensity: 0.1
    });
    const cockpit = new Mesh(cockpitGeometry, cockpitMaterial);
    cockpit.position.set(0, 0.25, -0.2);
    cockpit.rotation.x = -Math.PI / 2;
    this.mesh.add(cockpit);
  }
  /**
   * Create the dual front cannons
   */
  _createCannons() {
    const cannonGeometry = new CylinderGeometry(0.08, 0.06, 2, 8);
    const cannonMaterial = new MeshPhongMaterial({
      color: 16766720,
      // Gold
      specular: 16777215,
      shininess: 80,
      emissive: 16766720,
      emissiveIntensity: 0.2
    });
    this.leftCannon = new Mesh(cannonGeometry, cannonMaterial);
    this.leftCannon.position.set(0.2, 0, -1.5);
    this.leftCannon.rotation.x = Math.PI / 2;
    this.mesh.add(this.leftCannon);
    this.rightCannon = new Mesh(cannonGeometry, cannonMaterial);
    this.rightCannon.position.set(-0.2, 0, -1.5);
    this.rightCannon.rotation.x = Math.PI / 2;
    this.mesh.add(this.rightCannon);
  }
  /**
   * Create the cannon emitters (glowing tips)
   */
  _createEmitters() {
    const emitterGeometry = new SphereGeometry(0.08, 16, 16);
    const emitterMaterial = new MeshPhongMaterial({
      color: 16737792,
      emissive: 16724736,
      emissiveIntensity: 1
    });
    this.leftEmitter = new Mesh(emitterGeometry, emitterMaterial);
    this.leftEmitter.position.set(0.2, 0, -2.5);
    this.mesh.add(this.leftEmitter);
    this.rightEmitter = new Mesh(emitterGeometry, emitterMaterial);
    this.rightEmitter.position.set(-0.2, 0, -2.5);
    this.mesh.add(this.rightEmitter);
  }
  /**
   * Create curved wings using custom geometry
   */
  _createWings() {
    const createCurvedWing = (isLeft) => {
      const wingGroup = new Group();
      const wingMaterial = new MeshPhongMaterial({
        color: 16777215,
        // White
        specular: 16766720,
        // Gold specular 
        shininess: 80,
        emissive: 16777215,
        emissiveIntensity: 0.1
      });
      const wingBaseGeom = new BoxGeometry(0.1, 0.2, 0.6);
      const wingBase = new Mesh(wingBaseGeom, wingMaterial);
      wingBase.position.set(isLeft ? 0.55 : -0.55, 0, 0.2);
      wingGroup.add(wingBase);
      const wingCurveGeom = new BoxGeometry(0.8, 0.1, 0.5);
      const wingCurve = new Mesh(wingCurveGeom, wingMaterial);
      wingCurve.position.set(isLeft ? 1 : -1, 0, 0.2);
      wingCurve.rotation.z = isLeft ? Math.PI / 8 : -Math.PI / 8;
      wingGroup.add(wingCurve);
      const wingTipGeom = new BoxGeometry(0.3, 0.08, 0.3);
      const goldMaterial = new MeshPhongMaterial({
        color: 16766720,
        // Gold
        specular: 16777215,
        shininess: 100,
        emissive: 16766720,
        emissiveIntensity: 0.3
      });
      const wingTip = new Mesh(wingTipGeom, goldMaterial);
      wingTip.position.set(isLeft ? 1.4 : -1.4, 0, 0.2);
      wingTip.rotation.z = isLeft ? Math.PI / 6 : -Math.PI / 6;
      wingGroup.add(wingTip);
      return wingGroup;
    };
    const leftWing = createCurvedWing(true);
    this.mesh.add(leftWing);
    const rightWing = createCurvedWing(false);
    this.mesh.add(rightWing);
  }
  /**
   * Add gold accents to the ship body
   */
  _createGoldAccents() {
    const addGoldAccent = (width, height, depth, x, y, z, rotX = 0, rotY = 0, rotZ = 0) => {
      const accentGeom = new BoxGeometry(width, height, depth);
      const goldMaterial = new MeshPhongMaterial({
        color: 16766720,
        // Gold
        specular: 16777215,
        shininess: 100,
        emissive: 16766720,
        emissiveIntensity: 0.3
      });
      const accent = new Mesh(accentGeom, goldMaterial);
      accent.position.set(x, y, z);
      accent.rotation.set(rotX, rotY, rotZ);
      this.mesh.add(accent);
      return accent;
    };
    addGoldAccent(0.8, 0.05, 0.1, 0, -0.25, -0.3);
    addGoldAccent(0.8, 0.05, 0.1, 0, -0.25, 0.3);
    addGoldAccent(0.05, 0.05, 1, 0.3, -0.25, 0);
    addGoldAccent(0.05, 0.05, 1, -0.3, -0.25, 0);
  }
  /**
   * Create thrusters for the spaceship
   */
  _createThrusters() {
    const thrusterGeometry = new CylinderGeometry(0.2, 0.15, 0.5, 8);
    const thrusterMaterial = new MeshPhongMaterial({
      color: 16766720,
      // Gold
      emissive: 16733440,
      emissiveIntensity: 0.5
    });
    const mainThruster = new Mesh(thrusterGeometry, thrusterMaterial);
    mainThruster.position.z = 1.2;
    mainThruster.rotation.x = Math.PI;
    this.mesh.add(mainThruster);
    this.thrusters.push({ mesh: mainThruster, type: "main" });
    const reverseThruster = new Mesh(thrusterGeometry.clone(), thrusterMaterial.clone());
    reverseThruster.position.z = -1;
    reverseThruster.rotation.x = 0;
    reverseThruster.scale.set(0.6, 0.6, 0.6);
    this.mesh.add(reverseThruster);
    this.thrusters.push({ mesh: reverseThruster, type: "reverse" });
    const leftThruster = new Mesh(thrusterGeometry.clone(), thrusterMaterial.clone());
    leftThruster.position.set(0.5, 0, 0.5);
    leftThruster.rotation.z = Math.PI / 2;
    leftThruster.scale.set(0.5, 0.5, 0.5);
    this.mesh.add(leftThruster);
    this.thrusters.push({ mesh: leftThruster, type: "left" });
    const rightThruster = new Mesh(thrusterGeometry.clone(), thrusterMaterial.clone());
    rightThruster.position.set(-0.5, 0, 0.5);
    rightThruster.rotation.z = -Math.PI / 2;
    rightThruster.scale.set(0.5, 0.5, 0.5);
    this.mesh.add(rightThruster);
    this.thrusters.push({ mesh: rightThruster, type: "right" });
  }
  /**
   * Get references to important mesh components
   * @returns {object} Object containing mesh references
   */
  getComponents() {
    return {
      mesh: this.mesh,
      thrusters: this.thrusters,
      leftCannon: this.leftCannon,
      rightCannon: this.rightCannon,
      leftEmitter: this.leftEmitter,
      rightEmitter: this.rightEmitter,
      miningLaser: this.miningLaser
    };
  }
}
class ShipUpgrades {
  constructor(shipComponents) {
    this.components = shipComponents;
    this.fuelTankLevel = 1;
    this.fuelUpgradeCost = 1e3;
    this.engineLevel = 1;
    this.engineUpgradeCost = 800;
    this.miningLevel = 1;
    this.miningUpgradeCost = 1200;
    this.hullLevel = 1;
    this.hullUpgradeCost = 1500;
    this.scannerLevel = 1;
    this.scannerUpgradeCost = 600;
  }
  /**
   * Upgrade the fuel tank capacity
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} New fuel capacity
   */
  upgradeFuelTank(spaceshipState) {
    console.log("Upgrading fuel tank");
    spaceshipState.maxFuel *= 2;
    spaceshipState.fuel = spaceshipState.maxFuel;
    this.fuelTankLevel++;
    this.fuelUpgradeCost *= 4;
    return spaceshipState.maxFuel;
  }
  /**
   * Upgrade the ship's engines
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} New max velocity
   */
  upgradeEngine(spaceshipState) {
    console.log("Upgrading engines");
    spaceshipState.maxVelocity *= 1.25;
    this.components.thrusters.forEach((thruster) => {
      if (thruster.mesh && thruster.mesh.material) {
        thruster.mesh.material.emissiveIntensity += 0.2;
        if (this.engineLevel % 2 === 0) {
          thruster.mesh.material.emissive.setHex(16746496);
        } else {
          thruster.mesh.material.emissive.setHex(16755200);
        }
      }
    });
    this.engineLevel++;
    this.engineUpgradeCost = Math.floor(this.engineUpgradeCost * 2.5);
    return spaceshipState.maxVelocity;
  }
  /**
   * Upgrade the mining laser system
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} New mining efficiency
   */
  upgradeMiningLaser(spaceshipState) {
    console.log("Upgrading mining laser");
    spaceshipState.miningEfficiency *= 1.3;
    if (this.components.leftEmitter && this.components.leftEmitter.material) {
      this.components.leftEmitter.scale.set(1.1, 1.1, 1.1);
      const colors = [16711680, 16733440, 16750848, 16763904, 16772608];
      if (this.miningLevel < colors.length) {
        this.components.leftEmitter.material.color.setHex(colors[this.miningLevel]);
        this.components.leftEmitter.material.emissive.setHex(colors[this.miningLevel]);
      }
      this.components.leftEmitter.material.emissiveIntensity += 0.2;
    }
    if (this.components.rightEmitter && this.components.rightEmitter.material) {
      this.components.rightEmitter.scale.set(1.1, 1.1, 1.1);
      const colors = [16711680, 16733440, 16750848, 16763904, 16772608];
      if (this.miningLevel < colors.length) {
        this.components.rightEmitter.material.color.setHex(colors[this.miningLevel]);
        this.components.rightEmitter.material.emissive.setHex(colors[this.miningLevel]);
      }
      this.components.rightEmitter.material.emissiveIntensity += 0.2;
    }
    if (this.components.leftCannon && this.components.leftCannon.material) {
      this.components.leftCannon.scale.x *= 1.1;
      this.components.leftCannon.scale.y *= 1.1;
    }
    if (this.components.rightCannon && this.components.rightCannon.material) {
      this.components.rightCannon.scale.x *= 1.1;
      this.components.rightCannon.scale.y *= 1.1;
    }
    this.miningLevel++;
    this.miningUpgradeCost = Math.floor(this.miningUpgradeCost * 3);
    return spaceshipState.miningEfficiency;
  }
  /**
   * Upgrade the ship's hull armor
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} New collision resistance
   */
  upgradeHull(spaceshipState) {
    console.log("Upgrading hull");
    spaceshipState.collisionResistance *= 1.25;
    const bodyGroup = this.components.mesh.children.find((child) => child instanceof Group);
    if (bodyGroup && bodyGroup.children) {
      bodyGroup.children.forEach((part) => {
        if (part instanceof Mesh && part.material) {
          if (this.hullLevel % 2 === 0) {
            part.material.color.setHex(3195088);
          } else {
            part.material.color.setHex(3199168);
          }
          part.material.shininess += 10;
        }
      });
    }
    this.hullLevel++;
    this.hullUpgradeCost = Math.floor(this.hullUpgradeCost * 2);
    return spaceshipState.collisionResistance;
  }
  /**
   * Upgrade the ship's scanner system
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} New scanner range
   */
  upgradeScanner(spaceshipState) {
    console.log("Upgrading scanner");
    spaceshipState.scanRange *= 1.2;
    this.scannerLevel++;
    this.scannerUpgradeCost = Math.floor(this.scannerUpgradeCost * 1.8);
    return spaceshipState.scanRange;
  }
  /**
   * Get all upgrade levels for external access
   * @returns {object} All upgrade levels and costs
   */
  getUpgradeLevels() {
    return {
      fuelTankLevel: this.fuelTankLevel,
      fuelUpgradeCost: this.fuelUpgradeCost,
      engineLevel: this.engineLevel,
      engineUpgradeCost: this.engineUpgradeCost,
      miningLevel: this.miningLevel,
      miningUpgradeCost: this.miningUpgradeCost,
      hullLevel: this.hullLevel,
      hullUpgradeCost: this.hullUpgradeCost,
      scannerLevel: this.scannerLevel,
      scannerUpgradeCost: this.scannerUpgradeCost
    };
  }
  /**
   * Set upgrade levels from existing data (for loading saves)
   * @param {object} upgrades Upgrade data to restore
   */
  setUpgradeLevels(upgrades) {
    this.fuelTankLevel = upgrades.fuelTankLevel || 1;
    this.fuelUpgradeCost = upgrades.fuelUpgradeCost || 1e3;
    this.engineLevel = upgrades.engineLevel || 1;
    this.engineUpgradeCost = upgrades.engineUpgradeCost || 800;
    this.miningLevel = upgrades.miningLevel || 1;
    this.miningUpgradeCost = upgrades.miningUpgradeCost || 1200;
    this.hullLevel = upgrades.hullLevel || 1;
    this.hullUpgradeCost = upgrades.hullUpgradeCost || 1500;
    this.scannerLevel = upgrades.scannerLevel || 1;
    this.scannerUpgradeCost = upgrades.scannerUpgradeCost || 600;
  }
}
class ShipDocking {
  constructor(mesh, scene) {
    this.mesh = mesh;
    this.scene = scene;
    this.undockLocation = new Vector3(0, 1e4, 0);
  }
  /**
   * Dock the spaceship at the stargate
   * @param {object} spaceshipState Reference to spaceship state
   * @param {function} syncCallback Callback to sync values to health component
   */
  dock(spaceshipState, syncCallback) {
    console.log("Docking spaceship");
    console.log("Spaceship values before docking:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      isDocked: spaceshipState.isDocked
    });
    spaceshipState.isDocked = true;
    spaceshipState.velocity.set(0, 0, 0);
    this.mesh.visible = false;
    console.log("Spaceship values after docking:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      isDocked: spaceshipState.isDocked
    });
  }
  /**
   * Undock the spaceship from the stargate
   * @param {object} spaceshipState Reference to spaceship state
   * @param {function} syncCallback Callback to sync values to health component
   * @returns {THREE.Vector3} New position of the ship
   */
  undock(spaceshipState, syncCallback) {
    console.log("Undocking spaceship");
    console.log("Spaceship values before undocking:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      isDocked: spaceshipState.isDocked
    });
    const shieldBeforeUndock = spaceshipState.shield;
    spaceshipState.isDocked = false;
    this.mesh.visible = true;
    if (spaceshipState.shield !== shieldBeforeUndock) {
      console.log(`SHIELD RESET DETECTED during undock! Value changed from ${shieldBeforeUndock} to ${spaceshipState.shield}`);
      console.log("Restoring shield value to:", shieldBeforeUndock);
      spaceshipState.shield = shieldBeforeUndock;
    }
    console.log("Spaceship values after undocking:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      isDocked: spaceshipState.isDocked
    });
    if (syncCallback) {
      syncCallback();
    }
    if (this.undockLocation) {
      this.mesh.position.copy(this.undockLocation);
      this.mesh.rotation.set(Math.PI / 2, 0, 0);
    } else {
      const stargatePosition = this.scene.getObjectByName("stargate").position.clone();
      stargatePosition.z += 550;
      this.mesh.position.copy(stargatePosition);
      this.mesh.rotation.set(0, Math.PI, 0);
    }
    spaceshipState.velocity.set(0, 0, 0);
    return this.mesh.position.clone();
  }
  /**
   * Set the undocking location
   * @param {THREE.Vector3} location New undocking position
   */
  setUndockLocation(location2) {
    this.undockLocation = location2.clone();
  }
  /**
   * Get the current undocking location
   * @returns {THREE.Vector3} Current undocking position
   */
  getUndockLocation() {
    return this.undockLocation.clone();
  }
}
class ShipServices {
  constructor() {
  }
  /**
   * Refuel the spaceship to maximum capacity
   * @param {object} spaceshipState Reference to spaceship state
   * @returns {number} Cost of refueling
   */
  refuel(spaceshipState) {
    console.log("Refueling spaceship");
    spaceshipState.fuel = spaceshipState.maxFuel;
    return 100;
  }
  /**
   * Repair the ship's shield system
   * @param {object} spaceshipState Reference to spaceship state
   * @param {function} syncCallback Callback to sync values to health component
   * @returns {number} Cost of shield repair
   */
  repairShield(spaceshipState, syncCallback) {
    const oldShield = spaceshipState.shield;
    console.log(`===== SHIELD REPAIR INITIATED =====`);
    console.log(`Repairing shield: ${oldShield} → ${spaceshipState.maxShield}`);
    spaceshipState.shield = spaceshipState.maxShield;
    console.log(`Shield value is now: ${spaceshipState.shield} (Expected: ${spaceshipState.maxShield})`);
    console.log("Full spaceship state after shield repair:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      fuel: spaceshipState.fuel,
      maxFuel: spaceshipState.maxFuel
    });
    console.log(`===== SHIELD REPAIR COMPLETED =====`);
    if (window.game && window.game.world) {
      try {
        const players = window.game.world.getEntitiesByTag("player");
        if (players && players.length > 0) {
          const health = players[0].getComponent("HealthComponent");
          if (health) {
            const oldHealthShield = health.shield;
            health.shield = spaceshipState.shield;
            console.log(`Direct shield update on HealthComponent: ${oldHealthShield} → ${health.shield}`);
          }
        }
      } catch (e) {
        console.error("Error during direct HealthComponent update:", e);
      }
    }
    if (syncCallback) {
      syncCallback();
    }
    return 150;
  }
  /**
   * Repair the ship's hull structure
   * @param {object} spaceshipState Reference to spaceship state
   * @param {function} syncCallback Callback to sync values to health component
   * @returns {number} Cost of hull repair
   */
  repairHull(spaceshipState, syncCallback) {
    const oldHull = spaceshipState.hull;
    console.log(`===== HULL REPAIR INITIATED =====`);
    console.log(`Repairing hull: ${oldHull} → ${spaceshipState.maxHull}`);
    spaceshipState.hull = spaceshipState.maxHull;
    console.log(`Hull value is now: ${spaceshipState.hull} (Expected: ${spaceshipState.maxHull})`);
    console.log("Full spaceship state after hull repair:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull,
      fuel: spaceshipState.fuel,
      maxFuel: spaceshipState.maxFuel
    });
    console.log(`===== HULL REPAIR COMPLETED =====`);
    if (window.game && window.game.world) {
      try {
        const players = window.game.world.getEntitiesByTag("player");
        if (players && players.length > 0) {
          const health = players[0].getComponent("HealthComponent");
          if (health) {
            const oldHealthHull = health.health;
            health.health = spaceshipState.hull;
            console.log(`Direct hull update on HealthComponent: ${oldHealthHull} → ${health.health}`);
          }
        }
      } catch (e) {
        console.error("Error during direct HealthComponent update:", e);
      }
    }
    if (syncCallback) {
      syncCallback();
    }
    return 200;
  }
  /**
   * Check if fuel consumption is allowed and consume fuel
   * @param {object} spaceshipState Reference to spaceship state
   * @param {object} thrustState Current thrust state
   * @returns {boolean} True if we have fuel, false if empty
   */
  consumeFuel(spaceshipState, thrustState) {
    if (thrustState.forward || thrustState.backward || thrustState.left || thrustState.right) {
      let consumptionRate = spaceshipState.fuelConsumptionRate;
      if (thrustState.boost) {
        consumptionRate *= 3;
      }
      spaceshipState.fuel = Math.max(0, spaceshipState.fuel - consumptionRate);
    }
    return spaceshipState.fuel > 0;
  }
}
class ShipVisualEffects {
  constructor(shipComponents) {
    this.components = shipComponents;
  }
  /**
   * Activate mining laser visual effects
   */
  activateMiningLaser() {
    if (this.components.leftEmitter && this.components.rightEmitter) {
      this.components.leftEmitter.material.emissiveIntensity = 1.5;
      this.components.leftEmitter.scale.set(1.2, 1.2, 1.2);
      this.components.rightEmitter.material.emissiveIntensity = 1.5;
      this.components.rightEmitter.scale.set(1.2, 1.2, 1.2);
    }
  }
  /**
   * Deactivate mining laser visual effects
   */
  deactivateMiningLaser() {
    if (this.components.leftEmitter && this.components.rightEmitter) {
      this.components.leftEmitter.material.emissiveIntensity = 1;
      this.components.leftEmitter.scale.set(1, 1, 1);
      this.components.rightEmitter.material.emissiveIntensity = 1;
      this.components.rightEmitter.scale.set(1, 1, 1);
    }
  }
  /**
   * Update trail visibility based on movement
   * @param {boolean} isMoving Whether the ship is currently moving
   * @param {object} thrustState Current thrust state
   * @param {THREE.Vector3} velocity Current velocity
   * @param {object} trailEffects Trail effects instance
   */
  updateTrailVisibility(isMoving, thrustState, velocity, trailEffects) {
    if (trailEffects) {
      trailEffects.updateTrailVisibility(isMoving, thrustState, velocity);
    }
  }
  /**
   * Update particle effects
   * @param {object} thrustState Current thrust state
   * @param {THREE.Vector3} velocity Current velocity
   * @param {object} trailEffects Trail effects instance
   */
  updateParticles(thrustState, velocity, trailEffects) {
    if (trailEffects) {
      trailEffects.updateParticles(thrustState, velocity);
    }
  }
}
class HealthSync {
  constructor() {
  }
  /**
   * Subscribe to player entity destruction events
   * @param {MessageBus} messageBus The game's message bus
   * @param {function} destructionCallback Callback when player is destroyed
   */
  subscribeToDestructionEvents(messageBus, destructionCallback) {
    if (!messageBus) return;
    messageBus.subscribe("entity.destroyed", (message) => {
      const entity = message.data.entity;
      if (entity && entity.hasTag && entity.hasTag("player")) {
        console.log("Player entity destroyed - updating spaceship state");
        const healthComponent2 = entity.getComponent("HealthComponent");
        let hull = 0;
        let shield = 0;
        if (healthComponent2) {
          hull = healthComponent2.health;
          shield = healthComponent2.shield;
        } else {
          hull = 0;
          shield = 0;
        }
        destructionCallback(hull, shield);
      }
    });
    console.log("Spaceship subscribed to destruction events");
  }
  /**
   * Method to sync hull and shield values to the player entity's HealthComponent
   * @param {object} spaceshipState Current spaceship state
   */
  syncValuesToHealthComponent(spaceshipState) {
    console.log("Beginning shield and hull sync to HealthComponent");
    console.log("Current spaceship values:", {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull
    });
    const valuesForSync = {
      shield: spaceshipState.shield,
      maxShield: spaceshipState.maxShield,
      hull: spaceshipState.hull,
      maxHull: spaceshipState.maxHull
    };
    console.log(`Preparing to sync values to player HealthComponent: Shield=${spaceshipState.shield}, Hull=${spaceshipState.hull}`);
    try {
      if (window.game && window.game.messageBus) {
        window.game.messageBus.publish("player.syncHealth", valuesForSync);
        console.log("Published player.syncHealth event to game.messageBus with values:", valuesForSync);
      } else if (window.mainMessageBus) {
        window.mainMessageBus.publish("player.syncHealth", valuesForSync);
        console.log("Published player.syncHealth event to mainMessageBus with values:", valuesForSync);
      } else {
        console.warn("No message bus available to sync health values");
      }
    } catch (e) {
      console.error("Error publishing sync event:", e);
    }
    try {
      if (window.game && window.game.world) {
        const players = window.game.world.getEntitiesByTag("player");
        console.log(`Found ${players ? players.length : 0} player entities for direct sync`);
        if (players && players.length > 0) {
          const player = players[0];
          const health = player.getComponent("HealthComponent");
          if (health) {
            console.log("DIRECT SYNC - HealthComponent before sync:", {
              shield: health.shield,
              maxShield: health.maxShield,
              health: health.health,
              maxHealth: health.maxHealth
            });
            console.log("DIRECT SYNC - Spaceship values to sync:", {
              shield: spaceshipState.shield,
              maxShield: spaceshipState.maxShield,
              hull: spaceshipState.hull,
              maxHull: spaceshipState.maxHull
            });
            const oldShield = health.shield;
            health.shield = spaceshipState.shield;
            health.maxShield = spaceshipState.maxShield;
            const oldHealth = health.health;
            health.health = spaceshipState.hull;
            health.maxHealth = spaceshipState.maxHull;
            console.log(`Directly synced values to HealthComponent: Shield ${oldShield} → ${health.shield}, Hull ${oldHealth} → ${health.health}`);
            console.log("DIRECT SYNC - HealthComponent after sync:", {
              shield: health.shield,
              maxShield: health.maxShield,
              health: health.health,
              maxHealth: health.maxHealth
            });
          } else {
            console.warn("Player entity found but has no HealthComponent");
          }
        } else {
          console.warn("No player entities found for direct sync");
        }
      }
    } catch (e) {
      console.error("Error directly syncing values to HealthComponent:", e);
    }
  }
}
class Spaceship {
  constructor(scene) {
    this.scene = scene;
    this.mesh = null;
    this.thrusters = [];
    this.leftCannon = null;
    this.rightCannon = null;
    this.leftEmitter = null;
    this.rightEmitter = null;
    this.miningLaser = null;
    this.velocity = new Vector3(0, 0, 0);
    this.rotation = new Euler(0, 0, 0);
    this.thrust = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      boost: false
    };
    this.trailEffects = null;
    this.shipScale = 2;
    this.hull = 100;
    this.maxHull = 100;
    this.shield = 50;
    this.maxShield = 50;
    this.isDestroyed = false;
    this.fuel = 100;
    this.maxFuel = 100;
    this.fuelConsumptionRate = 0.01;
    this.isDocked = true;
    this.credits = 1e3;
    this.cargo = {
      iron: 0,
      gold: 0,
      platinum: 0
    };
    this.maxVelocity = 25;
    this.miningEfficiency = 1;
    this.collisionResistance = 1;
    this.scanRange = 1e3;
    this.deployableLaserCount = 0;
    this._initializeModules();
    this.createSpaceship();
    this.trailEffects = new TrailEffects(this.scene, this.mesh);
    if (this.mesh) {
      this.mesh.visible = false;
    }
  }
  /**
   * Initialize specialized modules for different aspects of the ship
   */
  _initializeModules() {
    this.shipModel = new ShipModel(this.scene, this.shipScale);
    this.shipUpgrades = null;
    this.shipDocking = null;
    this.shipServices = new ShipServices();
    this.shipVisualEffects = null;
    this.healthSync = new HealthSync();
  }
  /**
   * Create the spaceship using the model module
   */
  createSpaceship() {
    this.mesh = this.shipModel.createSpaceship();
    const components = this.shipModel.getComponents();
    this.thrusters = components.thrusters;
    this.leftCannon = components.leftCannon;
    this.rightCannon = components.rightCannon;
    this.leftEmitter = components.leftEmitter;
    this.rightEmitter = components.rightEmitter;
    this.miningLaser = components.miningLaser;
    this.shipUpgrades = new ShipUpgrades(components);
    this.shipDocking = new ShipDocking(this.mesh, this.scene);
    this.shipVisualEffects = new ShipVisualEffects(components);
  }
  // Methods for updating spaceship state in game loop
  update(deltaTime) {
    if (this.updateParticles && !this.isDocked) {
      this.updateParticles();
    }
  }
  // VISUAL EFFECTS - Delegate to visual effects module
  activateMiningLaser() {
    this.shipVisualEffects.activateMiningLaser();
  }
  deactivateMiningLaser() {
    this.shipVisualEffects.deactivateMiningLaser();
  }
  updateParticles() {
    this.shipVisualEffects.updateParticles(this.thrust, this.velocity, this.trailEffects);
  }
  updateTrailVisibility(isMoving) {
    this.shipVisualEffects.updateTrailVisibility(isMoving, this.thrust, this.velocity, this.trailEffects);
  }
  // DOCKING OPERATIONS - Delegate to docking module
  dock() {
    this.shipDocking.dock(this, this.syncValuesToHealthComponent.bind(this));
  }
  undock() {
    return this.shipDocking.undock(this, this.syncValuesToHealthComponent.bind(this));
  }
  // SERVICE OPERATIONS - Delegate to services module
  refuel() {
    return this.shipServices.refuel(this);
  }
  repairShield() {
    return this.shipServices.repairShield(this, this.syncValuesToHealthComponent.bind(this));
  }
  repairHull() {
    return this.shipServices.repairHull(this, this.syncValuesToHealthComponent.bind(this));
  }
  consumeFuel() {
    return this.shipServices.consumeFuel(this, this.thrust);
  }
  // UPGRADE OPERATIONS - Delegate to upgrades module
  upgradeFuelTank() {
    return this.shipUpgrades.upgradeFuelTank(this);
  }
  upgradeEngine() {
    return this.shipUpgrades.upgradeEngine(this);
  }
  upgradeMiningLaser() {
    return this.shipUpgrades.upgradeMiningLaser(this);
  }
  upgradeHull() {
    return this.shipUpgrades.upgradeHull(this);
  }
  upgradeScanner() {
    return this.shipUpgrades.upgradeScanner(this);
  }
  // Upgrade level access methods
  get fuelTankLevel() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.fuelTankLevel) || 1;
  }
  get fuelUpgradeCost() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.fuelUpgradeCost) || 1e3;
  }
  get engineLevel() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.engineLevel) || 1;
  }
  get engineUpgradeCost() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.engineUpgradeCost) || 800;
  }
  get miningLevel() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.miningLevel) || 1;
  }
  get miningUpgradeCost() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.miningUpgradeCost) || 1200;
  }
  get hullLevel() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.hullLevel) || 1;
  }
  get hullUpgradeCost() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.hullUpgradeCost) || 1500;
  }
  get scannerLevel() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.scannerLevel) || 1;
  }
  get scannerUpgradeCost() {
    var _a;
    return ((_a = this.shipUpgrades) == null ? void 0 : _a.scannerUpgradeCost) || 600;
  }
  // HEALTH SYNCHRONIZATION - Delegate to health sync module
  subscribeToDestructionEvents(messageBus) {
    this.healthSync.subscribeToDestructionEvents(messageBus, this.handleDestruction.bind(this));
  }
  syncValuesToHealthComponent() {
    this.healthSync.syncValuesToHealthComponent(this);
  }
  /**
   * Handle ship destruction effects
   */
  handleDestruction(hull, shield) {
    this.isDestroyed = true;
    this.hull = hull;
    this.shield = shield;
    if (this.mesh) {
      if (this.trailEffects) {
        this.trailEffects.particleSystems.forEach((ps) => {
          if (ps && ps.system) {
            ps.system.visible = false;
          }
        });
      }
    }
  }
  // POSITION AND ROTATION ACCESS (for external systems)
  get position() {
    return this.mesh ? this.mesh.position : new Vector3(0, 0, 0);
  }
  get rotation() {
    return this.mesh ? this.mesh.rotation : new Euler(0, 0, 0);
  }
  set position(newPosition) {
    if (this.mesh) {
      this.mesh.position.copy(newPosition);
    }
  }
  set rotation(newRotation) {
    if (this.mesh) {
      this.mesh.rotation.copy(newRotation);
    }
  }
  // UNDOCK LOCATION ACCESS
  get undockLocation() {
    var _a;
    return ((_a = this.shipDocking) == null ? void 0 : _a.getUndockLocation()) || new Vector3(0, 1e4, 0);
  }
  set undockLocation(location2) {
    if (this.shipDocking) {
      this.shipDocking.setUndockLocation(location2);
    }
  }
}
const _Physics = class _Physics {
  // Small friction to help with control (new)
  constructor(scene) {
    this.scene = scene;
    this.spaceship = null;
    this.camera = null;
    this.rotationState = {
      x: 0,
      y: 0
    };
    this.collided = false;
    this.raycaster = new Raycaster();
    this.direction = new Vector3(0, 0, -1);
    this.collisionDistance = _Physics.COLLISION_DISTANCE;
  }
  // Set spaceship reference
  setSpaceship(spaceship) {
    this.spaceship = spaceship;
  }
  // Set camera reference
  setCamera(camera) {
    this.camera = camera;
  }
  update(deltaTime) {
    if (!this.spaceship || this.spaceship.isDestroyed) return;
    if (this.spaceship.isDocked) return;
    if (window.game && window.game.introSequenceActive) {
      return;
    }
    this.normalizedDeltaTime = deltaTime * 60;
    const hasFuel = this.spaceship.consumeFuel();
    let thrustVector = new Vector3(0, 0, 0);
    let isThrusting = false;
    const shipForward = new Vector3(0, 0, -1);
    shipForward.applyQuaternion(this.spaceship.mesh.quaternion);
    shipForward.dot(this.spaceship.velocity);
    if (hasFuel) {
      const intent = window.inputIntent || 0;
      const forwardPressed = this.spaceship.thrust.forward || (intent & 1) !== 0;
      const backwardPressed = this.spaceship.thrust.backward || (intent & 2) !== 0;
      const leftPressed = this.spaceship.thrust.left || (intent & 4) !== 0;
      const rightPressed = this.spaceship.thrust.right || (intent & 8) !== 0;
      const boostPressed = this.spaceship.thrust.boost || (intent & 16) !== 0;
      if (forwardPressed) {
        isThrusting = true;
        const forwardThrust = new Vector3(0, 0, -0.5);
        if (boostPressed) forwardThrust.multiplyScalar(_Physics.BOOST_MULTIPLIER);
        thrustVector.add(forwardThrust);
      }
      if (backwardPressed) {
        isThrusting = true;
        thrustVector.add(new Vector3(0, 0, _Physics.THRUST_FORCE));
      }
      if (leftPressed) {
        isThrusting = true;
        thrustVector.add(new Vector3(-0.5, 0, 0));
      }
      if (rightPressed) {
        isThrusting = true;
        thrustVector.add(new Vector3(_Physics.THRUST_FORCE, 0, 0));
      }
      if (isThrusting) {
        thrustVector.applyQuaternion(this.spaceship.mesh.quaternion);
        thrustVector.multiplyScalar(this.normalizedDeltaTime);
        this.spaceship.velocity.add(thrustVector);
        const maxVelocity = this.getMaxVelocity();
        if (this.spaceship.velocity.length() > maxVelocity) {
          this.spaceship.velocity.normalize().multiplyScalar(maxVelocity);
        }
      }
    }
    if (!isThrusting && this.spaceship.velocity.length() > 0) {
      const friction = _Physics.FRICTION * this.normalizedDeltaTime;
      if (this.spaceship.velocity.length() > friction) {
        this.spaceship.velocity.multiplyScalar(1 - friction);
      } else {
        this.spaceship.velocity.set(0, 0, 0);
      }
    }
    const positionDelta = this.spaceship.velocity.clone().multiplyScalar(this.normalizedDeltaTime);
    this.spaceship.mesh.position.add(positionDelta);
    this.updateShipRotation();
    this.updateCamera();
    if (this.spaceship.trailEffects) {
      this.spaceship.thrust.forward || this.spaceship.thrust.backward || this.spaceship.thrust.left || this.spaceship.thrust.right;
      const isMoving = this.spaceship.velocity.length() > 0.1;
      this.spaceship.trailEffects.updateTrailVisibility(isMoving, this.spaceship.thrust, this.spaceship.velocity);
      this.spaceship.trailEffects.updateParticles(this.spaceship.thrust, this.spaceship.velocity);
    }
    this.checkCollisions();
  }
  // Helper method to get the max velocity from the spaceship or use the default
  getMaxVelocity() {
    return this.spaceship && this.spaceship.maxVelocity ? this.spaceship.maxVelocity : _Physics.MAX_VELOCITY;
  }
  updateShipRotation() {
    if (!this.spaceship) return;
    const maxY = Math.PI * 0.45;
    this.rotationState.y = Math.max(Math.min(this.rotationState.y, maxY), -maxY);
    const euler = new Euler(this.rotationState.y, this.rotationState.x, 0, "YXZ");
    const targetQuaternion = new Quaternion().setFromEuler(euler);
    this.spaceship.mesh.quaternion.slerp(targetQuaternion, _Physics.ROTATION_SPEED * this.normalizedDeltaTime);
  }
  updateCamera() {
    if (!this.spaceship || !this.camera) return;
    if (window.game && window.game.introSequenceActive) {
      console.log("Skipping camera update - intro sequence active");
      return;
    }
    const cameraOffset = new Vector3(0, 5, 25);
    const rotatedOffset = cameraOffset.clone();
    rotatedOffset.applyQuaternion(this.spaceship.mesh.quaternion);
    this.camera.position.copy(this.spaceship.mesh.position).add(rotatedOffset);
    const lookAtPoint = new Vector3(0, 0, -60);
    lookAtPoint.applyQuaternion(this.spaceship.mesh.quaternion);
    lookAtPoint.add(this.spaceship.mesh.position);
    this.camera.lookAt(lookAtPoint);
    this.camera.far = 4e5;
    this.camera.updateProjectionMatrix();
  }
  // Update rotation based on mouse movement deltas
  updateRotation(deltaX, deltaY) {
    this.rotationState.x -= deltaX;
    this.rotationState.y -= deltaY;
  }
  // Check for collisions with asteroids and planets
  checkCollisions() {
    if (!this.scene || !this.spaceship) return;
    const shipRadius = 15;
    const shipPosition = this.spaceship.mesh.position.clone();
    this.scene.traverse((object) => {
      var _a;
      if (object.type === "Mesh" && ((_a = object.geometry.type) == null ? void 0 : _a.includes("SphereGeometry")) && object.userData.isPlayerProjectile && object.userData.sourceId === "player") {
        return;
      }
    });
    const asteroidMeshes = [];
    const asteroidBelt2 = this.scene.children.find((child) => child.name === "asteroidBelt");
    let asteroids = [];
    if (asteroidBelt2 && asteroidBelt2.userData && asteroidBelt2.userData.asteroids) {
      asteroids = asteroidBelt2.userData.asteroids;
      asteroidMeshes.push(...asteroids.map((a) => a.mesh));
    } else {
      this.scene.traverse((object) => {
        var _a, _b, _c;
        if (object.type === "Mesh" && (((_a = object.geometry.type) == null ? void 0 : _a.includes("IcosahedronGeometry")) || ((_b = object.geometry.type) == null ? void 0 : _b.includes("TetrahedronGeometry")) || ((_c = object.geometry.type) == null ? void 0 : _c.includes("OctahedronGeometry")))) {
          const distFromCenter = Math.sqrt(
            object.position.x * object.position.x + object.position.z * object.position.z
          );
          if (distFromCenter > 16e3 && distFromCenter < 32e3) {
            asteroidMeshes.push(object);
          }
        }
      });
    }
    for (const asteroid of asteroidMeshes) {
      if (!asteroid || !asteroid.visible) continue;
      const distance = shipPosition.distanceTo(asteroid.position);
      let asteroidRadius = 0;
      if (asteroid.geometry && asteroid.geometry.parameters && asteroid.geometry.parameters.radius) {
        asteroidRadius = asteroid.geometry.parameters.radius;
      } else {
        asteroidRadius = 60;
      }
      if (distance < shipRadius + asteroidRadius) {
        if (window.DEBUG_MODE) {
          console.log(
            "Asteroid collision detected!",
            "Ship position:",
            shipPosition,
            "Asteroid position:",
            asteroid.position,
            "Distance:",
            distance,
            "Detection threshold:",
            shipRadius + asteroidRadius
          );
        }
        this.handleCollision(asteroid, "asteroid");
        return;
      }
    }
    this.scene.traverse((object) => {
      var _a;
      if (object.type === "Mesh" && object.geometry.type.includes("SphereGeometry") && object.scale.x >= 1 && // To filter out particles and small objects
      !((_a = object.userData.id) == null ? void 0 : _a.startsWith("asteroid-")) && // Not an asteroid
      !object.userData.isPlayerProjectile && // Not a player projectile
      object !== this.spaceship.mesh) {
        const distance = shipPosition.distanceTo(object.position);
        const planetRadius = object.geometry.parameters.radius * object.scale.x;
        if (object.material.emissive && object.material.emissive.r > 0.5 && object.material.emissive.g > 0.5) {
          if (distance < planetRadius + shipRadius) {
            this.handleCollision(object, "sun");
            return;
          }
        } else if (distance < planetRadius + shipRadius) {
          this.handleCollision(object, "planet");
          return;
        }
      }
    });
  }
  handleCollision(object, type) {
    if (this.collided || !this.scene) return;
    this.collided = true;
    if (window.DEBUG_MODE) {
      console.log("=== COLLISION DETECTED ===");
      console.log(`Collision type: ${type}`);
      console.log(`Ship velocity at impact: ${this.spaceship.velocity.length().toFixed(2)} units/frame`);
      console.log(`Ship position: x=${this.spaceship.mesh.position.x.toFixed(0)}, y=${this.spaceship.mesh.position.y.toFixed(0)}, z=${this.spaceship.mesh.position.z.toFixed(0)}`);
      console.log(`${type} position: x=${object.position.x.toFixed(0)}, y=${object.position.y.toFixed(0)}, z=${object.position.z.toFixed(0)}`);
      console.log(`Hull resistance: ${this.spaceship.collisionResistance}`);
    }
    if (this.attemptCollisionRecovery(type)) {
      if (window.DEBUG_MODE) console.log("Hull absorbed collision damage!");
      this.createRecoveryEffect();
      if (object && object.position) {
        const bounceDirection = new Vector3().subVectors(this.spaceship.mesh.position, object.position).normalize();
        this.spaceship.velocity.copy(bounceDirection.multiplyScalar(5));
      }
      if (window.game && window.game.audio) {
        window.game.audio.playSound("boink");
      }
      setTimeout(() => {
        this.collided = false;
        if (window.DEBUG_MODE) console.log("Collision state reset - ship ready for new collisions");
      }, 1e3);
      return;
    }
    this.spaceship.velocity.set(0, 0, 0);
    let explosionColor, explosionSize, explosionMessage, collisionType;
    if (type === "sun") {
      explosionColor = 16776960;
      explosionSize = 60;
      explosionMessage = "Your ship was incinerated by the sun!";
      collisionType = "SUN_DEATH";
    } else if (type === "planet") {
      explosionColor = 3394815;
      explosionSize = 40;
      explosionMessage = "Your ship crashed into a planet!";
      collisionType = "COLLISION_PLANET";
    } else {
      explosionColor = 16737792;
      explosionSize = 20;
      explosionMessage = "Your ship was destroyed by an asteroid!";
      collisionType = "COLLISION_ASTEROID";
    }
    const explosionGeometry = new SphereGeometry(explosionSize, 32, 32);
    const explosionMaterial = new MeshBasicMaterial({
      color: explosionColor,
      transparent: true,
      opacity: 0.8
    });
    const explosion = new Mesh(explosionGeometry, explosionMaterial);
    explosion.position.copy(this.spaceship.mesh.position);
    this.scene.add(explosion);
    this.animateExplosion(explosion);
    if (this.spaceship) {
      this.spaceship.isDestroyed = true;
    }
    console.log("Physics: Initiating game over sequence for collision with", type);
    if (window.mainMessageBus) {
      console.log("Physics: Using window.mainMessageBus");
      window.mainMessageBus.publish("game.over", {
        reason: explosionMessage,
        source: "physics",
        collisionType: type,
        type: collisionType
      });
    } else if (window.game && window.game.messageBus) {
      console.log("Physics: Using window.game.messageBus");
      window.game.messageBus.publish("game.over", {
        reason: explosionMessage,
        source: "physics",
        collisionType: type,
        type: collisionType
      });
    } else {
      __vitePreload(() => import("./core-CQR7b8gS.js"), true ? [] : void 0).then((module) => {
        const MessageBus2 = module.MessageBus;
        console.log("Physics: Using MessageBus.triggerGameOver");
        MessageBus2.triggerGameOver(explosionMessage, "physics");
      }).catch((err) => {
        console.error("Physics: Error importing MessageBus:", err);
      });
    }
  }
  // Method to attempt to recover from a collision based on hull resistance
  attemptCollisionRecovery(collisionType) {
    if (!this.spaceship || !this.spaceship.collisionResistance)
      return false;
    const resistance = this.spaceship.collisionResistance;
    let recoveryChance = 0;
    switch (collisionType) {
      case "asteroid":
        recoveryChance = 0.5 + (resistance - 1) * 0.08;
        if (window.DEBUG_MODE) console.log(`Asteroid collision recovery chance: ${(recoveryChance * 100).toFixed(1)}%`);
        break;
      case "planet":
        recoveryChance = 0.1 + (resistance - 1) * 0.2;
        if (window.DEBUG_MODE) console.log(`Planet collision recovery chance: ${(recoveryChance * 100).toFixed(1)}%`);
        break;
      case "sun":
        recoveryChance = (resistance - 1) * 0.05;
        if (window.DEBUG_MODE) console.log(`Sun collision recovery chance: ${(recoveryChance * 100).toFixed(1)}%`);
        break;
      default:
        recoveryChance = 0.2 + (resistance - 1) * 0.3;
        if (window.DEBUG_MODE) console.log(`Generic collision recovery chance: ${(recoveryChance * 100).toFixed(1)}%`);
    }
    const recoveryRoll = Math.random();
    const survived = recoveryRoll < recoveryChance;
    if (window.DEBUG_MODE) console.log(`Recovery roll: ${recoveryRoll.toFixed(3)}, needed ${recoveryChance.toFixed(3)} or lower to survive`);
    return survived;
  }
  // Create a visual effect when the ship survives a collision
  createRecoveryEffect() {
    if (!this.spaceship || !this.scene) return;
    const shieldGeometry = new SphereGeometry(60, 32, 32);
    const shieldMaterial = new MeshBasicMaterial({
      color: 3198928,
      transparent: true,
      opacity: 0.6,
      side: DoubleSide
    });
    const shield = new Mesh(shieldGeometry, shieldMaterial);
    shield.position.copy(this.spaceship.mesh.position);
    this.scene.add(shield);
    let scale = 1;
    const expandSpeed = 0.05;
    const fadeSpeed = 0.02;
    const animateShield = () => {
      if (scale > 2 || shield.material.opacity <= 0) {
        this.scene.remove(shield);
        return;
      }
      scale += expandSpeed;
      shield.scale.set(scale, scale, scale);
      shield.material.opacity -= fadeSpeed;
      if (this.spaceship && this.spaceship.mesh) {
        shield.position.copy(this.spaceship.mesh.position);
      }
      requestAnimationFrame(animateShield);
    };
    animateShield();
  }
  animateExplosion(explosion) {
    let scale = 1;
    const expandSpeed = 0.5;
    const fadeSpeed = 0.02;
    const animate = () => {
      if (scale > 20 || explosion.material.opacity <= 0) {
        this.scene.remove(explosion);
        return;
      }
      scale += expandSpeed;
      explosion.scale.set(scale, scale, scale);
      explosion.material.opacity -= fadeSpeed;
      requestAnimationFrame(animate);
    };
    animate();
  }
};
// Physics constants - significantly increased for super-fast movement
__publicField(_Physics, "THRUST_FORCE", 0.5);
// 5x increase from previous 0.1
__publicField(_Physics, "BOOST_MULTIPLIER", 4);
// Keep the same boost multiplier
__publicField(_Physics, "MAX_VELOCITY", 25);
// Default maximum velocity (will use spaceship's value if available)
__publicField(_Physics, "ROTATION_SPEED", 0.3);
// Increased for more responsive controls
__publicField(_Physics, "COLLISION_DISTANCE", 15);
// Reduced from 70 to match actual ship size
__publicField(_Physics, "FRICTION", 0.01);
let Physics = _Physics;
class Skybox {
  constructor(scene) {
    this.scene = scene;
    this.skybox = null;
    this.time = 0;
    this.textureLoader = new TextureLoader();
    this.milkyWayTexture = this.textureLoader.load("./assets/2k_stars_milky_way.jpg");
    this.milkyWayTexture.colorSpace = SRGBColorSpace;
    this.skyboxTextures = {};
    this.solarSystemParams = {
      starDensity: 1,
      nebulaDensity: 0.5,
      color: 16777215,
      texturePath: "./assets/2k_stars_milky_way.jpg",
      brightness: 1
      // Default brightness for Solar System
    };
    this.createProceduralSkybox(this.solarSystemParams);
  }
  // Update skybox based on star system parameters
  updateForSystem(params) {
    if (!params) return;
    console.log("Updating skybox with parameters:", params);
    if (params.isSolarSystem || params.color === 16777215 && params.starDensity === 1 && params.nebulaDensity === 0.5) {
      console.log("Detected Solar System skybox parameters, using stored solar system configuration");
      params = this.solarSystemParams;
    }
    if (this.skybox) {
      console.log("Removing existing skybox");
      this.scene.remove(this.skybox);
    }
    if (params.resetTime) {
      this.time = 0;
    }
    this.createProceduralSkybox(params);
  }
  // Load texture if needed and return it
  getTexture(texturePath) {
    if (!texturePath) {
      return this.milkyWayTexture;
    }
    if (texturePath === "./assets/2k_stars_milky_way.jpg") {
      return this.milkyWayTexture;
    }
    let adjustedTexturePath = texturePath;
    if (texturePath.startsWith("/images/")) {
      if (window.location.port === "8000") {
        const serverHost = window.location.hostname;
        adjustedTexturePath = `http://${serverHost}:8001${texturePath}`;
        console.log(`Adjusted texture path to API server: ${adjustedTexturePath}`);
      }
    }
    if (!this.skyboxTextures[texturePath]) {
      console.log(`Loading new skybox texture: ${adjustedTexturePath}`);
      this.skyboxTextures[texturePath] = this.textureLoader.load(adjustedTexturePath);
      this.skyboxTextures[texturePath].colorSpace = SRGBColorSpace;
    }
    return this.skyboxTextures[texturePath];
  }
  createProceduralSkybox(params = {}) {
    let starDensity = (params == null ? void 0 : params.starDensity) || 1;
    let nebulaDensity = (params == null ? void 0 : params.nebulaDensity) || 0.5;
    let skyboxColor = (params == null ? void 0 : params.color) || 0;
    let brightness = (params == null ? void 0 : params.brightness) !== void 0 ? params.brightness : 1;
    const size = 32e4;
    const texturePath = (params == null ? void 0 : params.texturePath) || "./assets/2k_stars_milky_way.jpg";
    console.log(`Creating enhanced skybox with star density: ${starDensity}, nebula density: ${nebulaDensity}, color: 0x${skyboxColor.toString(16)}, texture: ${texturePath}, brightness: ${brightness}`);
    const skyboxTexture = this.getTexture(texturePath);
    const skyMaterial = new ShaderMaterial({
      uniforms: {
        time: { value: this.time || 0 },
        milkyWayTexture: { value: skyboxTexture },
        starDensity: { value: starDensity },
        nebulaDensity: { value: nebulaDensity },
        skyColor: { value: new Color(skyboxColor) },
        brightness: { value: brightness }
      },
      vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform sampler2D milkyWayTexture;
                uniform float time;
                uniform float starDensity;
                uniform float nebulaDensity;
                uniform vec3 skyColor;
                uniform float brightness;
                
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    // Sample the Milky Way texture with adjusted brightness
                    vec4 milkyWay = texture2D(milkyWayTexture, vUv);
                    milkyWay.rgb *= 1.5 * brightness; // Apply brightness factor
                    
                    // Use only the Milky Way texture without procedural stars
                    vec3 finalColor = milkyWay.rgb * nebulaDensity * 1.2 * brightness;
                    
                    // Reduced ambient light
                    finalColor += vec3(0.05);
                    
                    // Subtle color tint
                    finalColor = mix(finalColor, skyColor * 1.2 * brightness, 0.1);
                    
                    // Apply gamma correction for more natural brightness
                    finalColor = pow(finalColor, vec3(0.9));
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
      side: BackSide
    });
    const skyboxGeometry = new BoxGeometry(size, size, size);
    this.skybox = new Mesh(skyboxGeometry, skyMaterial);
    this.skybox.rotation.x = Math.PI / 4;
    this.skybox.rotation.y = Math.PI / 6;
    this.scene.add(this.skybox);
    this.skyMaterial = skyMaterial;
    console.log("Enhanced skybox created with texture");
  }
  update(deltaTime = 0.016, camera) {
    if (this.skyMaterial) {
      this.time += deltaTime * 0.1;
      this.skyMaterial.uniforms.time.value = this.time;
    }
    if (this.skybox && camera) {
      this.skybox.position.copy(camera.position);
    }
  }
}
class SunShaders {
  static createSunMaterial() {
    return new ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        sunColor: { value: new Color(16742144) },
        surfaceDetail: { value: 1.2 },
        surfaceDistortion: { value: 0.3 },
        sunActivity: { value: 0.8 }
      },
      vertexShader: `
                varying vec3 vNormal;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform float time;
                uniform vec3 sunColor;
                uniform float surfaceDetail;
                uniform float surfaceDistortion;
                uniform float sunActivity;
                
                varying vec3 vNormal;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                float hash(float n) { return fract(sin(n) * 43758.5453123); }
                float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
                
                float noise(vec3 x) {
                    vec3 p = floor(x);
                    vec3 f = fract(x);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    float n = p.x + p.y * 157.0 + 113.0 * p.z;
                    return mix(
                        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                            mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
                        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                            mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y),
                        f.z);
                }
                
                float fbm(vec3 x) {
                    float v = 0.0;
                    float a = 0.5;
                    vec3 shift = vec3(100);
                    
                    for (int i = 0; i < 7; ++i) {
                        v += a * noise(x);
                        x = x * 2.0 + shift;
                        a *= 0.5;
                    }
                    
                    return v;
                }
                
                void main() {
                    vec3 surfacePos = vPosition * surfaceDetail * 0.01;
                    float granulation = fbm(surfacePos + time * 0.15);
                    
                    float flareBase = fbm(surfacePos * 2.5 + time * 0.3);
                    float flares = pow(flareBase, 1.8) * sunActivity;
                    flares = smoothstep(0.65, 0.9, flares);
                    
                    float hotspots = fbm(surfacePos * 3.0 + time * 0.2) * fbm(surfacePos * 1.5 - time * 0.1);
                    hotspots = pow(hotspots, 3.0) * 1.5;
                    
                    vec3 distortedNormal = vNormal;
                    distortedNormal.x += noise(surfacePos * 6.0 + time * 0.15) * surfaceDistortion;
                    distortedNormal.y += noise(surfacePos * 6.0 + time * 0.2) * surfaceDistortion;
                    distortedNormal.z += noise(surfacePos * 6.0 + time * 0.17) * surfaceDistortion;
                    distortedNormal = normalize(distortedNormal);
                    
                    float edgeBrightness = 1.0 - dot(distortedNormal, vec3(0.0, 0.0, 1.0));
                    edgeBrightness = pow(edgeBrightness, 2.5) * 0.4;
                    
                    vec3 baseColor = sunColor;
                    vec3 hotColor = vec3(1.0, 0.8, 0.4);
                    vec3 flareColor = vec3(1.0, 0.6, 0.3);
                    
                    vec3 finalColor = baseColor * (1.0 + granulation * 0.4);
                    finalColor = mix(finalColor, hotColor, hotspots);
                    finalColor += flareColor * flares;
                    finalColor += vec3(1.0, 0.9, 0.7) * edgeBrightness;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
      side: FrontSide
    });
  }
  static createCoronaMaterial() {
    return new ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        coronaColor: { value: new Color(16750912) },
        viewVector: { value: new Vector3(0, 0, 1) },
        turbulence: { value: 0.6 }
      },
      vertexShader: `
                uniform vec3 viewVector;
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying float vIntensity;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    
                    vec3 viewDir = normalize(viewVector);
                    vIntensity = pow(1.15 - dot(vNormal, viewDir), 1.5) * 0.8 + 0.2;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform float time;
                uniform vec3 coronaColor;
                uniform float turbulence;
                
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying float vIntensity;
                
                float hash(vec3 p) {
                    p = fract(p * vec3(443.897, 441.423, 437.195));
                    p += dot(p, p.yzx + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f*f*(3.0-2.0*f);
                    
                    return mix(
                        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float f = 0.0;
                    float weight = 0.5;
                    for (int i = 0; i < 5; i++) {
                        f += weight * noise(p);
                        weight *= 0.5;
                        p *= 2.0;
                    }
                    return f;
                }
                
                void main() {
                    float turbulenceFactor = fbm(vPosition * 0.005 + time * 0.15) * turbulence;
                    float finalIntensity = vIntensity * (1.0 + turbulenceFactor);
                    
                    float wisps = fbm(vPosition * 0.01 - time * 0.05) * fbm(vPosition * 0.02 + time * 0.1);
                    wisps = pow(wisps, 2.0) * 0.5;
                    
                    vec3 finalColor = coronaColor * (finalIntensity + wisps);
                    
                    if (finalIntensity > 0.7) {
                        finalColor = mix(finalColor, vec3(1.0, 0.9, 0.7), (finalIntensity - 0.7) * 3.0);
                    }
                    
                    float alpha = smoothstep(0.0, 0.15, finalIntensity + wisps * 0.5);
                    
                    gl_FragColor = vec4(finalColor, alpha * 0.9);
                }
            `,
      transparent: true,
      blending: AdditiveBlending,
      depthWrite: false,
      side: BackSide
    });
  }
  static createOuterCoronaMaterial() {
    return new ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        coronaColor: { value: new Color(16746496) },
        viewVector: { value: new Vector3(0, 0, 1) }
      },
      vertexShader: `
                uniform vec3 viewVector;
                varying float vIntensity;
                varying vec3 vPosition;
                
                void main() {
                    vec3 vNormal = normalize(normalMatrix * normal);
                    vec3 vNormel = normalize(viewVector);
                    vIntensity = pow(1.05 - dot(vNormal, vNormel), 2.0) * 0.7 + 0.3;
                    vPosition = position;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform float time;
                uniform vec3 coronaColor;
                varying float vIntensity;
                varying vec3 vPosition;
                
                float hash(vec3 p) {
                    p = fract(p * vec3(443.897, 441.423, 437.195));
                    p += dot(p, p.yzx + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f*f*(3.0-2.0*f);
                    
                    return mix(
                        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                void main() {
                    float noiseVal = noise(vPosition * 0.002 + time * 0.1);
                    float pulseIntensity = vIntensity * (1.0 + 0.2 * sin(time + noiseVal * 5.0));
                    
                    pulseIntensity += noiseVal * 0.2;
                    
                    vec3 glow = coronaColor * pulseIntensity;
                    gl_FragColor = vec4(glow, pulseIntensity * 0.4);
                }
            `,
      transparent: true,
      blending: AdditiveBlending,
      depthWrite: false,
      side: BackSide
    });
  }
}
class SunFlares {
  constructor(scene, sunGroup) {
    this.scene = scene;
    this.sunGroup = sunGroup;
    this.lensFlares = [];
    this.createFireballFlares();
  }
  createFireballFlares() {
    const flareTextures = [
      "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/lensflare/lensflare0.png",
      "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/lensflare/lensflare2.png",
      "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/lensflare/lensflare3.png"
    ];
    const textureLoader2 = new TextureLoader();
    this.clearFlares();
    const mainFlareTexture = textureLoader2.load(flareTextures[0]);
    mainFlareTexture.colorSpace = SRGBColorSpace;
    const mainFlare = new Sprite(new SpriteMaterial({
      map: mainFlareTexture,
      color: 16755285,
      transparent: true,
      blending: AdditiveBlending,
      depthTest: false
    }));
    mainFlare.scale.set(700, 700, 1);
    this.sunGroup.add(mainFlare);
    this.lensFlares.push(mainFlare);
    const flareCount = 8;
    const radius = 300;
    for (let i = 0; i < flareCount; i++) {
      const textureIndex = 1 + i % 2;
      const flareTexture = textureLoader2.load(flareTextures[textureIndex]);
      flareTexture.colorSpace = SRGBColorSpace;
      const flare = new Sprite(new SpriteMaterial({
        map: flareTexture,
        color: i % 3 === 0 ? 16764023 : i % 3 === 1 ? 16746581 : 16737826,
        transparent: true,
        blending: AdditiveBlending,
        depthTest: false
      }));
      const angle = i / flareCount * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      flare.position.set(x, y, 0);
      const size = 200 + Math.random() * 200;
      flare.scale.set(size, size, 1);
      this.sunGroup.add(flare);
      this.lensFlares.push(flare);
      if (i % 2 === 0) {
        const smallFlareTexture = textureLoader2.load(flareTextures[i % 3]);
        smallFlareTexture.colorSpace = SRGBColorSpace;
        const smallFlare = new Sprite(new SpriteMaterial({
          map: smallFlareTexture,
          color: 16755234,
          transparent: true,
          blending: AdditiveBlending,
          depthTest: false
        }));
        const farRadius = radius * 2;
        const farAngle = angle + (Math.random() * 0.2 - 0.1);
        const farX = Math.cos(farAngle) * farRadius;
        const farY = Math.sin(farAngle) * farRadius;
        smallFlare.position.set(farX, farY, 0);
        const smallSize = 100 + Math.random() * 150;
        smallFlare.scale.set(smallSize, smallSize, 1);
        this.sunGroup.add(smallFlare);
        this.lensFlares.push(smallFlare);
      }
    }
  }
  clearFlares() {
    this.lensFlares.forEach((flare) => {
      if (flare.parent) flare.parent.remove(flare);
    });
    this.lensFlares = [];
  }
  updateFlareColors(color) {
    this.lensFlares.forEach((flare, index) => {
      if (flare && flare.material) {
        const flareColor = new Color(color);
        if (index % 3 === 0) {
          flareColor.r = Math.min(1, flareColor.r * 1.2);
        } else if (index % 3 === 1) {
          flareColor.g = Math.min(1, flareColor.g * 1.1);
        }
        flare.material.color = flareColor;
      }
    });
  }
  update(time, camera) {
    if (!camera) return;
    const viewVector = new Vector3().subVectors(
      camera.position,
      this.sunGroup.position
    ).normalize();
    this.lensFlares.forEach((flare, index) => {
      if (!flare) return;
      const pulseSpeed = 0.5 + index % 3 * 0.3;
      const pulseFactor = 0.9 + Math.sin(time * pulseSpeed + index) * 0.1;
      if (index === 0) {
        const mainScale = 700 * pulseFactor;
        flare.scale.set(mainScale, mainScale, 1);
      } else {
        const originalSize = 200 + index % 3 * 100;
        const size = originalSize * pulseFactor;
        flare.scale.set(size, size, 1);
        if (flare.userData.originalPos) {
          const orbit = 0.1 + index % 5 * 0.05;
          const orbitSpeed = 0.3 + index % 4 * 0.1;
          flare.position.x = flare.userData.originalPos.x + Math.sin(time * orbitSpeed) * orbit * originalSize;
          flare.position.y = flare.userData.originalPos.y + Math.cos(time * orbitSpeed) * orbit * originalSize;
        } else {
          flare.userData.originalPos = flare.position.clone();
        }
      }
      const angleToCam = viewVector.dot(new Vector3(0, 0, -1).applyQuaternion(camera.quaternion));
      if (angleToCam > 0.5) {
        const opacity = Math.min(1, (angleToCam - 0.5) / 0.3 + 0.3);
        flare.material.opacity = opacity;
        flare.visible = true;
      } else {
        const reducedOpacity = Math.max(0.1, (angleToCam + 0.5) / 1) * 0.5;
        flare.material.opacity = reducedOpacity;
        flare.visible = true;
      }
    });
  }
}
class SunLighting {
  constructor(scene, sunGroup) {
    this.scene = scene;
    this.sunGroup = sunGroup;
    this.baseLightIntensity = 2e5;
    this.sunFlickerIntensity = 1;
    this.sunFlickerDirection = 0.02;
    this.createLights();
  }
  createLights() {
    this.sunLight = new PointLight(16775920, 2e5, 1e5, 2);
    this.sunGroup.add(this.sunLight);
    this.sunDirectionalLight = new DirectionalLight(16775920, 1.5);
    this.sunDirectionalLight.position.set(0, 0, 0);
    this.sunDirectionalLight.castShadow = true;
    this.sunDirectionalLight.shadow.mapSize.width = 4096;
    this.sunDirectionalLight.shadow.mapSize.height = 4096;
    this.sunDirectionalLight.shadow.camera.near = 1e3;
    this.sunDirectionalLight.shadow.camera.far = 1e5;
    this.sunDirectionalLight.shadow.camera.left = -5e4;
    this.sunDirectionalLight.shadow.camera.right = 5e4;
    this.sunDirectionalLight.shadow.camera.top = 5e4;
    this.sunDirectionalLight.shadow.camera.bottom = -5e4;
    this.sunDirectionalLight.shadow.bias = -5e-5;
    this.sunDirectionalLight.shadow.normalBias = 0.02;
    this.sunDirectionalLight.shadow.radius = 2;
    if (this.scene && this.scene.renderer) {
      this.scene.renderer.shadowMap.type = PCFSoftShadowMap;
    }
    this.sunGroup.add(this.sunDirectionalLight);
    this.shadowHelper = null;
  }
  updateForStarType(starType, color, temperature, lightIntensityMultiplier = 1) {
    if (this.sunLight) {
      this.sunLight.color.setHex(color);
      this.sunLight.intensity = (2e5 + temperature / 1e4 * 2e5) * lightIntensityMultiplier;
      this.sunLight._intensityMultiplier = lightIntensityMultiplier;
    }
  }
  update(deltaTime, camera, sunType) {
    this.sunFlickerIntensity += this.sunFlickerDirection;
    if (this.sunFlickerIntensity > 1.2) {
      this.sunFlickerIntensity = 1.2;
      this.sunFlickerDirection = -Math.random() * 0.03;
    } else if (this.sunFlickerIntensity < 0.9) {
      this.sunFlickerIntensity = 0.9;
      this.sunFlickerDirection = Math.random() * 0.03;
    }
    if (this.sunLight) {
      const intensityMultiplier = this.sunLight._intensityMultiplier || 1;
      const baseIntensity = this.baseLightIntensity + (sunType === "G" ? 3e4 : sunType === "O" || sunType === "B" ? 1e5 : sunType === "M" ? 1e4 : 5e4);
      let viewDependentMultiplier = 1;
      if (camera) {
        const viewVector = new Vector3().subVectors(
          camera.position,
          this.sunGroup.position
        ).normalize();
        const cameraNormal = new Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const angleToCam = viewVector.dot(cameraNormal);
        if (angleToCam > 0.8) {
          viewDependentMultiplier = 0.5 + (1 - angleToCam) * 0.5;
        }
      }
      this.sunLight.intensity = baseIntensity * this.sunFlickerIntensity * intensityMultiplier * viewDependentMultiplier;
    }
    if (this.sunDirectionalLight && camera) {
      const cameraPos = camera.position.clone();
      const sunToCam = cameraPos.clone().sub(this.sunGroup.position).normalize();
      const lightPos = sunToCam.clone().multiplyScalar(-15e3).add(this.sunGroup.position);
      this.sunDirectionalLight.position.copy(lightPos);
      this.sunDirectionalLight.target.position.copy(this.sunGroup.position);
      if (!this.sunDirectionalLight.target.parent) {
        this.scene.add(this.sunDirectionalLight.target);
      }
      const camDistanceToSun = cameraPos.distanceTo(this.sunGroup.position);
      const shadowSize = Math.max(5e4, camDistanceToSun * 2);
      this.sunDirectionalLight.shadow.camera.left = -shadowSize;
      this.sunDirectionalLight.shadow.camera.right = shadowSize;
      this.sunDirectionalLight.shadow.camera.top = shadowSize;
      this.sunDirectionalLight.shadow.camera.bottom = -shadowSize;
      this.sunDirectionalLight.shadow.camera.updateProjectionMatrix();
      this.sunDirectionalLight.intensity = 1.5 * this.sunFlickerIntensity;
    }
  }
  toggleShadowHelper(enabled) {
    if (this.shadowHelper && this.shadowHelper.parent) {
      this.shadowHelper.parent.remove(this.shadowHelper);
      this.shadowHelper = null;
    }
    if (enabled && this.sunDirectionalLight && this.scene) {
      this.shadowHelper = new CameraHelper(this.sunDirectionalLight.shadow.camera);
      this.scene.add(this.shadowHelper);
      console.log("Shadow camera helper enabled - showing sun shadow frustum");
    }
  }
}
class Sun {
  constructor(scene) {
    this.scene = scene;
    this.sun = null;
    this.time = 0;
    this.sunType = "G";
    this.createSun();
  }
  createSun() {
    this.sun = new Group();
    this.sun.name = "sun";
    this.scene.add(this.sun);
    const sunGeometry = new SphereGeometry(1e3, 64, 64);
    this.sunMaterial = SunShaders.createSunMaterial();
    const sunCoreMesh = new Mesh(sunGeometry, this.sunMaterial);
    this.sun.add(sunCoreMesh);
    const coronaGeometry = new SphereGeometry(2e3, 64, 64);
    this.coronaMaterial = SunShaders.createCoronaMaterial();
    const coronaMesh = new Mesh(coronaGeometry, this.coronaMaterial);
    this.sun.add(coronaMesh);
    const outerCoronaGeometry = new SphereGeometry(3e3, 32, 32);
    this.outerCoronaMaterial = SunShaders.createOuterCoronaMaterial();
    const outerCoronaMesh = new Mesh(outerCoronaGeometry, this.outerCoronaMaterial);
    this.sun.add(outerCoronaMesh);
    this.lighting = new SunLighting(this.scene, this.sun);
    this.flares = new SunFlares(this.scene, this.sun);
  }
  // Update sun based on star type (O, B, A, F, G, K, M)
  updateSunType(type, lightIntensityMultiplier = 1) {
    this.sunType = type || "G";
    let color, temperature, activity;
    switch (this.sunType) {
      case "O":
        color = 10335487;
        temperature = 3e4;
        activity = 0.8;
        break;
      case "B":
        color = 11190271;
        temperature = 2e4;
        activity = 0.75;
        break;
      case "A":
        color = 13293567;
        temperature = 1e4;
        activity = 0.7;
        break;
      case "F":
        color = 16316415;
        temperature = 7e3;
        activity = 0.65;
        break;
      case "G":
        color = 16774378;
        temperature = 5500;
        activity = 0.6;
        break;
      case "K":
        color = 16765601;
        temperature = 4e3;
        activity = 0.5;
        break;
      case "M":
        color = 16764015;
        temperature = 3e3;
        activity = 0.4;
        break;
      default:
        color = 16774378;
        temperature = 5500;
        activity = 0.6;
    }
    if (this.sunMaterial) {
      this.sunMaterial.uniforms.sunColor.value.setHex(color);
      this.sunMaterial.uniforms.sunActivity.value = activity;
    }
    if (this.coronaMaterial) {
      const coronaColor = new Color(color);
      coronaColor.r = Math.min(1, coronaColor.r * 1.2);
      coronaColor.g = Math.min(1, coronaColor.g * 1.1);
      this.coronaMaterial.uniforms.coronaColor.value = coronaColor;
    }
    if (this.outerCoronaMaterial) {
      const outerCoronaColor = new Color(color);
      outerCoronaColor.r = Math.min(1, outerCoronaColor.r * 1.3);
      outerCoronaColor.g = Math.min(1, outerCoronaColor.g * 1.2);
      outerCoronaColor.b = Math.min(1, outerCoronaColor.b * 1.1);
      this.outerCoronaMaterial.uniforms.coronaColor.value = outerCoronaColor;
    }
    this.lighting.updateForStarType(this.sunType, color, temperature, lightIntensityMultiplier);
    this.flares.updateFlareColors(color);
    console.log(`Updated sun to type ${this.sunType}, color: ${color.toString(16)}, intensity multiplier: ${lightIntensityMultiplier}`);
  }
  getRadius() {
    return 3e3;
  }
  getPosition() {
    return new Vector3(0, 0, 0);
  }
  update(deltaTime = 0.016) {
    if (!this.sun) return;
    this.time += deltaTime * 0.4;
    if (this.sunMaterial && this.sunMaterial.uniforms.time) {
      this.sunMaterial.uniforms.time.value = this.time;
    }
    if (this.coronaMaterial && this.coronaMaterial.uniforms.time) {
      this.coronaMaterial.uniforms.time.value = this.time;
    }
    if (this.outerCoronaMaterial && this.outerCoronaMaterial.uniforms.time) {
      this.outerCoronaMaterial.uniforms.time.value = this.time;
    }
    if (this.scene && this.scene.camera) {
      const viewVector = new Vector3().subVectors(
        this.scene.camera.position,
        this.sun.position
      ).normalize();
      if (this.coronaMaterial && this.coronaMaterial.uniforms.viewVector) {
        this.coronaMaterial.uniforms.viewVector.value = viewVector;
      }
      if (this.outerCoronaMaterial && this.outerCoronaMaterial.uniforms.viewVector) {
        this.outerCoronaMaterial.uniforms.viewVector.value = viewVector;
      }
    }
    this.lighting.update(deltaTime, this.scene.camera, this.sunType);
    this.flares.update(this.time, this.scene.camera);
  }
  // Toggle shadow camera helper for debugging
  toggleShadowHelper(enabled) {
    this.lighting.toggleShadowHelper(enabled);
  }
}
class PlanetGenerator {
  static generatePlanetsForSystem(systemId, starSystemGenerator) {
    console.log(`Generating new planets for system: ${systemId}`);
    if (starSystemGenerator && starSystemGenerator.customPlanetData && starSystemGenerator.customPlanetData[systemId]) {
      const customPlanets = starSystemGenerator.customPlanetData[systemId];
      console.log(`Using ${customPlanets.length} custom planets for system: ${systemId}`);
      customPlanets.forEach((planet) => {
        if (planet.textureUrl) {
          console.log(`Custom planet ${planet.name} has texture URL: ${planet.textureUrl}`);
        } else {
          console.log(`Custom planet ${planet.name} does not have a texture URL`);
        }
      });
      return starSystemGenerator.customPlanetData[systemId];
    }
    const prefixes = [
      "New",
      "Alpha",
      "Beta",
      "Gamma",
      "Delta",
      "Nova",
      "Proxima",
      "Ultima",
      "Astro",
      "Cosmo",
      "Stella",
      "Terra",
      "Astra",
      "Prime",
      "Orb"
    ];
    const suffixes = [
      "sphere",
      "world",
      "orb",
      "terra",
      "oid",
      "globus",
      "ium",
      "ian",
      "aria",
      "anth",
      "urus",
      "alos",
      "onos",
      "era",
      "ax",
      "is",
      "os"
    ];
    const starClass = systemId.includes("System-") ? systemId.split("-")[1][0] : "M";
    const planetCount = 2 + Math.floor(Math.random() * 7);
    const planetData = [];
    let sizeMultiplier = 1;
    let distanceMultiplier = 1;
    let colorPalette = [];
    switch (starClass) {
      case "O":
        sizeMultiplier = 1.8;
        distanceMultiplier = 1.6;
        colorPalette = [6711039, 10066431, 13421823, 11184895, 8947933];
        break;
      case "B":
        sizeMultiplier = 1.5;
        distanceMultiplier = 1.3;
        colorPalette = [10070783, 11189247, 13421823, 14540287, 12298956];
        break;
      case "A":
        sizeMultiplier = 1.3;
        distanceMultiplier = 1.1;
        colorPalette = [13421823, 14540287, 15658751, 16777215, 14535901];
        break;
      case "F":
        sizeMultiplier = 1.1;
        distanceMultiplier = 1;
        colorPalette = [10070783, 11193514, 13426124, 16764074, 15658700];
        break;
      case "G":
        sizeMultiplier = 1;
        distanceMultiplier = 1;
        colorPalette = [11184810, 4286945, 13000005, 14070398, 15787465];
        break;
      case "K":
        sizeMultiplier = 0.8;
        distanceMultiplier = 0.9;
        colorPalette = [15125660, 13413e3, 14531481, 12294519, 13404262];
        break;
      case "M":
        sizeMultiplier = 0.6;
        distanceMultiplier = 0.7;
        colorPalette = [13395524, 14514005, 15632486, 16750967, 12277043];
        break;
      default:
        colorPalette = [11184810, 4286945, 13000005, 14070398, 15787465];
    }
    for (let i = 0; i < planetCount; i++) {
      const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
      const name = `${prefix}${suffix}`;
      const sizeClass = Math.random();
      let size;
      if (sizeClass < 0.5) {
        size = (240 + Math.random() * 200) * sizeMultiplier;
      } else if (sizeClass < 0.8) {
        size = (440 + Math.random() * 280) * sizeMultiplier;
      } else {
        size = (720 + Math.random() * 360) * sizeMultiplier;
      }
      const baseDistance = 4800 + i * 8e3;
      const distanceVariation = baseDistance * 0.2;
      const distance = (baseDistance + (Math.random() * distanceVariation - distanceVariation / 2)) * distanceMultiplier;
      const speed = 2e-3 / (distance / 1e3);
      const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
      const rings = size > 600 ? Math.random() < 0.4 : false;
      const axialTilt = Math.random() * Math.PI * 0.5;
      const orbitalTilt = Math.random() * Math.PI * 0.2;
      planetData.push({
        name,
        size: Math.floor(size),
        distance: Math.floor(distance),
        speed,
        color,
        rings,
        axialTilt,
        orbitalTilt
      });
    }
    return planetData;
  }
  static createHomeSolarSystemPlanets() {
    return [
      { name: "Mercury", size: 220, distance: 4800, speed: 16e-4, color: 11184810, rings: false },
      { name: "Venus", size: 400, distance: 8e3, speed: 13e-4, color: 15125660, rings: false },
      { name: "Earth", size: 420, distance: 12e3, speed: 1e-3, color: 4286945, rings: false },
      { name: "Mars", size: 320, distance: 16800, speed: 8e-4, color: 13000005, rings: false },
      { name: "Jupiter", size: 1e3, distance: 3e4, speed: 4e-4, color: 14070398, rings: true },
      { name: "Saturn", size: 880, distance: 4e4, speed: 3e-4, color: 15787465, rings: true },
      { name: "Uranus", size: 720, distance: 56e3, speed: 2e-4, color: 13298929, rings: true },
      { name: "Neptune", size: 700, distance: 72e3, speed: 16e-5, color: 6267867, rings: false }
    ];
  }
}
const textureLoader$1 = new TextureLoader();
const planetTextures = {
  mercury: textureLoader$1.load("./assets/2k_mercury.jpg"),
  venus: {
    surface: textureLoader$1.load("./assets/2k_venus_surface.jpg"),
    atmosphere: textureLoader$1.load("./assets/2k_venus_atmosphere.jpg")
  },
  earth: textureLoader$1.load("./assets/2k_earth_daymap.jpg"),
  mars: textureLoader$1.load("./assets/2k_mars.jpg"),
  jupiter: textureLoader$1.load("./assets/2k_jupiter.jpg"),
  saturn: {
    surface: textureLoader$1.load("./assets/2k_saturn.jpg"),
    rings: textureLoader$1.load("./assets/2k_saturn_ring_alpha.png")
  },
  uranus: textureLoader$1.load("./assets/2k_uranus.jpg"),
  neptune: textureLoader$1.load("./assets/2k_neptune.jpg")
};
planetTextures.mercury.colorSpace = SRGBColorSpace;
planetTextures.venus.surface.colorSpace = SRGBColorSpace;
planetTextures.venus.atmosphere.colorSpace = SRGBColorSpace;
planetTextures.earth.colorSpace = SRGBColorSpace;
planetTextures.mars.colorSpace = SRGBColorSpace;
planetTextures.jupiter.colorSpace = SRGBColorSpace;
planetTextures.saturn.surface.colorSpace = SRGBColorSpace;
planetTextures.saturn.rings.colorSpace = SRGBColorSpace;
planetTextures.uranus.colorSpace = SRGBColorSpace;
planetTextures.neptune.colorSpace = SRGBColorSpace;
const proceduralTextures = [];
for (let i = 1; i <= 22; i++) {
  const texture = textureLoader$1.load(`./assets/p${i}.jpeg`);
  texture.colorSpace = SRGBColorSpace;
  proceduralTextures.push(texture);
}
const textureLoader = new TextureLoader();
class PlanetMaterials {
  static createMaterialForPlanet(planet) {
    if (planet.textureUrl) {
      console.log(`Creating planet ${planet.name} with custom texture: ${planet.textureUrl}`);
      let adjustedTextureUrl = planet.textureUrl;
      if (planet.textureUrl.startsWith("/images/")) {
        if (window.location.port === "8000") {
          const serverHost = window.location.hostname;
          adjustedTextureUrl = `http://${serverHost}:8001${planet.textureUrl}`;
          console.log(`Adjusted planet texture path to API server: ${adjustedTextureUrl}`);
        }
      }
      const customTexture = textureLoader.load(adjustedTextureUrl);
      customTexture.colorSpace = SRGBColorSpace;
      return new MeshStandardMaterial({
        map: customTexture,
        roughness: 0.7,
        metalness: 0.2,
        flatShading: false,
        emissive: new Color(planet.color || 16777215),
        emissiveIntensity: 0.2,
        emissiveMap: customTexture
      });
    }
    switch (planet.name) {
      case "Mercury":
        return new MeshStandardMaterial({
          map: planetTextures.mercury,
          roughness: 0.7,
          metalness: 0.2,
          flatShading: false,
          emissive: new Color(5592405),
          emissiveIntensity: 0.2,
          emissiveMap: planetTextures.mercury
        });
      case "Venus":
        return new MeshStandardMaterial({
          map: planetTextures.venus.surface,
          roughness: 0.6,
          metalness: 0.1,
          flatShading: false,
          emissive: new Color(15125660),
          emissiveIntensity: 0.25,
          emissiveMap: planetTextures.venus.surface
        });
      case "Earth":
        return new MeshStandardMaterial({
          map: planetTextures.earth,
          roughness: 0.5,
          metalness: 0.1,
          flatShading: false,
          emissive: new Color(4286945),
          emissiveIntensity: 0.2,
          emissiveMap: planetTextures.earth
        });
      case "Mars":
        return new MeshStandardMaterial({
          map: planetTextures.mars,
          roughness: 0.7,
          metalness: 0.1,
          flatShading: false,
          emissive: new Color(13000005),
          emissiveIntensity: 0.25,
          emissiveMap: planetTextures.mars
        });
      case "Jupiter":
        return new MeshStandardMaterial({
          map: planetTextures.jupiter,
          roughness: 0.5,
          metalness: 0,
          flatShading: false,
          emissive: new Color(14070398),
          emissiveIntensity: 0.2,
          emissiveMap: planetTextures.jupiter
        });
      case "Saturn":
        return new MeshStandardMaterial({
          map: planetTextures.saturn.surface,
          roughness: 0.6,
          metalness: 0.1,
          flatShading: false,
          emissive: new Color(15787465),
          emissiveIntensity: 0.2,
          emissiveMap: planetTextures.saturn.surface
        });
      case "Uranus":
        return new MeshStandardMaterial({
          map: planetTextures.uranus,
          roughness: 0.5,
          metalness: 0,
          flatShading: false,
          emissive: new Color(8960972),
          emissiveIntensity: 0.25,
          emissiveMap: planetTextures.uranus
        });
      case "Neptune":
        return new MeshStandardMaterial({
          map: planetTextures.neptune,
          roughness: 0.5,
          metalness: 0,
          flatShading: false,
          emissive: new Color(6267867),
          emissiveIntensity: 0.25,
          emissiveMap: planetTextures.neptune
        });
      default:
        const textureIndex = Math.floor(Math.random() * proceduralTextures.length);
        return new MeshStandardMaterial({
          map: proceduralTextures[textureIndex],
          roughness: 0.6,
          metalness: 0.2,
          color: new Color(planet.color),
          flatShading: false,
          emissive: new Color(planet.color),
          emissiveIntensity: 0.3,
          emissiveMap: proceduralTextures[textureIndex]
        });
    }
  }
  static createRingMaterial(planet) {
    if (planet.name === "Saturn") {
      return new MeshStandardMaterial({
        map: planetTextures.saturn.rings,
        side: DoubleSide,
        transparent: true,
        opacity: 0.8,
        roughness: 0.8,
        metalness: 0.1,
        emissive: new Color(15787465),
        emissiveIntensity: 0.2,
        emissiveMap: planetTextures.saturn.rings
      });
    } else {
      return new MeshStandardMaterial({
        color: planet.color,
        side: DoubleSide,
        transparent: true,
        opacity: 0.4,
        roughness: 0.7,
        metalness: 0.2,
        emissive: new Color(planet.color),
        emissiveIntensity: 0.3
      });
    }
  }
}
class PlanetFactory {
  static createPlanetMesh(planet) {
    const planetGeometry = new SphereGeometry(planet.size, 32, 32);
    const planetMaterial = PlanetMaterials.createMaterialForPlanet(planet);
    const planetMesh = new Mesh(planetGeometry, planetMaterial);
    const angle = Math.random() * Math.PI * 2;
    const orbitalTilt = planet.orbitalTilt || 0;
    const axialTilt = planet.axialTilt || 0;
    planetMesh.position.x = Math.cos(angle) * planet.distance;
    planetMesh.position.y = Math.sin(orbitalTilt) * planet.distance;
    planetMesh.position.z = Math.sin(angle) * Math.cos(orbitalTilt) * planet.distance;
    planetMesh.rotation.x = axialTilt;
    planetMesh.castShadow = true;
    planetMesh.receiveShadow = true;
    if (planet.rings) {
      const ringMesh = PlanetFactory.createRingMesh(planet);
      planetMesh.add(ringMesh);
    }
    return {
      mesh: planetMesh,
      distance: planet.distance,
      speed: planet.speed,
      angle,
      orbitalTilt
    };
  }
  static createRingMesh(planet) {
    let ringGeometry, ringMaterial;
    if (planet.name === "Saturn") {
      ringGeometry = new RingGeometry(planet.size * 1.4, planet.size * 2, 32);
    } else {
      ringGeometry = new RingGeometry(planet.size * 1.3, planet.size * 1.8, 32);
    }
    ringMaterial = PlanetMaterials.createRingMaterial(planet);
    const ringMesh = new Mesh(ringGeometry, ringMaterial);
    ringMesh.rotation.x = Math.PI / 2;
    ringMesh.castShadow = true;
    ringMesh.receiveShadow = true;
    return ringMesh;
  }
}
class Planets {
  constructor(scene, starSystemGenerator) {
    this.scene = scene;
    this.starSystemGenerator = starSystemGenerator;
    this.planets = [];
    this.planetRegions = {};
    this.currentSystemId = "Solar System";
    this.systemPlanets = {};
    this.createHomeSolarSystem();
  }
  // Create our home solar system (the only non-procedural system)
  createHomeSolarSystem() {
    const solarSystemPlanets = PlanetGenerator.createHomeSolarSystemPlanets();
    this.systemPlanets["Solar System"] = solarSystemPlanets;
    this.createPlanetsForSystem("Solar System");
  }
  // Create planet objects for the current system
  createPlanetsForSystem(systemId) {
    this.clearPlanets();
    this.currentSystemId = systemId;
    if (this.systemPlanets[systemId]) {
      this.createPlanetsFromData(this.systemPlanets[systemId]);
      return;
    }
    const generatedPlanets = this.generatePlanetsForSystem(systemId);
    this.systemPlanets[systemId] = generatedPlanets;
    this.createPlanetsFromData(generatedPlanets);
  }
  // Generate procedural planets for a new star system
  generatePlanetsForSystem(systemId) {
    return PlanetGenerator.generatePlanetsForSystem(systemId, this.starSystemGenerator);
  }
  // Create planet objects from data array
  createPlanetsFromData(planetData) {
    this.clearPlanets();
    planetData.forEach((planet) => {
      const planetObj = PlanetFactory.createPlanetMesh(planet);
      this.scene.add(planetObj.mesh);
      this.planets.push(planetObj);
      this.planetRegions[planet.name] = {
        name: planet.name,
        position: planetObj.mesh.position.clone(),
        radius: planet.size * 2
      };
    });
  }
  // Clear all existing planets
  clearPlanets() {
    this.planets.forEach((planet) => {
      this.scene.remove(planet.mesh);
    });
    this.planets = [];
    this.planetRegions = {};
  }
  // Set up planet system for specified star system
  updateForSystem(systemId) {
    console.log(`Updating planets for system: ${systemId}`);
    this.createPlanetsForSystem(systemId);
    return true;
  }
  getPlanetRegions() {
    return this.planetRegions;
  }
  getPlanets() {
    return this.planets;
  }
  update(deltaTime) {
    this.planets.forEach((planet) => {
      planet.angle += planet.speed * deltaTime;
      planet.mesh.position.x = Math.cos(planet.angle) * planet.distance;
      planet.mesh.position.z = Math.sin(planet.angle) * Math.cos(planet.orbitalTilt) * planet.distance;
      planet.mesh.position.y = Math.sin(planet.angle) * Math.sin(planet.orbitalTilt) * planet.distance;
      planet.mesh.rotation.y += deltaTime * 0.1;
      if (planet.mesh) {
        Object.values(this.planetRegions).forEach((region) => {
          if (region && region.position) {
            const distance = region.position.distanceTo(planet.mesh.position);
            if (distance < 5e3) {
              region.position.copy(planet.mesh.position);
            }
          }
        });
      }
    });
  }
}
class Stargate {
  constructor(scene) {
    this.scene = scene;
    this.stargate = null;
    this.navLights = [];
    this.portalParticles = [];
    this.createStargate();
  }
  createStargate() {
    const stargateGroup = new Group();
    stargateGroup.name = "stargate";
    const ringGeometry = new TorusGeometry(1e3, 200, 32, 100);
    const ringMaterial = new MeshStandardMaterial({
      color: 1118481,
      roughness: 0.9,
      metalness: 0.1,
      emissive: 0
    });
    const ring = new Mesh(ringGeometry, ringMaterial);
    stargateGroup.add(ring);
    const createAccentRing = (radius, tubeRadius, position = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) => {
      const geometry = new TorusGeometry(radius, tubeRadius, 16, 100);
      const material = new MeshStandardMaterial({
        color: 65535,
        emissive: 65535,
        emissiveIntensity: 1.5,
        roughness: 0.2,
        metalness: 0.8
      });
      const accentRing = new Mesh(geometry, material);
      accentRing.position.set(position.x, position.y, position.z);
      accentRing.rotation.set(rotation.x, rotation.y, rotation.z);
      return accentRing;
    };
    const outerRing1 = createAccentRing(1060, 10);
    const outerRing2 = createAccentRing(940, 10);
    const innerRing = createAccentRing(850, 5);
    stargateGroup.add(outerRing1);
    stargateGroup.add(outerRing2);
    stargateGroup.add(innerRing);
    this.createPortalEffect(stargateGroup);
    const detailsGroup = this.createNeonDetails();
    stargateGroup.add(detailsGroup);
    stargateGroup.position.set(0, 1e4, 0);
    stargateGroup.rotation.x = Math.PI / 2;
    this.scene.add(stargateGroup);
    this.stargate = stargateGroup;
    this.createCounterRotatingRing(stargateGroup);
  }
  createCounterRotatingRing(parentGroup) {
    const innerStructure = new Group();
    const thinRingGeometry = new TorusGeometry(820, 3, 16, 100);
    const thinRingMaterial = new MeshStandardMaterial({
      color: 65535,
      emissive: 65535,
      emissiveIntensity: 2,
      roughness: 0.1,
      metalness: 0.9,
      transparent: true,
      opacity: 0.7
    });
    for (let i = 0; i < 3; i++) {
      const ring = new Mesh(thinRingGeometry, thinRingMaterial.clone());
      ring.rotation.x = Math.PI * i / 3;
      ring.rotation.y = Math.PI * i / 3;
      innerStructure.add(ring);
    }
    parentGroup.add(innerStructure);
    this.counterRotatingRing = innerStructure;
  }
  createPortalEffect(parentGroup) {
    const portalShaderMaterial = new ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        resolution: { value: new Vector2(1024, 1024) },
        baseColor: { value: new Color(65535) }
      },
      vertexShader: `
            varying vec2 vUv;
            
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
      fragmentShader: `
            uniform float time;
            uniform vec2 resolution;
            uniform vec3 baseColor;
            varying vec2 vUv;
            
            // Simple noise function
            float noise(vec2 p) {
              return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            // Smoothed noise
            float smoothNoise(vec2 p) {
              vec2 ip = floor(p);
              vec2 fp = fract(p);
              
              vec2 u = fp * fp * (3.0 - 2.0 * fp);
              
              float a = noise(ip);
              float b = noise(ip + vec2(1.0, 0.0));
              float c = noise(ip + vec2(0.0, 1.0));
              float d = noise(ip + vec2(1.0, 1.0));
              
              return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
            }
            
            // Fractal Brownian Motion
            float fbm(vec2 p) {
              float value = 0.0;
              float amplitude = 0.5;
              float frequency = 3.0;
              
              for (int i = 0; i < 6; i++) {
                value += amplitude * smoothNoise(p * frequency);
                amplitude *= 0.5;
                frequency *= 2.0;
              }
              
              return value;
            }
            
            void main() {
              // Convert uv to be centered at (0.5, 0.5) with range -1 to 1
              vec2 centeredUV = (vUv - 0.5) * 2.0;
              float dist = length(centeredUV);
              
              // Create angle for rotation
              float angle = atan(centeredUV.y, centeredUV.x);
              
              // Enhanced swirling effect parameters - more aggressive
              float swirl = sin(angle * 6.0 + time * 2.0) * 0.5 + 0.5;
              float pulse = sin(time * 0.8) * 0.5 + 0.5;
              
              // Create more distorted coordinates for noise - enhances warp feel
              vec2 distortedUV = vec2(
                centeredUV.x + sin(time * 0.7 + centeredUV.y * 5.0) * 0.2,
                centeredUV.y + cos(time * 0.6 + centeredUV.x * 5.0) * 0.2
              );
              
              // Create noise patterns - more contrast
              float noiseValue = fbm(distortedUV * 3.0 + time * 0.3);
              float ripple = sin(dist * 20.0 - time * 3.0) * 0.5 + 0.5;
              
              // Combine effects with more intensity
              float alpha = smoothstep(0.9, 0.0, dist);
              float intensity = mix(noiseValue, ripple, 0.7) * swirl * pulse;
              
              // Enhanced portal colors - bright cyan to deep blue
              vec3 darkColor = vec3(0.0, 0.1, 0.3);
              vec3 brightColor = vec3(0.0, 1.0, 1.0) * 2.0;
              vec3 accentColor = vec3(0.3, 0.8, 1.0);
              
              // More complex color mixing
              vec3 finalColor = mix(darkColor, brightColor, intensity);
              finalColor = mix(finalColor, accentColor, ripple * swirl);
              
              // Enhanced edge glow for portal effect
              float edgeGlow = smoothstep(0.8, 0.4, dist) * smoothstep(0.0, 0.6, dist);
              finalColor = mix(finalColor, brightColor, edgeGlow * pulse);
              
              // Add portal event horizon effect
              float eventHorizon = smoothstep(0.8, 0.78, dist) * 2.0;
              finalColor += vec3(0.0, 1.0, 1.0) * eventHorizon;
              
              gl_FragColor = vec4(finalColor, alpha);
            }
          `,
      transparent: true,
      side: DoubleSide
    });
    const portalGeometry = new CircleGeometry(800, 128);
    const portal = new Mesh(portalGeometry, portalShaderMaterial);
    parentGroup.add(portal);
    const portalLight = new PointLight(65535, 400, 2e3, 2);
    portalLight.position.set(0, 0, 0);
    parentGroup.add(portalLight);
    const createPortalWisps = () => {
      const wispGeometry = new TorusGeometry(650, 10, 8, 100);
      const wispMaterial = new MeshStandardMaterial({
        color: 65535,
        emissive: 65535,
        emissiveIntensity: 2,
        transparent: true,
        opacity: 0.3,
        side: DoubleSide
      });
      const wisp = new Mesh(wispGeometry, wispMaterial);
      wisp.rotation.x = Math.random() * Math.PI;
      wisp.rotation.y = Math.random() * Math.PI;
      wisp.userData = {
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.02,
          // 10x faster rotation
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.02
        },
        pulseSpeed: 0.5 + Math.random() * 0.3
      };
      this.portalParticles.push(wisp);
      return wisp;
    };
    for (let i = 0; i < 8; i++) {
      parentGroup.add(createPortalWisps());
    }
    this.portalShaderMaterial = portalShaderMaterial;
    this.portalLight = portalLight;
  }
  createNeonDetails() {
    const detailsGroup = new Group();
    const createNeonAccent = (angle) => {
      const accentGroup = new Group();
      const beamGeometry = new CylinderGeometry(10, 10, 300, 8);
      const beamMaterial = new MeshStandardMaterial({
        color: 65535,
        emissive: 65535,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.8
      });
      const beam = new Mesh(beamGeometry, beamMaterial);
      beam.rotation.x = Math.PI / 2;
      const light = new PointLight(65535, 100, 400, 2);
      light.position.set(0, 0, 0);
      accentGroup.add(beam);
      accentGroup.add(light);
      accentGroup.position.x = Math.cos(angle) * 1e3;
      accentGroup.position.y = Math.sin(angle) * 1e3;
      accentGroup.rotation.z = angle - Math.PI / 2;
      light.userData = {
        originalIntensity: light.intensity,
        phase: Math.random() * Math.PI * 2
      };
      this.navLights.push({ light, lightMesh: beam });
      return accentGroup;
    };
    for (let i = 0; i < 8; i++) {
      const angle = i / 8 * Math.PI * 2;
      detailsGroup.add(createNeonAccent(angle));
    }
    return detailsGroup;
  }
  getPosition() {
    return new Vector3(0, 1e4, 0);
  }
  getRegionInfo() {
    return {
      center: new Vector3(0, 1e4, 0),
      radius: 2e3
    };
  }
  update() {
    if (this.navLights) {
      this.navLights.forEach(({ light, lightMesh }) => {
        const time = Date.now() * 1e-3;
        const flicker = 0.7 + 0.3 * Math.sin(time * 2 + light.userData.phase);
        light.intensity = light.userData.originalIntensity * flicker;
        if (lightMesh.material) {
          lightMesh.material.emissiveIntensity = flicker;
          lightMesh.material.opacity = 0.5 + flicker * 0.5;
        }
      });
    }
    if (this.portalShaderMaterial) {
      this.portalShaderMaterial.uniforms.time.value = Date.now() * 1e-3;
      if (this.portalLight) {
        const time = Date.now() * 1e-3;
        this.portalLight.intensity = 400 + Math.sin(time * 2) * 150;
      }
    }
    if (this.portalParticles) {
      this.portalParticles.forEach((particle) => {
        const time = Date.now() * 1e-3;
        if (particle.userData.rotationSpeed) {
          particle.rotation.x += particle.userData.rotationSpeed.x;
          particle.rotation.y += particle.userData.rotationSpeed.y;
          particle.rotation.z += particle.userData.rotationSpeed.z;
        }
        if (particle.userData.pulseSpeed) {
          const pulse = 0.9 + 0.2 * Math.sin(time * particle.userData.pulseSpeed);
          particle.scale.set(pulse, pulse, pulse);
        }
      });
    }
    if (this.counterRotatingRing) {
      this.counterRotatingRing.rotation.x += 6e-3;
      this.counterRotatingRing.rotation.y += 9e-3;
      this.counterRotatingRing.rotation.z -= 3e-3;
    }
    if (this.stargate) {
      this.stargate.rotation.x += 3e-3;
      this.stargate.rotation.y += 45e-4;
      this.stargate.rotation.z += 6e-3;
    }
  }
}
const STAR_CLASSES = ["O", "B", "A", "F", "G", "K", "M"];
const SYSTEM_CLASSIFICATIONS = [
  "Resource-Rich",
  "Ancient",
  "Unstable",
  "Barren",
  "Hazardous",
  "Peaceful"
];
const SKYBOX_TEXTURES = [
  "./assets/s1.jpg",
  "./assets/s2.jpg",
  "./assets/s3.jpg",
  "./assets/s4.jpg",
  "./assets/s5.jpg",
  "./assets/s6.jpg",
  "./assets/s7.jpg",
  "./assets/s8.jpg",
  "./assets/s9.jpg"
];
const RESOURCE_DISTRIBUTION = {
  "O": { iron: 0.3, gold: 0.4, platinum: 0.3 },
  "B": { iron: 0.2, gold: 0.3, platinum: 0.5 },
  "A": { iron: 0.2, gold: 0.5, platinum: 0.3 },
  "F": { iron: 0.3, gold: 0.4, platinum: 0.3 },
  "G": { iron: 0.4, gold: 0.3, platinum: 0.3 },
  "K": { iron: 0.5, gold: 0.3, platinum: 0.2 },
  "M": { iron: 0.6, gold: 0.2, platinum: 0.2 }
};
const CLASSIFICATION_MULTIPLIERS = {
  "Resource-Rich": { iron: 2, gold: 2, platinum: 2 },
  "Ancient": { iron: 1, gold: 1.5, platinum: 2.5 },
  "Unstable": { iron: 1, gold: 1, platinum: 3 },
  "Barren": { iron: 0.5, gold: 0.5, platinum: 0.5 },
  "Hazardous": { iron: 1.5, gold: 1.5, platinum: 1.5 },
  "Peaceful": { iron: 1, gold: 1, platinum: 1 },
  "Home System": { iron: 1, gold: 1, platinum: 1 }
};
const STAR_COLORS = {
  "O": 10203391,
  // Blue
  "B": 11190271,
  // Blue-white
  "A": 13293567,
  // White
  "F": 16316415,
  // Yellow-white
  "G": 16774378,
  // Yellow (like our sun)
  "K": 16765601,
  // Orange
  "M": 16764015
  // Red
};
const SKYBOX_COLORS = {
  "O": 255,
  // Blue tint
  "B": 4474111,
  // Blue-white tint
  "A": 8947967,
  // White-blue tint
  "F": 14540287,
  // Yellow-white tint
  "G": 16777181,
  // Yellow tint
  "K": 16768426,
  // Orange tint
  "M": 16746598
  // Red tint
};
class SystemNames {
  static generateSystemName(starClass) {
    const prefixes = [
      "Alpha",
      "Beta",
      "Gamma",
      "Delta",
      "Epsilon",
      "Zeta",
      "Eta",
      "Theta",
      "Proxima",
      "Nova",
      "Sirius",
      "Vega",
      "Rigel",
      "Antares",
      "Arcturus"
    ];
    const suffixes = [
      "Prime",
      "Major",
      "Minor",
      "A",
      "B",
      "I",
      "II",
      "III",
      "IV",
      "V"
    ];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = Math.random() > 0.7 ? ` ${suffixes[Math.floor(Math.random() * suffixes.length)]}` : "";
    const number = Math.floor(Math.random() * 999) + 1;
    return `${prefix} ${starClass}${number}${suffix}`;
  }
  static generateSpecialFeatures(classification) {
    const features = [];
    switch (classification) {
      case "Resource-Rich":
        features.push("Dense Asteroid Fields", "Rich Mineral Veins");
        break;
      case "Ancient":
        features.push("Abandoned Structures", "Ancient Artifacts");
        break;
      case "Unstable":
        features.push("Solar Flares", "Radiation Bursts");
        break;
      case "Barren":
        features.push("Minimal Resources", "Few Planets");
        break;
      case "Hazardous":
        features.push("Asteroid Storms", "Energy Anomalies");
        break;
      case "Peaceful":
        features.push("Stable Environment", "Optimal Mining Conditions");
        break;
    }
    return features;
  }
  static generateDescription(starClass, classification) {
    const starDescriptions = {
      "O": "A rare, hot blue star system with intense radiation.",
      "B": "A blue-white star system with high energy output.",
      "A": "A white star system with moderate radiation levels.",
      "F": "A yellow-white star system with mild conditions.",
      "G": "A yellow star system similar to our Solar System.",
      "K": "An orange star system with reduced energy output.",
      "M": "A common red dwarf system with low energy output."
    };
    const classDescriptions = {
      "Resource-Rich": "The system is known for its abundant resources and dense asteroid fields.",
      "Ancient": "This ancient system contains remnants of long-lost civilizations.",
      "Unstable": "Be cautious as unpredictable stellar activity occurs in this system.",
      "Barren": "Resources are scarce in this mostly empty star system.",
      "Hazardous": "Environmental hazards make mining operations difficult but rewarding.",
      "Peaceful": "This system offers stable and optimal conditions for mining operations.",
      "Home System": "Our home system, containing Earth and the origin of humanity."
    };
    return `${starDescriptions[starClass]} ${classDescriptions[classification]}`;
  }
}
class SystemUtils {
  static getRandomStarClass() {
    const weights = [1, 2, 5, 10, 15, 20, 50];
    const total = weights.reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * total;
    for (let i = 0; i < weights.length; i++) {
      if (random < weights[i]) {
        return STAR_CLASSES[i];
      }
      random -= weights[i];
    }
    return STAR_CLASSES[SystemUtils.getRandomInt(0, STAR_CLASSES.length - 1)];
  }
  static getRandomClassification() {
    return SYSTEM_CLASSIFICATIONS[SystemUtils.getRandomInt(0, SYSTEM_CLASSIFICATIONS.length - 1)];
  }
  static getRandomSkyboxTexture() {
    return SKYBOX_TEXTURES[SystemUtils.getRandomInt(0, SKYBOX_TEXTURES.length - 1)];
  }
  static generateMapPosition() {
    const radius = 150 + Math.random() * 100;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    return new Vector3(x, y, 0);
  }
  static getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  static getRandomFloat(min, max) {
    return Math.random() * (max - min) + min;
  }
  static getRandomColor() {
    return Math.floor(Math.random() * 16777215);
  }
}
class SystemFactory {
  static createSolarSystem() {
    return {
      id: "Solar System",
      name: "Solar System",
      starClass: "G",
      classification: "Home System",
      starColor: 16776960,
      planetCount: 8,
      asteroidDensity: 1,
      specialFeatures: ["Earth"],
      description: "Our home system, with Earth as the starting location.",
      connections: [],
      position: new Vector3(0, 0, 0),
      skyboxParams: {
        starDensity: 1,
        nebulaDensity: 0.5,
        color: 16777215,
        texturePath: "./assets/2k_stars_milky_way.jpg",
        brightness: 1
      },
      resourceMultipliers: {
        iron: 1,
        gold: 1,
        platinum: 1
      }
    };
  }
  static createRandomSystem(id) {
    const starClass = SystemUtils.getRandomStarClass();
    const classification = SystemUtils.getRandomClassification();
    const starColor = STAR_COLORS[starClass] || 16777215;
    const resourceMult = SystemFactory.calculateResourceMultipliers(starClass, classification);
    const skyboxTexture = SystemUtils.getRandomSkyboxTexture();
    return {
      id,
      name: SystemNames.generateSystemName(starClass),
      starClass,
      classification,
      starColor,
      planetCount: SystemUtils.getRandomInt(2, 10),
      asteroidDensity: SystemUtils.getRandomFloat(0.5, 2.5),
      specialFeatures: SystemNames.generateSpecialFeatures(classification),
      description: SystemNames.generateDescription(starClass, classification),
      connections: [],
      position: SystemUtils.generateMapPosition(),
      skyboxParams: {
        starDensity: SystemUtils.getRandomFloat(0.7, 1.5),
        nebulaDensity: SystemUtils.getRandomFloat(0.3, 1.2),
        color: SKYBOX_COLORS[starClass] || 16777215,
        texturePath: skyboxTexture,
        brightness: 0.8
      },
      resourceMultipliers: resourceMult
    };
  }
  static calculateResourceMultipliers(starClass, classification) {
    const baseDistribution = RESOURCE_DISTRIBUTION[starClass];
    const classMultiplier = CLASSIFICATION_MULTIPLIERS[classification];
    return {
      iron: baseDistribution.iron * classMultiplier.iron,
      gold: baseDistribution.gold * classMultiplier.gold,
      platinum: baseDistribution.platinum * classMultiplier.platinum
    };
  }
  static createCustomSystem(systemData) {
    var _a, _b, _c, _d;
    if (!systemData || !systemData.id || !systemData.name) {
      console.error("Invalid system data", systemData);
      return null;
    }
    return {
      id: systemData.id,
      name: systemData.name,
      starClass: systemData.starClass || SystemUtils.getRandomStarClass(),
      classification: systemData.classification || "Custom",
      starColor: systemData.starColor || STAR_COLORS[systemData.starClass || "G"],
      planetCount: systemData.planetData ? systemData.planetData.length : 0,
      asteroidDensity: systemData.asteroidDensity || 1,
      specialFeatures: systemData.specialFeatures || ["User Created"],
      description: systemData.description || "A custom star system created by the user",
      connections: [],
      position: systemData.position || SystemUtils.generateMapPosition(),
      skyboxParams: {
        starDensity: ((_a = systemData.skyboxParams) == null ? void 0 : _a.starDensity) || 1,
        nebulaDensity: ((_b = systemData.skyboxParams) == null ? void 0 : _b.nebulaDensity) || 0.8,
        color: ((_c = systemData.skyboxParams) == null ? void 0 : _c.color) || SKYBOX_COLORS[systemData.starClass || "G"],
        texturePath: systemData.skyboxUrl || SystemUtils.getRandomSkyboxTexture(),
        brightness: ((_d = systemData.skyboxParams) == null ? void 0 : _d.brightness) || 0.8,
        isCustomTexture: !!systemData.skyboxUrl
      },
      resourceMultipliers: systemData.resourceMultipliers || {
        iron: 1,
        gold: 1,
        platinum: 1
      },
      isCustomSystem: true
    };
  }
}
class StarSystemGenerator {
  constructor(scene) {
    this.scene = scene;
    this.systems = {};
    this.currentSystem = null;
    this.warpGates = {};
    this.initializeSystems();
  }
  // Initialize star systems with Solar System as default
  initializeSystems() {
    console.log("Initializing star systems...");
    this.systems["Solar System"] = SystemFactory.createSolarSystem();
    this.generateRandomSystems(5);
    this.createSystemConnections();
    this.setCurrentSystem("Solar System");
    console.log("Star systems initialized");
  }
  // Generate random star systems
  generateRandomSystems(count) {
    for (let i = 0; i < count; i++) {
      const id = `System-${i + 1}`;
      this.systems[id] = SystemFactory.createRandomSystem(id);
    }
  }
  // Create connections between systems
  createSystemConnections() {
    const systemIds = Object.keys(this.systems);
    const solarConnections = this.getRandomSystemsExcept("Solar System", 2);
    for (const targetId of solarConnections) {
      this.createConnection("Solar System", targetId);
    }
    for (const systemId of systemIds) {
      const system = this.systems[systemId];
      if (system.connections.length === 0) {
        const targetId = this.getRandomSystemExcept(systemId);
        this.createConnection(systemId, targetId);
      }
    }
    const extraConnectionCount = Math.floor(systemIds.length / 2);
    for (let i = 0; i < extraConnectionCount; i++) {
      const sourceId = systemIds[SystemUtils.getRandomInt(0, systemIds.length - 1)];
      const targetId = this.getRandomSystemExcept(sourceId);
      if (!this.systems[sourceId].connections.includes(targetId)) {
        this.createConnection(sourceId, targetId);
      }
    }
  }
  // Create a connection between two systems
  createConnection(sourceId, targetId) {
    this.systems[sourceId].connections.push(targetId);
    this.systems[targetId].connections.push(sourceId);
    if (!this.warpGates[sourceId]) {
      this.warpGates[sourceId] = [];
    }
    if (!this.warpGates[targetId]) {
      this.warpGates[targetId] = [];
    }
    this.warpGates[sourceId].push(targetId);
    this.warpGates[targetId].push(sourceId);
    console.log(`Created connection between ${sourceId} and ${targetId}`);
  }
  // Get list of connections for current system
  getCurrentSystemConnections() {
    if (!this.currentSystem) return [];
    return this.systems[this.currentSystem].connections;
  }
  // Get resource distribution for current system
  getCurrentSystemResources() {
    if (!this.currentSystem) return { iron: 1, gold: 1, platinum: 1 };
    const system = this.systems[this.currentSystem];
    return system.resourceMultipliers;
  }
  // Set the current active system
  setCurrentSystem(systemId) {
    if (this.systems[systemId]) {
      this.currentSystem = systemId;
      console.log(`Traveled to system: ${systemId}`);
      return true;
    }
    return false;
  }
  // Travel to a connected system
  travelToSystem(targetSystemId) {
    if (!this.systems[targetSystemId]) {
      console.error(`System ${targetSystemId} does not exist`);
      return false;
    }
    const connections = this.getCurrentSystemConnections();
    if (!connections.includes(targetSystemId)) {
      console.error(`No connection from ${this.currentSystem} to ${targetSystemId}`);
      return false;
    }
    if (window.game && window.game.spaceship && window.game.spaceship.isDocked) {
      console.log("Player is docked during interstellar travel");
    }
    if (this.systems[this.currentSystem]) {
      const currentParams = this.systems[this.currentSystem].skyboxParams;
      console.log(`${this.currentSystem} skybox params before travel: 
                         color=${currentParams.color.toString(16)}, 
                         starDensity=${currentParams.starDensity}, 
                         nebulaDensity=${currentParams.nebulaDensity}, 
                         texture=${currentParams.texturePath}`);
    }
    if (this.systems[targetSystemId]) {
      const targetParams = this.systems[targetSystemId].skyboxParams;
      console.log(`Traveling to ${targetSystemId} with skybox params: 
                         color=${targetParams.color.toString(16)}, 
                         starDensity=${targetParams.starDensity}, 
                         nebulaDensity=${targetParams.nebulaDensity}, 
                         texture=${targetParams.texturePath}`);
    }
    this.setCurrentSystem(targetSystemId);
    return true;
  }
  // Get all star systems for the map
  getAllSystems() {
    return this.systems;
  }
  // Get current system data
  getCurrentSystemData() {
    if (!this.currentSystem) return null;
    return this.systems[this.currentSystem];
  }
  // Helper methods
  getRandomSystemsExcept(exceptId, count) {
    const systemIds = Object.keys(this.systems).filter((id) => id !== exceptId);
    const selected = [];
    for (let i = 0; i < Math.min(count, systemIds.length); i++) {
      const index = SystemUtils.getRandomInt(0, systemIds.length - 1);
      selected.push(systemIds[index]);
      systemIds.splice(index, 1);
    }
    return selected;
  }
  getRandomSystemExcept(exceptId) {
    const systemIds = Object.keys(this.systems).filter((id) => id !== exceptId);
    const index = SystemUtils.getRandomInt(0, systemIds.length - 1);
    return systemIds[index];
  }
  // Add custom system
  addCustomSystem(systemData) {
    const customSystem = SystemFactory.createCustomSystem(systemData);
    if (!customSystem) {
      return false;
    }
    if (this.systems[systemData.id]) {
      console.warn(`System with ID ${systemData.id} already exists, overwriting`);
    }
    console.log(`Adding custom system: ${systemData.name} (${systemData.id})`);
    if (systemData.planetData && Array.isArray(systemData.planetData)) {
      this.storePlanetData(systemData.id, systemData.planetData);
    }
    this.systems[systemData.id] = customSystem;
    this.createConnection("Solar System", systemData.id);
    const randomSystem = this.getRandomSystemExcept(systemData.id, "Solar System");
    if (randomSystem) {
      this.createConnection(systemData.id, randomSystem);
    }
    console.log(`Custom system ${systemData.name} added successfully with connections to Solar System and ${randomSystem || "no other system"}`);
    return true;
  }
  // Store custom planet data
  storePlanetData(systemId, planetData) {
    if (!Array.isArray(planetData)) {
      console.error("Planet data must be an array");
      return;
    }
    const standardizedPlanets = [];
    for (let i = 0; i < planetData.length; i++) {
      const planet = planetData[i];
      standardizedPlanets.push({
        name: planet.name || `Planet-${i + 1}`,
        size: planet.size || 300 + Math.random() * 500,
        distance: planet.distance || 4800 + i * 8e3 + Math.random() * 2e3,
        speed: planet.speed || 1e-3 + Math.random() * 1e-3,
        color: planet.color || SystemUtils.getRandomColor(),
        rings: planet.rings !== void 0 ? planet.rings : Math.random() > 0.7,
        textureUrl: planet.textureUrl || null,
        axialTilt: planet.axialTilt || Math.random() * Math.PI * 0.5,
        orbitalTilt: planet.orbitalTilt || Math.random() * Math.PI * 0.2
      });
    }
    if (!this.customPlanetData) {
      this.customPlanetData = {};
    }
    this.customPlanetData[systemId] = standardizedPlanets;
    console.log(`Stored ${standardizedPlanets.length} planets for system ${systemId}`);
  }
  /**
   * Returns player to stargate after interstellar travel
   * Should be called after travel to ensure proper docking state
   */
  returnFromTravel() {
    var _a, _b, _c;
    console.log("StarSystemGenerator: Handling return from interstellar travel");
    if (!window.game || !window.game.spaceship) {
      console.error("StarSystemGenerator: Cannot return from travel - game or spaceship not found");
      return false;
    }
    if (!window.game.spaceship.isDocked) {
      console.log("StarSystemGenerator: Setting ship to docked state after travel");
      window.game.spaceship.dock();
    }
    const dockingSystem = (_a = window.game.controls) == null ? void 0 : _a.dockingSystem;
    if (dockingSystem) {
      console.log("StarSystemGenerator: Repositioning ship near stargate");
      dockingSystem.positionNearStargate();
      if (typeof dockingSystem.showStargateUI === "function") {
        console.log("StarSystemGenerator: Showing stargate UI via docking system");
        dockingSystem.showStargateUI();
        return true;
      }
    }
    if ((_c = (_b = window.game.ui) == null ? void 0 : _b.stargateInterface) == null ? void 0 : _c.showStargateUI) {
      console.log("StarSystemGenerator: Showing stargate UI via game.ui.stargateInterface");
      window.game.ui.stargateInterface.showStargateUI();
      return true;
    }
    console.warn("StarSystemGenerator: Could not fully complete return from travel");
    return false;
  }
}
class SceneInitializer {
  constructor(scene) {
    this.scene = scene;
    this.componentsLoaded = false;
  }
  // Initialize essential components first
  initializeEssentialComponents() {
    console.log("Initializing essential environment components...");
    this.skybox = new Skybox(this.scene);
    this.sun = new Sun(this.scene);
    this.starSystemGenerator = new StarSystemGenerator(this.scene);
    this.planets = new Planets(this.scene, this.starSystemGenerator);
    this.stargate = new Stargate(this.scene);
    console.log("Essential environment components initialized");
    return {
      skybox: this.skybox,
      sun: this.sun,
      starSystemGenerator: this.starSystemGenerator,
      planets: this.planets,
      stargate: this.stargate
    };
  }
  // Load remaining non-essential components asynchronously
  async loadRemainingComponents() {
    console.log("Loading remaining environment components...");
    const { AsteroidBelt: AsteroidBelt2 } = await __vitePreload(async () => {
      const { AsteroidBelt: AsteroidBelt3 } = await Promise.resolve().then(() => asteroidBelt);
      return { AsteroidBelt: AsteroidBelt3 };
    }, true ? void 0 : void 0);
    this.asteroidBelt = new AsteroidBelt2(this.scene);
    const { SpaceAnomalies: SpaceAnomalies2 } = await __vitePreload(async () => {
      const { SpaceAnomalies: SpaceAnomalies3 } = await Promise.resolve().then(() => spaceAnomalies);
      return { SpaceAnomalies: SpaceAnomalies3 };
    }, true ? void 0 : void 0);
    this.spaceAnomalies = new SpaceAnomalies2(this.scene);
    const { SystemTransition: SystemTransition2 } = await __vitePreload(async () => {
      const { SystemTransition: SystemTransition3 } = await Promise.resolve().then(() => systemTransition);
      return { SystemTransition: SystemTransition3 };
    }, true ? void 0 : void 0);
    this.systemTransition = new SystemTransition2(this.scene, this.scene.camera);
    const { CustomSystemCreator: CustomSystemCreator2 } = await __vitePreload(async () => {
      const { CustomSystemCreator: CustomSystemCreator3 } = await Promise.resolve().then(() => customSystemCreator);
      return { CustomSystemCreator: CustomSystemCreator3 };
    }, true ? void 0 : void 0);
    this.customSystemCreator = new CustomSystemCreator2(this.starSystemGenerator, this);
    console.log("Custom system creator initialized:", this.customSystemCreator);
    this.componentsLoaded = true;
    console.log("All environment components initialized");
    return {
      asteroidBelt: this.asteroidBelt,
      spaceAnomalies: this.spaceAnomalies,
      systemTransition: this.systemTransition,
      customSystemCreator: this.customSystemCreator
    };
  }
  // Initialize VibeVerse portals - requires spaceship reference
  async initializePortals(spaceship) {
    const { VibeVersePortals: VibeVersePortals2 } = await __vitePreload(async () => {
      const { VibeVersePortals: VibeVersePortals3 } = await Promise.resolve().then(() => vibeVersePortals);
      return { VibeVersePortals: VibeVersePortals3 };
    }, true ? void 0 : void 0);
    this.vibeVersePortals = new VibeVersePortals2(this.scene, spaceship);
    console.log("VibeVerse portals initialized");
    return this.vibeVersePortals;
  }
  dispose() {
    if (this.skybox) this.skybox.dispose();
    if (this.sun) this.sun.dispose();
    if (this.planets) this.planets.dispose();
    if (this.asteroidBelt) this.asteroidBelt.dispose();
    if (this.stargate) this.stargate.dispose();
    if (this.spaceAnomalies) this.spaceAnomalies.clearAllAnomalies();
    if (this.vibeVersePortals) this.vibeVersePortals.dispose();
  }
}
class RegionManager {
  constructor() {
    this.planetRegions = {};
  }
  // Basic region setup for essential components only
  setupInitialRegions(sun, stargate, planets) {
    console.log("Setting up essential environment regions");
    this.planetRegions = {};
    if (planets && typeof planets.getPlanetRegions === "function") {
      try {
        this.planetRegions = planets.getPlanetRegions();
      } catch (error) {
        console.warn("Error getting planet regions:", error);
      }
    } else {
      console.warn("planets.getPlanetRegions is not available, using empty object instead");
    }
    this.planetRegions["Sun"] = {
      center: sun.getPosition(),
      radius: sun.getRadius()
    };
    const stargateRegion = stargate.getRegionInfo();
    this.planetRegions["Stargate"] = {
      center: stargateRegion.center,
      radius: stargateRegion.radius
    };
  }
  // Complete region setup with all components
  setupRegions(sun, stargate, planets, asteroidBelt2, spaceAnomalies2) {
    console.log("Setting up environment regions");
    this.planetRegions = {};
    if (planets && typeof planets.getPlanetRegions === "function") {
      try {
        this.planetRegions = planets.getPlanetRegions();
      } catch (error) {
        console.warn("Error getting planet regions in setupRegions:", error);
      }
    } else {
      console.warn("planets.getPlanetRegions is not available in setupRegions, using empty object");
    }
    this.planetRegions["Sun"] = {
      center: sun.getPosition(),
      radius: sun.getRadius()
    };
    const asteroidBeltRegion = asteroidBelt2.getRegionInfo();
    this.planetRegions["Asteroid Belt"] = {
      center: asteroidBeltRegion.center,
      minRadius: asteroidBeltRegion.innerRadius,
      maxRadius: asteroidBeltRegion.outerRadius
    };
    const stargateRegion = stargate.getRegionInfo();
    this.planetRegions["Stargate"] = {
      center: stargateRegion.center,
      radius: stargateRegion.radius
    };
    const anomaliesRegion = spaceAnomalies2.getRegionInfo();
    this.planetRegions["Space Anomalies"] = {
      center: anomaliesRegion.center,
      minRadius: anomaliesRegion.innerRadius,
      maxRadius: anomaliesRegion.outerRadius
    };
  }
  // Get the player's current location based on position
  getPlayerLocation(playerPosition, spaceAnomalies2, asteroids, componentsLoaded) {
    if (!playerPosition) {
      return "Unknown Location";
    }
    const stargateRegion = this.planetRegions["Stargate"];
    if (stargateRegion) {
      const distanceToStargate = playerPosition.distanceTo(stargateRegion.center);
      if (distanceToStargate <= stargateRegion.radius) {
        return "Stargate";
      }
    }
    if (componentsLoaded && spaceAnomalies2) {
      const closestAnomaly = spaceAnomalies2.findClosestAnomaly(playerPosition, 2e3);
      if (closestAnomaly) {
        const distance = playerPosition.distanceTo(closestAnomaly.position);
        if (distance < 800) {
          let anomalyType = "";
          switch (closestAnomaly.type) {
            case "vortex":
              anomalyType = "Vortex";
              break;
            case "crystalCluster":
              anomalyType = "Crystal Cluster";
              break;
            case "nebulaNexus":
              anomalyType = "Nebula Nexus";
              break;
            case "quantumFlux":
              anomalyType = "Quantum Flux";
              break;
            case "darkMatter":
              anomalyType = "Dark Matter";
              break;
          }
          const orbStatus = closestAnomaly.orbCollected ? "Depleted" : "Active";
          return `${anomalyType} Anomaly (${orbStatus})`;
        }
      }
    }
    for (const [name, region] of Object.entries(this.planetRegions)) {
      if (name === "Asteroid Belt" && componentsLoaded && asteroids) {
        const distance = playerPosition.distanceTo(region.center);
        if (region.minRadius && region.maxRadius && distance >= region.minRadius && distance <= region.maxRadius) {
          const nearbyAsteroids = asteroids.filter((asteroid) => {
            return playerPosition.distanceTo(asteroid.mesh.position) < 500;
          });
          if (nearbyAsteroids.length > 0) {
            return `Asteroid Field (${nearbyAsteroids.length} nearby)`;
          }
          return "Asteroid Belt";
        }
      } else if (name === "Space Anomalies" && componentsLoaded) {
        const distance = playerPosition.distanceTo(region.center);
        if (region.minRadius && region.maxRadius && distance >= region.minRadius && distance <= region.maxRadius) {
          return "Space Anomaly Field";
        }
      } else if (name !== "Sun" && name !== "Stargate" && region.center && region.radius) {
        const distance = playerPosition.distanceTo(region.center);
        if (distance <= region.radius) {
          return `Near ${name}`;
        }
      }
    }
    const sunRegion = this.planetRegions["Sun"];
    if (sunRegion) {
      const distanceToSun = playerPosition.distanceTo(sunRegion.center);
      if (distanceToSun <= sunRegion.radius) {
        return "Near Sun";
      }
    }
    return "Deep Space";
  }
  getPlanetRegions() {
    return this.planetRegions;
  }
}
class SystemTransitionManager {
  constructor() {
    this.currentSystemId = "Solar System";
  }
  // Set up handlers for star system transitions
  setupSystemTransitionHandlers(starSystemGenerator, asteroidBelt2) {
    if (starSystemGenerator && asteroidBelt2) {
      const resources = starSystemGenerator.getCurrentSystemResources();
      asteroidBelt2.setResourceMultipliers(resources);
    }
  }
  // Travel to a new star system
  travelToSystem(systemId, starSystemGenerator, systemTransition2, updateEnvironmentCallback) {
    if (!starSystemGenerator || !systemTransition2) return false;
    if (!starSystemGenerator.travelToSystem(systemId)) {
      console.error(`Cannot travel to system ${systemId}`);
      return false;
    }
    console.log(`Starting transition to system: ${systemId}`);
    systemTransition2.startTransition(() => {
      console.log(`Transition complete, updating environment for: ${systemId}`);
      updateEnvironmentCallback(systemId);
      this.showSystemWelcomeNotification(systemId, starSystemGenerator);
      if (window.game && window.game.spaceship && window.game.spaceship.isDocked) {
        console.log("Player is docked after arriving in new system, showing interface");
        if (window.game.controls && window.game.controls.dockingSystem) {
          setTimeout(() => {
            window.game.controls.dockingSystem.dockWithStargate();
          }, 500);
        }
      }
    });
    return true;
  }
  // Update environment visuals and properties for the new system
  updateEnvironmentForSystem(systemId, starSystemGenerator, skybox, sun, planets, asteroidBelt2, spaceAnomalies2, regionManager) {
    const systemData = starSystemGenerator.getAllSystems()[systemId];
    if (!systemData) {
      console.error(`No system data found for ${systemId}`);
      return;
    }
    console.log(`Updating environment for system: ${systemId}`, systemData);
    this.currentSystemId = systemId;
    if (skybox && skybox.updateForSystem) {
      if (systemId === "Solar System") {
        const solarSystemParams = {
          starDensity: 1,
          nebulaDensity: 0.5,
          color: 16777215,
          // Ensure white color for Solar System
          isSolarSystem: true,
          // Flag this as Solar System
          resetTime: true
          // Reset the time for consistent appearance
        };
        console.log(`Updating skybox for Solar System with enforced white color`);
        skybox.updateForSystem(solarSystemParams);
      } else {
        console.log(`Updating skybox for ${systemId} with params:`, systemData.skyboxParams);
        skybox.updateForSystem(systemData.skyboxParams);
      }
    } else {
      console.warn("Skybox or updateForSystem method not available");
    }
    if (sun) {
      const lightIntensityMultiplier = systemData.lightIntensityMultiplier || 1;
      if (sun.updateSunType && systemData.starClass) {
        console.log(`Updating sun type for ${systemId} to ${systemData.starClass} with intensity multiplier: ${lightIntensityMultiplier}`);
        sun.updateSunType(systemData.starClass, lightIntensityMultiplier);
      } else if (sun.updateColor) {
        console.log(`Updating sun color for ${systemId} to:`, systemData.starColor.toString(16));
        sun.updateColor(systemData.starColor);
        if (sun.sunLight) {
          sun.sunLight._intensityMultiplier = lightIntensityMultiplier;
        }
      } else {
        console.warn("Sun update methods not available");
      }
    } else {
      console.warn("Sun not available");
    }
    if (planets && planets.updateForSystem) {
      console.log(`Updating planets for ${systemId}`);
      planets.updateForSystem(systemId);
      if (typeof planets.getPlanetRegions === "function") {
        try {
          regionManager.planetRegions = planets.getPlanetRegions();
        } catch (error) {
          console.warn(`Error getting planet regions for system ${systemId}:`, error);
        }
      } else {
        console.warn(`planets.getPlanetRegions is not available for system ${systemId}`);
      }
    } else {
      console.warn("Planets or updateForSystem method not available");
    }
    if (asteroidBelt2) {
      if (asteroidBelt2.dispose) {
        console.log(`Disposing old asteroids before updating for ${systemId}`);
        asteroidBelt2.dispose();
      }
      if (asteroidBelt2.createAsteroidBelt) {
        console.log(`Creating new asteroids for ${systemId}`);
        asteroidBelt2.createAsteroidBelt();
      }
      if (asteroidBelt2.setResourceMultipliers) {
        console.log(`Updating asteroid resources for ${systemId}:`, systemData.resourceMultipliers);
        asteroidBelt2.setResourceMultipliers(systemData.resourceMultipliers);
      }
      if (asteroidBelt2.updateDensity) {
        console.log(`Updating asteroid density for ${systemId}:`, systemData.asteroidDensity);
        asteroidBelt2.updateDensity(systemData.asteroidDensity);
      }
    } else {
      console.warn("AsteroidBelt not available");
    }
    if (spaceAnomalies2 && spaceAnomalies2.updateForSystem) {
      console.log(`Updating space anomalies for ${systemId}`);
      spaceAnomalies2.updateForSystem(systemData);
    } else {
      console.warn("SpaceAnomalies or updateForSystem method not available");
    }
    console.log(`Environment updated for ${systemId}`);
  }
  // Show welcome notification when arriving at a new system
  showSystemWelcomeNotification(systemId, starSystemGenerator) {
    const system = starSystemGenerator.getAllSystems()[systemId];
    if (!system) return;
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = "25%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#fff";
    notification.style.padding = "20px 40px";
    notification.style.borderRadius = "10px";
    notification.style.border = `2px solid #${system.starColor.toString(16).padStart(6, "0")}`;
    notification.style.boxShadow = `0 0 30px #${system.starColor.toString(16).padStart(6, "0")}`;
    notification.style.fontFamily = "Courier New, monospace";
    notification.style.fontSize = "18px";
    notification.style.zIndex = "9999";
    notification.style.textAlign = "center";
    if (systemId === "Solar System") {
      notification.innerHTML = `
                <h2 style="color: #30cfd0; margin-top: 0;">Welcome to the Solar System</h2>
                <p>Your home system, with Earth as your starting location.</p>
                <p style="font-size: 14px; margin-bottom: 0; color: #aaa;">Safe travels, commander.</p>
            `;
    } else {
      notification.innerHTML = `
                <h2 style="color: #${system.starColor.toString(16).padStart(6, "0")}; margin-top: 0;">Welcome to ${system.name}</h2>
                <p>${system.description}</p>
                <p style="font-size: 14px; margin-bottom: 0; color: #aaa;">Classification: ${system.classification} - Star Class: ${system.starClass}</p>
            `;
    }
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 1s";
      setTimeout(() => {
        notification.remove();
      }, 1e3);
    }, 5e3);
  }
  getCurrentSystemId() {
    return this.currentSystemId;
  }
}
class AsteroidBelt {
  constructor(scene) {
    this.scene = scene;
    this.asteroids = [];
    this.innerRadius = 2e4;
    this.outerRadius = 28e3;
    this.width = 1800;
    this.resourceMultipliers = { iron: 1, gold: 1, platinum: 1 };
    this.createAsteroidBelt();
  }
  createAsteroidBelt() {
    const asteroidCount = 1e3;
    for (let i = 0; i < asteroidCount; i++) {
      const size = Math.random() * 120 + 120;
      let geometry;
      const type = Math.floor(Math.random() * 3);
      if (type === 0) {
        geometry = new IcosahedronGeometry(size, 0);
      } else if (type === 1) {
        geometry = new TetrahedronGeometry(size, 0);
      } else {
        geometry = new OctahedronGeometry(size, 0);
      }
      const positions = geometry.attributes.position;
      for (let j = 0; j < positions.count; j++) {
        const vertex = new Vector3();
        vertex.fromBufferAttribute(positions, j);
        vertex.x += (Math.random() - 0.5) * 0.4 * size;
        vertex.y += (Math.random() - 0.5) * 0.4 * size;
        vertex.z += (Math.random() - 0.5) * 0.4 * size;
        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
      }
      geometry.computeVertexNormals();
      const color = new Color();
      const resourceRoll = Math.random();
      let resourceType = null;
      if (resourceRoll < 0.7) {
        color.setHSL(0.02, 0.3, 0.35 + Math.random() * 0.2);
        resourceType = "iron";
      } else if (resourceRoll < 0.93) {
        color.setHSL(0.12, 0.7, 0.5 + Math.random() * 0.2);
        resourceType = "gold";
      } else {
        color.setHSL(0.1, 0.3, 0.7 + Math.random() * 0.15);
        resourceType = "platinum";
      }
      const material = new MeshStandardMaterial({
        color,
        roughness: 0.6 + Math.random() * 0.2,
        // Reduced roughness
        metalness: 0.4 + Math.random() * 0.4,
        // Increased metalness
        flatShading: true,
        emissive: color.clone().multiplyScalar(0.3),
        // Add emissive glow
        emissiveIntensity: 0.2
        // Subtle glow for better visibility
      });
      const mesh = new Mesh(geometry, material);
      const angle = Math.random() * Math.PI * 2;
      const radius = this.innerRadius + Math.random() * (this.outerRadius - this.innerRadius);
      const heightVariation = (Math.random() - 0.5) * this.width;
      mesh.position.set(
        Math.cos(angle) * radius,
        heightVariation,
        Math.sin(angle) * radius
      );
      mesh.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      const orbitSpeed = 5e-5 + Math.random() * 5e-5;
      const orbitRadius = radius;
      const orbitTilt = Math.random() * Math.PI * 0.15;
      this.scene.add(mesh);
      const baseResourceAmount = 50 + Math.random() * 50;
      this.asteroids.push({
        mesh,
        size,
        orbitSpeed,
        orbitRadius,
        orbitAngle: angle,
        orbitTilt,
        initialHeight: heightVariation,
        // Store initial height variation
        rotationSpeed: {
          x: (Math.random() - 0.5) * 5e-3,
          y: (Math.random() - 0.5) * 5e-3,
          z: (Math.random() - 0.5) * 5e-3
        },
        resourceType,
        baseResourceAmount,
        // Base amount
        resourceAmount: baseResourceAmount,
        // Current amount
        maxResourceAmount: baseResourceAmount,
        // Max capacity
        minable: true
      });
    }
  }
  getRegionInfo() {
    return {
      center: new Vector3(0, 0, 0),
      innerRadius: this.innerRadius,
      outerRadius: this.outerRadius
    };
  }
  getAsteroids() {
    return this.asteroids;
  }
  // Set resource multipliers based on the current star system
  setResourceMultipliers(multipliers) {
    if (!multipliers) return;
    this.resourceMultipliers = multipliers;
    this.updateAsteroidResources();
    console.log("Updated asteroid belt with resource multipliers:", multipliers);
  }
  // Update asteroid resources based on current system
  updateAsteroidResources() {
    this.asteroids.forEach((asteroid) => {
      if (asteroid.resourceType) {
        switch (asteroid.resourceType) {
          case "iron":
            asteroid.resourceAmount = asteroid.baseResourceAmount * this.resourceMultipliers.iron;
            break;
          case "gold":
            asteroid.resourceAmount = asteroid.baseResourceAmount * this.resourceMultipliers.gold;
            break;
          case "platinum":
            asteroid.resourceAmount = asteroid.baseResourceAmount * this.resourceMultipliers.platinum;
            break;
        }
      }
    });
  }
  // Update asteroid density based on system characteristics
  updateForSystem(params) {
    if (!params) return;
    if (params.asteroidDensity) {
      this.updateDensity(params.asteroidDensity);
    }
    if (params.resourceMultipliers) {
      this.setResourceMultipliers(params.resourceMultipliers);
    }
  }
  // Update asteroid density
  updateDensity(densityMultiplier = 1) {
    if (densityMultiplier < 0.5) densityMultiplier = 0.5;
    if (densityMultiplier > 3) densityMultiplier = 3;
    this.asteroids.forEach((asteroid, index) => {
      const shouldBeVisible = index % 10 < densityMultiplier * 5;
      asteroid.mesh.visible = shouldBeVisible;
      asteroid.minable = shouldBeVisible;
    });
  }
  // Helper function to find the closest asteroid to a point (for mining)
  findClosestAsteroid(position, maxDistance = 1600) {
    let closestAsteroid = null;
    let closestDistance = maxDistance;
    this.asteroids.forEach((asteroid) => {
      if (!asteroid.minable || !asteroid.mesh.visible) return;
      const distance = position.distanceTo(asteroid.mesh.position);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestAsteroid = asteroid;
      }
    });
    return closestAsteroid;
  }
  removeAsteroid(asteroid) {
    this.scene.remove(asteroid.mesh);
    if (asteroid.mesh.geometry) {
      asteroid.mesh.geometry.dispose();
    }
    if (asteroid.mesh.material) {
      if (asteroid.mesh.material.map) asteroid.mesh.material.map.dispose();
      if (asteroid.mesh.material.emissiveMap) asteroid.mesh.material.emissiveMap.dispose();
      if (asteroid.mesh.material.normalMap) asteroid.mesh.material.normalMap.dispose();
      if (asteroid.mesh.material.roughnessMap) asteroid.mesh.material.roughnessMap.dispose();
      if (asteroid.mesh.material.metalnessMap) asteroid.mesh.material.metalnessMap.dispose();
      asteroid.mesh.material.dispose();
    }
    const index = this.asteroids.findIndex((a) => a === asteroid);
    if (index !== -1) {
      this.asteroids.splice(index, 1);
    }
  }
  update(deltaTime = 0.016) {
    this.asteroids.forEach((asteroid) => {
      asteroid.mesh.rotation.x += asteroid.rotationSpeed.x;
      asteroid.mesh.rotation.y += asteroid.rotationSpeed.y;
      asteroid.mesh.rotation.z += asteroid.rotationSpeed.z;
      asteroid.orbitAngle += asteroid.orbitSpeed;
      const flatX = Math.cos(asteroid.orbitAngle) * asteroid.orbitRadius;
      const flatZ = Math.sin(asteroid.orbitAngle) * asteroid.orbitRadius;
      if (asteroid.orbitTilt) {
        const tiltY = flatZ * Math.sin(asteroid.orbitTilt);
        const tiltZ = flatZ * Math.cos(asteroid.orbitTilt);
        asteroid.mesh.position.x = flatX;
        asteroid.mesh.position.z = tiltZ;
        asteroid.mesh.position.y = tiltY + asteroid.initialHeight;
      } else {
        asteroid.mesh.position.x = flatX;
        asteroid.mesh.position.z = flatZ;
        asteroid.mesh.position.y = asteroid.initialHeight;
      }
    });
  }
  // Clean up all asteroids (for system transitions)
  dispose() {
    while (this.asteroids.length > 0) {
      const asteroid = this.asteroids[0];
      this.removeAsteroid(asteroid);
    }
    this.asteroids = [];
  }
}
const asteroidBelt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AsteroidBelt
}, Symbol.toStringTag, { value: "Module" }));
class SystemTransition {
  constructor(scene, camera) {
    this.scene = scene;
    this.camera = camera;
    this.isTransitioning = false;
    this.transitionDuration = 3e3;
    this.onTransitionComplete = null;
    this.setupTransitionElements();
  }
  setupTransitionElements() {
    this.warpTunnel = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        color: 3198928,
        size: 2,
        blending: AdditiveBlending,
        transparent: true,
        sizeAttenuation: true
      })
    );
    this.createWarpParticles();
    this.createOverlay();
  }
  createWarpParticles() {
    const particleCount = 2e3;
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const radius = 50 + Math.random() * 50;
      const theta = Math.random() * Math.PI * 2;
      const length = -500 - Math.random() * 3e3;
      positions[i3] = radius * Math.cos(theta);
      positions[i3 + 1] = radius * Math.sin(theta);
      positions[i3 + 2] = length;
    }
    this.warpTunnel.geometry.setAttribute("position", new BufferAttribute(positions, 3));
    this.originalPositions = new Float32Array(positions);
  }
  createOverlay() {
    this.overlay = document.createElement("div");
    this.overlay.id = "warp-overlay";
    this.overlay.style.position = "fixed";
    this.overlay.style.top = "0";
    this.overlay.style.left = "0";
    this.overlay.style.width = "100%";
    this.overlay.style.height = "100%";
    this.overlay.style.backgroundColor = "#30cfd0";
    this.overlay.style.opacity = "0";
    this.overlay.style.transition = "opacity 0.5s";
    this.overlay.style.pointerEvents = "none";
    this.overlay.style.zIndex = "9999";
    document.body.appendChild(this.overlay);
  }
  // Start a transition between systems
  startTransition(onComplete) {
    if (this.isTransitioning) return;
    console.log("Starting system transition...");
    this.isTransitioning = true;
    this.onTransitionComplete = onComplete;
    this.scene.add(this.warpTunnel);
    this.initialCameraPosition = this.camera.position.clone();
    this.initialCameraRotation = this.camera.rotation.clone();
    this.startTime = Date.now();
    this.showOverlay();
    this.animate();
  }
  // Animation loop for transition
  animate() {
    if (!this.isTransitioning) return;
    const currentTime = Date.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.transitionDuration, 1);
    this.updateWarpEffect(progress);
    if (progress >= 1) {
      this.completeTransition();
      return;
    }
    requestAnimationFrame(this.animate.bind(this));
  }
  // Update warp tunnel effect
  updateWarpEffect(progress) {
    const positions = this.warpTunnel.geometry.attributes.position.array;
    const warpSpeed = 3 + progress * 20;
    for (let i = 0; i < positions.length; i += 3) {
      positions[i + 2] += warpSpeed;
      if (positions[i + 2] > 100) {
        positions[i] = this.originalPositions[i];
        positions[i + 1] = this.originalPositions[i + 1];
        positions[i + 2] = this.originalPositions[i + 2] - 500;
      }
    }
    this.warpTunnel.geometry.attributes.position.needsUpdate = true;
    if (this.camera) {
      this.camera.rotation.z += 5e-4 * Math.sin(progress * Math.PI);
    }
  }
  // Show overlay with flash effect
  showOverlay() {
    if (!this.overlay) return;
    this.overlay.style.opacity = "0.2";
    setTimeout(() => {
      this.overlay.style.opacity = "1";
      setTimeout(() => {
        this.overlay.style.opacity = "0";
      }, 500);
    }, this.transitionDuration - 1e3);
  }
  // Complete the transition
  completeTransition() {
    console.log("System transition complete");
    this.isTransitioning = false;
    this.scene.remove(this.warpTunnel);
    if (this.camera && this.initialCameraPosition && this.initialCameraRotation) {
      this.camera.position.copy(this.initialCameraPosition);
      this.camera.rotation.copy(this.initialCameraRotation);
    }
    if (this.onTransitionComplete && typeof this.onTransitionComplete === "function") {
      setTimeout(() => {
        console.log("Executing transition completion callback");
        this.onTransitionComplete();
      }, 100);
    }
  }
}
const systemTransition = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SystemTransition
}, Symbol.toStringTag, { value: "Module" }));
class ApiClient {
  constructor() {
    this.apiBaseUrl = this.getApiBaseUrl();
    this.token = null;
    this.tokenExpiry = null;
    this.clientId = "game_client";
    this.isRefreshing = false;
    this.refreshCallbacks = [];
    console.log(`API Client initialized with base URL: ${this.apiBaseUrl}`);
  }
  // Get base URL from environment or use default
  getApiBaseUrl() {
    if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      return "http://localhost:8001";
    }
    return "https://aminer-skybox-generator-833fe937a945.herokuapp.com";
  }
  // Check if token is valid and not expired
  hasValidToken() {
    if (!this.token || !this.tokenExpiry) {
      return false;
    }
    const expiryTime = new Date(this.tokenExpiry).getTime();
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const fiveMinutesInMs = 5 * 60 * 1e3;
    return expiryTime - currentTime > fiveMinutesInMs;
  }
  // Clear token from memory
  clearToken() {
    this.token = null;
    this.tokenExpiry = null;
  }
  // Get a new token from the API
  async getToken() {
    if (this.isRefreshing) {
      return new Promise((resolve) => {
        this.refreshCallbacks.push((success) => resolve(success));
      });
    }
    this.isRefreshing = true;
    try {
      const response = await fetch(`${this.apiBaseUrl}/token`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ client_id: this.clientId })
      });
      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.detail || "Failed to get token";
        console.error(`Token error (${response.status}): ${errorMessage}`);
        this.refreshCallbacks.forEach((cb) => cb(false));
        this.refreshCallbacks = [];
        this.isRefreshing = false;
        throw new Error(errorMessage);
      }
      const data = await response.json();
      this.token = data.access_token;
      const expiryDate = /* @__PURE__ */ new Date();
      expiryDate.setHours(expiryDate.getHours() + 1);
      this.tokenExpiry = expiryDate.toISOString();
      this.refreshCallbacks.forEach((cb) => cb(true));
      this.refreshCallbacks = [];
      this.isRefreshing = false;
      return true;
    } catch (error) {
      console.error("Error getting token:", error);
      this.refreshCallbacks.forEach((cb) => cb(false));
      this.refreshCallbacks = [];
      this.isRefreshing = false;
      return false;
    }
  }
  // Handle API response errors
  async handleApiResponse(response) {
    if (response.status === 401) {
      this.clearToken();
      const success = await this.getToken();
      if (!success) {
        throw new Error("Authentication failed. Please reload the application.");
      }
      return false;
    }
    if (response.status === 429) {
      throw new Error("Rate limit exceeded. Please try again later.");
    }
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || errorData.detail || `Error: ${response.status} ${response.statusText}`);
    }
    return true;
  }
  // Generate a skybox based on the system name and description
  async generateSkybox(systemName, description) {
    if (!this.hasValidToken()) {
      const success = await this.getToken();
      if (!success) {
        throw new Error("Failed to authenticate with the API");
      }
    }
    const response = await fetch(`${this.apiBaseUrl}/generate-skybox`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify({
        system_name: systemName,
        skybox_description: description
      })
    });
    const isValid = await this.handleApiResponse(response);
    if (!isValid) {
      return this.generateSkybox(systemName, description);
    }
    return await response.json();
  }
  // Generate a planet texture based on the planet name and description
  async generatePlanet(planetName, description) {
    if (!this.hasValidToken()) {
      const success = await this.getToken();
      if (!success) {
        throw new Error("Failed to authenticate with the API");
      }
    }
    const response = await fetch(`${this.apiBaseUrl}/generate-planet`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.token}`
      },
      body: JSON.stringify({
        planet_name: planetName,
        planet_description: description
      })
    });
    const isValid = await this.handleApiResponse(response);
    if (!isValid) {
      return this.generatePlanet(planetName, description);
    }
    return await response.json();
  }
  // Convert a relative image path to a full URL
  getFullImageUrl(relativeUrl) {
    if (relativeUrl.startsWith("http")) {
      return relativeUrl;
    }
    const cleanPath = relativeUrl.startsWith("/") ? relativeUrl.substring(1) : relativeUrl;
    const baseUrl = this.apiBaseUrl;
    return `${baseUrl}/${cleanPath}`;
  }
}
class StyleManager {
  constructor(isMobile = false) {
    this.isMobile = isMobile;
    this.stylesInjected = false;
  }
  injectStyles() {
    if (this.stylesInjected) return;
    this.injectBaseStyles();
    if (this.isMobile) {
      this.injectMobileStyles();
    }
    this.stylesInjected = true;
  }
  injectBaseStyles() {
    if (!document.getElementById("custom-system-creator-styles")) {
      const style = document.createElement("style");
      style.id = "custom-system-creator-styles";
      style.textContent = `
                .property-row {
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                }
                
                .property-row label {
                    flex: 0 0 150px;
                    margin-right: 10px;
                }
                
                .property-row .slider {
                    flex: 1;
                    height: 10px;
                    background: #2a2a2a;
                    outline: none;
                    border-radius: 5px;
                }
                
                .property-row .slider-value {
                    flex: 0 0 60px;
                    margin-left: 10px;
                    text-align: right;
                }
                
                .planet-properties {
                    background: rgba(0, 0, 0, 0.2);
                    padding: 15px;
                    border-radius: 5px;
                    margin-top: 10px;
                    margin-bottom: 15px;
                }
                
                .help-text {
                    font-size: 12px;
                    color: #aaa;
                    margin-top: 5px;
                }
                
                select.form-control {
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    background: #25303e;
                    color: white;
                    border: 1px solid #3a5472;
                }
                
                /* Active slider styles */
                .slider-active {
                    background: #3a5472 !important;
                }
                
                /* Add smooth transitions */
                #custom-system-creator button {
                    transition: all 0.2s ease;
                }
                
                #custom-system-creator button:active {
                    transform: scale(0.95);
                }

                /* Modal open styles */
                .modal-open {
                    overflow: hidden;
                    position: fixed;
                    width: 100%;
                    height: 100%;
                }
            `;
      document.head.appendChild(style);
    }
  }
  injectMobileStyles() {
    if (!document.getElementById("custom-system-creator-mobile-styles")) {
      const style = document.createElement("style");
      style.id = "custom-system-creator-mobile-styles";
      style.innerHTML = `
                @media (max-width: 900px) {
                    /* Mobile-specific styles for CustomSystemCreator */
                    #custom-system-creator .modal-content {
                        border-radius: 10px;
                        padding-bottom: 120px;
                    }
                    
                    #custom-system-creator .form-group {
                        margin-bottom: 24px;
                    }
                    
                    #custom-system-creator label {
                        font-size: 16px;
                        margin-bottom: 10px;
                        display: block;
                    }
                    
                    #custom-system-creator .property-row {
                        flex-direction: column;
                        align-items: flex-start;
                        margin-bottom: 20px;
                    }
                    
                    #custom-system-creator .property-row label {
                        margin-bottom: 10px;
                        width: 100%;
                    }
                    
                    #custom-system-creator .slider {
                        width: 100%;
                        margin: 10px 0;
                    }
                    
                    #custom-system-creator .slider-value {
                        margin-top: 5px;
                        align-self: flex-end;
                    }
                    
                    #custom-system-creator .planet-input {
                        padding: 20px;
                        margin-bottom: 30px;
                    }
                    
                    #custom-system-creator input[type="text"],
                    #custom-system-creator textarea,
                    #custom-system-creator select {
                        font-size: 16px !important;
                        padding: 14px !important;
                    }
                    
                    #custom-system-creator .planet-preview {
                        flex: 0 0 100%;
                        margin-bottom: 15px;
                    }
                    
                    #custom-system-creator .form-actions {
                        text-align: center;
                    }
                    
                    /* Better slider for touch */
                    #custom-system-creator input[type="range"] {
                        -webkit-appearance: none;
                        height: 30px;
                        background: #0d1e2f;
                        border-radius: 15px;
                        padding: 0;
                        outline: none;
                    }
                    
                    #custom-system-creator input[type="range"]::-webkit-slider-thumb {
                        -webkit-appearance: none;
                        width: 30px;
                        height: 30px;
                        border-radius: 50%;
                        background: #4a9dff;
                        cursor: pointer;
                    }
                    
                    #custom-system-creator input[type="range"]::-moz-range-thumb {
                        width: 30px;
                        height: 30px;
                        border-radius: 50%;
                        background: #4a9dff;
                        cursor: pointer;
                        border: none;
                    }
                    
                    /* Touch ripple effect for buttons */
                    .ripple {
                        position: relative;
                        overflow: hidden;
                        transform: translate3d(0, 0, 0);
                    }
                    
                    .ripple:after {
                        content: "";
                        display: block;
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        top: 0;
                        left: 0;
                        pointer-events: none;
                        background-image: radial-gradient(circle, #fff 10%, transparent 10.01%);
                        background-repeat: no-repeat;
                        background-position: 50%;
                        transform: scale(10, 10);
                        opacity: 0;
                        transition: transform .5s, opacity 1s;
                    }
                    
                    .ripple:active:after {
                        transform: scale(0, 0);
                        opacity: .3;
                        transition: 0s;
                    }
                    
                    /* Character counter for text areas */
                    .char-counter {
                        font-size: 12px;
                        color: #aaa;
                        text-align: right;
                        margin-top: 5px;
                    }
                    
                    .char-counter.warning {
                        color: #ff9900;
                    }
                    
                    .char-counter.error {
                        color: #ff3030;
                    }
                }
            `;
      document.head.appendChild(style);
    }
  }
  getMobileStyles(type = "") {
    const styles = {
      modalContent: this.isMobile ? "width: 94%; max-height: 85vh; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: 100px; overscroll-behavior: contain;" : "",
      closeBtn: this.isMobile ? "font-size: 28px; padding: 12px; min-height: 48px; min-width: 48px;" : "",
      modalBody: this.isMobile ? "padding-bottom: 150px;" : "",
      input: this.isMobile ? "font-size: 16px; padding: 14px; height: 48px;" : "",
      textarea: this.isMobile ? "font-size: 16px; padding: 14px;" : "",
      select: this.isMobile ? "font-size: 16px; padding: 14px; height: 48px;" : "",
      slider: this.isMobile ? "height: 30px; margin: 10px 0;" : "",
      checkbox: this.isMobile ? "transform: scale(1.7); margin: 0 15px; min-height: 24px; min-width: 24px;" : "",
      checkboxRow: this.isMobile ? "margin-top: 15px;" : "",
      primaryBtn: this.isMobile ? "min-height: 54px; padding: 16px; font-size: 18px; margin-top: 20px; width: 100%;" : "",
      secondaryBtn: this.isMobile ? "min-height: 50px; padding: 14px; font-size: 16px; width: 100%; margin: 15px 0;" : "",
      removeBtn: this.isMobile ? "min-height: 50px; padding: 14px; font-size: 16px; right: 15px; top: 15px;" : "",
      previewContainer: this.isMobile ? "flex-direction: column;" : "",
      skyboxPreview: this.isMobile ? "width: 100%; margin-bottom: 20px;" : "",
      planetsPreview: this.isMobile ? "width: 100%;" : "",
      formActions: this.isMobile ? "padding-bottom: 30px;" : ""
    };
    return type ? styles[type] : styles;
  }
  getTextareaRows(defaultRows) {
    return this.isMobile ? Math.max(2, defaultRows - 1) : defaultRows;
  }
  cleanup() {
    const stylesToRemove = [
      "custom-system-creator-styles",
      "custom-system-creator-mobile-styles",
      "modal-open-style"
    ];
    stylesToRemove.forEach((id) => {
      const style = document.getElementById(id);
      if (style) {
        style.remove();
      }
    });
    this.stylesInjected = false;
  }
}
class ValidationManager {
  constructor(isMobile = false) {
    this.isMobile = isMobile;
  }
  validateSystemForm(systemNameInput, skyboxDescription) {
    const systemName = systemNameInput.value.trim();
    const skyboxDesc = skyboxDescription.value.trim();
    if (!systemName) {
      return { isValid: false, message: "Please enter a system name." };
    }
    if (!skyboxDesc) {
      return { isValid: false, message: "Please enter a skybox description." };
    }
    if (systemName.length < 3) {
      return { isValid: false, message: "System name must be at least 3 characters long." };
    }
    if (skyboxDesc.length < 10) {
      return { isValid: false, message: "Skybox description must be at least 10 characters long." };
    }
    return { isValid: true };
  }
  validatePlanetData(planetDiv, planetIndex) {
    const nameInput = planetDiv.querySelector(`input[id^="planet-name-"]`);
    const descInput = planetDiv.querySelector(`textarea[id^="planet-description-"]`);
    if (!nameInput || !descInput) {
      return { isValid: false, message: `Planet ${planetIndex} is missing required fields.` };
    }
    const planetName = nameInput.value.trim();
    const planetDesc = descInput.value.trim();
    if (!planetName) {
      return { isValid: false, message: `Please enter a name for Planet ${planetIndex}.` };
    }
    if (!planetDesc) {
      return { isValid: false, message: `Please enter a description for Planet ${planetIndex}.` };
    }
    if (planetName.length < 2) {
      return { isValid: false, message: `Planet ${planetIndex} name must be at least 2 characters long.` };
    }
    if (planetDesc.length < 5) {
      return { isValid: false, message: `Planet ${planetIndex} description must be at least 5 characters long.` };
    }
    return { isValid: true };
  }
  collectPlanetData(planetInputs) {
    const planets = [];
    const errors = [];
    for (let i = 0; i < planetInputs.length; i++) {
      const planetDiv = planetInputs[i];
      const planetIndex = i + 1;
      const validation = this.validatePlanetData(planetDiv, planetIndex);
      if (!validation.isValid) {
        errors.push(validation.message);
        continue;
      }
      const nameInput = planetDiv.querySelector(`input[id^="planet-name-"]`);
      const descInput = planetDiv.querySelector(`textarea[id^="planet-description-"]`);
      const sizeInput = planetDiv.querySelector(`input[id^="planet-size-"]`);
      const distanceInput = planetDiv.querySelector(`input[id^="planet-distance-"]`);
      const speedInput = planetDiv.querySelector(`input[id^="planet-speed-"]`);
      const ringsInput = planetDiv.querySelector(`input[id^="planet-rings-"]`);
      const speedValue = parseFloat(speedInput.value);
      const orbitSpeed = 1e-3 + (speedValue - 1) * (1e-3 / 9);
      planets.push({
        name: nameInput.value.trim(),
        description: descInput.value.trim(),
        size: parseInt(sizeInput.value),
        distance: parseInt(distanceInput.value),
        speed: orbitSpeed,
        rings: ringsInput.checked
      });
    }
    return { planets, errors };
  }
  addCharacterCounter(textarea, maxChars) {
    if (!textarea || !this.isMobile) return;
    const counter = document.createElement("div");
    counter.className = "char-counter";
    const updateCounter = () => {
      const remaining = maxChars - textarea.value.length;
      counter.textContent = `${remaining} characters remaining`;
      counter.className = "char-counter";
      if (remaining < 30) {
        counter.classList.add("warning");
      }
      if (remaining < 10) {
        counter.classList.add("error");
      }
      if (remaining < 0) {
        textarea.value = textarea.value.substring(0, maxChars);
        counter.textContent = "0 characters remaining";
      }
    };
    textarea.addEventListener("input", updateCounter);
    textarea.addEventListener("keydown", (e) => {
      if (textarea.value.length >= maxChars && e.key !== "Backspace" && e.key !== "Delete" && e.key !== "ArrowLeft" && e.key !== "ArrowRight" && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
      }
    });
    updateCounter();
    textarea.parentNode.insertBefore(counter, textarea.nextSibling);
    textarea.setAttribute("maxlength", maxChars.toString());
  }
  setupCharacterCounters(skyboxDescription, planetDescriptions) {
    if (!this.isMobile) return;
    this.addCharacterCounter(skyboxDescription, 250);
    const firstPlanetDesc = document.getElementById("planet-description-1");
    if (firstPlanetDesc) {
      this.addCharacterCounter(firstPlanetDesc, 150);
    }
  }
  validatePlanetCount(planetInputs) {
    if (planetInputs.length === 0) {
      return { isValid: false, message: "Please add at least one planet to your system." };
    }
    if (planetInputs.length > 8) {
      return { isValid: false, message: "Maximum of 8 planets allowed per system." };
    }
    return { isValid: true };
  }
  showMobileAlert(message, playUISound = null) {
    if (this.isMobile) {
      const alertOverlay = document.createElement("div");
      alertOverlay.style.position = "fixed";
      alertOverlay.style.top = "0";
      alertOverlay.style.left = "0";
      alertOverlay.style.width = "100%";
      alertOverlay.style.height = "100%";
      alertOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
      alertOverlay.style.display = "flex";
      alertOverlay.style.justifyContent = "center";
      alertOverlay.style.alignItems = "center";
      alertOverlay.style.zIndex = "10000";
      const alertBox = document.createElement("div");
      alertBox.style.backgroundColor = "#0a1a2a";
      alertBox.style.color = "#c5d8f1";
      alertBox.style.padding = "20px";
      alertBox.style.borderRadius = "10px";
      alertBox.style.maxWidth = "80%";
      alertBox.style.textAlign = "center";
      alertBox.style.border = "2px solid #2c5a8c";
      const messageEl = document.createElement("p");
      messageEl.textContent = message;
      messageEl.style.marginBottom = "20px";
      messageEl.style.fontSize = "16px";
      const okButton = document.createElement("button");
      okButton.textContent = "OK";
      okButton.style.padding = "12px 30px";
      okButton.style.fontSize = "16px";
      okButton.style.backgroundColor = "#2c5a8c";
      okButton.style.color = "white";
      okButton.style.border = "none";
      okButton.style.borderRadius = "5px";
      okButton.style.minHeight = "48px";
      okButton.style.minWidth = "120px";
      alertBox.appendChild(messageEl);
      alertBox.appendChild(okButton);
      alertOverlay.appendChild(alertBox);
      document.body.appendChild(alertOverlay);
      if (playUISound) {
        playUISound();
      }
      okButton.addEventListener("click", () => {
        document.body.removeChild(alertOverlay);
      });
      okButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        document.body.removeChild(alertOverlay);
        if (playUISound) {
          playUISound();
        }
      });
    } else {
      alert(message);
    }
  }
}
class SystemDataManager {
  constructor() {
    this.starClasses = this.getStarClasses();
    this.planetDefaults = this.getPlanetDefaults();
  }
  getStarClasses() {
    return [
      { value: "O", label: "O - Blue Giant (Hot, Blue)", color: 10203391 },
      { value: "B", label: "B - Blue-White", color: 11190271 },
      { value: "A", label: "A - White", color: 13293567 },
      { value: "F", label: "F - Yellow-White", color: 16316415 },
      { value: "G", label: "G - Yellow (Sun-like)", color: 16774378, selected: true },
      { value: "K", label: "K - Orange", color: 16765601 },
      { value: "M", label: "M - Red Dwarf", color: 16764015 }
    ];
  }
  getPlanetDefaults() {
    return {
      size: { min: 300, max: 1e3, default: 450 },
      distance: { min: 4e3, max: 6e4, default: 8e3 },
      speed: { min: 1, max: 10, default: 5 },
      rings: false
    };
  }
  getStarColorForClass(starClass) {
    const starClassData = this.starClasses.find((sc) => sc.value === starClass);
    return starClassData ? starClassData.color : 16774378;
  }
  createSystemData(systemName, starClass, skyboxUrl, planets, lightIntensityMultiplier = 0.8) {
    return {
      id: `Custom-${Date.now()}`,
      name: systemName,
      starClass,
      classification: "Custom",
      description: `Custom star system with ${planets.length} planets`,
      skyboxUrl,
      lightIntensityMultiplier,
      planetData: planets.map((planet, i) => {
        return {
          name: planet.name,
          textureUrl: planet.textureUrl || null,
          size: planet.size,
          distance: planet.distance,
          speed: planet.speed,
          color: this.getStarColorForClass(starClass),
          rings: planet.rings
        };
      })
    };
  }
  calculatePlanetDistance(planetIndex, baseDistance = 4e3, increment = 6e3) {
    return baseDistance + planetIndex * increment;
  }
  convertSpeedSliderToOrbitSpeed(sliderValue) {
    return 1e-3 + (sliderValue - 1) * (1e-3 / 9);
  }
  getDefaultPlanetData(planetIndex) {
    return {
      name: "",
      description: "",
      size: this.planetDefaults.size.default,
      distance: this.calculatePlanetDistance(planetIndex),
      speed: this.convertSpeedSliderToOrbitSpeed(this.planetDefaults.speed.default),
      rings: this.planetDefaults.rings
    };
  }
  getSystemPresets() {
    return {
      solar: {
        name: "Sol System",
        starClass: "G",
        skyboxDescription: "Deep space with distant stars and nebulae",
        planets: [
          {
            name: "Mercury",
            description: "A small, rocky planet closest to the star",
            size: 350,
            distance: 4e3,
            speed: 2e-3,
            rings: false
          },
          {
            name: "Venus",
            description: "A hot, cloudy planet with a thick atmosphere",
            size: 420,
            distance: 6e3,
            speed: 18e-4,
            rings: false
          },
          {
            name: "Earth",
            description: "A blue planet with oceans and continents",
            size: 450,
            distance: 8e3,
            speed: 15e-4,
            rings: false
          }
        ]
      },
      binary: {
        name: "Binary System",
        starClass: "F",
        skyboxDescription: "A system with twin stars casting complex shadows",
        planets: [
          {
            name: "Proxima",
            description: "A tidally locked world with extreme temperature differences",
            size: 380,
            distance: 12e3,
            speed: 1e-3,
            rings: false
          },
          {
            name: "Gemini Prime",
            description: "A large gas giant with spectacular ring systems",
            size: 800,
            distance: 25e3,
            speed: 8e-4,
            rings: true
          }
        ]
      },
      exotic: {
        name: "Exotic System",
        starClass: "O",
        skyboxDescription: "A violent nebula with intense radiation and stellar phenomena",
        planets: [
          {
            name: "Crystalline",
            description: "A planet of living crystal formations and energy storms",
            size: 600,
            distance: 15e3,
            speed: 12e-4,
            rings: true
          }
        ]
      }
    };
  }
  validateSystemData(systemData) {
    var _a;
    const errors = [];
    if (!systemData.name || systemData.name.trim().length < 3) {
      errors.push("System name must be at least 3 characters long");
    }
    if (!systemData.starClass || !this.starClasses.find((sc) => sc.value === systemData.starClass)) {
      errors.push("Invalid star class selected");
    }
    if (!systemData.planetData || systemData.planetData.length === 0) {
      errors.push("System must have at least one planet");
    }
    if (systemData.planetData && systemData.planetData.length > 8) {
      errors.push("System cannot have more than 8 planets");
    }
    (_a = systemData.planetData) == null ? void 0 : _a.forEach((planet, index) => {
      if (!planet.name || planet.name.trim().length < 2) {
        errors.push(`Planet ${index + 1} name must be at least 2 characters long`);
      }
      if (planet.size < this.planetDefaults.size.min || planet.size > this.planetDefaults.size.max) {
        errors.push(`Planet ${index + 1} size must be between ${this.planetDefaults.size.min} and ${this.planetDefaults.size.max}`);
      }
      if (planet.distance < this.planetDefaults.distance.min || planet.distance > this.planetDefaults.distance.max) {
        errors.push(`Planet ${index + 1} distance must be between ${this.planetDefaults.distance.min} and ${this.planetDefaults.distance.max}`);
      }
    });
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
class FormViewManager {
  constructor(isMobile = false, styleManager = null) {
    this.isMobile = isMobile;
    this.styleManager = styleManager;
    this.scrollTimeout = null;
  }
  createMainContainer() {
    const container = document.createElement("div");
    container.id = "custom-system-creator";
    container.className = "modal-container";
    container.style.display = "none";
    return container;
  }
  createModalContent() {
    var _a;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    return `
            <div class="modal-content" style="${styles.modalContent}">
                <div class="modal-header">
                    <h2>Create New Star System</h2>
                    <button id="close-system-creator" class="close-btn" style="${styles.closeBtn}">&times;</button>
                </div>
                <div class="modal-body" style="${styles.modalBody}">
                    <div id="system-creator-form">
                        ${this.createSystemForm()}
                        ${this.createPlanetSection()}
                        ${this.createFormActions()}
                    </div>
                    ${this.createProgressSection()}
                    ${this.createPreviewSection()}
                </div>
            </div>
        `;
  }
  createSystemForm() {
    var _a, _b;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    return `
            <div class="form-group">
                <label for="system-name">System Name:</label>
                <input type="text" id="system-name" placeholder="Enter a name for your star system" style="${styles.input}">
            </div>
            
            <div class="form-group">
                <label for="skybox-description">Skybox Description:</label>
                <textarea id="skybox-description" rows="${((_b = this.styleManager) == null ? void 0 : _b.getTextareaRows(4)) || 4}" placeholder="Describe the skybox/space environment (e.g., 'A vibrant nebula with blue and purple clouds, dotted with bright stars')" style="${styles.textarea}"></textarea>
            </div>
            
            <div class="form-group">
                <label for="star-class">Star Class:</label>
                <select id="star-class" class="form-control" style="${styles.select}">
                    <option value="O">O - Blue Giant (Hot, Blue)</option>
                    <option value="B">B - Blue-White</option>
                    <option value="A">A - White</option>
                    <option value="F">F - Yellow-White</option>
                    <option value="G" selected>G - Yellow (Sun-like)</option>
                    <option value="K">K - Orange</option>
                    <option value="M">M - Red Dwarf</option>
                </select>
                <p class="help-text">Different star classes affect the lighting and appearance of your system.</p>
            </div>
        `;
  }
  createPlanetSection() {
    var _a;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    return `
            <div id="planet-descriptions">
                <div class="form-group planet-input">
                    ${this.createPlanetForm(1, styles)}
                </div>
            </div>
            
            <button id="add-planet-btn" class="secondary-btn" style="${styles.secondaryBtn}">+ Add Another Planet</button>
        `;
  }
  createPlanetForm(index, styles = {}) {
    var _a;
    return `
            <h3>Planet ${index}</h3>
            <label for="planet-name-${index}">Planet Name:</label>
            <input type="text" id="planet-name-${index}" placeholder="Enter a name for this planet" style="${styles.input}">
            
            <label for="planet-description-${index}">Planet Description:</label>
            <textarea id="planet-description-${index}" rows="${((_a = this.styleManager) == null ? void 0 : _a.getTextareaRows(3)) || 3}" placeholder="Describe the planet (e.g., 'A rocky planet with large oceans and ice caps')" style="${styles.textarea}" maxlength="150"></textarea>
            
            <div class="planet-properties">
                ${this.createPlanetSliders(index, styles)}
                ${this.createPlanetRings(index, styles)}
            </div>
            
            ${index > 1 ? this.createRemoveButton(styles) : ""}
        `;
  }
  createPlanetSliders(index, styles = {}) {
    return `
            <div class="property-row">
                <label for="planet-size-${index}">Size:</label>
                <input type="range" id="planet-size-${index}" min="300" max="1000" value="450" class="slider" style="${styles.slider}">
                <span class="slider-value" id="planet-size-value-${index}">450</span>
            </div>
            
            <div class="property-row">
                <label for="planet-distance-${index}">Distance from Star:</label>
                <input type="range" id="planet-distance-${index}" min="4000" max="60000" value="${4e3 + index * 6e3}" class="slider" style="${styles.slider}">
                <span class="slider-value" id="planet-distance-value-${index}">${4e3 + index * 6e3}</span>
            </div>
            
            <div class="property-row">
                <label for="planet-speed-${index}">Orbit Speed:</label>
                <input type="range" id="planet-speed-${index}" min="1" max="10" value="5" class="slider" style="${styles.slider}">
                <span class="slider-value" id="planet-speed-value-${index}">0.0015</span>
            </div>
        `;
  }
  createPlanetRings(index, styles = {}) {
    return `
            <div class="property-row" style="${styles.checkboxRow}">
                <label for="planet-rings-${index}">Has Rings:</label>
                <input type="checkbox" id="planet-rings-${index}" style="${styles.checkbox}">
            </div>
        `;
  }
  createRemoveButton(styles = {}) {
    const rippleClass = this.isMobile ? "ripple" : "";
    return `<button class="remove-planet-btn danger-btn ${rippleClass}" style="${styles.removeBtn}">Remove</button>`;
  }
  createFormActions() {
    var _a;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    return `
            <div class="form-actions">
                <button id="generate-system-btn" class="primary-btn" style="${styles.primaryBtn}">Generate System</button>
            </div>
        `;
  }
  createProgressSection() {
    return `
            <div id="generation-progress" style="display: none;">
                <h3>Generating your star system...</h3>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <p id="generation-status">Initializing...</p>
            </div>
        `;
  }
  createPreviewSection() {
    var _a;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    return `
            <div id="system-preview" style="display: none;">
                <h3>Preview</h3>
                <div class="preview-container" style="${styles.previewContainer}">
                    <div class="skybox-preview" style="${styles.skyboxPreview}">
                        <h4>Skybox</h4>
                        <img id="skybox-preview-img" src="" alt="Skybox Preview">
                    </div>
                    <div class="planets-preview" id="planets-preview" style="${styles.planetsPreview}">
                        <!-- Planet previews will be added here dynamically -->
                    </div>
                </div>
                <div class="form-actions" style="${styles.formActions}">
                    <button id="travel-to-system-btn" class="primary-btn" style="${styles.primaryBtn}">Travel to System</button>
                    <button id="regenerate-system-btn" class="secondary-btn" style="${styles.secondaryBtn}">Regenerate</button>
                </div>
            </div>
        `;
  }
  addPlanetInput(planetDescriptions, setupSliderListeners, updatePlanetNumbers, playUISound) {
    var _a;
    const planetInputs = planetDescriptions.getElementsByClassName("planet-input");
    const newIndex = planetInputs.length + 1;
    const styles = ((_a = this.styleManager) == null ? void 0 : _a.getMobileStyles()) || {};
    const planetDiv = document.createElement("div");
    planetDiv.className = "form-group planet-input";
    planetDiv.innerHTML = this.createPlanetForm(newIndex, styles);
    planetDescriptions.appendChild(planetDiv);
    setupSliderListeners(newIndex);
    const removeBtn = planetDiv.querySelector(".remove-planet-btn");
    if (removeBtn) {
      this.setupRemoveButton(removeBtn, planetDiv, updatePlanetNumbers, playUISound);
    }
    if (this.isMobile) {
      this.enhanceMobileInteraction(planetDiv);
    }
    this.scrollToNewPlanet(planetDescriptions);
    return planetDiv;
  }
  setupRemoveButton(removeBtn, planetDiv, updatePlanetNumbers, playUISound) {
    const removeHandler = (e) => {
      if (e) e.preventDefault();
      planetDiv.remove();
      updatePlanetNumbers();
      if (playUISound) playUISound();
    };
    removeBtn.addEventListener("click", removeHandler);
    if (this.isMobile) {
      removeBtn.addEventListener("touchend", removeHandler);
    }
  }
  enhanceMobileInteraction(planetDiv) {
    const sliders = planetDiv.querySelectorAll('input[type="range"]');
    sliders.forEach((slider) => {
      slider.addEventListener("touchstart", () => {
        slider.classList.add("slider-active");
      });
      slider.addEventListener("touchend", () => {
        slider.classList.remove("slider-active");
      });
    });
    const planetDesc = planetDiv.querySelector(`textarea[id^="planet-description-"]`);
    if (planetDesc && this.validationManager) {
      this.validationManager.addCharacterCounter(planetDesc, 150);
    }
  }
  scrollToNewPlanet(planetDescriptions) {
    if (!this.isMobile) return;
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    this.scrollTimeout = setTimeout(() => {
      try {
        const modalContent = document.querySelector("#custom-system-creator .modal-content");
        const newPlanet = planetDescriptions.lastElementChild;
        if (modalContent && newPlanet) {
          const planetPos = newPlanet.offsetTop;
          const scrollPos = planetPos - modalContent.clientHeight / 4;
          modalContent.scrollTo({
            top: scrollPos,
            behavior: "smooth"
          });
        }
      } catch (err) {
        console.warn("Error during scroll:", err);
      }
    }, 100);
  }
  updatePlanetNumbers(planetDescriptions) {
    const planetInputs = planetDescriptions.getElementsByClassName("planet-input");
    for (let i = 0; i < planetInputs.length; i++) {
      const planetDiv = planetInputs[i];
      const planetHeader = planetDiv.querySelector("h3");
      if (planetHeader) {
        planetHeader.textContent = `Planet ${i + 1}`;
      }
    }
  }
  addRippleEffect(container) {
    if (!this.isMobile) return;
    const buttons = container.querySelectorAll("button");
    buttons.forEach((button) => {
      if (!button.classList.contains("ripple")) {
        button.classList.add("ripple");
      }
    });
  }
  setupSliderListeners(index) {
    const sizeSlider = document.getElementById(`planet-size-${index}`);
    const sizeValue = document.getElementById(`planet-size-value-${index}`);
    if (sizeSlider && sizeValue) {
      sizeSlider.addEventListener("input", () => {
        sizeValue.textContent = sizeSlider.value;
      });
    }
    const distanceSlider = document.getElementById(`planet-distance-${index}`);
    const distanceValue = document.getElementById(`planet-distance-value-${index}`);
    if (distanceSlider && distanceValue) {
      distanceSlider.addEventListener("input", () => {
        distanceValue.textContent = distanceSlider.value;
      });
    }
    const speedSlider = document.getElementById(`planet-speed-${index}`);
    const speedValue = document.getElementById(`planet-speed-value-${index}`);
    if (speedSlider && speedValue) {
      speedSlider.addEventListener("input", () => {
        const speed = 1e-3 + (speedSlider.value - 1) * (1e-3 / 9);
        speedValue.textContent = speed.toFixed(4);
      });
    }
    if (this.isMobile) {
      const sliders = [sizeSlider, distanceSlider, speedSlider].filter(Boolean);
      sliders.forEach((slider) => {
        slider.addEventListener("touchstart", () => {
          slider.classList.add("slider-active");
        });
        slider.addEventListener("touchend", () => {
          slider.classList.remove("slider-active");
        });
      });
    }
  }
  cleanup() {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
  }
}
class PreviewManager {
  constructor(isMobile = false) {
    this.isMobile = isMobile;
  }
  showSystemPreview(generatedSkyboxUrl, generatedPlanetUrls, apiClient) {
    this.updateSkyboxPreview(generatedSkyboxUrl, apiClient);
    this.updatePlanetPreviews(generatedPlanetUrls, apiClient);
    this.showPreviewUI();
  }
  updateSkyboxPreview(skyboxUrl, apiClient) {
    const skyboxPreviewImg = document.getElementById("skybox-preview-img");
    if (skyboxPreviewImg && skyboxUrl && apiClient) {
      skyboxPreviewImg.src = apiClient.getFullImageUrl(skyboxUrl);
    }
  }
  updatePlanetPreviews(planetUrls, apiClient) {
    const planetsPreview = document.getElementById("planets-preview");
    if (!planetsPreview) return;
    planetsPreview.innerHTML = "";
    if (!planetUrls || !Array.isArray(planetUrls)) return;
    planetUrls.forEach((planet) => {
      const planetDiv = document.createElement("div");
      planetDiv.className = "planet-preview";
      const planetImageSrc = apiClient && planet.url ? apiClient.getFullImageUrl(planet.url) : planet.url || "";
      planetDiv.innerHTML = `
                <h4>${planet.name || "Unknown Planet"}</h4>
                <img src="${planetImageSrc}" alt="${planet.name || "Planet"}" loading="lazy">
            `;
      planetsPreview.appendChild(planetDiv);
    });
  }
  showPreviewUI() {
    const generationProgress = document.getElementById("generation-progress");
    const systemPreview = document.getElementById("system-preview");
    if (generationProgress) {
      generationProgress.style.display = "none";
    }
    if (systemPreview) {
      systemPreview.style.display = "block";
    }
    if (this.isMobile) {
      setTimeout(() => {
        if (systemPreview) {
          systemPreview.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }, 50);
    }
  }
  hidePreview() {
    const systemPreview = document.getElementById("system-preview");
    const systemForm = document.getElementById("system-creator-form");
    if (systemPreview) {
      systemPreview.style.display = "none";
    }
    if (systemForm) {
      systemForm.style.display = "block";
    }
  }
  showProgress(message = "Initializing...") {
    const systemForm = document.getElementById("system-creator-form");
    const generationProgress = document.getElementById("generation-progress");
    const generationStatus = document.getElementById("generation-status");
    if (systemForm) {
      systemForm.style.display = "none";
    }
    if (generationProgress) {
      generationProgress.style.display = "block";
    }
    if (generationStatus) {
      generationStatus.textContent = message;
    }
  }
  hideProgress() {
    const generationProgress = document.getElementById("generation-progress");
    const systemForm = document.getElementById("system-creator-form");
    if (generationProgress) {
      generationProgress.style.display = "none";
    }
    if (systemForm) {
      systemForm.style.display = "block";
    }
  }
  updateGenerationStatus(message) {
    const generationStatus = document.getElementById("generation-status");
    if (generationStatus) {
      generationStatus.textContent = message;
      console.log("Generation status:", message);
    }
  }
  createPlanetPreviewElement(planet, apiClient) {
    const planetDiv = document.createElement("div");
    planetDiv.className = "planet-preview";
    const imageUrl = apiClient && planet.url ? apiClient.getFullImageUrl(planet.url) : planet.url || "";
    const img = document.createElement("img");
    img.src = imageUrl;
    img.alt = planet.name || "Planet";
    img.loading = "lazy";
    img.onerror = () => {
      img.style.display = "none";
      const errorMsg = document.createElement("div");
      errorMsg.className = "image-error";
      errorMsg.textContent = "Image failed to load";
      errorMsg.style.padding = "20px";
      errorMsg.style.textAlign = "center";
      errorMsg.style.color = "#999";
      planetDiv.appendChild(errorMsg);
    };
    const title = document.createElement("h4");
    title.textContent = planet.name || "Unknown Planet";
    planetDiv.appendChild(title);
    planetDiv.appendChild(img);
    return planetDiv;
  }
  clearPreviews() {
    const skyboxPreviewImg = document.getElementById("skybox-preview-img");
    const planetsPreview = document.getElementById("planets-preview");
    if (skyboxPreviewImg) {
      skyboxPreviewImg.src = "";
    }
    if (planetsPreview) {
      planetsPreview.innerHTML = "";
    }
  }
  isPreviewVisible() {
    const systemPreview = document.getElementById("system-preview");
    return systemPreview && systemPreview.style.display !== "none";
  }
  isProgressVisible() {
    const generationProgress = document.getElementById("generation-progress");
    return generationProgress && generationProgress.style.display !== "none";
  }
  resetToForm() {
    this.hidePreview();
    this.hideProgress();
    this.clearPreviews();
  }
}
class EventHandlerManager {
  constructor(customSystemCreator2, isMobile = false) {
    this.customSystemCreator = customSystemCreator2;
    this.isMobile = isMobile;
    this.handlers = /* @__PURE__ */ new Map();
  }
  setupAllEventHandlers(container, elements) {
    this.setupCloseHandlers(elements.closeBtn);
    this.setupFormHandlers(elements);
    this.setupKeyboardHandlers();
    this.setupContainerHandlers(container);
    if (this.isMobile) {
      this.setupMobileHandlers(container, elements);
    }
  }
  setupCloseHandlers(closeBtn) {
    const closeHandler = (e) => {
      if (e) e.preventDefault();
      this.customSystemCreator.hide();
      this.customSystemCreator.playUISound();
    };
    closeBtn.addEventListener("click", closeHandler);
    if (this.isMobile) {
      closeBtn.addEventListener("touchend", closeHandler);
    }
  }
  setupFormHandlers(elements) {
    const addPlanetHandler = (e) => {
      if (e) e.preventDefault();
      this.customSystemCreator.addPlanetInput();
      this.customSystemCreator.playUISound();
    };
    elements.addPlanetBtn.addEventListener("click", addPlanetHandler);
    if (this.isMobile) {
      elements.addPlanetBtn.addEventListener("touchend", addPlanetHandler);
    }
    const generateHandler = (e) => {
      if (e) e.preventDefault();
      this.customSystemCreator.generateSystem();
      this.customSystemCreator.playUISound();
    };
    elements.generateSystemBtn.addEventListener("click", generateHandler);
    if (this.isMobile) {
      elements.generateSystemBtn.addEventListener("touchend", generateHandler);
    }
    const travelHandler = (e) => {
      if (e) e.preventDefault();
      this.customSystemCreator.travelToSystem();
      this.customSystemCreator.playUISound();
    };
    elements.travelToSystemBtn.addEventListener("click", travelHandler);
    if (this.isMobile) {
      elements.travelToSystemBtn.addEventListener("touchend", travelHandler);
    }
    const regenerateHandler = (e) => {
      if (e) e.preventDefault();
      elements.systemPreview.style.display = "none";
      elements.systemForm.style.display = "block";
      this.customSystemCreator.playUISound();
    };
    elements.regenerateSystemBtn.addEventListener("click", regenerateHandler);
    if (this.isMobile) {
      elements.regenerateSystemBtn.addEventListener("touchend", regenerateHandler);
    }
  }
  setupKeyboardHandlers() {
    const escapeHandler = (e) => {
      if (e.key === "Escape" && this.customSystemCreator.isVisible) {
        this.customSystemCreator.hide();
      }
    };
    document.addEventListener("keydown", escapeHandler);
    this.handlers.set("escape", escapeHandler);
  }
  setupContainerHandlers(container) {
    const clickOutsideHandler = (e) => {
      if (e.target === container) {
        this.customSystemCreator.hide();
      }
    };
    container.addEventListener("click", clickOutsideHandler);
    this.handlers.set("clickOutside", clickOutsideHandler);
  }
  setupMobileHandlers(container, elements) {
    const touchCloseHandler = (e) => {
      if (e.target === container) {
        e.preventDefault();
        this.customSystemCreator.hide();
      }
    };
    container.addEventListener("touchstart", touchCloseHandler, { passive: false });
    this.handlers.set("touchClose", touchCloseHandler);
    container.addEventListener("touchmove", (e) => {
      e.stopPropagation();
    }, { passive: true });
    const modalContent = container.querySelector(".modal-content");
    if (modalContent) {
      modalContent.addEventListener("touchstart", () => {
      }, { passive: true });
      modalContent.addEventListener("touchmove", () => {
      }, { passive: true });
    }
    this.setupBodyScrollPrevention();
  }
  setupBodyScrollPrevention() {
    const preventScroll = (e) => {
      if (this.customSystemCreator.isVisible) {
        e.preventDefault();
      }
    };
    document.body.addEventListener("touchmove", preventScroll, { passive: false });
    this.handlers.set("preventScroll", preventScroll);
  }
  setupSliderHandlers(index, formViewManager) {
    if (formViewManager && typeof formViewManager.setupSliderListeners === "function") {
      formViewManager.setupSliderListeners(index);
    }
  }
  setupRemoveButtonHandler(removeBtn, planetDiv, updatePlanetNumbers) {
    const removeHandler = (e) => {
      if (e) e.preventDefault();
      planetDiv.remove();
      updatePlanetNumbers();
      this.customSystemCreator.playUISound();
    };
    removeBtn.addEventListener("click", removeHandler);
    if (this.isMobile) {
      removeBtn.addEventListener("touchend", removeHandler);
      const sliders = planetDiv.querySelectorAll('input[type="range"]');
      sliders.forEach((slider) => {
        slider.addEventListener("touchstart", () => {
          slider.classList.add("slider-active");
        });
        slider.addEventListener("touchend", () => {
          slider.classList.remove("slider-active");
        });
      });
    }
  }
  addDynamicEventHandlers(element, handlers = {}) {
    Object.entries(handlers).forEach(([event, handler]) => {
      if (typeof handler === "function") {
        element.addEventListener(event, handler);
        if (!this.handlers.has(element)) {
          this.handlers.set(element, /* @__PURE__ */ new Map());
        }
        this.handlers.get(element).set(event, handler);
      }
    });
  }
  removeDynamicEventHandlers(element) {
    if (this.handlers.has(element)) {
      const elementHandlers = this.handlers.get(element);
      elementHandlers.forEach((handler, event) => {
        element.removeEventListener(event, handler);
      });
      this.handlers.delete(element);
    }
  }
  cleanup() {
    this.handlers.forEach((handler, key) => {
      if (typeof key === "string") {
        switch (key) {
          case "escape":
            document.removeEventListener("keydown", handler);
            break;
          case "preventScroll":
            document.body.removeEventListener("touchmove", handler);
            break;
        }
      } else if (key instanceof Element) {
        if (handler instanceof Map) {
          handler.forEach((handlerFunc, event) => {
            key.removeEventListener(event, handlerFunc);
          });
        } else {
          key.removeEventListener("click", handler);
          key.removeEventListener("touchend", handler);
          key.removeEventListener("touchstart", handler);
          key.removeEventListener("touchmove", handler);
        }
      }
    });
    this.handlers.clear();
  }
  // Utility method to add mobile-friendly event listeners
  addMobileFriendlyListener(element, eventType, handler, options = {}) {
    const wrappedHandler = (e) => {
      if (this.isMobile && e.type === "touchend") {
        e.preventDefault();
      }
      handler(e);
    };
    element.addEventListener(eventType, wrappedHandler, options);
    if (this.isMobile && eventType === "click") {
      element.addEventListener("touchend", wrappedHandler, options);
    }
    if (!this.handlers.has(element)) {
      this.handlers.set(element, /* @__PURE__ */ new Map());
    }
    this.handlers.get(element).set(eventType, wrappedHandler);
    return wrappedHandler;
  }
  // Method to handle form validation events
  setupValidationHandlers(elements, validationManager) {
    if (!validationManager) return;
    elements.systemNameInput.addEventListener("blur", () => {
      const validation = validationManager.validateSystemForm(
        elements.systemNameInput,
        elements.skyboxDescription
      );
      if (!validation.isValid && elements.systemNameInput.value.trim()) {
        this.showFieldError(elements.systemNameInput, validation.message);
      } else {
        this.clearFieldError(elements.systemNameInput);
      }
    });
    elements.skyboxDescription.addEventListener("blur", () => {
      const validation = validationManager.validateSystemForm(
        elements.systemNameInput,
        elements.skyboxDescription
      );
      if (!validation.isValid && elements.skyboxDescription.value.trim()) {
        this.showFieldError(elements.skyboxDescription, validation.message);
      } else {
        this.clearFieldError(elements.skyboxDescription);
      }
    });
  }
  showFieldError(field, message) {
    this.clearFieldError(field);
    const errorDiv = document.createElement("div");
    errorDiv.className = "field-error";
    errorDiv.textContent = message;
    errorDiv.style.color = "#ff3030";
    errorDiv.style.fontSize = "12px";
    errorDiv.style.marginTop = "5px";
    field.parentNode.insertBefore(errorDiv, field.nextSibling);
    field.style.borderColor = "#ff3030";
  }
  clearFieldError(field) {
    const existingError = field.parentNode.querySelector(".field-error");
    if (existingError) {
      existingError.remove();
    }
    field.style.borderColor = "";
  }
}
class HelperManager {
  constructor() {
    this.scrollTimeout = null;
  }
  detectMobile() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.innerWidth < 900;
  }
  playUISound() {
    if (window.game && window.game.audio) {
      window.game.audio.playSound("boink");
    }
  }
  formatSliderValue(value, type = "default") {
    switch (type) {
      case "speed":
        const speed = 1e-3 + (value - 1) * (1e-3 / 9);
        return speed.toFixed(4);
      case "size":
      case "distance":
        return parseInt(value).toString();
      default:
        return value.toString();
    }
  }
  calculateDefaultDistance(planetIndex, baseDistance = 4e3, increment = 6e3) {
    return baseDistance + planetIndex * increment;
  }
  convertSpeedSliderValue(sliderValue) {
    return 1e-3 + (sliderValue - 1) * (1e-3 / 9);
  }
  cleanupScrolling() {
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = null;
    }
  }
  safeScrollTo(element, options = {}) {
    if (!element) return;
    this.cleanupScrolling();
    this.scrollTimeout = setTimeout(() => {
      try {
        if (typeof element.scrollIntoView === "function") {
          element.scrollIntoView({
            behavior: "smooth",
            block: "start",
            ...options
          });
        }
      } catch (err) {
        console.warn("Error during scroll:", err);
      }
    }, 100);
  }
  generateUniqueId(prefix = "custom") {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  debounce(func, wait, immediate = false) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func(...args);
    };
  }
  throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  sanitizeInput(input, maxLength = null) {
    if (typeof input !== "string") return "";
    let sanitized = input.trim();
    if (maxLength && sanitized.length > maxLength) {
      sanitized = sanitized.substring(0, maxLength);
    }
    return sanitized;
  }
  validateURL(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
  formatFileSize(bytes) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  deepClone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Date) return new Date(obj.getTime());
    if (obj instanceof Array) return obj.map((item) => this.deepClone(item));
    if (typeof obj === "object") {
      const clonedObj = {};
      Object.keys(obj).forEach((key) => {
        clonedObj[key] = this.deepClone(obj[key]);
      });
      return clonedObj;
    }
  }
  createElement(tag, className = "", content = "", attributes = {}) {
    const element = document.createElement(tag);
    if (className) {
      element.className = className;
    }
    if (content) {
      element.textContent = content;
    }
    Object.entries(attributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });
    return element;
  }
  removeElement(element) {
    if (element && element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
  findElementById(id, container = document) {
    return container.getElementById ? container.getElementById(id) : container.querySelector(`#${id}`);
  }
  findElementsByClass(className, container = document) {
    return container.getElementsByClassName ? Array.from(container.getElementsByClassName(className)) : Array.from(container.querySelectorAll(`.${className}`));
  }
  addEventListenerSafe(element, event, handler, options = {}) {
    if (element && typeof element.addEventListener === "function") {
      element.addEventListener(event, handler, options);
      return true;
    }
    return false;
  }
  removeEventListenerSafe(element, event, handler, options = {}) {
    if (element && typeof element.removeEventListener === "function") {
      element.removeEventListener(event, handler, options);
      return true;
    }
    return false;
  }
  getElementDimensions(element) {
    if (!element) return { width: 0, height: 0 };
    const rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height,
      top: rect.top,
      left: rect.left,
      bottom: rect.bottom,
      right: rect.right
    };
  }
  isElementVisible(element) {
    if (!element) return false;
    const style = window.getComputedStyle(element);
    return style.display !== "none" && style.visibility !== "hidden" && style.opacity !== "0";
  }
  scrollToTop(container, smooth = true) {
    if (!container) return;
    if (smooth && container.scrollTo) {
      container.scrollTo({
        top: 0,
        behavior: "smooth"
      });
    } else {
      container.scrollTop = 0;
    }
  }
  addClassSafe(element, className) {
    if (element && element.classList) {
      element.classList.add(className);
    }
  }
  removeClassSafe(element, className) {
    if (element && element.classList) {
      element.classList.remove(className);
    }
  }
  toggleClassSafe(element, className) {
    if (element && element.classList) {
      element.classList.toggle(className);
    }
  }
  hasClassSafe(element, className) {
    return element && element.classList && element.classList.contains(className);
  }
  setStyleSafe(element, property, value) {
    if (element && element.style) {
      element.style[property] = value;
    }
  }
  getStyleSafe(element, property) {
    if (element && element.style) {
      return element.style[property];
    }
    return null;
  }
  forceReflow(element) {
    if (element) {
      void element.offsetHeight;
    }
  }
  waitForElement(selector, timeout = 5e3) {
    return new Promise((resolve, reject) => {
      const element = document.querySelector(selector);
      if (element) {
        resolve(element);
        return;
      }
      const observer = new MutationObserver((mutations, obs) => {
        const element2 = document.querySelector(selector);
        if (element2) {
          obs.disconnect();
          resolve(element2);
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      setTimeout(() => {
        observer.disconnect();
        reject(new Error(`Element ${selector} not found within ${timeout}ms`));
      }, timeout);
    });
  }
  async waitFor(condition, timeout = 5e3, interval = 100) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      if (condition()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Condition not met within timeout");
  }
  cleanup() {
    this.cleanupScrolling();
  }
}
class CustomSystemCreator {
  constructor(starSystemGenerator, environment) {
    this.starSystemGenerator = starSystemGenerator;
    this.environment = environment;
    this.apiClient = new ApiClient();
    this.isVisible = false;
    this.isGenerating = false;
    this.generatedSkyboxUrl = null;
    this.generatedPlanetUrls = [];
    this.systemData = null;
    this.helpers = new HelperManager();
    this.isMobile = this.helpers.detectMobile();
    this.styleManager = new StyleManager(this.isMobile);
    this.validationManager = new ValidationManager(this.isMobile);
    this.systemDataManager = new SystemDataManager();
    this.formViewManager = new FormViewManager(this.isMobile, this.styleManager);
    this.previewManager = new PreviewManager(this.isMobile);
    this.eventHandlerManager = new EventHandlerManager(this, this.isMobile);
    this.createUI();
    this.setupEventHandlers();
    this.setupSliderListeners(1);
  }
  createUI() {
    this.styleManager.injectStyles();
    this.container = this.formViewManager.createMainContainer();
    this.container.innerHTML = this.formViewManager.createModalContent();
    document.body.appendChild(this.container);
    this.captureElementReferences();
    if (this.isMobile) {
      this.setupMobileEnhancements();
    }
  }
  captureElementReferences() {
    this.systemNameInput = document.getElementById("system-name");
    this.skyboxDescription = document.getElementById("skybox-description");
    this.planetDescriptions = document.getElementById("planet-descriptions");
    this.addPlanetBtn = document.getElementById("add-planet-btn");
    this.generateSystemBtn = document.getElementById("generate-system-btn");
    this.generationProgress = document.getElementById("generation-progress");
    this.generationStatus = document.getElementById("generation-status");
    this.systemForm = document.getElementById("system-creator-form");
    this.systemPreview = document.getElementById("system-preview");
    this.skyboxPreviewImg = document.getElementById("skybox-preview-img");
    this.planetsPreview = document.getElementById("planets-preview");
    this.travelToSystemBtn = document.getElementById("travel-to-system-btn");
    this.regenerateSystemBtn = document.getElementById("regenerate-system-btn");
    this.closeBtn = document.getElementById("close-system-creator");
  }
  setupMobileEnhancements() {
    this.formViewManager.addRippleEffect(this.container);
    this.validationManager.setupCharacterCounters(this.skyboxDescription, this.planetDescriptions);
  }
  setupEventHandlers() {
    const elements = {
      closeBtn: this.closeBtn,
      addPlanetBtn: this.addPlanetBtn,
      generateSystemBtn: this.generateSystemBtn,
      travelToSystemBtn: this.travelToSystemBtn,
      regenerateSystemBtn: this.regenerateSystemBtn,
      systemForm: this.systemForm,
      systemPreview: this.systemPreview,
      systemNameInput: this.systemNameInput,
      skyboxDescription: this.skyboxDescription
    };
    this.eventHandlerManager.setupAllEventHandlers(this.container, elements);
    this.eventHandlerManager.setupValidationHandlers(elements, this.validationManager);
  }
  addPlanetInput() {
    const planetDiv = this.formViewManager.addPlanetInput(
      this.planetDescriptions,
      this.setupSliderListeners.bind(this),
      this.updatePlanetNumbers.bind(this),
      this.playUISound.bind(this)
    );
    if (this.isMobile) {
      const planetDesc = planetDiv.querySelector(`textarea[id^="planet-description-"]`);
      if (planetDesc) {
        this.validationManager.addCharacterCounter(planetDesc, 150);
      }
    }
  }
  setupSliderListeners(index) {
    this.formViewManager.setupSliderListeners(index);
  }
  updatePlanetNumbers() {
    this.formViewManager.updatePlanetNumbers(this.planetDescriptions);
  }
  async generateSystem() {
    var _a, _b;
    const systemValidation = this.validationManager.validateSystemForm(
      this.systemNameInput,
      this.skyboxDescription
    );
    if (!systemValidation.isValid) {
      this.validationManager.showMobileAlert(systemValidation.message, this.playUISound.bind(this));
      return;
    }
    const planetInputs = this.planetDescriptions.getElementsByClassName("planet-input");
    const planetValidation = this.validationManager.validatePlanetCount(planetInputs);
    if (!planetValidation.isValid) {
      this.validationManager.showMobileAlert(planetValidation.message, this.playUISound.bind(this));
      return;
    }
    const { planets, errors } = this.validationManager.collectPlanetData(planetInputs);
    if (errors.length > 0) {
      this.validationManager.showMobileAlert(errors[0], this.playUISound.bind(this));
      return;
    }
    this.previewManager.showProgress("Initializing...");
    this.isGenerating = true;
    try {
      if (!this.apiClient.hasValidToken()) {
        this.previewManager.updateGenerationStatus("Authenticating...");
        await this.apiClient.getToken();
      }
      this.previewManager.updateGenerationStatus("Generating skybox...");
      const skyboxResponse = await this.apiClient.generateSkybox(
        this.systemNameInput.value.trim(),
        this.skyboxDescription.value.trim()
      );
      if (!skyboxResponse.success || !((_a = skyboxResponse.image_paths) == null ? void 0 : _a.length)) {
        throw new Error(skyboxResponse.message || "Failed to generate skybox");
      }
      this.generatedSkyboxUrl = skyboxResponse.image_paths[0];
      this.generatedPlanetUrls = [];
      for (let i = 0; i < planets.length; i++) {
        const planet = planets[i];
        this.previewManager.updateGenerationStatus(
          `Generating planet ${i + 1} of ${planets.length}: ${planet.name}...`
        );
        const planetResponse = await this.apiClient.generatePlanet(planet.name, planet.description);
        if (planetResponse.success && ((_b = planetResponse.image_paths) == null ? void 0 : _b.length)) {
          this.generatedPlanetUrls.push({
            name: planet.name,
            url: planetResponse.image_paths[0]
          });
        }
      }
      const starClass = document.getElementById("star-class").value;
      this.systemData = this.systemDataManager.createSystemData(
        this.systemNameInput.value.trim(),
        starClass,
        this.generatedSkyboxUrl,
        planets.map((planet, i) => {
          var _a2;
          return {
            ...planet,
            textureUrl: ((_a2 = this.generatedPlanetUrls[i]) == null ? void 0 : _a2.url) || null
          };
        })
      );
      this.previewManager.showSystemPreview(
        this.generatedSkyboxUrl,
        this.generatedPlanetUrls,
        this.apiClient
      );
    } catch (error) {
      console.error("Error generating system:", error);
      this.validationManager.showMobileAlert(
        `Failed to generate system: ${error.message}`,
        this.playUISound.bind(this)
      );
      this.previewManager.hideProgress();
    }
    this.isGenerating = false;
  }
  travelToSystem() {
    var _a;
    if (!this.systemData) {
      this.validationManager.showMobileAlert(
        "No system data available. Please generate a system first.",
        this.playUISound.bind(this)
      );
      return;
    }
    try {
      const success = this.starSystemGenerator.addCustomSystem(this.systemData);
      if (!success) {
        throw new Error("Failed to add custom system");
      }
      this.hide();
      if ((_a = this.environment) == null ? void 0 : _a.travelToSystem) {
        this.environment.travelToSystem(this.systemData.id);
      } else {
        console.error("Environment or travelToSystem method not available");
      }
    } catch (error) {
      console.error("Error traveling to custom system:", error);
      this.validationManager.showMobileAlert(
        `Failed to travel to custom system: ${error.message}`,
        this.playUISound.bind(this)
      );
    }
  }
  playUISound() {
    this.helpers.playUISound();
  }
  show() {
    if (!this.container) return;
    this.cleanupBeforeHiding();
    this.container.style.display = "flex";
    this.isVisible = true;
    this.previewManager.resetToForm();
    this.playUISound();
    if (this.isMobile) {
      this.setupMobileShow();
    } else {
      this.setupDesktopShow();
    }
  }
  setupMobileShow() {
    const modalContent = this.container.querySelector(".modal-content");
    if (modalContent) {
      this.helpers.scrollToTop(modalContent);
      this.helpers.setStyleSafe(modalContent, "overflowY", "auto");
      this.helpers.setStyleSafe(modalContent, "webkitOverflowScrolling", "touch");
      this.helpers.setStyleSafe(modalContent, "overscrollBehavior", "contain");
    }
    this.helpers.addClassSafe(document.body, "modal-open");
    setTimeout(() => {
      if (this.systemNameInput) {
        this.systemNameInput.focus();
      }
    }, 300);
  }
  setupDesktopShow() {
    setTimeout(() => {
      if (this.systemNameInput) {
        this.systemNameInput.focus();
      }
    }, 300);
  }
  hide() {
    if (!this.container || this.isGenerating) return;
    this.cleanupBeforeHiding();
    this.container.style.display = "none";
    this.isVisible = false;
    this.playUISound();
    setTimeout(() => {
      var _a, _b;
      if ((_b = (_a = window.game) == null ? void 0 : _a.ui) == null ? void 0 : _b.stargateInterface) {
        console.log("CustomSystemCreator: Returning to stargate UI");
        window.game.ui.stargateInterface.showStargateUI();
      } else {
        const stargateUI = document.getElementById("stargate-ui");
        if (stargateUI) {
          stargateUI.style.display = "block";
          console.log("CustomSystemCreator: Showed stargate UI via direct DOM access");
        } else {
          console.warn("CustomSystemCreator: Could not find stargate UI to return to");
        }
      }
    }, 100);
  }
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  cleanupBeforeHiding() {
    if (this.isGenerating) {
      this.isGenerating = false;
      this.previewManager.hideProgress();
    }
    this.helpers.cleanupScrolling();
    this.helpers.setStyleSafe(document.body, "pointerEvents", "auto");
    if (this.isMobile) {
      this.helpers.setStyleSafe(document.body, "touchAction", "auto");
      this.helpers.removeClassSafe(document.body, "modal-open");
      this.helpers.forceReflow(this.container);
    }
  }
  destroy() {
    var _a;
    this.cleanupBeforeHiding();
    this.eventHandlerManager.cleanup();
    this.styleManager.cleanup();
    this.helpers.cleanup();
    this.formViewManager.cleanup();
    if ((_a = this.container) == null ? void 0 : _a.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }
}
const customSystemCreator = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CustomSystemCreator
}, Symbol.toStringTag, { value: "Module" }));
class VibeVersePortals {
  constructor(scene, spaceship) {
    this.scene = scene;
    this.spaceship = spaceship;
    this.startPortalGroup = null;
    this.exitPortalGroup = null;
    this.startPortalBox = null;
    this.exitPortalBox = null;
    this.startPortalParticleSystem = null;
    this.exitPortalParticleSystem = null;
    this.shouldCreateStartPortal = new URLSearchParams(window.location.search).has("portal");
    this.refUrl = new URLSearchParams(window.location.search).get("ref") || "";
    this.init();
  }
  init() {
    if (this.shouldCreateStartPortal) {
      this.createStartPortal();
    }
  }
  createStartPortal() {
    this.startPortalGroup = new Group();
    this.startPortalGroup.name = "startPortal";
    const ringGeometry = new TorusGeometry(150, 15, 32, 100);
    const ringMaterial = new MeshStandardMaterial({
      color: 16711680,
      emissive: 16711680,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.7
    });
    const ring = new Mesh(ringGeometry, ringMaterial);
    this.startPortalGroup.add(ring);
    const surfaceGeometry = new CircleGeometry(135, 32);
    const surfaceMaterial = new MeshBasicMaterial({
      color: 16711680,
      transparent: true,
      opacity: 0.3,
      side: DoubleSide
    });
    const surface = new Mesh(surfaceGeometry, surfaceMaterial);
    surface.position.z = 0.1;
    this.startPortalGroup.add(surface);
    const particleCount = 500;
    const particleGeometry = new BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const angle = i / particleCount * Math.PI * 2;
      const radius = 135 + (Math.random() * 30 - 15);
      positions[i * 3] = Math.cos(angle) * radius;
      positions[i * 3 + 1] = Math.sin(angle) * radius;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
    }
    particleGeometry.setAttribute("position", new BufferAttribute(positions, 3));
    const particleMaterial = new PointsMaterial({
      color: 16733525,
      size: 3.5,
      // Increased particle size
      blending: AdditiveBlending,
      transparent: true
    });
    this.startPortalParticleSystem = new Points(particleGeometry, particleMaterial);
    this.startPortalGroup.add(this.startPortalParticleSystem);
    this.startPortalGroup.position.set(0, 15e3, 0);
    this.startPortalGroup.rotation.x = Math.PI / 2;
    this.scene.add(this.startPortalGroup);
    this.startPortalBox = new Box3().setFromObject(this.startPortalGroup);
    console.log("Start portal created at position:", this.startPortalGroup.position);
  }
  createExitPortal() {
    this.exitPortalGroup = new Group();
    this.exitPortalGroup.name = "exitPortal";
    const ringGeometry = new TorusGeometry(150, 15, 32, 100);
    const ringMaterial = new MeshStandardMaterial({
      color: 65280,
      emissive: 65280,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.7
    });
    const ring = new Mesh(ringGeometry, ringMaterial);
    this.exitPortalGroup.add(ring);
    const surfaceGeometry = new CircleGeometry(135, 32);
    const surfaceMaterial = new MeshBasicMaterial({
      color: 65280,
      transparent: true,
      opacity: 0.3,
      side: DoubleSide
    });
    const surface = new Mesh(surfaceGeometry, surfaceMaterial);
    surface.position.z = 0.1;
    this.exitPortalGroup.add(surface);
    const particleCount = 500;
    const particleGeometry = new BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      const angle = i / particleCount * Math.PI * 2;
      const radius = 135 + (Math.random() * 30 - 15);
      positions[i * 3] = Math.cos(angle) * radius;
      positions[i * 3 + 1] = Math.sin(angle) * radius;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
    }
    particleGeometry.setAttribute("position", new BufferAttribute(positions, 3));
    const particleMaterial = new PointsMaterial({
      color: 5635925,
      size: 3.5,
      // Increased particle size
      blending: AdditiveBlending,
      transparent: true
    });
    this.exitPortalParticleSystem = new Points(particleGeometry, particleMaterial);
    this.exitPortalGroup.add(this.exitPortalParticleSystem);
    const canvas = document.createElement("canvas");
    canvas.width = 1024;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = "72px Arial";
    ctx.fillStyle = "#00ff00";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("VIBEVERSE PORTAL", canvas.width / 2, canvas.height / 2);
    const texture = new CanvasTexture(canvas);
    const labelGeometry = new PlaneGeometry(200, 50);
    const labelMaterial = new MeshBasicMaterial({
      map: texture,
      transparent: true,
      side: DoubleSide
    });
    const label = new Mesh(labelGeometry, labelMaterial);
    label.position.set(0, 200, 0);
    this.exitPortalGroup.add(label);
    this.exitPortalGroup.position.set(0, 16e3, 0);
    this.exitPortalGroup.rotation.x = Math.PI / 2;
    this.scene.add(this.exitPortalGroup);
    this.exitPortalBox = new Box3().setFromObject(this.exitPortalGroup);
    console.log("Exit portal created at position:", this.exitPortalGroup.position);
  }
  animateStartPortal(deltaTime) {
    if (!this.startPortalGroup || !this.startPortalParticleSystem) return;
    this.startPortalParticleSystem.rotation.z += deltaTime * 0.5;
    if (Math.random() < 0.05) {
      this.startPortalBox.setFromObject(this.startPortalGroup);
    }
  }
  animateExitPortal(deltaTime) {
    if (!this.exitPortalGroup || !this.exitPortalParticleSystem) return;
    this.exitPortalParticleSystem.rotation.z += deltaTime * 0.5;
    if (Math.random() < 0.05) {
      this.exitPortalBox.setFromObject(this.exitPortalGroup);
    }
  }
  checkPortalInteractions(deltaTime) {
    if (!this.spaceship || !this.spaceship.mesh) return;
    const shipBox = new Box3().setFromObject(this.spaceship.mesh);
    if (this.startPortalGroup && this.startPortalBox) {
      const distance = this.spaceship.mesh.position.distanceTo(this.startPortalGroup.position);
      if (distance < 400) {
        if (shipBox.intersectsBox(this.startPortalBox)) {
          this.handleStartPortalEntry();
        }
      }
    }
  }
  handleStartPortalEntry() {
    if (this._isRedirecting) return;
    this._isRedirecting = true;
    console.log("Player entered start portal");
    let targetUrl = this.refUrl;
    if (targetUrl && !targetUrl.startsWith("http")) {
      targetUrl = "https://" + targetUrl;
    }
    if (!targetUrl) {
      console.error("No target URL specified for portal");
      this._isRedirecting = false;
      return;
    }
    const currentParams = new URLSearchParams(window.location.search);
    currentParams.delete("ref");
    currentParams.delete("portal");
    let finalUrl;
    try {
      finalUrl = new URL(targetUrl);
      for (const [key, value] of currentParams.entries()) {
        finalUrl.searchParams.append(key, value);
      }
    } catch (e) {
      console.error("Invalid target URL:", targetUrl);
      this._isRedirecting = false;
      return;
    }
    console.log("Redirecting to:", finalUrl.toString());
    setTimeout(() => {
      window.location.href = finalUrl.toString();
    }, 100);
  }
  handleExitPortalEntry() {
    if (this._isRedirecting) return;
    this._isRedirecting = true;
    console.log("Player entered exit portal");
    let nextPage = "https://portal.pieter.com";
    const currentParams = new URLSearchParams(window.location.search);
    const url = new URL(nextPage);
    url.searchParams.append("portal", "true");
    url.searchParams.append("username", this.getUsername());
    url.searchParams.append("color", "white");
    url.searchParams.append("speed", this.getPlayerSpeed());
    for (const [key, value] of currentParams.entries()) {
      if (!["portal", "username", "color", "speed"].includes(key)) {
        url.searchParams.append(key, value);
      }
    }
    console.log("Redirecting to:", url.toString());
    setTimeout(() => {
      window.location.href = url.toString();
    }, 100);
  }
  getUsername() {
    if (window.game && window.game.selfUsername) {
      return window.game.selfUsername;
    }
    return `Miner${Math.floor(Math.random() * 1e4)}`;
  }
  getPlayerSpeed() {
    if (window.game && window.game.currentSpeed) {
      return window.game.currentSpeed.toString();
    }
    if (this.spaceship && this.spaceship.velocity) {
      return this.spaceship.velocity.length().toString();
    }
    return "10";
  }
  update(deltaTime) {
    this.animateStartPortal(deltaTime);
    this.checkPortalInteractions(deltaTime);
  }
  dispose() {
    if (this.startPortalGroup) {
      this.scene.remove(this.startPortalGroup);
    }
    if (this.exitPortalGroup) {
      this.scene.remove(this.exitPortalGroup);
    }
    this.startPortalGroup = null;
    this.exitPortalGroup = null;
    this.startPortalBox = null;
    this.exitPortalBox = null;
    this.startPortalParticleSystem = null;
    this.exitPortalParticleSystem = null;
  }
}
const vibeVersePortals = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VibeVersePortals
}, Symbol.toStringTag, { value: "Module" }));
class VortexAnomaly {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
  }
  create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyGroup = new Group();
    anomalyGroup.position.copy(position);
    anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);
    const ringCount = 6;
    const rings = [];
    for (let i = 0; i < ringCount; i++) {
      const radius = 400 - i * 50;
      const geometry = new TorusGeometry(radius, 15, 16, 100);
      const hue = 0.5 + i * 0.05;
      const color = new Color().setHSL(hue, 0.9, 0.6);
      const material = new MeshStandardMaterial({
        color,
        emissive: color.clone().multiplyScalar(0.5),
        emissiveIntensity: 1,
        metalness: 0.8,
        roughness: 0.2,
        transparent: true,
        opacity: 0.95
      });
      const ring = new Mesh(geometry, material);
      ring.rotation.x = Math.PI / 2 + i * 0.2;
      ring.rotation.y = i * 0.3;
      anomalyGroup.add(ring);
      rings.push({
        mesh: ring,
        rotationSpeed: {
          x: 5e-3 + i * 2e-3,
          y: 3e-3 + i * 1e-3,
          z: 1e-3 + i * 5e-4
        }
      });
    }
    const orbRarity = getRandomOrbRarityCallback();
    const orb = createEnergyOrbCallback(orbRarity);
    anomalyGroup.add(orb.mesh);
    addToSceneCallback(anomalyGroup);
    return {
      type: "vortex",
      mesh: anomalyGroup,
      position: position.clone(),
      rings,
      orb,
      collisionRadius: 350,
      // Overall collision size
      orbCollected: false,
      rotationSpeed: new Vector3(1e-3, 2e-3, 15e-4)
    };
  }
  update(anomaly, deltaTime) {
    anomaly.rings.forEach((ring) => {
      ring.mesh.rotation.x += ring.rotationSpeed.x * deltaTime;
      ring.mesh.rotation.y += ring.rotationSpeed.y * deltaTime;
      ring.mesh.rotation.z += ring.rotationSpeed.z * deltaTime;
    });
  }
  cleanup(anomaly) {
    if (anomaly.rings) {
      anomaly.rings.forEach((ring) => {
        if (ring.mesh && ring.mesh.geometry) {
          ring.mesh.geometry.dispose();
        }
        if (ring.mesh && ring.mesh.material) {
          if (Array.isArray(ring.mesh.material)) {
            ring.mesh.material.forEach((m) => m.dispose());
          } else {
            ring.mesh.material.dispose();
          }
        }
      });
    }
  }
}
class CrystalClusterAnomaly {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
  }
  create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyGroup = new Group();
    anomalyGroup.position.copy(position);
    anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);
    const crystals = [];
    const crystalCount = 20;
    for (let i = 0; i < crystalCount; i++) {
      const size = 50 + Math.random() * 100;
      let geometry;
      const crystalType = Math.floor(Math.random() * 3);
      if (crystalType === 0) {
        geometry = new OctahedronGeometry(size, 0);
      } else if (crystalType === 1) {
        geometry = new DodecahedronGeometry(size, 0);
      } else {
        geometry = new TetrahedronGeometry(size, 0);
        const positions = geometry.attributes.position;
        for (let j = 0; j < positions.count; j++) {
          const vertex = new Vector3();
          vertex.fromBufferAttribute(positions, j);
          vertex.y *= 2.5;
          positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
        }
        geometry.computeVertexNormals();
      }
      const hue = 0.45 + Math.random() * 0.1;
      const saturation = 0.9 + Math.random() * 0.1;
      const lightness = 0.6 + Math.random() * 0.2;
      const color = new Color().setHSL(hue, saturation, lightness);
      const material = new MeshStandardMaterial({
        color,
        metalness: 0.9,
        roughness: 0.1,
        transparent: true,
        opacity: 0.9,
        emissive: color.clone(),
        emissiveIntensity: 0.5
      });
      const crystal = new Mesh(geometry, material);
      const radius = 200 + Math.random() * 100;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      crystal.position.set(
        radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.sin(phi) * Math.sin(theta),
        radius * Math.cos(phi)
      );
      crystal.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
      anomalyGroup.add(crystal);
      crystals.push({
        mesh: crystal,
        initialPosition: crystal.position.clone(),
        floatPhase: Math.random() * Math.PI * 2,
        floatSpeed: 0.3 + Math.random() * 0.3,
        floatAmplitude: 5 + Math.random() * 10,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.01,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.01
        }
      });
    }
    const orbRarity = getRandomOrbRarityCallback();
    const orb = createEnergyOrbCallback(orbRarity);
    anomalyGroup.add(orb.mesh);
    addToSceneCallback(anomalyGroup);
    return {
      type: "crystalCluster",
      mesh: anomalyGroup,
      position: position.clone(),
      crystals,
      orb,
      collisionRadius: 300,
      // Overall collision size
      orbCollected: false,
      rotationSpeed: new Vector3(5e-4, 1e-3, 5e-4)
    };
  }
  update(anomaly, deltaTime) {
    anomaly.crystals.forEach((crystal) => {
      crystal.floatPhase += deltaTime * crystal.floatSpeed;
      const floatOffset = Math.sin(crystal.floatPhase) * crystal.floatAmplitude;
      crystal.mesh.position.y = crystal.initialPosition.y + floatOffset;
      crystal.mesh.rotation.x += crystal.rotationSpeed.x;
      crystal.mesh.rotation.y += crystal.rotationSpeed.y;
      crystal.mesh.rotation.z += crystal.rotationSpeed.z;
    });
  }
  cleanup(anomaly) {
    if (anomaly.crystals) {
      anomaly.crystals.forEach((crystal) => {
        if (crystal.mesh && crystal.mesh.geometry) {
          crystal.mesh.geometry.dispose();
        }
        if (crystal.mesh && crystal.mesh.material) {
          if (Array.isArray(crystal.mesh.material)) {
            crystal.mesh.material.forEach((m) => m.dispose());
          } else {
            crystal.mesh.material.dispose();
          }
        }
      });
    }
  }
}
class NebulaNexusAnomaly {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
  }
  create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyGroup = new Group();
    anomalyGroup.position.copy(position);
    anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);
    const ringCount = 3;
    const rings = [];
    for (let i = 0; i < ringCount; i++) {
      const ringRadius = 200 + i * 60;
      const ringGeometry = new TorusGeometry(ringRadius, 8, 16, 50);
      const ringHue = 0.6 + i * 0.1;
      const ringColor = new Color().setHSL(ringHue, 1, 0.6);
      const ringMaterial = new MeshStandardMaterial({
        color: ringColor,
        emissive: ringColor.clone().multiplyScalar(0.5),
        emissiveIntensity: 1,
        metalness: 0.9,
        roughness: 0.1,
        transparent: false,
        opacity: 1
      });
      const ring = new Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2 + i * Math.PI / 3;
      ring.rotation.y = i * Math.PI / 4;
      anomalyGroup.add(ring);
      const crystalCount = 10 + i * 5;
      const crystals = [];
      for (let j = 0; j < crystalCount; j++) {
        const angle = j / crystalCount * Math.PI * 2;
        const crystalSize = 15 + Math.random() * 10;
        const crystalGeometry = new OctahedronGeometry(crystalSize, 0);
        const crystalHue = (ringHue + 0.5) % 1;
        const crystalColor = new Color().setHSL(crystalHue, 1, 0.7);
        const crystalMaterial = new MeshStandardMaterial({
          color: crystalColor,
          emissive: crystalColor.clone(),
          emissiveIntensity: 0.8,
          metalness: 0.9,
          roughness: 0.1,
          transparent: false,
          opacity: 1
        });
        const crystal = new Mesh(crystalGeometry, crystalMaterial);
        crystal.position.x = ringRadius * Math.cos(angle);
        crystal.position.y = 0;
        crystal.position.z = ringRadius * Math.sin(angle);
        crystal.rotation.x = Math.random() * Math.PI;
        crystal.rotation.y = Math.random() * Math.PI;
        crystal.rotation.z = Math.random() * Math.PI;
        ring.add(crystal);
        crystals.push({
          mesh: crystal,
          initialPosition: crystal.position.clone(),
          pulsePhase: Math.random() * Math.PI * 2,
          pulseSpeed: 0.5 + Math.random() * 0.5
        });
      }
      rings.push({
        mesh: ring,
        crystals,
        rotationSpeed: 0.1 - i * 0.03,
        // Outer rings rotate slower
        rotationAxis: new Vector3(
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ).normalize()
      });
    }
    const coreRadius = 80;
    const coreGeometry = new SphereGeometry(coreRadius, 32, 32);
    const coreColor = new Color().setHSL(0.15, 1, 0.6);
    const coreMaterial = new MeshStandardMaterial({
      color: coreColor,
      emissive: coreColor,
      emissiveIntensity: 1,
      metalness: 1,
      roughness: 0.3,
      transparent: true,
      opacity: 0.9
    });
    const core = new Mesh(coreGeometry, coreMaterial);
    anomalyGroup.add(core);
    const arcCount = 8;
    const arcs = [];
    for (let i = 0; i < arcCount; i++) {
      const curve = new CubicBezierCurve3(
        new Vector3(0, 0, 0),
        new Vector3(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        ),
        new Vector3(
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300
        ),
        new Vector3(
          (Math.random() - 0.5) * 400,
          (Math.random() - 0.5) * 400,
          (Math.random() - 0.5) * 400
        )
      );
      const points = curve.getPoints(20);
      const arcGeometry = new BufferGeometry().setFromPoints(points);
      const arcColor = new Color().setHSL(0.15, 1, 0.6);
      const arcMaterial = new LineBasicMaterial({
        color: arcColor,
        linewidth: 3,
        transparent: true,
        opacity: 0.8
      });
      const arc = new Line(arcGeometry, arcMaterial);
      anomalyGroup.add(arc);
      arcs.push({
        mesh: arc,
        curve,
        updatePhase: Math.random() * Math.PI * 2,
        updateSpeed: 0.2 + Math.random() * 0.3
      });
    }
    const orbRarity = getRandomOrbRarityCallback();
    const orb = createEnergyOrbCallback(orbRarity);
    anomalyGroup.add(orb.mesh);
    addToSceneCallback(anomalyGroup);
    return {
      type: "nebulaNexus",
      mesh: anomalyGroup,
      position: position.clone(),
      rings,
      core: {
        mesh: core,
        pulsePhase: 0,
        pulseSpeed: 0.5
      },
      arcs,
      orb,
      collisionRadius: 250,
      orbCollected: false,
      rotationSpeed: new Vector3(3e-4, 4e-4, 2e-4)
    };
  }
  update(anomaly, deltaTime) {
    anomaly.core.pulsePhase += deltaTime * anomaly.core.pulseSpeed;
    const scale = 1 + 0.2 * Math.sin(anomaly.core.pulsePhase);
    anomaly.core.mesh.scale.set(scale, scale, scale);
    anomaly.rings.forEach((ring) => {
      const rotationMatrix = new Matrix4().makeRotationAxis(
        ring.rotationAxis,
        ring.rotationSpeed * deltaTime
      );
      ring.mesh.applyMatrix4(rotationMatrix);
      ring.crystals.forEach((crystal) => {
        crystal.pulsePhase += deltaTime * crystal.pulseSpeed;
        const crystalScale = 1 + 0.3 * Math.sin(crystal.pulsePhase);
        crystal.mesh.scale.set(crystalScale, crystalScale, crystalScale);
      });
    });
    anomaly.arcs.forEach((arc) => {
      arc.updatePhase += deltaTime * arc.updateSpeed;
      const controlPoint1 = arc.curve.v1;
      const controlPoint2 = arc.curve.v2;
      controlPoint1.x = Math.sin(arc.updatePhase) * 200;
      controlPoint1.y = Math.cos(arc.updatePhase * 0.7) * 200;
      controlPoint1.z = Math.sin(arc.updatePhase * 1.3) * 200;
      controlPoint2.x = Math.sin(arc.updatePhase * 0.8 + 1) * 300;
      controlPoint2.y = Math.cos(arc.updatePhase * 1.2 + 2) * 300;
      controlPoint2.z = Math.sin(arc.updatePhase * 0.9 + 3) * 300;
      const points = arc.curve.getPoints(20);
      arc.mesh.geometry.setFromPoints(points);
      arc.mesh.geometry.attributes.position.needsUpdate = true;
    });
  }
  cleanup(anomaly) {
    if (anomaly.rings) {
      anomaly.rings.forEach((ring) => {
        if (ring.mesh && ring.mesh.geometry) {
          ring.mesh.geometry.dispose();
        }
        if (ring.mesh && ring.mesh.material) {
          if (Array.isArray(ring.mesh.material)) {
            ring.mesh.material.forEach((m) => m.dispose());
          } else {
            ring.mesh.material.dispose();
          }
        }
      });
    }
    if (anomaly.core && anomaly.core.mesh) {
      if (anomaly.core.mesh.geometry) anomaly.core.mesh.geometry.dispose();
      if (anomaly.core.mesh.material) {
        if (Array.isArray(anomaly.core.mesh.material)) {
          anomaly.core.mesh.material.forEach((m) => m.dispose());
        } else {
          anomaly.core.mesh.material.dispose();
        }
      }
    }
    if (anomaly.arcs) {
      anomaly.arcs.forEach((arc) => {
        if (arc.mesh && arc.mesh.geometry) {
          arc.mesh.geometry.dispose();
        }
        if (arc.mesh && arc.mesh.material) {
          if (Array.isArray(arc.mesh.material)) {
            arc.mesh.material.forEach((m) => m.dispose());
          } else {
            arc.mesh.material.dispose();
          }
        }
      });
    }
  }
}
class QuantumFluxAnomaly {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
  }
  create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyGroup = new Group();
    anomalyGroup.position.copy(position);
    anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);
    const frames = [];
    const frameCount = 5;
    for (let i = 0; i < frameCount; i++) {
      const size = 250 - i * 40;
      const geometry = new BoxGeometry(size, size, size);
      const innerGeometry = new BoxGeometry(size * 0.98, size * 0.98, size * 0.98);
      const edges = new EdgesGeometry(geometry);
      const hue = 0.3 + i * 0.1;
      const color = new Color().setHSL(hue, 1, 0.6);
      const material = new LineBasicMaterial({
        color,
        linewidth: 2,
        transparent: false,
        // Changed to non-transparent for better visibility
        opacity: 1
      });
      const innerMaterial = new MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.1,
        side: DoubleSide
      });
      const frame = new LineSegments(edges, material);
      const innerBox = new Mesh(innerGeometry, innerMaterial);
      anomalyGroup.add(frame);
      anomalyGroup.add(innerBox);
      frames.push({
        mesh: frame,
        innerBox,
        rotationAxis: new Vector3(
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ).normalize(),
        rotationSpeed: 0.01 + i * 5e-3,
        pulsePhase: Math.random() * Math.PI * 2
      });
    }
    const particleCount = 200;
    const particleGeometry = new BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const radius = 100 * Math.random();
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      particlePositions[i3 + 2] = radius * Math.cos(phi);
      particleSizes[i] = 2 + Math.random() * 3;
    }
    particleGeometry.setAttribute("position", new BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute("size", new BufferAttribute(particleSizes, 1));
    const particleMaterial = new PointsMaterial({
      color: 16711935,
      // Magenta
      size: 6,
      blending: AdditiveBlending,
      transparent: true,
      opacity: 0.9
    });
    const particles = new Points(particleGeometry, particleMaterial);
    anomalyGroup.add(particles);
    const orbRarity = getRandomOrbRarityCallback();
    const orb = createEnergyOrbCallback(orbRarity);
    anomalyGroup.add(orb.mesh);
    addToSceneCallback(anomalyGroup);
    return {
      type: "quantumFlux",
      mesh: anomalyGroup,
      position: position.clone(),
      frames,
      particles: {
        mesh: particles,
        positions: particlePositions,
        initialPositions: particlePositions.slice(),
        // Clone for reference
        velocities: Array(particleCount).fill().map(() => new Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ))
      },
      orb,
      collisionRadius: 230,
      // Overall collision size
      orbCollected: false,
      rotationSpeed: new Vector3(1e-4, 2e-4, 1e-4)
    };
  }
  update(anomaly, deltaTime) {
    anomaly.frames.forEach((frame) => {
      const rotationMatrix = new Matrix4().makeRotationAxis(
        frame.rotationAxis,
        frame.rotationSpeed * deltaTime
      );
      frame.mesh.applyMatrix4(rotationMatrix);
      if (frame.innerBox) {
        frame.innerBox.applyMatrix4(rotationMatrix);
      }
      frame.pulsePhase += deltaTime;
      const pulseScale = 1 + 0.05 * Math.sin(frame.pulsePhase);
      frame.mesh.scale.set(pulseScale, pulseScale, pulseScale);
      if (frame.innerBox) {
        frame.innerBox.scale.set(pulseScale, pulseScale, pulseScale);
      }
    });
    const positions = anomaly.particles.positions;
    const velocities = anomaly.particles.velocities;
    for (let i = 0; i < positions.length / 3; i++) {
      const i3 = i * 3;
      positions[i3] += velocities[i].x;
      positions[i3 + 1] += velocities[i].y;
      positions[i3 + 2] += velocities[i].z;
      const maxDist = 120;
      const pos = new Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
      if (pos.length() > maxDist) {
        pos.normalize().multiplyScalar(maxDist);
        positions[i3] = pos.x;
        positions[i3 + 1] = pos.y;
        positions[i3 + 2] = pos.z;
        velocities[i].reflect(pos.normalize());
      }
    }
    anomaly.particles.mesh.geometry.attributes.position.needsUpdate = true;
  }
  cleanup(anomaly) {
    if (anomaly.frames) {
      anomaly.frames.forEach((frame) => {
        if (frame.mesh && frame.mesh.geometry) {
          frame.mesh.geometry.dispose();
        }
        if (frame.mesh && frame.mesh.material) {
          if (Array.isArray(frame.mesh.material)) {
            frame.mesh.material.forEach((m) => m.dispose());
          } else {
            frame.mesh.material.dispose();
          }
        }
        if (frame.innerBox) {
          if (frame.innerBox.geometry) frame.innerBox.geometry.dispose();
          if (frame.innerBox.material) {
            if (Array.isArray(frame.innerBox.material)) {
              frame.innerBox.material.forEach((m) => m.dispose());
            } else {
              frame.innerBox.material.dispose();
            }
          }
        }
      });
    }
    if (anomaly.particles && anomaly.particles.mesh) {
      if (anomaly.particles.mesh.geometry) anomaly.particles.mesh.geometry.dispose();
      if (anomaly.particles.mesh.material) {
        if (Array.isArray(anomaly.particles.mesh.material)) {
          anomaly.particles.mesh.material.forEach((m) => m.dispose());
        } else {
          anomaly.particles.mesh.material.dispose();
        }
      }
    }
  }
}
class DarkMatterAnomaly {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
  }
  create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyGroup = new Group();
    anomalyGroup.position.copy(position);
    anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);
    const coreRadius = 100;
    const coreGeometry = new SphereGeometry(coreRadius, 32, 32);
    const coreMaterial = new MeshStandardMaterial({
      color: 3342387,
      emissive: 8913032,
      emissiveIntensity: 1.5,
      metalness: 1,
      roughness: 0,
      transparent: true,
      opacity: 0.95
    });
    const core = new Mesh(coreGeometry, coreMaterial);
    const glowGeometry = new SphereGeometry(coreRadius * 1.2, 32, 32);
    const glowMaterial = new MeshBasicMaterial({
      color: 10027263,
      transparent: true,
      opacity: 0.3,
      side: BackSide
    });
    const glow = new Mesh(glowGeometry, glowMaterial);
    core.add(glow);
    anomalyGroup.add(core);
    const rings = [];
    const ringCount = 4;
    for (let i = 0; i < ringCount; i++) {
      const radius = 150 + i * 60;
      const tubeRadius = 4 + i * 2;
      const geometry = new TorusGeometry(radius, tubeRadius, 16, 100);
      const color = new Color().setHSL(0.75, 0.9, 0.1 + i * 0.15);
      const material = new MeshStandardMaterial({
        color,
        emissive: color.clone().multiplyScalar(0.7),
        emissiveIntensity: 0.5 + i * 0.2,
        metalness: 0.8,
        roughness: 0.2,
        transparent: true,
        opacity: 0.85
      });
      const ring = new Mesh(geometry, material);
      ring.rotation.x = Math.random() * Math.PI;
      ring.rotation.y = Math.random() * Math.PI;
      ring.rotation.z = Math.random() * Math.PI;
      anomalyGroup.add(ring);
      rings.push({
        mesh: ring,
        rotationAxis: new Vector3(
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ).normalize(),
        rotationSpeed: 2e-3 + i * 1e-3,
        warpPhase: Math.random() * Math.PI * 2,
        warpSpeed: 0.5 + Math.random() * 0.5
      });
    }
    const particleCount = 300;
    const particleGeometry = new BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const radius = 120 + Math.random() * 250;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      particlePositions[i3 + 2] = radius * Math.cos(phi);
      particleSizes[i] = 1 + Math.random() * 3;
    }
    particleGeometry.setAttribute("position", new BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute("size", new BufferAttribute(particleSizes, 1));
    const particleMaterial = new PointsMaterial({
      color: 8913151,
      size: 5,
      blending: AdditiveBlending,
      transparent: true,
      opacity: 0.8
    });
    const particles = new Points(particleGeometry, particleMaterial);
    anomalyGroup.add(particles);
    const orbRarity = getRandomOrbRarityCallback();
    const orb = createEnergyOrbCallback(orbRarity);
    anomalyGroup.add(orb.mesh);
    addToSceneCallback(anomalyGroup);
    return {
      type: "darkMatter",
      mesh: anomalyGroup,
      position: position.clone(),
      core: {
        mesh: core,
        pulsePhase: 0
      },
      rings,
      particles: {
        mesh: particles,
        positions: particlePositions,
        initialPositions: particlePositions.slice(),
        phases: Array(particleCount).fill().map(() => Math.random() * Math.PI * 2)
      },
      orb,
      collisionRadius: 200,
      // Overall collision size
      orbCollected: false,
      rotationSpeed: new Vector3(2e-4, 3e-4, 1e-4)
    };
  }
  update(anomaly, deltaTime) {
    anomaly.core.pulsePhase += deltaTime * 0.5;
    const corePulse = 1 + 0.1 * Math.sin(anomaly.core.pulsePhase);
    anomaly.core.mesh.scale.set(corePulse, corePulse, corePulse);
    anomaly.rings.forEach((ring) => {
      const rotationMatrix = new Matrix4().makeRotationAxis(
        ring.rotationAxis,
        ring.rotationSpeed * deltaTime
      );
      ring.mesh.applyMatrix4(rotationMatrix);
      ring.warpPhase += deltaTime * ring.warpSpeed;
      const warpX = 1 + 0.1 * Math.sin(ring.warpPhase);
      const warpY = 1 + 0.1 * Math.sin(ring.warpPhase + Math.PI / 3);
      const warpZ = 1 + 0.1 * Math.sin(ring.warpPhase + Math.PI * 2 / 3);
      ring.mesh.scale.set(warpX, warpY, warpZ);
    });
    const positions = anomaly.particles.positions;
    const initialPositions = anomaly.particles.initialPositions;
    const phases = anomaly.particles.phases;
    for (let i = 0; i < positions.length / 3; i++) {
      const i3 = i * 3;
      phases[i] += deltaTime;
      const dist = Math.sqrt(
        initialPositions[i3] * initialPositions[i3] + initialPositions[i3 + 1] * initialPositions[i3 + 1] + initialPositions[i3 + 2] * initialPositions[i3 + 2]
      );
      const orbitSpeed = 0.5 + 300 / (dist + 10);
      phases[i] += deltaTime * orbitSpeed;
      const radialPulse = 1 + 0.2 * Math.sin(phases[i] * 0.5);
      const pos = new Vector3(
        initialPositions[i3],
        initialPositions[i3 + 1],
        initialPositions[i3 + 2]
      );
      const rotY = phases[i] * 0.2;
      const rotZ = phases[i] * 0.1;
      pos.applyAxisAngle(new Vector3(0, 1, 0), rotY);
      pos.applyAxisAngle(new Vector3(0, 0, 1), rotZ);
      pos.multiplyScalar(radialPulse);
      positions[i3] = pos.x;
      positions[i3 + 1] = pos.y;
      positions[i3 + 2] = pos.z;
    }
    anomaly.particles.mesh.geometry.attributes.position.needsUpdate = true;
  }
  cleanup(anomaly) {
    if (anomaly.core && anomaly.core.mesh) {
      if (anomaly.core.mesh.geometry) anomaly.core.mesh.geometry.dispose();
      if (anomaly.core.mesh.material) {
        if (Array.isArray(anomaly.core.mesh.material)) {
          anomaly.core.mesh.material.forEach((m) => m.dispose());
        } else {
          anomaly.core.mesh.material.dispose();
        }
      }
    }
    if (anomaly.rings) {
      anomaly.rings.forEach((ring) => {
        if (ring.mesh && ring.mesh.geometry) {
          ring.mesh.geometry.dispose();
        }
        if (ring.mesh && ring.mesh.material) {
          if (Array.isArray(ring.mesh.material)) {
            ring.mesh.material.forEach((m) => m.dispose());
          } else {
            ring.mesh.material.dispose();
          }
        }
      });
    }
    if (anomaly.particles && anomaly.particles.mesh) {
      if (anomaly.particles.mesh.geometry) anomaly.particles.mesh.geometry.dispose();
      if (anomaly.particles.mesh.material) {
        if (Array.isArray(anomaly.particles.mesh.material)) {
          anomaly.particles.mesh.material.forEach((m) => m.dispose());
        } else {
          anomaly.particles.mesh.material.dispose();
        }
      }
    }
  }
}
class AnomalyRegistry {
  constructor(scene, anomalyScale = 4, orbScale = 4) {
    this.scene = scene;
    this.anomalyScale = anomalyScale;
    this.orbScale = orbScale;
    this.anomalyTypes = {
      "vortex": new VortexAnomaly(scene, anomalyScale, orbScale),
      "crystalCluster": new CrystalClusterAnomaly(scene, anomalyScale, orbScale),
      "nebulaNexus": new NebulaNexusAnomaly(scene, anomalyScale, orbScale),
      "quantumFlux": new QuantumFluxAnomaly(scene, anomalyScale, orbScale),
      "darkMatter": new DarkMatterAnomaly(scene, anomalyScale, orbScale)
    };
  }
  /**
   * Create an anomaly of the specified type
   * @param {string} type - The type of anomaly to create
   * @param {THREE.Vector3} position - Position where the anomaly should be created
   * @param {Function} createEnergyOrbCallback - Callback to create energy orbs
   * @param {Function} getRandomOrbRarityCallback - Callback to get random orb rarity
   * @param {Function} addToSceneCallback - Callback to add objects to the scene
   * @returns {Object} The created anomaly data
   */
  createAnomaly(type, position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback) {
    const anomalyClass = this.anomalyTypes[type];
    if (!anomalyClass) {
      throw new Error(`Unknown anomaly type: ${type}`);
    }
    return anomalyClass.create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback);
  }
  /**
   * Update an anomaly of the specified type
   * @param {Object} anomaly - The anomaly to update
   * @param {number} deltaTime - Time since last update
   */
  updateAnomaly(anomaly, deltaTime) {
    const anomalyClass = this.anomalyTypes[anomaly.type];
    if (anomalyClass && typeof anomalyClass.update === "function") {
      anomalyClass.update(anomaly, deltaTime);
    }
  }
  /**
   * Clean up an anomaly of the specified type
   * @param {Object} anomaly - The anomaly to clean up
   */
  cleanupAnomaly(anomaly) {
    const anomalyClass = this.anomalyTypes[anomaly.type];
    if (anomalyClass && typeof anomalyClass.cleanup === "function") {
      anomalyClass.cleanup(anomaly);
    }
  }
  /**
   * Get all available anomaly type names
   * @returns {string[]} Array of anomaly type names
   */
  getAvailableTypes() {
    return Object.keys(this.anomalyTypes);
  }
  /**
   * Check if an anomaly type is supported
   * @param {string} type - The anomaly type to check
   * @returns {boolean} True if the type is supported
   */
  isTypeSupported(type) {
    return type in this.anomalyTypes;
  }
}
class SpaceAnomalies {
  constructor(scene) {
    this.scene = scene;
    this.anomalies = [];
    this.minRadius = 32e3;
    this.maxRadius = 45e3;
    this.width = 3e3;
    this.anomalyScale = 4;
    this.orbScale = 4;
    this.orbValues = {
      common: 100,
      // Green orb - 100 credits
      uncommon: 500,
      // Blue orb - 500 credits
      rare: 1500,
      // Purple orb - 1500 credits
      epic: 5e3,
      // Orange orb - 5000 credits
      legendary: 15e3
      // Red orb - 15000 credits
    };
    this.spawnTimer = 0;
    this.checkInterval = 60;
    this.spawnChance = 0.5;
    this.despawnChance = 0.3;
    this.anomalyRegistry = new AnomalyRegistry(scene, this.anomalyScale, this.orbScale);
    this.anomalyTypes = this.anomalyRegistry.getAvailableTypes();
    this.maxAnomalies = 5;
    this.updateAnomalyCountDisplay();
  }
  // --- Renderer facade helpers ---
  _getRenderer() {
    return window.game && window.game.renderer ? window.game.renderer : null;
  }
  _addToScene(object) {
    const renderer = this._getRenderer();
    if (renderer && typeof renderer._withGuard === "function") {
      renderer._withGuard(() => renderer.add(object));
    } else if (this.scene && typeof this.scene.add === "function") {
      this.scene.add(object);
    }
  }
  _removeFromScene(object) {
    const renderer = this._getRenderer();
    if (!object) return;
    if (renderer && typeof renderer._withGuard === "function") {
      renderer._withGuard(() => this.scene.remove(object));
    } else if (this.scene && typeof this.scene.remove === "function") {
      this.scene.remove(object);
    }
  }
  // Method to check and potentially spawn/despawn anomalies
  checkAnomalySpawning(deltaTime) {
    this.spawnTimer += deltaTime;
    if (this.spawnTimer >= this.checkInterval) {
      this.spawnTimer -= this.checkInterval;
      if (this.anomalies.length < this.maxAnomalies && Math.random() < this.spawnChance) {
        const availableTypes = this.anomalyTypes.filter(
          (type) => !this.anomalies.some((anomaly) => anomaly.type === type)
        );
        if (availableTypes.length > 0) {
          const typeToSpawn = availableTypes[Math.floor(Math.random() * availableTypes.length)];
          this.spawnAnomaly(typeToSpawn);
          this.updateAnomalyCountDisplay();
        }
      }
      const anomaliesToRemove = [];
      this.anomalies.forEach((anomaly) => {
        if (Math.random() < this.despawnChance) {
          anomaliesToRemove.push(anomaly);
        }
      });
      if (anomaliesToRemove.length > 0) {
        anomaliesToRemove.forEach((anomaly) => {
          this.despawnAnomaly(anomaly);
        });
        this.updateAnomalyCountDisplay();
      }
    }
  }
  // Spawn a specific type of anomaly
  spawnAnomaly(type) {
    console.log(`Spawning ${type} anomaly`);
    if (!this.anomalyRegistry.isTypeSupported(type)) {
      console.error(`Unknown anomaly type: ${type}`);
      return;
    }
    const position = this.getRandomAnomalyPosition();
    const anomaly = this.anomalyRegistry.createAnomaly(
      type,
      position,
      (rarity) => this.createEnergyOrb(rarity),
      () => this.getRandomOrbRarity(),
      (object) => this._addToScene(object)
    );
    this.anomalies.push(anomaly);
  }
  // Despawn and cleanup a specific anomaly
  despawnAnomaly(anomaly) {
    console.log(`Despawning ${anomaly.type} anomaly`);
    this._removeFromScene(anomaly.mesh);
    this.anomalyRegistry.cleanupAnomaly(anomaly);
    if (anomaly.orb && anomaly.orb.mesh) {
      if (anomaly.orb.mesh.geometry) anomaly.orb.mesh.geometry.dispose();
      if (anomaly.orb.mesh.material) {
        if (Array.isArray(anomaly.orb.mesh.material)) {
          anomaly.orb.mesh.material.forEach((m) => m.dispose());
        } else {
          anomaly.orb.mesh.material.dispose();
        }
      }
    }
    const index = this.anomalies.indexOf(anomaly);
    if (index !== -1) {
      this.anomalies.splice(index, 1);
    }
  }
  // Update HUD to show active anomaly count
  updateAnomalyCountDisplay() {
    const anomalyCountEl = document.getElementById("anomaly-count");
    if (anomalyCountEl) {
      anomalyCountEl.textContent = this.anomalies.length.toString();
    }
  }
  // Get the number of active anomalies
  getActiveAnomalyCount() {
    return this.anomalies.length;
  }
  // Modified update method to include anomaly spawning/despawning checks
  update(deltaTime) {
    this.checkAnomalySpawning(deltaTime);
    let playerPosition = null;
    if (window.game && window.game.spaceship && window.game.spaceship.mesh) {
      playerPosition = window.game.spaceship.mesh.position;
    }
    for (let i = 0; i < this.anomalies.length; i++) {
      const anomaly = this.anomalies[i];
      if (anomaly.orbCollected) {
        if (anomaly.mesh && anomaly.rotationSpeed) {
          anomaly.mesh.rotation.x += anomaly.rotationSpeed.x * deltaTime;
          anomaly.mesh.rotation.y += anomaly.rotationSpeed.y * deltaTime;
          anomaly.mesh.rotation.z += anomaly.rotationSpeed.z * deltaTime;
        }
        continue;
      }
      let playerNearby = false;
      if (playerPosition) {
        const distance = playerPosition.distanceTo(anomaly.position);
        playerNearby = distance < anomaly.orb.size * 3 * this.orbScale;
      }
      if (anomaly.mesh && anomaly.rotationSpeed) {
        anomaly.mesh.rotation.x += anomaly.rotationSpeed.x * deltaTime;
        anomaly.mesh.rotation.y += anomaly.rotationSpeed.y * deltaTime;
        anomaly.mesh.rotation.z += anomaly.rotationSpeed.z * deltaTime;
      }
      this.anomalyRegistry.updateAnomaly(anomaly, deltaTime);
      this.updateOrbEffects(anomaly, playerNearby);
    }
  }
  createEnergyOrb(rarity) {
    let color, size, intensity, pulseSpeed;
    switch (rarity) {
      case "legendary":
        color = new Color(16711680);
        size = 30 * this.orbScale;
        intensity = 0.9;
        pulseSpeed = 2;
        break;
      case "epic":
        color = new Color(16737792);
        size = 25 * this.orbScale;
        intensity = 0.8;
        pulseSpeed = 1.8;
        break;
      case "rare":
        color = new Color(10027263);
        size = 22 * this.orbScale;
        intensity = 0.7;
        pulseSpeed = 1.5;
        break;
      case "uncommon":
        color = new Color(26367);
        size = 20 * this.orbScale;
        intensity = 0.6;
        pulseSpeed = 1.2;
        break;
      default:
        color = new Color(65382);
        size = 18 * this.orbScale;
        intensity = 0.5;
        pulseSpeed = 1;
        break;
    }
    const orbGeometry = new SphereGeometry(size, 32, 32);
    const orbMaterial = new MeshStandardMaterial({
      color,
      emissive: color,
      emissiveIntensity: intensity,
      metalness: 0.8,
      roughness: 0.2,
      transparent: true,
      opacity: 0.9
    });
    const orb = new Mesh(orbGeometry, orbMaterial);
    const glowSize = size * 1.5;
    const glowGeometry = new SphereGeometry(glowSize, 32, 32);
    const glowMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.3,
      side: BackSide,
      blending: AdditiveBlending
    });
    const glow = new Mesh(glowGeometry, glowMaterial);
    orb.add(glow);
    return {
      mesh: orb,
      rarity,
      value: this.orbValues[rarity],
      size,
      color,
      pulsePhase: 0,
      pulseSpeed,
      glow
    };
  }
  getRandomAnomalyPosition() {
    const angle = Math.random() * Math.PI * 2;
    const radius = this.minRadius + Math.random() * (this.maxRadius - this.minRadius);
    const heightVariation = (Math.random() - 0.5) * this.width;
    return new Vector3(
      Math.cos(angle) * radius,
      heightVariation,
      Math.sin(angle) * radius
    );
  }
  getRandomOrbRarity() {
    const roll = Math.random();
    if (roll < 5e-3) {
      return "legendary";
    } else if (roll < 0.025) {
      return "epic";
    } else if (roll < 0.1) {
      return "rare";
    } else if (roll < 0.3) {
      return "uncommon";
    } else {
      return "common";
    }
  }
  getRegionInfo() {
    return {
      center: new Vector3(0, 0, 0),
      innerRadius: this.minRadius,
      outerRadius: this.maxRadius
    };
  }
  findClosestAnomaly(position, maxDistance = 8e3) {
    let closestAnomaly = null;
    let closestDistance = maxDistance;
    this.anomalies.forEach((anomaly) => {
      const distance = position.distanceTo(anomaly.position);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestAnomaly = anomaly;
      }
    });
    return closestAnomaly;
  }
  collectOrb(anomaly) {
    if (!anomaly || anomaly.orbCollected) {
      return null;
    }
    const orbData = {
      rarity: anomaly.orb.rarity,
      value: this.orbValues[anomaly.orb.rarity] || 100
      // Default to 100 if rarity not found
    };
    anomaly.orbCollected = true;
    if (anomaly.orb && anomaly.orb.mesh) {
      anomaly.orb.mesh.visible = false;
      if (anomaly.orb.glow) {
        anomaly.orb.glow.visible = false;
      }
    }
    return orbData;
  }
  checkCollision(position, anomaly) {
    if (!position || !anomaly || !anomaly.position) return false;
    const distance = position.distanceTo(anomaly.position);
    return distance < anomaly.orb.size * 2 * this.orbScale;
  }
  updateOrbEffects(anomaly, playerNearby) {
    if (!anomaly || !anomaly.orb || anomaly.orbCollected) return;
    if (playerNearby) {
      const scale = 1.5 + Math.sin(performance.now() * 5e-3) * 0.5;
      anomaly.orb.mesh.scale.set(scale, scale, scale);
      if (anomaly.orb.mesh.material) {
        anomaly.orb.mesh.material.emissiveIntensity = 2;
      }
    } else {
      const scale = 1 + Math.sin(performance.now() * 2e-3) * 0.2;
      anomaly.orb.mesh.scale.set(scale, scale, scale);
      if (anomaly.orb.mesh.material) {
        anomaly.orb.mesh.material.emissiveIntensity = 0.8;
      }
    }
  }
  updateForSystem(systemData) {
    console.log("Updating space anomalies for new star system");
    this.clearAllAnomalies();
    this.spawnTimer = this.checkInterval;
    this.updateAnomalyCountDisplay();
  }
  clearAllAnomalies() {
    const anomaliesToRemove = [...this.anomalies];
    anomaliesToRemove.forEach((anomaly) => {
      this.despawnAnomaly(anomaly);
    });
    this.anomalies = [];
    this.updateAnomalyCountDisplay();
  }
}
const spaceAnomalies = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SpaceAnomalies
}, Symbol.toStringTag, { value: "Module" }));
class Environment {
  constructor(scene) {
    this.scene = scene;
    this.componentsLoaded = false;
    this.sceneInitializer = new SceneInitializer(scene);
    this.regionManager = new RegionManager();
    this.transitionManager = new SystemTransitionManager();
    const essentialComponents = this.sceneInitializer.initializeEssentialComponents();
    Object.assign(this, essentialComponents);
    this.asteroids = [];
    this.currentSystemId = this.transitionManager.getCurrentSystemId();
    this.regionManager.setupInitialRegions(this.sun, this.stargate, this.planets);
    setTimeout(async () => {
      const remainingComponents = await this.sceneInitializer.loadRemainingComponents();
      Object.assign(this, remainingComponents);
      if (this.asteroidBelt) {
        this.asteroids = this.asteroidBelt.getAsteroids();
      }
      this.componentsLoaded = true;
    }, 500);
  }
  // Called after spaceship is created - we need this to initialize portals
  async setSpaceship(spaceship) {
    this.spaceship = spaceship;
    this.vibeVersePortals = await this.sceneInitializer.initializePortals(spaceship);
  }
  // Travel to a new star system
  travelToSystem(systemId) {
    return this.transitionManager.travelToSystem(
      systemId,
      this.starSystemGenerator,
      this.systemTransition,
      (systemId2) => this.updateEnvironmentForSystem(systemId2)
    );
  }
  // Update environment visuals and properties for the new system
  updateEnvironmentForSystem(systemId) {
    this.transitionManager.updateEnvironmentForSystem(
      systemId,
      this.starSystemGenerator,
      this.skybox,
      this.sun,
      this.planets,
      this.asteroidBelt,
      this.spaceAnomalies,
      this.regionManager
    );
    this.currentSystemId = this.transitionManager.getCurrentSystemId();
  }
  // Get the player's current location based on position
  getPlayerLocation(playerPosition) {
    return this.regionManager.getPlayerLocation(
      playerPosition,
      this.spaceAnomalies,
      this.asteroids,
      this.componentsLoaded
    );
  }
  // Get planet regions for external access
  getPlanetRegions() {
    return this.regionManager.getPlanetRegions();
  }
  // Find the closest asteroid to a position
  findClosestAsteroid(position, maxDistance) {
    if (this.componentsLoaded && this.asteroidBelt && this.asteroidBelt.findClosestAsteroid) {
      return this.asteroidBelt.findClosestAsteroid(position, maxDistance);
    }
    return null;
  }
  // Find the closest space anomaly
  findClosestAnomaly(position, maxDistance) {
    if (this.componentsLoaded && this.spaceAnomalies && this.spaceAnomalies.findClosestAnomaly) {
      return this.spaceAnomalies.findClosestAnomaly(position, maxDistance);
    }
    return null;
  }
  // Check if position collides with any anomaly
  checkAnomalyCollision(position) {
    if (!this.componentsLoaded || !this.spaceAnomalies) return null;
    const closestAnomaly = this.spaceAnomalies.findClosestAnomaly(position, 8e3);
    if (closestAnomaly && this.spaceAnomalies.checkCollision(position, closestAnomaly)) {
      return closestAnomaly;
    }
    return null;
  }
  // Collect energy orb from anomaly
  collectAnomalyOrb(anomaly) {
    if (this.componentsLoaded && this.spaceAnomalies && this.spaceAnomalies.collectOrb) {
      return this.spaceAnomalies.collectOrb(anomaly);
    }
  }
  update(deltaTime = 0.016, camera) {
    if (this.skybox && typeof this.skybox.update === "function") {
      this.skybox.update(deltaTime);
    }
    if (this.sun && typeof this.sun.update === "function") {
      this.sun.update(deltaTime);
    }
    if (this.planets && typeof this.planets.update === "function") {
      this.planets.update(deltaTime);
    }
    if (this.systemTransition && typeof this.systemTransition.update === "function") {
      this.systemTransition.update(deltaTime);
    }
    if (this.componentsLoaded) {
      if (this.asteroidBelt && typeof this.asteroidBelt.update === "function") {
        this.asteroidBelt.update(deltaTime);
      }
      if (this.stargate && typeof this.stargate.update === "function") {
        this.stargate.update(deltaTime);
      }
      if (this.spaceAnomalies && typeof this.spaceAnomalies.update === "function") {
        this.spaceAnomalies.update(deltaTime, camera);
      }
      if (this.vibeVersePortals && typeof this.vibeVersePortals.update === "function") {
        this.vibeVersePortals.update(deltaTime);
      }
    }
  }
  dispose() {
    if (this.sceneInitializer) {
      this.sceneInitializer.dispose();
    }
  }
}
class InputHandler {
  constructor(spaceship, physics) {
    this.spaceship = spaceship;
    this.physics = physics;
    this.isPointerLocked = false;
    this.mouseSensitivity = 1e-3;
    this.setupKeyboardControls();
    this.setupPointerLock();
  }
  setupKeyboardControls() {
    document.addEventListener("keydown", (e) => {
      if (this.spaceship.isDocked || window.game && window.game.introSequenceActive) return;
      switch (e.key.toLowerCase()) {
        case "w":
          window.inputIntent = (window.inputIntent || 0) | 1;
          break;
        case "s":
          window.inputIntent = (window.inputIntent || 0) | 2;
          break;
        case "a":
          window.inputIntent = (window.inputIntent || 0) | 4;
          break;
        case "d":
          window.inputIntent = (window.inputIntent || 0) | 8;
          break;
        case "shift":
          window.inputIntent = (window.inputIntent || 0) | 16;
          break;
      }
    });
    document.addEventListener("keyup", (e) => {
      if (window.game && window.game.introSequenceActive) {
        this.spaceship.thrust.forward = false;
        this.spaceship.thrust.backward = false;
        this.spaceship.thrust.right = false;
        this.spaceship.thrust.left = false;
        this.spaceship.thrust.boost = false;
        return;
      }
      const clearBit = (bit) => {
        window.inputIntent = (window.inputIntent || 0) & ~bit;
      };
      switch (e.key.toLowerCase()) {
        case "w":
          clearBit(1);
          break;
        case "s":
          clearBit(2);
          break;
        case "a":
          clearBit(4);
          break;
        case "d":
          clearBit(8);
          break;
        case "shift":
          clearBit(16);
          break;
      }
    });
  }
  setupPointerLock() {
    const canvas = document.querySelector("canvas");
    canvas.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      if (!this.isPointerLocked && !this.spaceship.isDocked) {
        canvas.requestPointerLock();
      }
    });
    document.addEventListener("pointerlockchange", () => {
      if (document.pointerLockElement === canvas) {
        this.isPointerLocked = true;
        document.addEventListener("pointermove", this.handlePointerMove.bind(this));
      } else {
        this.isPointerLocked = false;
        document.removeEventListener("pointermove", this.handlePointerMove.bind(this));
      }
    });
    const instructionsElement = document.createElement("div");
    instructionsElement.id = "pointer-lock-instructions";
    instructionsElement.innerHTML = `
            Click on the game to enable mouse rotation
        `;
    instructionsElement.style.position = "absolute";
    instructionsElement.style.top = "60px";
    instructionsElement.style.left = "50%";
    instructionsElement.style.transform = "translateX(-50%)";
    instructionsElement.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    instructionsElement.style.padding = "10px 20px";
    instructionsElement.style.borderRadius = "20px";
    instructionsElement.style.border = "1px solid #30cfd0";
    instructionsElement.style.boxShadow = "0 0 10px #30cfd0";
    instructionsElement.style.color = "#fff";
    instructionsElement.style.fontFamily = "Courier New, monospace";
    instructionsElement.style.zIndex = "999";
    instructionsElement.style.textAlign = "center";
    document.body.appendChild(instructionsElement);
    document.addEventListener("pointerlockchange", () => {
      instructionsElement.style.display = document.pointerLockElement ? "none" : "block";
    });
  }
  handlePointerMove(e) {
    if (window.game && window.game.introSequenceActive) return;
    if (!this.isPointerLocked) return;
    const movementX = e.movementX || 0;
    const movementY = e.movementY || 0;
    this.physics.updateRotation(
      movementX * this.mouseSensitivity,
      movementY * this.mouseSensitivity
    );
  }
  isLocked() {
    return this.isPointerLocked;
  }
  exitPointerLock() {
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  }
}
class GamepadHandler {
  constructor(spaceship, physics, controls) {
    this.spaceship = spaceship;
    this.physics = physics;
    this.controls = controls;
    this.gamepads = {};
    this.activeGamepadIndex = null;
    this.enabled = true;
    this.vibrationEnabled = true;
    this.deadZone = 0.15;
    this.triggerDeadZone = 0.15;
    this.lookSensitivity = 1;
    this.movementSensitivity = 1;
    this.rotationSmoothing = {
      targetX: 0,
      targetY: 0,
      currentX: 0,
      currentY: 0,
      smoothingFactor: 0.15
      // Lower = smoother, higher = more responsive
    };
    this.buttonMap = {
      // Face buttons
      A: 0,
      // Jump/Accept
      B: 1,
      // Cancel/Back
      X: 2,
      // Reload/Interact
      Y: 3,
      // Switch weapon
      // Bumpers and triggers
      LB: 4,
      // Previous target
      RB: 5,
      // Next target
      LT: 6,
      // Mining laser
      RT: 7,
      // Fire weapon
      // Special buttons
      BACK: 8,
      // Menu/Settings
      START: 9,
      // Pause
      L3: 10,
      // Left stick click - boost
      R3: 11,
      // Right stick click - toggle targeting
      // D-Pad
      DPAD_UP: 12,
      // Deploy turret
      DPAD_DOWN: 13,
      // Deploy shield
      DPAD_LEFT: 14,
      // Previous weapon
      DPAD_RIGHT: 15
      // Next weapon
    };
    this.axisMap = {
      LEFT_STICK_X: 0,
      // Strafe left/right
      LEFT_STICK_Y: 1,
      // Move forward/backward
      RIGHT_STICK_X: 2,
      // Look left/right (yaw)
      RIGHT_STICK_Y: 3,
      // Look up/down (pitch)
      LT: 4,
      // Left trigger (some controllers)
      RT: 5
      // Right trigger (some controllers)
    };
    this.buttonStates = {};
    this.previousButtonStates = {};
    this.wasFiring = false;
    this.init();
    this.debugMode = false;
    this.debugDisplay = null;
  }
  init() {
    if (!("getGamepads" in navigator)) {
      console.warn("Gamepad API not supported in this browser");
      return;
    }
    window.addEventListener("gamepadconnected", (e) => {
      console.log(`Gamepad connected: ${e.gamepad.id} (index: ${e.gamepad.index})`);
      this.onGamepadConnected(e.gamepad);
    });
    window.addEventListener("gamepaddisconnected", (e) => {
      console.log(`Gamepad disconnected: ${e.gamepad.id} (index: ${e.gamepad.index})`);
      this.onGamepadDisconnected(e.gamepad);
    });
    this.scanForGamepads();
    console.log("Gamepad handler initialized - ready for controller input");
  }
  scanForGamepads() {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
      if (gamepads[i]) {
        this.onGamepadConnected(gamepads[i]);
      }
    }
  }
  onGamepadConnected(gamepad) {
    this.gamepads[gamepad.index] = gamepad;
    if (this.activeGamepadIndex === null) {
      this.activeGamepadIndex = gamepad.index;
      this.showNotification(`Controller connected: ${this.getGamepadName(gamepad)}`);
      this.vibrate(0.3, 200);
    }
  }
  onGamepadDisconnected(gamepad) {
    delete this.gamepads[gamepad.index];
    if (this.activeGamepadIndex === gamepad.index) {
      this.activeGamepadIndex = null;
      this.showNotification("Controller disconnected");
      for (let index in this.gamepads) {
        this.activeGamepadIndex = parseInt(index);
        this.showNotification(`Switched to controller: ${this.getGamepadName(this.gamepads[index])}`);
        break;
      }
    }
  }
  getGamepadName(gamepad) {
    const name = gamepad.id.toLowerCase();
    if (name.includes("xbox")) return "Xbox Controller";
    if (name.includes("playstation") || name.includes("dualshock")) return "PlayStation Controller";
    if (name.includes("switch") || name.includes("pro controller")) return "Switch Pro Controller";
    return "Generic Controller";
  }
  update(deltaTime) {
    if (!this.enabled || this.activeGamepadIndex === null) return;
    const gamepads = navigator.getGamepads();
    const gamepad = gamepads[this.activeGamepadIndex];
    if (!gamepad) return;
    if (this.debugMode) {
      this.updateDebugDisplay(gamepad);
    }
    if (window.game && window.game.introSequenceActive || this.spaceship.isDocked) {
      this.resetControls();
      return;
    }
    this.previousButtonStates = { ...this.buttonStates };
    gamepad.buttons.forEach((button, index) => {
      this.buttonStates[index] = button.pressed;
    });
    this.handleMovement(gamepad);
    this.handleCameraLook(gamepad, deltaTime);
    this.handleButtons(gamepad);
    this.handleTriggers(gamepad);
  }
  handleMovement(gamepad) {
    const leftX = this.applyDeadZone(gamepad.axes[this.axisMap.LEFT_STICK_X]);
    const leftY = this.applyDeadZone(gamepad.axes[this.axisMap.LEFT_STICK_Y]);
    this.spaceship.thrust.forward = false;
    this.spaceship.thrust.backward = false;
    this.spaceship.thrust.left = false;
    this.spaceship.thrust.right = false;
    if (leftY < -0.1) {
      this.spaceship.thrust.forward = true;
      this.spaceship.thrustPower = Math.abs(leftY);
    } else if (leftY > 0.1) {
      this.spaceship.thrust.backward = true;
      this.spaceship.thrustPower = Math.abs(leftY);
    }
    if (leftX < -0.1) {
      this.spaceship.thrust.right = true;
      this.spaceship.strafePower = Math.abs(leftX);
    } else if (leftX > 0.1) {
      this.spaceship.thrust.left = true;
      this.spaceship.strafePower = Math.abs(leftX);
    }
    if (gamepad.buttons[this.buttonMap.L3].pressed) {
      this.spaceship.thrust.boost = true;
    } else {
      this.spaceship.thrust.boost = false;
    }
  }
  handleCameraLook(gamepad, deltaTime) {
    const rightStickX = this.applyDeadZone(gamepad.axes[3] || 0);
    const rightStickY = this.applyDeadZone(gamepad.axes[4] || 0);
    const applyCurve = (value) => {
      const sign = Math.sign(value);
      const abs = Math.abs(value);
      if (abs < 0.5) {
        return sign * abs * abs * 2;
      } else {
        return sign * (abs * 0.5 + 0.25);
      }
    };
    const curvedX = applyCurve(rightStickX);
    const curvedY = applyCurve(rightStickY);
    const baseSpeed = 15e-4;
    this.rotationSmoothing.targetX = curvedX * baseSpeed * this.lookSensitivity * 60;
    this.rotationSmoothing.targetY = curvedY * baseSpeed * this.lookSensitivity * 60;
    const smoothing = this.rotationSmoothing.smoothingFactor;
    this.rotationSmoothing.currentX += (this.rotationSmoothing.targetX - this.rotationSmoothing.currentX) * smoothing;
    this.rotationSmoothing.currentY += (this.rotationSmoothing.targetY - this.rotationSmoothing.currentY) * smoothing;
    if (Math.abs(this.rotationSmoothing.currentX) > 1e-4 || Math.abs(this.rotationSmoothing.currentY) > 1e-4) {
      this.physics.updateRotation(this.rotationSmoothing.currentX, this.rotationSmoothing.currentY);
    } else {
      this.rotationSmoothing.currentX = 0;
      this.rotationSmoothing.currentY = 0;
    }
  }
  handleButtons(gamepad) {
    if (this.wasButtonPressed(this.buttonMap.A)) {
      if (this.controls && this.controls.targetingSystem) {
        this.controls.targetingSystem.toggleLockOn();
      }
    }
    if (this.wasButtonPressed(this.buttonMap.B)) {
      if (this.controls && this.controls.miningSystem && this.controls.targetingSystem) {
        if (this.controls.miningSystem.isMining) {
          this.controls.miningSystem.stopMining();
        } else {
          const target = this.controls.targetingSystem.getCurrentTarget();
          if (target) {
            this.controls.miningSystem.setTargetAsteroid(target);
            this.controls.miningSystem.startMining();
          }
        }
      }
    }
    if (this.wasButtonPressed(this.buttonMap.X)) {
      if (this.controls && this.controls.dockingSystem && this.controls.dockingSystem.canDock()) {
        this.controls.dockingSystem.initiateDocking();
      }
    }
    if (this.wasButtonPressed(this.buttonMap.Y)) {
      if (window.game && window.game.deployTurret) {
        window.game.deployTurret();
      }
    }
    if (this.wasButtonPressed(this.buttonMap.LB)) {
      if (this.controls && this.controls.targetingSystem) {
        this.controls.targetingSystem.cycleLockOnTarget(-1);
      }
    }
    if (this.wasButtonPressed(this.buttonMap.RB)) {
      if (this.controls && this.controls.targetingSystem) {
        const target = this.controls.targetingSystem.cycleLockOnTarget(1);
        if (target && this.controls.miningSystem) {
          this.controls.miningSystem.setTargetAsteroid(target);
        }
      }
    }
    if (this.wasButtonPressed(this.buttonMap.DPAD_UP)) {
      if (window.game && window.game.deployTurret) {
        window.game.deployTurret();
      }
    }
    if (this.wasButtonPressed(this.buttonMap.DPAD_DOWN)) {
      if (window.game && window.game.deployShieldDrone) {
        window.game.deployShieldDrone();
      }
    }
    if (this.wasButtonPressed(this.buttonMap.START)) {
      if (window.game && window.game.togglePause) {
        window.game.togglePause();
      }
    }
  }
  handleTriggers(gamepad) {
    let rtValue = 0;
    if (gamepad.buttons[7]) {
      rtValue = gamepad.buttons[7].value;
    }
    if (gamepad.buttons[6]) {
      gamepad.buttons[6].value;
    }
    gamepad.axes[4] || 0;
    const axis5 = gamepad.axes[5] || 0;
    if (rtValue < 0.01 && Math.abs(axis5) > 0.01) {
      rtValue = (axis5 + 1) / 2;
    }
    if (rtValue > this.triggerDeadZone) {
      if (!this.wasFiring) {
        if (window.game && window.game.combat) {
          window.game.combat.setFiring(true);
          this.wasFiring = true;
        }
      }
    } else {
      if (this.wasFiring) {
        if (window.game && window.game.combat) {
          window.game.combat.setFiring(false);
          this.wasFiring = false;
        }
      }
    }
  }
  applyDeadZone(value) {
    if (Math.abs(value) < this.deadZone) {
      return 0;
    }
    const sign = value > 0 ? 1 : -1;
    return sign * ((Math.abs(value) - this.deadZone) / (1 - this.deadZone));
  }
  wasButtonPressed(buttonIndex) {
    return this.buttonStates[buttonIndex] && !this.previousButtonStates[buttonIndex];
  }
  wasButtonReleased(buttonIndex) {
    return !this.buttonStates[buttonIndex] && this.previousButtonStates[buttonIndex];
  }
  vibrate(intensity = 0.5, duration = 100) {
    if (!this.vibrationEnabled || this.activeGamepadIndex === null) return;
    const gamepads = navigator.getGamepads();
    const gamepad = gamepads[this.activeGamepadIndex];
    if (gamepad && gamepad.vibrationActuator) {
      gamepad.vibrationActuator.playEffect("dual-rumble", {
        startDelay: 0,
        duration,
        weakMagnitude: intensity * 0.5,
        strongMagnitude: intensity
      });
    }
  }
  resetControls() {
    this.spaceship.thrust.forward = false;
    this.spaceship.thrust.backward = false;
    this.spaceship.thrust.left = false;
    this.spaceship.thrust.right = false;
    this.spaceship.thrust.boost = false;
    this.spaceship.thrustPower = 1;
    this.spaceship.strafePower = 1;
  }
  showNotification(message) {
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.bottom = "100px";
    notification.style.left = "50%";
    notification.style.transform = "translateX(-50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#30cfd0";
    notification.style.padding = "10px 20px";
    notification.style.borderRadius = "5px";
    notification.style.border = "1px solid #30cfd0";
    notification.style.fontFamily = "monospace";
    notification.style.fontSize = "14px";
    notification.style.zIndex = "10000";
    notification.textContent = "🎮 " + message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.transition = "opacity 0.5s";
      notification.style.opacity = "0";
      setTimeout(() => notification.remove(), 500);
    }, 3e3);
  }
  // Settings methods
  setLookSensitivity(value) {
    this.lookSensitivity = Math.max(0.1, Math.min(5, value));
  }
  setMovementSensitivity(value) {
    this.movementSensitivity = Math.max(0.1, Math.min(2, value));
  }
  setDeadZone(value) {
    this.deadZone = Math.max(0.05, Math.min(0.3, value));
  }
  setVibration(enabled) {
    this.vibrationEnabled = enabled;
  }
  isConnected() {
    return this.activeGamepadIndex !== null;
  }
  // Debug methods for testing
  toggleDebug() {
    this.debugMode = !this.debugMode;
    if (this.debugMode) {
      this.createDebugDisplay();
    } else {
      this.removeDebugDisplay();
    }
  }
  createDebugDisplay() {
    if (this.debugDisplay) return;
    this.debugDisplay = document.createElement("div");
    this.debugDisplay.id = "gamepad-debug";
    this.debugDisplay.style.position = "fixed";
    this.debugDisplay.style.top = "10px";
    this.debugDisplay.style.right = "10px";
    this.debugDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    this.debugDisplay.style.color = "#0f0";
    this.debugDisplay.style.padding = "10px";
    this.debugDisplay.style.fontFamily = "monospace";
    this.debugDisplay.style.fontSize = "12px";
    this.debugDisplay.style.borderRadius = "5px";
    this.debugDisplay.style.border = "1px solid #0f0";
    this.debugDisplay.style.zIndex = "10001";
    this.debugDisplay.style.maxWidth = "300px";
    this.debugDisplay.style.pointerEvents = "none";
    document.body.appendChild(this.debugDisplay);
  }
  removeDebugDisplay() {
    if (this.debugDisplay) {
      this.debugDisplay.remove();
      this.debugDisplay = null;
    }
  }
  updateDebugDisplay(gamepad) {
    var _a, _b, _c, _d;
    if (!this.debugDisplay) {
      this.createDebugDisplay();
    }
    let html = `<strong>🎮 Gamepad Debug</strong><br>`;
    html += `Controller: ${gamepad.id}<br>`;
    html += `Mapping: ${gamepad.mapping || "non-standard"}<br>`;
    html += `<br><strong>All Axes (${gamepad.axes.length}):</strong><br>`;
    for (let i = 0; i < gamepad.axes.length; i++) {
      const value = gamepad.axes[i].toFixed(2);
      const isRightX = i === this.rightStickXAxis;
      const isRightY = i === this.rightStickYAxis;
      const label = isRightX ? " (R-X)" : isRightY ? " (R-Y)" : "";
      html += `[${i}]: ${value}${label} `;
      if (i % 2 === 1) html += "<br>";
    }
    html += `<br><strong>Detected Mapping:</strong><br>`;
    html += `Left Stick: axes[0,1]<br>`;
    html += `Right Stick: axes[${this.rightStickXAxis},${this.rightStickYAxis}]<br>`;
    const rightX = ((_a = gamepad.axes[this.rightStickXAxis]) == null ? void 0 : _a.toFixed(2)) || "0";
    const rightY = ((_b = gamepad.axes[this.rightStickYAxis]) == null ? void 0 : _b.toFixed(2)) || "0";
    html += `Right Values: X=${rightX} Y=${rightY}<br>`;
    const rt = ((_c = gamepad.buttons[7]) == null ? void 0 : _c.value.toFixed(2)) || "0";
    const lt = ((_d = gamepad.buttons[6]) == null ? void 0 : _d.value.toFixed(2)) || "0";
    html += `<br><strong>Triggers:</strong><br>`;
    html += `LT: ${lt} | RT: ${rt}<br>`;
    html += `<br><strong>Active:</strong><br>`;
    if (this.spaceship.thrust.forward) html += "↑ Forward ";
    if (this.spaceship.thrust.backward) html += "↓ Backward ";
    if (this.spaceship.thrust.left) html += "→ Right ";
    if (this.spaceship.thrust.right) html += "← Left ";
    if (this.spaceship.thrust.boost) html += "⚡ Boost ";
    html += `<br><small>Press F8 to swap X/Y axes</small>`;
    this.debugDisplay.innerHTML = html;
  }
  // Method to swap right stick axes if they're incorrect
  swapRightStickAxes() {
    const temp = this.rightStickXAxis;
    this.rightStickXAxis = this.rightStickYAxis;
    this.rightStickYAxis = temp;
    console.log(`Swapped right stick axes: X is now axis ${this.rightStickXAxis}, Y is now axis ${this.rightStickYAxis}`);
    this.axisDetectionMode = false;
  }
}
class LaserControl {
  constructor(scene, spaceship) {
    this.scene = scene;
    this.spaceship = spaceship;
  }
  /**
   * Update laser beam position and appearance
   */
  updateLaserBeam(targetAsteroid) {
    const laserBeam = document.getElementById("laser-beam");
    if (!laserBeam || !targetAsteroid || !this.spaceship.mesh) return;
    const shipPosition = this.spaceship.mesh.position.clone();
    const asteroidPosition = targetAsteroid.mesh.position.clone();
    const shipOffset = new Vector3(0, 0, -60);
    shipOffset.applyQuaternion(this.spaceship.mesh.quaternion);
    shipPosition.add(shipOffset);
    const tempVector = new Vector3();
    const camera = this.scene.camera;
    if (!camera) return;
    tempVector.copy(shipPosition);
    tempVector.project(camera);
    const shipX = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
    const shipY = (-(tempVector.y * 0.5) + 0.5) * window.innerHeight;
    tempVector.copy(asteroidPosition);
    tempVector.project(camera);
    const asteroidX = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
    const asteroidY = (-(tempVector.y * 0.5) + 0.5) * window.innerHeight;
    const dx = asteroidX - shipX;
    const dy = asteroidY - shipY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    laserBeam.style.width = `${distance}px`;
    laserBeam.style.left = `${shipX}px`;
    laserBeam.style.top = `${shipY}px`;
    laserBeam.style.transform = `rotate(${angle}rad)`;
    const intensity = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
    laserBeam.style.opacity = intensity.toString();
    const efficiency = this.spaceship.miningEfficiency || 1;
    const thickness = Math.max(2, Math.ceil(2 * Math.sqrt(efficiency)));
    laserBeam.style.height = `${thickness}px`;
    if (!laserBeam.hasChildNodes()) {
      for (let i = 0; i < 2; i++) {
        const additionalBeam = document.createElement("div");
        additionalBeam.style.position = "absolute";
        additionalBeam.style.left = "0";
        additionalBeam.style.top = `${i === 0 ? -1 : 1}px`;
        additionalBeam.style.width = "100%";
        additionalBeam.style.height = "1px";
        additionalBeam.style.backgroundColor = "#ff6060";
        additionalBeam.style.opacity = "0.7";
        laserBeam.appendChild(additionalBeam);
      }
    }
  }
  /**
   * Create or get laser beam element
   */
  setupLaserBeam(targetAsteroid) {
    let laserBeam = document.getElementById("laser-beam");
    if (!laserBeam) {
      console.log("LaserControl: Creating laser beam element");
      laserBeam = document.createElement("div");
      laserBeam.id = "laser-beam";
      laserBeam.style.position = "absolute";
      laserBeam.style.height = "2px";
      laserBeam.style.backgroundColor = "#ff3030";
      laserBeam.style.transformOrigin = "0 0";
      laserBeam.style.zIndex = "100";
      laserBeam.style.pointerEvents = "none";
      document.body.appendChild(laserBeam);
    }
    if (laserBeam) {
      laserBeam.style.display = "block";
      if (targetAsteroid.resourceType) {
        const resourceType = targetAsteroid.resourceType.toLowerCase();
        let laserColor = "#ff3030";
        let glowColor = "#ff0000";
        if (resourceType === "gold") {
          laserColor = "#ffcc00";
          glowColor = "#ffaa00";
        } else if (resourceType === "platinum") {
          laserColor = "#66ffff";
          glowColor = "#00ffff";
        }
        const efficiency = this.spaceship.miningEfficiency || 1;
        if (efficiency > 1) {
          const laserIntensity = Math.min(1 + (efficiency - 1) * 0.5, 3);
          laserBeam.style.boxShadow = `0 0 ${10 * laserIntensity}px ${glowColor}, 0 0 ${20 * laserIntensity}px ${glowColor}`;
        } else {
          laserBeam.style.boxShadow = `0 0 10px ${glowColor}, 0 0 20px ${glowColor}`;
        }
        laserBeam.style.backgroundColor = laserColor;
      } else {
        laserBeam.style.backgroundColor = "#ff3030";
        laserBeam.style.boxShadow = "0 0 10px #ff0000, 0 0 20px #ff0000";
      }
    }
  }
  /**
   * Hide laser beam
   */
  hideLaserBeam() {
    const laserBeam = document.getElementById("laser-beam");
    if (laserBeam) {
      laserBeam.style.display = "none";
    }
  }
  /**
   * Activate spaceship's mining laser
   */
  activateSpaceshipLaser() {
    if (this.spaceship && typeof this.spaceship.activateMiningLaser === "function") {
      this.spaceship.activateMiningLaser();
    }
  }
  /**
   * Deactivate spaceship's mining laser
   */
  deactivateSpaceshipLaser() {
    if (this.spaceship && typeof this.spaceship.deactivateMiningLaser === "function") {
      this.spaceship.deactivateMiningLaser();
    }
  }
}
class TargetValidation {
  constructor(spaceship, miningDistance = 6e3) {
    this.spaceship = spaceship;
    this.miningDistance = miningDistance;
  }
  /**
   * Validate asteroid target
   */
  validateAsteroid(asteroid) {
    try {
      console.log("TargetValidation: validating asteroid", asteroid);
      if (!asteroid || !asteroid.mesh || !asteroid.mesh.position) {
        console.error("TargetValidation: Invalid asteroid provided");
        return false;
      }
      return true;
    } catch (error) {
      console.error("TargetValidation: Error validating asteroid:", error);
      return false;
    }
  }
  /**
   * Check if target is in mining range
   */
  isInRange(asteroid) {
    if (!asteroid || !asteroid.mesh || !this.spaceship || !this.spaceship.mesh) {
      return false;
    }
    const distance = this.spaceship.mesh.position.distanceTo(asteroid.mesh.position);
    return distance <= this.miningDistance;
  }
  /**
   * Get distance to target
   */
  getDistanceToTarget(asteroid) {
    if (!asteroid || !asteroid.mesh || !this.spaceship || !this.spaceship.mesh) {
      return Infinity;
    }
    return this.spaceship.mesh.position.distanceTo(asteroid.mesh.position);
  }
  /**
   * Validate spaceship for mining
   */
  validateSpaceship() {
    if (!this.spaceship || !this.spaceship.mesh || !this.spaceship.mesh.position) {
      console.error("TargetValidation: Spaceship is missing mesh or position");
      return false;
    }
    return true;
  }
  /**
   * Check if asteroid is valid for mining start
   */
  canStartMining(asteroid) {
    if (!this.validateAsteroid(asteroid)) {
      return { valid: false, reason: "Invalid asteroid" };
    }
    if (!this.validateSpaceship()) {
      return { valid: false, reason: "Invalid spaceship" };
    }
    const distance = this.getDistanceToTarget(asteroid);
    if (distance > this.miningDistance) {
      return {
        valid: false,
        reason: "Out of range",
        distance,
        maxRange: this.miningDistance
      };
    }
    return { valid: true };
  }
}
class ResourceExtraction {
  constructor() {
    this.resources = {
      iron: 0,
      gold: 0,
      platinum: 0
    };
  }
  /**
   * Add all resources from the mined asteroid to the player's inventory at once
   */
  addAsteroidResources(targetAsteroid, efficiency = 1) {
    if (!targetAsteroid) return false;
    const resourceType = targetAsteroid.resourceType || "iron";
    const bonusChance = (efficiency - 1) * 0.5;
    let amount = 0;
    switch (resourceType.toLowerCase()) {
      case "iron":
        amount = Math.floor(Math.random() * 5) + 10;
        break;
      case "gold":
        amount = Math.floor(Math.random() * 3) + 5;
        break;
      case "platinum":
        amount = Math.floor(Math.random() * 2) + 2;
        break;
      default:
        amount = 10;
    }
    if (efficiency > 1 && Math.random() < bonusChance) {
      amount = Math.ceil(amount * 1.2);
    }
    switch (resourceType.toLowerCase()) {
      case "iron":
        this.resources.iron += amount;
        break;
      case "gold":
        this.resources.gold += amount;
        break;
      case "platinum":
        this.resources.platinum += amount;
        break;
      default:
        this.resources.iron += amount;
    }
    console.log(`ResourceExtraction: Added ${amount} ${resourceType} from asteroid`);
    this.showResourceGainNotification(amount, resourceType);
    return true;
  }
  /**
   * Show a notification for resources gained
   */
  showResourceGainNotification(amount, resourceType) {
    let color = "#a0a0a0";
    if (resourceType === "gold") {
      color = "#ffcc00";
    } else if (resourceType === "platinum") {
      color = "#66ffff";
    }
    const notification = document.createElement("div");
    notification.textContent = `+${amount} ${resourceType.toUpperCase()}`;
    notification.style.position = "absolute";
    notification.style.top = "40%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.color = color;
    notification.style.fontSize = "24px";
    notification.style.fontWeight = "bold";
    notification.style.textShadow = "0 0 8px black";
    notification.style.zIndex = "1000";
    notification.style.opacity = "1";
    notification.style.transition = "all 1.5s ease-out";
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.top = "30%";
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 1500);
    }, 100);
  }
  /**
   * Get current resource counts
   */
  getResources() {
    return { ...this.resources };
  }
  /**
   * Get resource count for specific type
   */
  getResource(type) {
    return this.resources[type.toLowerCase()] || 0;
  }
}
class UIUpdates {
  constructor() {
  }
  /**
   * Update target info UI elements
   */
  updateTargetInfo(asteroid, spaceship, miningDistance) {
    var _a, _b, _c, _d;
    if (!asteroid || !asteroid.mesh || !spaceship || !spaceship.mesh) return;
    try {
      const targetingSystem = ((_b = (_a = window.gameInstance) == null ? void 0 : _a.controls) == null ? void 0 : _b.targetingSystem) || ((_d = (_c = window.game) == null ? void 0 : _c.controls) == null ? void 0 : _d.targetingSystem);
      const isTargetingEnabled = targetingSystem && targetingSystem.isLockOnEnabled();
      if (!isTargetingEnabled) return;
      const distance = spaceship.mesh.position.distanceTo(asteroid.mesh.position);
      const inRange = distance <= miningDistance;
      const targetDistance = document.getElementById("target-distance");
      if (targetDistance) {
        const rangeStatus = inRange ? " [IN RANGE]" : " [OUT OF RANGE]";
        const rangeColor = inRange ? "#00ff00" : "#ff4400";
        targetDistance.innerHTML = `Distance: ${Math.round(distance)} units<span style="color: ${rangeColor}">${rangeStatus}</span>`;
      }
      const targetInfo = document.getElementById("target-info");
      if (targetInfo) {
        targetInfo.style.color = inRange ? "#30cfd0" : "#ff4400";
        targetInfo.style.display = "block";
      }
      const targetName = document.getElementById("target-name");
      if (targetName && asteroid.resourceType) {
        const resourceType = asteroid.resourceType.toUpperCase();
        if (!inRange) {
          targetName.textContent = `${resourceType} Asteroid - OUT OF RANGE`;
          targetName.style.color = "#ff4400";
        } else {
          targetName.textContent = `${resourceType} Asteroid`;
          targetName.style.color = "#30cfd0";
        }
      }
    } catch (error) {
      console.error("UIUpdates: Error updating target info:", error);
    }
  }
  /**
   * Update mining status with time estimate
   */
  updateMiningStatusWithTime(asteroid, miningSpeed, efficiency = 1) {
    const miningStatusElement = document.getElementById("mining-status");
    if (!miningStatusElement || !asteroid || !asteroid.resourceType) return;
    const resourceType = asteroid.resourceType.toLowerCase();
    const secondsRequired = Math.round(1 / miningSpeed);
    let efficiencyText = "";
    if (efficiency > 1) {
      efficiencyText = ` [${Math.round(efficiency * 100)}% efficiency]`;
    }
    miningStatusElement.textContent = `MINING ${resourceType.toUpperCase()} (${secondsRequired}s)${efficiencyText}`;
    miningStatusElement.style.color = "#ff4400";
  }
  /**
   * Reset mining status display
   */
  resetMiningStatus() {
    const miningStatusElement = document.getElementById("mining-status");
    if (miningStatusElement) {
      miningStatusElement.textContent = "INACTIVE";
      miningStatusElement.style.color = "#30cfd0";
    }
  }
  /**
   * Create or update mining progress bar
   */
  setupMiningProgressBar() {
    let miningProgressContainer = document.getElementById("mining-progress-container");
    if (!miningProgressContainer) {
      console.log("UIUpdates: Creating mining progress container");
      miningProgressContainer = document.createElement("div");
      miningProgressContainer.id = "mining-progress-container";
      miningProgressContainer.style.position = "absolute";
      miningProgressContainer.style.bottom = "20px";
      miningProgressContainer.style.left = "50%";
      miningProgressContainer.style.transform = "translateX(-50%)";
      miningProgressContainer.style.width = "200px";
      miningProgressContainer.style.height = "10px";
      miningProgressContainer.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
      miningProgressContainer.style.border = "1px solid #30cfd0";
      miningProgressContainer.style.zIndex = "1000";
      document.body.appendChild(miningProgressContainer);
      const progressBar = document.createElement("div");
      progressBar.id = "mining-progress-bar";
      progressBar.style.width = "0%";
      progressBar.style.height = "100%";
      progressBar.style.backgroundColor = "#30cfd0";
      miningProgressContainer.appendChild(progressBar);
    } else {
      miningProgressContainer.style.display = "block";
      const progressBar = document.getElementById("mining-progress-bar");
      if (progressBar) {
        progressBar.style.width = "0%";
      }
    }
  }
  /**
   * Update mining progress bar
   */
  updateMiningProgress(progress) {
    const progressBar = document.getElementById("mining-progress-bar");
    if (progressBar) {
      progressBar.style.width = `${progress * 100}%`;
    }
  }
  /**
   * Hide mining progress bar
   */
  hideMiningProgressBar() {
    const miningProgressContainer = document.getElementById("mining-progress-container");
    if (miningProgressContainer) {
      miningProgressContainer.style.display = "none";
    }
  }
  /**
   * Show out of range message
   */
  showOutOfRangeMessage() {
    var _a, _b, _c, _d;
    const targetingSystem = ((_b = (_a = window.gameInstance) == null ? void 0 : _a.controls) == null ? void 0 : _b.targetingSystem) || ((_d = (_c = window.game) == null ? void 0 : _c.controls) == null ? void 0 : _d.targetingSystem);
    const isTargetingEnabled = targetingSystem && targetingSystem.isLockOnEnabled();
    const targetInfo = document.getElementById("target-info");
    if (targetInfo && isTargetingEnabled) {
      targetInfo.textContent = "TARGET OUT OF RANGE";
      targetInfo.style.color = "#ff4400";
      targetInfo.style.display = "block";
      setTimeout(() => {
        if (!targetingSystem || !targetingSystem.isLockOnEnabled()) {
          targetInfo.style.display = "none";
        }
      }, 2e3);
    }
  }
}
class VisualEffects {
  constructor(scene) {
    this.scene = scene;
    this.miningParticles = null;
    this.setupMiningParticles();
  }
  /**
   * Setup mining particles effect
   */
  setupMiningParticles() {
    const particleCount = 100;
    const particles = new BufferGeometry();
    const particleMaterial = new PointsMaterial({
      color: 16733440,
      size: 1.5,
      blending: AdditiveBlending,
      transparent: true,
      opacity: 0.8
    });
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = 0;
      positions[i * 3 + 1] = 0;
      positions[i * 3 + 2] = 0;
    }
    particles.setAttribute("position", new BufferAttribute(positions, 3));
    this.miningParticles = new Points(particles, particleMaterial);
    this.miningParticles.visible = false;
    this.scene.add(this.miningParticles);
  }
  /**
   * Show mining particles with appropriate color
   */
  showMiningParticles(asteroid, efficiency = 1) {
    if (!this.miningParticles) return;
    this.miningParticles.visible = true;
    if (asteroid.resourceType && this.miningParticles.material) {
      const resourceType = asteroid.resourceType.toLowerCase();
      if (resourceType === "iron") {
        this.miningParticles.material.color.set(16733440);
      } else if (resourceType === "gold") {
        this.miningParticles.material.color.set(16763904);
      } else if (resourceType === "platinum") {
        this.miningParticles.material.color.set(6750207);
      }
      if (efficiency > 1) {
        this.miningParticles.material.size = 1.5 * Math.sqrt(efficiency);
      }
    }
  }
  /**
   * Hide mining particles
   */
  hideMiningParticles() {
    if (this.miningParticles) {
      this.miningParticles.visible = false;
    }
  }
  /**
   * Update mining particles animation
   */
  updateMiningParticles(efficiency = 1) {
    if (!this.miningParticles || !this.miningParticles.visible) return;
    const positions = this.miningParticles.geometry.attributes.position.array;
    const particleSpeed = 0.3 * efficiency;
    for (let i = 0; i < positions.length; i += 3) {
      const dir = new Vector3(positions[i], positions[i + 1], positions[i + 2]);
      dir.normalize().multiplyScalar(particleSpeed);
      positions[i] += dir.x;
      positions[i + 1] += dir.y;
      positions[i + 2] += dir.z;
      const dist = Math.sqrt(
        positions[i] * positions[i] + positions[i + 1] * positions[i + 1] + positions[i + 2] * positions[i + 2]
      );
      if (dist > 36) {
        positions[i] = (Math.random() - 0.5) * 24;
        positions[i + 1] = (Math.random() - 0.5) * 24;
        positions[i + 2] = (Math.random() - 0.5) * 24;
      }
    }
    this.miningParticles.geometry.attributes.position.needsUpdate = true;
  }
  /**
   * Update particles position to asteroid location
   */
  setParticlesPosition(position) {
    if (this.miningParticles && this.miningParticles.visible) {
      this.miningParticles.position.copy(position);
    }
  }
  /**
   * Create asteroid break effect
   */
  createAsteroidBreakEffect(position) {
    const particleCount = 50;
    const particles = new BufferGeometry();
    const particleMaterial = new PointsMaterial({
      color: 11184810,
      size: 12,
      blending: AdditiveBlending,
      transparent: true,
      opacity: 0.8
    });
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = position.x;
      positions[i * 3 + 1] = position.y;
      positions[i * 3 + 2] = position.z;
      velocities.push({
        x: (Math.random() - 0.5) * 8,
        y: (Math.random() - 0.5) * 8,
        z: (Math.random() - 0.5) * 8
      });
    }
    particles.setAttribute("position", new BufferAttribute(positions, 3));
    const particleSystem = new Points(particles, particleMaterial);
    this.scene.add(particleSystem);
    let frameCount = 0;
    const animateParticles = () => {
      frameCount++;
      const positions2 = particleSystem.geometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        positions2[i * 3] += velocities[i].x;
        positions2[i * 3 + 1] += velocities[i].y;
        positions2[i * 3 + 2] += velocities[i].z;
      }
      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.material.opacity = Math.max(0, 0.8 - frameCount * 0.02);
      if (frameCount < 40) {
        requestAnimationFrame(animateParticles);
      } else {
        this.scene.remove(particleSystem);
      }
    };
    animateParticles();
  }
  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.miningParticles) {
      if (this.miningParticles.geometry) this.miningParticles.geometry.dispose();
      if (this.miningParticles.material) this.miningParticles.material.dispose();
      this.scene.remove(this.miningParticles);
      this.miningParticles = null;
    }
  }
}
class MiningSystem {
  constructor(spaceship, scene) {
    this.spaceship = spaceship;
    this.scene = scene;
    this.isMining = false;
    this.targetAsteroid = null;
    this.miningProgress = 0;
    this.lastDestroyedAsteroid = null;
    this.miningSpeedByType = {
      iron: 0.133,
      // 1/7.5 seconds to complete
      gold: 0.044,
      // 1/22.5 seconds to complete
      platinum: 0.022
      // 1/45 seconds to complete
    };
    this.miningSpeed = 0.133;
    this.miningDistance = 6e3;
    this.miningCooldown = 0;
    this.laserControl = new LaserControl(scene, spaceship);
    this.targetValidation = new TargetValidation(spaceship, this.miningDistance);
    this.resourceExtraction = new ResourceExtraction();
    this.uiUpdates = new UIUpdates();
    this.visualEffects = new VisualEffects(scene);
  }
  // Helper method to get the mining efficiency from the spaceship
  getMiningEfficiency() {
    return this.spaceship && this.spaceship.miningEfficiency ? this.spaceship.miningEfficiency : 1;
  }
  // Expose resources from the resource extraction module
  get resources() {
    return this.resourceExtraction.getResources();
  }
  setTargetAsteroid(asteroid) {
    try {
      console.log("MiningSystem: setTargetAsteroid called", asteroid);
      if (!this.targetValidation.validateAsteroid(asteroid)) {
        return false;
      }
      this.targetAsteroid = asteroid;
      if (asteroid && asteroid.resourceType) {
        const resourceType = asteroid.resourceType.toLowerCase();
        const baseSpeed = this.miningSpeedByType[resourceType] || this.miningSpeedByType.iron;
        const efficiency = this.getMiningEfficiency();
        this.miningSpeed = baseSpeed * efficiency;
        console.log(`Mining ${resourceType} asteroid with speed: ${this.miningSpeed} (efficiency: ${efficiency}x)`);
        this.uiUpdates.updateTargetInfo(asteroid, this.spaceship, this.miningDistance);
      } else {
        this.miningSpeed = this.miningSpeedByType.iron * this.getMiningEfficiency();
      }
      return true;
    } catch (error) {
      console.error("MiningSystem: Error in setTargetAsteroid:", error);
      return false;
    }
  }
  startMining() {
    try {
      console.log("MiningSystem: startMining called");
      if (!this.targetAsteroid) {
        console.error("MiningSystem: Cannot start mining - no target asteroid set");
        return;
      }
      const canMine = this.targetValidation.canStartMining(this.targetAsteroid);
      if (!canMine.valid) {
        if (canMine.reason === "Out of range") {
          this.uiUpdates.showOutOfRangeMessage();
        }
        console.log(`MiningSystem: ${canMine.reason}`);
        return;
      }
      this.isMining = true;
      this.miningProgress = 0;
      console.log("MiningSystem: Mining state activated");
      this.laserControl.setupLaserBeam(this.targetAsteroid);
      this.visualEffects.showMiningParticles(this.targetAsteroid, this.getMiningEfficiency());
      this.uiUpdates.setupMiningProgressBar();
      this.laserControl.activateSpaceshipLaser();
      this.updateMiningStatusWithTime();
      if (window.game && window.game.audio) {
        window.game.audio.playSound("mining-laser");
      } else if (window.game && window.game.audio) {
        window.game.audio.playSound("laser");
      }
      console.log("MiningSystem: Mining successfully started");
    } catch (error) {
      console.error("MiningSystem: Error in startMining:", error);
      this.isMining = false;
    }
  }
  // Update the mining status with time estimate
  updateMiningStatusWithTime() {
    this.uiUpdates.updateMiningStatusWithTime(
      this.targetAsteroid,
      this.miningSpeed,
      this.getMiningEfficiency()
    );
  }
  stopMining() {
    if (!this.isMining) return;
    this.isMining = false;
    this.miningProgress = 0;
    this.laserControl.hideLaserBeam();
    this.visualEffects.hideMiningParticles();
    this.uiUpdates.hideMiningProgressBar();
    this.laserControl.deactivateSpaceshipLaser();
    this.uiUpdates.resetMiningStatus();
    if (window.game && window.game.audio) {
      window.game.audio.stopSound("mining-laser");
    }
  }
  update(deltaTime = 1 / 60) {
    if (this.miningCooldown > 0) {
      this.miningCooldown--;
    }
    if (this.isMining) {
      this.updateMining(deltaTime);
    }
    this.visualEffects.updateMiningParticles(this.getMiningEfficiency());
    if (this.targetAsteroid && !this.isMining) {
      this.uiUpdates.updateTargetInfo(this.targetAsteroid, this.spaceship, this.miningDistance);
    }
  }
  updateMining(deltaTime = 1 / 60) {
    if (!this.targetAsteroid || !this.isMining) {
      this.stopMining();
      return;
    }
    const distance = this.spaceship.mesh.position.distanceTo(this.targetAsteroid.mesh.position);
    if (distance > this.miningDistance) {
      this.stopMining();
      return;
    }
    this.miningProgress += this.miningSpeed * deltaTime;
    this.laserControl.updateLaserBeam(this.targetAsteroid);
    this.visualEffects.setParticlesPosition(this.targetAsteroid.mesh.position);
    if (this.miningProgress >= 1) {
      this.resourceExtraction.addAsteroidResources(this.targetAsteroid, this.getMiningEfficiency());
      this.visualEffects.createAsteroidBreakEffect(this.targetAsteroid.mesh.position);
      this.lastDestroyedAsteroid = this.targetAsteroid;
      this.scene.remove(this.targetAsteroid.mesh);
      this.stopMining();
      this.targetAsteroid = null;
    }
    this.uiUpdates.updateMiningProgress(this.miningProgress);
  }
  // New method to retrieve the last destroyed asteroid and reset the property
  getLastDestroyedAsteroid() {
    const destroyedAsteroid = this.lastDestroyedAsteroid;
    this.lastDestroyedAsteroid = null;
    return destroyedAsteroid;
  }
}
class TargetingSystem {
  constructor(spaceship, scene, environment) {
    this.spaceship = spaceship;
    this.scene = scene;
    this.environment = environment;
    this.lockOnEnabled = false;
    this.nearbyAsteroids = [];
    this.currentLockOnIndex = -1;
    this.targetAsteroid = null;
    this.scanRadius = this.getScanRadius();
    this.createTargetReticle();
    this.createOffScreenIndicators();
  }
  createTargetReticle() {
    const ringGeometry = new RingGeometry(150, 180, 32);
    const ringMaterial = new MeshBasicMaterial({
      color: 16724016,
      side: DoubleSide,
      transparent: true,
      opacity: 0.7
    });
    this.targetReticle = new Mesh(ringGeometry, ringMaterial);
    this.targetReticle.visible = false;
    this.scene.add(this.targetReticle);
    const innerRingGeometry = new RingGeometry(75, 90, 32);
    const innerRingMaterial = new MeshBasicMaterial({
      color: 16736352,
      side: DoubleSide,
      transparent: true,
      opacity: 0.5
    });
    const innerRing = new Mesh(innerRingGeometry, innerRingMaterial);
    this.targetReticle.add(innerRing);
  }
  // Helper method to get the current scan radius from the spaceship
  getScanRadius() {
    return this.spaceship && this.spaceship.scanRange ? this.spaceship.scanRange * 5 : 5e3;
  }
  toggleLockOn() {
    this.lockOnEnabled = !this.lockOnEnabled;
    if (this.lockOnEnabled) {
      this.scanRadius = this.getScanRadius();
      this.scanForAsteroids();
      const targetInfoElement = document.getElementById("target-info");
      if (targetInfoElement) {
        targetInfoElement.style.display = "block";
        targetInfoElement.style.color = "#30cfd0";
        const targetName = document.getElementById("target-name");
        if (targetName) {
          targetName.textContent = "Scanning for targets...";
        }
      }
      if (this.nearbyAsteroids.length > 0) {
        this.findNearestTarget();
      }
    } else {
      this.nearbyAsteroids = [];
      this.currentLockOnIndex = -1;
      this.targetAsteroid = null;
      this.targetReticle.visible = false;
      this.hideOffScreenIndicators();
      const targetInfoElement = document.getElementById("target-info");
      if (targetInfoElement) {
        targetInfoElement.style.display = "none";
      }
    }
    return this.lockOnEnabled;
  }
  scanForAsteroids() {
    this.nearbyAsteroids = [];
    const shipPosition = this.spaceship.mesh.position;
    const raycaster = new Raycaster();
    const asteroids = this.environment.asteroids;
    asteroids.forEach((asteroid) => {
      if (!asteroid.minable || !asteroid.mesh.visible) return;
      const distance = shipPosition.distanceTo(asteroid.mesh.position);
      if (distance <= this.scanRadius) {
        const direction = new Vector3().subVectors(asteroid.mesh.position, shipPosition).normalize();
        raycaster.set(shipPosition, direction);
        raycaster.far = distance;
        const intersects = raycaster.intersectObjects(
          asteroids.filter((a) => a.mesh && a.mesh.visible).map((a) => a.mesh)
        );
        if (intersects.length > 0 && intersects[0].object === asteroid.mesh) {
          this.nearbyAsteroids.push({
            asteroid,
            distance
          });
        }
      }
    });
    this.nearbyAsteroids.sort((a, b) => a.distance - b.distance);
    this.nearbyAsteroids = this.nearbyAsteroids.map((item) => item.asteroid);
    if (this.nearbyAsteroids.length > 0) {
      this.currentLockOnIndex = 0;
      this.updateLockedOnTarget();
      const targetNameElement = document.getElementById("target-name");
      if (targetNameElement) {
        targetNameElement.textContent = `Target 1/${this.nearbyAsteroids.length} (${Math.round(this.nearbyAsteroids[0].mesh.position.distanceTo(shipPosition))} units)`;
      }
      return true;
    } else {
      const targetNameElement = document.getElementById("target-name");
      if (targetNameElement) {
        targetNameElement.textContent = "No targets in range";
      }
      this.targetReticle.visible = false;
      this.targetAsteroid = null;
      return false;
    }
  }
  cycleLockOnTarget() {
    if (!this.lockOnEnabled || this.nearbyAsteroids.length === 0) return null;
    this.currentLockOnIndex = (this.currentLockOnIndex + 1) % this.nearbyAsteroids.length;
    return this.updateLockedOnTarget();
  }
  updateLockedOnTarget() {
    this.targetAsteroid = this.nearbyAsteroids[this.currentLockOnIndex];
    if (this.targetAsteroid) {
      console.log(`Target locked: ${this.targetAsteroid.resourceType} asteroid`);
      this.targetReticle.position.copy(this.targetAsteroid.mesh.position);
      this.targetReticle.visible = true;
      const lookAtPos = new Vector3().copy(this.scene.camera.position);
      this.targetReticle.lookAt(lookAtPos);
      this.targetReticle.scale.set(1, 1, 1);
      this.targetReticle.material.opacity = 0.8;
      if (this.targetReticle.children.length > 0) {
        this.targetReticle.children[0].material.opacity = 0.8;
      }
    }
    return this.targetAsteroid;
  }
  getCurrentTarget() {
    try {
      console.log("TargetingSystem: getCurrentTarget called");
      if (!this.targetAsteroid) {
        console.log("TargetingSystem: No current target");
        return null;
      }
      if (!this.targetAsteroid.mesh || !this.targetAsteroid.mesh.position) {
        console.error("TargetingSystem: Current target is invalid, clearing target");
        this.targetAsteroid = null;
        return null;
      }
      console.log("TargetingSystem: Returning current target:", this.targetAsteroid);
      return this.targetAsteroid;
    } catch (error) {
      console.error("TargetingSystem: Error in getCurrentTarget:", error);
      return null;
    }
  }
  isLockOnEnabled() {
    return this.lockOnEnabled === true;
  }
  findNearestTarget() {
    try {
      if (!this.spaceship || !this.spaceship.mesh || !this.spaceship.mesh.position) {
        return null;
      }
      let asteroids = [];
      const game = window.gameInstance || window.game;
      if (game && game.environment && Array.isArray(game.environment.asteroids)) {
        asteroids = game.environment.asteroids;
      } else {
        return null;
      }
      if (asteroids.length === 0) {
        return null;
      }
      let closestAsteroid = null;
      let closestDistance = Infinity;
      for (const asteroid of asteroids) {
        if (!asteroid || !asteroid.mesh || !asteroid.mesh.position || !asteroid.mesh.visible || !asteroid.minable) {
          continue;
        }
        const distance = this.spaceship.mesh.position.distanceTo(asteroid.mesh.position);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestAsteroid = asteroid;
        }
      }
      if (closestAsteroid) {
        console.log("TargetingSystem: Found nearest target:", closestAsteroid);
        this.setTarget(closestAsteroid);
        return closestAsteroid;
      } else {
        console.log("TargetingSystem: No valid asteroid found after checking all asteroids");
        return null;
      }
    } catch (error) {
      console.error("TargetingSystem: Error in findNearestTarget:", error);
      return null;
    }
  }
  update() {
    if (!this.scanRadiusCounter) this.scanRadiusCounter = 0;
    this.scanRadiusCounter++;
    if (this.scanRadiusCounter >= 30) {
      this.scanRadiusCounter = 0;
      this.scanRadius = this.getScanRadius();
    }
    if (this.lockOnEnabled) {
      if (!this.rescanCounter) this.rescanCounter = 0;
      this.rescanCounter++;
      if (this.rescanCounter >= 120) {
        this.rescanCounter = 0;
        this.nearbyAsteroids.length;
        this.scanForAsteroids();
        if (this.nearbyAsteroids.length > 0 && !this.targetAsteroid) {
          this.findNearestTarget();
        }
      }
    }
    if (this.lockOnEnabled && this.targetAsteroid) {
      this.targetReticle.position.copy(this.targetAsteroid.mesh.position);
      if (!this.lookAtCounter) this.lookAtCounter = 0;
      this.lookAtCounter++;
      if (this.lookAtCounter >= 10) {
        this.lookAtCounter = 0;
        this.targetReticle.lookAt(this.scene.camera.position);
      }
      this.targetReticle.rotation.z += 5e-3;
      if (this.targetReticle.children.length > 0) {
        this.targetReticle.children[0].rotation.z -= 0.01;
      }
      if (!this.pulseTime) this.pulseTime = 0;
      this.pulseTime += 0.02;
      const pulseValue = Math.sin(this.pulseTime);
      const opacity = 0.7 + 0.2 * pulseValue;
      this.targetReticle.material.opacity = opacity;
      if (!this.uiUpdateCounter) this.uiUpdateCounter = 0;
      this.uiUpdateCounter++;
      if (this.uiUpdateCounter >= 30) {
        this.uiUpdateCounter = 0;
        const targetDistanceElement = document.getElementById("target-distance");
        if (targetDistanceElement) {
          const distance = Math.round(this.spaceship.mesh.position.distanceTo(this.targetAsteroid.mesh.position));
          targetDistanceElement.textContent = `Distance: ${distance} units`;
        }
        if (!this.targetAsteroid.mesh.parent || this.spaceship.mesh.position.distanceTo(this.targetAsteroid.mesh.position) > this.scanRadius) {
          this.scanForAsteroids();
        }
      }
      this.targetReticle.visible = true;
      if (this.uiUpdateCounter === 15) {
        const isOnScreen = this.isTargetOnScreen();
        if (!isOnScreen) {
          const screenPosition = this.getScreenPosition(this.targetAsteroid.mesh.position);
          const targetDirection = this.getTargetDirection();
          this.showOffScreenIndicator(screenPosition, targetDirection);
        } else {
          this.hideOffScreenIndicators();
        }
      }
    }
  }
  setTarget(target) {
    try {
      console.log("TargetingSystem: setTarget called", target);
      if (!target) {
        console.error("TargetingSystem: Cannot set null target");
        return;
      }
      if (!target.mesh || !target.mesh.position) {
        console.error("TargetingSystem: Target is missing mesh or position properties", target);
        return;
      }
      this.targetAsteroid = target;
      if (this.targetDisplay) {
        this.targetDisplay.style.display = "block";
      }
      if (this.targetInfoElement) {
        const distance = this.calculateDistanceToTarget();
        let resourceType = target.resourceType || "Unknown";
        resourceType = resourceType.charAt(0).toUpperCase() + resourceType.slice(1);
        this.targetInfoElement.textContent = `${resourceType} Asteroid - ${distance.toFixed(0)}m`;
        this.targetInfoElement.style.color = "#30cfd0";
        this.targetInfoElement.style.display = "block";
      }
      console.log("TargetingSystem: Target successfully set", this.targetAsteroid);
      this.lockOnEnabled = true;
      return true;
    } catch (error) {
      console.error("TargetingSystem: Error in setTarget:", error);
      return false;
    }
  }
  calculateDistanceToTarget() {
    try {
      if (!this.targetAsteroid || !this.targetAsteroid.mesh || !this.targetAsteroid.mesh.position) {
        console.error("TargetingSystem: Cannot calculate distance - invalid target asteroid");
        return Infinity;
      }
      if (!this.spaceship || !this.spaceship.mesh || !this.spaceship.mesh.position) {
        console.error("TargetingSystem: Cannot calculate distance - invalid spaceship");
        return Infinity;
      }
      const distance = this.spaceship.mesh.position.distanceTo(this.targetAsteroid.mesh.position);
      return distance;
    } catch (error) {
      console.error("TargetingSystem: Error calculating distance to target:", error);
      return Infinity;
    }
  }
  // Add methods for off-screen indicators
  createOffScreenIndicators() {
    this.offScreenContainer = document.createElement("div");
    this.offScreenContainer.id = "off-screen-indicators";
    this.offScreenContainer.style.position = "absolute";
    this.offScreenContainer.style.top = "0";
    this.offScreenContainer.style.left = "0";
    this.offScreenContainer.style.width = "100%";
    this.offScreenContainer.style.height = "100%";
    this.offScreenContainer.style.pointerEvents = "none";
    this.offScreenContainer.style.display = "none";
    document.body.appendChild(this.offScreenContainer);
    this.offScreenIndicator = document.createElement("div");
    this.offScreenIndicator.style.position = "absolute";
    this.offScreenIndicator.style.width = "30px";
    this.offScreenIndicator.style.height = "30px";
    this.offScreenIndicator.innerHTML = `
            <svg width="30" height="30" viewBox="0 0 30 30">
                <polygon points="15,0 30,30 15,22 0,30" fill="#ff3030" />
            </svg>
        `;
    this.offScreenIndicator.style.transformOrigin = "center center";
    this.offScreenIndicator.style.display = "none";
    this.offScreenContainer.appendChild(this.offScreenIndicator);
  }
  hideOffScreenIndicators() {
    if (this.offScreenContainer) {
      this.offScreenContainer.style.display = "none";
    }
    if (this.offScreenIndicator) {
      this.offScreenIndicator.style.display = "none";
    }
  }
  showOffScreenIndicator(screenPosition, targetDirection) {
    if (!this.offScreenContainer || !this.offScreenIndicator) return;
    this.offScreenContainer.style.display = "block";
    this.offScreenIndicator.style.display = "block";
    const angle = Math.atan2(targetDirection.y, targetDirection.x) * (180 / Math.PI);
    const margin = 50;
    const halfWidth = window.innerWidth / 2;
    const halfHeight = window.innerHeight / 2;
    const normalizedDir = new Vector2(targetDirection.x, targetDirection.y).normalize();
    let edgeX, edgeY;
    const slopeRatio = Math.abs(normalizedDir.y / normalizedDir.x);
    const screenRatio = halfHeight / halfWidth;
    if (slopeRatio > screenRatio) {
      edgeY = normalizedDir.y > 0 ? halfHeight - margin : -halfHeight + margin;
      edgeX = edgeY / normalizedDir.y * normalizedDir.x;
    } else {
      edgeX = normalizedDir.x > 0 ? halfWidth - margin : -halfWidth + margin;
      edgeY = edgeX / normalizedDir.x * normalizedDir.y;
    }
    this.offScreenIndicator.style.left = halfWidth + edgeX + "px";
    this.offScreenIndicator.style.top = halfHeight + edgeY + "px";
    this.offScreenIndicator.style.transform = `rotate(${angle}deg)`;
  }
  // Helper methods for screen position calculations
  isTargetOnScreen() {
    if (!this.targetAsteroid || !this.targetAsteroid.mesh) return false;
    const screenPosition = this.getScreenPosition(this.targetAsteroid.mesh.position);
    const margin = 0.1;
    return screenPosition.x >= -1 + margin && screenPosition.x <= 1 - margin && screenPosition.y >= -1 + margin && screenPosition.y <= 1 - margin;
  }
  getScreenPosition(worldPosition) {
    const tempVector = new Vector3().copy(worldPosition);
    tempVector.project(this.scene.camera);
    return new Vector2(tempVector.x, tempVector.y);
  }
  getTargetDirection() {
    const screenPosition = this.getScreenPosition(this.targetAsteroid.mesh.position);
    return new Vector2(screenPosition.x, screenPosition.y);
  }
}
class ProximityDetector {
  constructor() {
    this.nearStargate = false;
  }
  // Check if spaceship is within docking range of stargate
  checkStargateProximity(spaceship, stargate, ui) {
    if (spaceship.isDocked) return;
    if (!stargate || !spaceship || !spaceship.mesh) return;
    const stargatePosition = stargate.getPosition();
    if (!stargatePosition) return;
    const distance = spaceship.mesh.position.distanceTo(stargatePosition);
    if (distance < 2e3) {
      this.nearStargate = true;
      if (ui && ui.stargateInterface) {
        ui.stargateInterface.showDockingPrompt();
      }
      if (ui && ui.controls && ui.controls.isMobile && ui.controls.touchControls) {
        ui.controls.touchControls.showDockButton();
      }
    } else {
      this.nearStargate = false;
      if (ui && ui.stargateInterface) {
        ui.stargateInterface.hideDockingPrompt();
      }
      if (ui && ui.controls && ui.controls.isMobile && ui.controls.touchControls) {
        ui.controls.touchControls.hideDockButton();
      }
    }
  }
  isNearStargate() {
    return this.nearStargate;
  }
}
class DockingLogic {
  constructor() {
    this.isDocked = false;
    this.dockingAvailable = false;
    this.autoPointerLockOnUndock = true;
    this.preUndockShieldValue = 0;
  }
  // Method to detect mobile devices
  isMobileDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.innerWidth < 900;
  }
  dockWithStargate(spaceship, stargate, ui) {
    console.log("Docking with stargate");
    if (!spaceship.isDocked) {
      spaceship.dock();
      this.isDocked = true;
      if (spaceship.world && spaceship.world.messageBus) {
        spaceship.world.messageBus.publish("player.docked", {
          playerPosition: spaceship.mesh.position.clone(),
          stargate
        });
        console.log("Published player.docked event");
      }
    } else {
      console.log("Ship is already docked, just showing UI");
    }
    if (this.isMobileDevice()) {
      console.log("Mobile device detected - preparing for stargate UI");
      document.body.classList.remove("undocking", "modal-open");
      document.body.style.position = "static";
      document.body.style.touchAction = "auto";
      document.body.style.pointerEvents = "auto";
      document.body.style.overflow = "auto";
    }
    if (ui && ui.stargateInterface) {
      console.log("Showing stargate UI...");
      ui.stargateInterface.showStargateUI();
      if (this.isMobileDevice()) {
        setTimeout(() => {
          const stargateUI = document.getElementById("stargate-ui");
          if (stargateUI && stargateUI.style.display !== "block") {
            console.log("Forcing stargate UI display");
            stargateUI.style.display = "block";
          }
        }, 100);
      }
    }
    if (ui) {
      ui.hideUI();
    }
    if (document.pointerLockElement) {
      document.exitPointerLock();
      console.log("Exited pointer lock for UI interaction");
    }
  }
  // Helper to wrap steps in requestAnimationFrame for smoother UI updates
  async performStep(stepFunction, stepName) {
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        try {
          stepFunction();
          console.log(`Completed step: ${stepName}`);
        } catch (err) {
          console.error(`Error during step ${stepName}:`, err);
        }
        resolve();
      });
    });
  }
  // Helper to yield control to the browser
  async yieldToBrowser() {
    return new Promise((resolve) => requestAnimationFrame(resolve));
  }
  // Optimized method to reset mobile styles
  resetMobileStyles() {
    if (this.isMobileDevice()) {
      document.body.classList.remove("undocking", "modal-open");
    }
    requestAnimationFrame(() => {
      document.body.style.cssText = "";
      document.body.style.overflow = "auto";
      document.body.style.position = "static";
      document.body.style.height = "auto";
      document.body.style.width = "auto";
      document.body.style.touchAction = "auto";
      document.body.style.pointerEvents = "auto";
      document.body.style.webkitOverflowScrolling = "touch";
      document.body.classList.remove("modal-open", "undocking");
      document.querySelectorAll(".modal-content, #stargate-ui, #star-map").forEach((container) => {
        if (container && container.style) {
          container.style.cssText = "overflow: auto; -webkit-overflow-scrolling: touch;";
          container.scrollTop = 0;
        }
      });
    });
  }
  // Helper method to request pointer lock
  requestPointerLock() {
    const canvas = document.querySelector("canvas");
    if (canvas && !document.pointerLockElement) {
      setTimeout(() => {
        canvas.requestPointerLock();
        console.log("Requested pointer lock for ship control");
      }, 200);
    }
  }
  async undockFromStargate(spaceship, ui, closeAllModalsCallback, hideStargateUICallback, showGameUICallback) {
    var _a;
    if (!spaceship.isDocked) {
      console.log("Not docked, can't undock");
      return;
    }
    if (this.isMobileDevice()) {
      document.body.classList.remove("undocking");
      this.resetMobileStyles();
    }
    const loadingIndicator = document.createElement("div");
    loadingIndicator.className = "undocking-indicator";
    loadingIndicator.textContent = "Undocking...";
    document.body.appendChild(loadingIndicator);
    try {
      console.log("Starting undock sequence...");
      this.preUndockShieldValue = spaceship.shield;
      console.log(`Storing pre-undock shield value: ${this.preUndockShieldValue}`);
      await this.performStep(() => closeAllModalsCallback(), "Closing modals");
      await this.yieldToBrowser();
      if (this.isMobileDevice()) {
        await this.performStep(() => this.resetMobileStyles(), "Resetting mobile styles");
        await this.yieldToBrowser();
      }
      await this.performStep(() => hideStargateUICallback(), "Hiding stargate UI");
      await this.yieldToBrowser();
      await this.performStep(() => showGameUICallback(), "Showing game UI");
      await this.yieldToBrowser();
      console.log("Performing core undock...");
      const newPosition = spaceship.undock();
      console.log("Syncing health values...");
      if (spaceship.shield === 0 && this.preUndockShieldValue > 0) {
        console.log(`Fixing shield reset: Restoring to ${this.preUndockShieldValue}`);
        spaceship.shield = this.preUndockShieldValue;
      }
      spaceship.syncValuesToHealthComponent();
      const healthData = {
        shield: spaceship.shield,
        maxShield: spaceship.maxShield,
        hull: spaceship.hull,
        maxHull: spaceship.maxHull
      };
      const messageBus = ((_a = window.game) == null ? void 0 : _a.messageBus) || window.mainMessageBus;
      if (messageBus) {
        messageBus.publish("player.undocked", healthData);
        console.log("Published player.undocked event with health values:", healthData);
      }
      this.dockingAvailable = false;
      if (this.autoPointerLockOnUndock && !this.isMobileDevice()) {
        await this.performStep(() => this.requestPointerLock(), "Requesting pointer lock");
      }
      console.log("Undock sequence complete");
    } catch (error) {
      console.error("Error during undocking:", error);
    } finally {
      if (document.body.contains(loadingIndicator)) {
        document.body.removeChild(loadingIndicator);
      }
      if (this.isMobileDevice()) {
        document.body.classList.remove("undocking", "modal-open");
        this.resetMobileStyles();
        document.body.style.pointerEvents = "";
        document.body.style.touchAction = "";
        document.body.style.overflowY = "";
        document.body.style.position = "";
      } else {
        document.body.classList.remove("undocking");
      }
    }
  }
}
class UIIntegration {
  constructor() {
    this.resources = null;
  }
  setupDockingControls(proximityDetector, dockingLogic, spaceship, ui) {
    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "q") {
        if (proximityDetector.isNearStargate() && !spaceship.isDocked) {
          console.log("Q key pressed: Docking with stargate");
          dockingLogic.dockWithStargate(spaceship, ui.stargate, ui);
        } else if (spaceship.isDocked) {
          console.log("Q key pressed while docked: No action (use Undock button)");
        } else if (!proximityDetector.isNearStargate()) {
          console.log("Q key pressed but not near stargate");
        }
      }
    });
    this.setupStargateUIControls(spaceship, ui);
  }
  setupStargateUIControls(spaceship, ui) {
    const refuelBtn = document.getElementById("refuel-btn");
    if (refuelBtn) {
      refuelBtn.addEventListener("click", () => {
        if (spaceship.credits >= 100) {
          spaceship.credits -= spaceship.refuel();
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
    const repairShieldBtn = document.getElementById("repair-shield-btn");
    if (repairShieldBtn) {
      repairShieldBtn.addEventListener("click", () => {
        if (spaceship.credits >= 150) {
          spaceship.credits -= spaceship.repairShield();
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
    const repairHullBtn = document.getElementById("repair-hull-btn");
    if (repairHullBtn) {
      repairHullBtn.addEventListener("click", () => {
        if (spaceship.credits >= 200) {
          spaceship.credits -= spaceship.repairHull();
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
    this.setupUndockButton();
    this.setupSellingButtons(spaceship, ui);
    this.setupUpgradeButtons(spaceship, ui);
  }
  setupUndockButton() {
    const undockBtn = document.getElementById("undock-btn");
    if (undockBtn) {
      undockBtn.addEventListener("touchstart", (e) => {
        console.log("Touch started on undock button");
        e.stopPropagation();
      }, { passive: false });
    }
  }
  setupSellingButtons(spaceship, ui) {
    const sellIronBtn = document.getElementById("sell-iron");
    if (sellIronBtn) {
      sellIronBtn.addEventListener("click", () => {
        if (this.resources.iron > 0) {
          spaceship.credits += this.resources.iron * 10;
          this.resources.iron = 0;
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
    const sellGoldBtn = document.getElementById("sell-gold");
    if (sellGoldBtn) {
      sellGoldBtn.addEventListener("click", () => {
        if (this.resources.gold > 0) {
          spaceship.credits += this.resources.gold * 50;
          this.resources.gold = 0;
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
    const sellPlatinumBtn = document.getElementById("sell-platinum");
    if (sellPlatinumBtn) {
      sellPlatinumBtn.addEventListener("click", () => {
        if (this.resources.platinum > 0) {
          spaceship.credits += this.resources.platinum * 200;
          this.resources.platinum = 0;
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
  }
  setupUpgradeButtons(spaceship, ui) {
    this.setupUpgradeButton(
      "upgrade-fuel-tank",
      () => spaceship.fuelUpgradeCost,
      () => spaceship.upgradeFuelTank(),
      spaceship,
      ui
    );
    this.setupUpgradeButton(
      "upgrade-engine",
      () => spaceship.engineUpgradeCost,
      () => spaceship.upgradeEngine(),
      spaceship,
      ui
    );
    this.setupUpgradeButton(
      "upgrade-mining",
      () => spaceship.miningUpgradeCost,
      () => spaceship.upgradeMiningLaser(),
      spaceship,
      ui
    );
    this.setupUpgradeButton(
      "upgrade-hull",
      () => spaceship.hullUpgradeCost,
      () => spaceship.upgradeHull(),
      spaceship,
      ui
    );
    this.setupUpgradeButton(
      "upgrade-scanner",
      () => spaceship.scannerUpgradeCost,
      () => spaceship.upgradeScanner(),
      spaceship,
      ui
    );
  }
  // Helper method to set up an upgrade button with a given cost getter and upgrade function
  setupUpgradeButton(buttonId, costGetter, upgradeFunction, spaceship, ui) {
    const button = document.getElementById(buttonId);
    if (button) {
      button.addEventListener("click", () => {
        const cost = costGetter();
        if (spaceship.credits >= cost) {
          spaceship.credits -= cost;
          upgradeFunction();
          if (buttonId === "upgrade-mining" && this.updateMiningSystem) {
            this.updateMiningSystem(spaceship, ui);
          }
          this.updateStargateUI(spaceship, ui);
        }
      });
    }
  }
  // Method to update the mining system when mining efficiency is upgraded
  updateMiningSystem(spaceship, ui) {
    if (ui && ui.controls && ui.controls.miningSystem) {
      const miningSystem = ui.controls.miningSystem;
      Object.keys(miningSystem.miningSpeedByType).forEach((resourceType) => {
        const baseSpeed = miningSystem.miningSpeedByType[resourceType];
        miningSystem.miningSpeedByType[resourceType] = baseSpeed * spaceship.miningEfficiency;
      });
      console.log("Mining system updated with new efficiency:", spaceship.miningEfficiency);
    }
  }
  updateStargateUI(spaceship, ui) {
    if (ui && ui.stargateInterface) {
      ui.stargateInterface.updateStargateUI(spaceship, this.resources);
    }
  }
  // Optimized method to hide UI elements using a single reflow
  hideStargateUI(ui) {
    if (ui && ui.stargateInterface) {
      document.body.classList.add("undocking");
      ui.stargateInterface.hideStargateUI();
      console.log("Hiding stargate interface");
    }
  }
  // Optimized method to show game UI elements using a single reflow
  showGameUI(ui) {
    if (ui) {
      document.body.classList.remove("undocking");
      ui.showUI();
      console.log("Showing game UI");
    }
  }
  // Method to close any open modal UI that might conflict with undocking
  closeAllModals() {
    try {
      const customSystemCreator2 = document.getElementById("custom-system-creator");
      if (customSystemCreator2 && window.getComputedStyle(customSystemCreator2).display !== "none") {
        console.log("Closing custom system creator before undocking");
        const closeBtn = customSystemCreator2.querySelector("#close-system-creator");
        if (closeBtn) {
          closeBtn.click();
        } else {
          customSystemCreator2.style.display = "none";
        }
        if (window.game && window.game.ui) {
          if (window.game.ui.starMap && typeof window.game.ui.starMap.hide === "function") {
            window.game.ui.starMap.hide();
          }
          if (window.game.ui.customSystemCreator && typeof window.game.ui.customSystemCreator.hide === "function") {
            window.game.ui.customSystemCreator.hide();
          }
          document.body.classList.remove("modal-open");
        }
      }
      const starMap = document.getElementById("star-map");
      if (starMap && window.getComputedStyle(starMap).display !== "none") {
        console.log("Closing star map before undocking");
        const closeStarMapBtn = starMap.querySelector("#close-star-map");
        if (closeStarMapBtn) {
          closeStarMapBtn.click();
        } else {
          starMap.style.display = "none";
        }
      }
      const allModals = document.querySelectorAll(".modal-container");
      allModals.forEach((modal) => {
        if (window.getComputedStyle(modal).display !== "none") {
          console.log("Closing modal before undocking:", modal.id || "unnamed modal");
          modal.style.display = "none";
        }
      });
    } catch (err) {
      console.warn("Error while closing modals:", err);
    }
  }
  // Setter for resources to allow dependency injection
  setResources(resources) {
    this.resources = resources;
  }
}
class DockingSystem {
  constructor(spaceship, stargate, ui) {
    this.spaceship = spaceship;
    this.stargate = stargate;
    this.ui = ui;
    this.proximityDetector = new ProximityDetector();
    this.dockingLogic = new DockingLogic();
    this.uiIntegration = new UIIntegration();
    this.isDocked = this.spaceship.isDocked;
    if (this.spaceship && this.spaceship.undockLocation && this.stargate) {
      this.spaceship.undockLocation.set(0, 1e4, 0);
    }
    console.log("Initializing docking system, ship is " + (this.isDocked ? "docked" : "undocked"));
    this.setupDockingControls();
    if (this.isDocked && this.spaceship.world && this.spaceship.world.messageBus) {
      this.spaceship.world.messageBus.publish("player.docked", {
        playerPosition: this.spaceship.mesh ? this.spaceship.mesh.position.clone() : null,
        stargate: this.stargate
      });
      console.log("Published initial player.docked event");
    }
  }
  setupDockingControls() {
    this.uiIntegration.setupDockingControls(
      this.proximityDetector,
      this.dockingLogic,
      this.spaceship,
      this.ui
    );
    this.setupUndockButton();
  }
  setupStargateUIControls() {
    this.uiIntegration.setupStargateUIControls(this.spaceship, this.ui);
  }
  setupUndockButton() {
    const undockBtn = document.getElementById("undock-btn");
    if (undockBtn) {
      const handleUndock = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log(`Undock button ${e.type} event triggered`);
        if (this.dockingLogic.isMobileDevice()) {
          document.body.classList.remove("undocking", "modal-open");
          setTimeout(() => {
            this.undockFromStargate();
          }, 50);
        } else {
          this.undockFromStargate();
        }
      };
      undockBtn.addEventListener("click", handleUndock);
      undockBtn.addEventListener("touchend", handleUndock);
    }
  }
  dockWithStargate() {
    this.dockingLogic.dockWithStargate(this.spaceship, this.stargate, this.ui);
    this.isDocked = true;
    this.updateStargateUI();
  }
  async undockFromStargate() {
    await this.dockingLogic.undockFromStargate(
      this.spaceship,
      this.ui,
      () => this.uiIntegration.closeAllModals(),
      () => this.uiIntegration.hideStargateUI(this.ui),
      () => this.uiIntegration.showGameUI(this.ui)
    );
    this.isDocked = false;
  }
  updateStargateUI() {
    this.uiIntegration.updateStargateUI(this.spaceship, this.ui);
  }
  checkStargateProximity() {
    this.proximityDetector.checkStargateProximity(this.spaceship, this.stargate, this.ui);
    this.nearStargate = this.proximityDetector.isNearStargate();
  }
  update() {
    this.checkStargateProximity();
  }
  // Setter for resources to allow dependency injection
  setResources(resources) {
    this.resources = resources;
    this.uiIntegration.setResources(resources);
  }
}
class JoystickZones {
  constructor() {
    this.leftJoystickZone = null;
    this.rightJoystickZone = null;
  }
  createJoystickZones() {
    this.createLeftJoystickZone();
    this.createRightJoystickZone();
    return {
      leftZone: this.leftJoystickZone,
      rightZone: this.rightJoystickZone
    };
  }
  createLeftJoystickZone() {
    const leftJoystickZone = document.createElement("div");
    leftJoystickZone.id = "leftJoystickZone";
    leftJoystickZone.style.position = "absolute";
    leftJoystickZone.style.bottom = "50px";
    leftJoystickZone.style.left = "50px";
    leftJoystickZone.style.width = "100px";
    leftJoystickZone.style.height = "100px";
    leftJoystickZone.style.zIndex = "1000";
    leftJoystickZone.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
    leftJoystickZone.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
    leftJoystickZone.addEventListener("touchend", (e) => e.preventDefault(), { passive: false });
    document.body.appendChild(leftJoystickZone);
    this.leftJoystickZone = leftJoystickZone;
    return leftJoystickZone;
  }
  createRightJoystickZone() {
    const rightJoystickZone = document.createElement("div");
    rightJoystickZone.id = "rightJoystickZone";
    rightJoystickZone.style.position = "absolute";
    rightJoystickZone.style.bottom = "50px";
    rightJoystickZone.style.right = "50px";
    rightJoystickZone.style.width = "100px";
    rightJoystickZone.style.height = "100px";
    rightJoystickZone.style.zIndex = "1000";
    rightJoystickZone.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
    rightJoystickZone.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
    rightJoystickZone.addEventListener("touchend", (e) => e.preventDefault(), { passive: false });
    document.body.appendChild(rightJoystickZone);
    this.rightJoystickZone = rightJoystickZone;
    return rightJoystickZone;
  }
  hideZones() {
    if (this.leftJoystickZone) this.leftJoystickZone.style.display = "none";
    if (this.rightJoystickZone) this.rightJoystickZone.style.display = "none";
  }
  showZones() {
    if (this.leftJoystickZone) this.leftJoystickZone.style.display = "block";
    if (this.rightJoystickZone) this.rightJoystickZone.style.display = "block";
  }
  getLeftZone() {
    return this.leftJoystickZone;
  }
  getRightZone() {
    return this.rightJoystickZone;
  }
}
class ActionButtons {
  constructor() {
    this.buttons = {
      fire: null,
      mine: null,
      target: null,
      dock: null,
      deployLaser: null
    };
    this.containers = {
      left: null,
      right: null
    };
  }
  createActionButtons() {
    this.createButtonContainers();
    this.createFireButton();
    this.createMineButton();
    this.createTargetButton();
    this.createDockButton();
    this.createDeployLaserButton();
    return this.buttons;
  }
  createButtonContainers() {
    const leftActionButtonsContainer = document.createElement("div");
    leftActionButtonsContainer.id = "mobile-action-buttons-left";
    leftActionButtonsContainer.style.position = "absolute";
    leftActionButtonsContainer.style.bottom = "170px";
    leftActionButtonsContainer.style.left = "20px";
    leftActionButtonsContainer.style.display = "flex";
    leftActionButtonsContainer.style.flexDirection = "column";
    leftActionButtonsContainer.style.gap = "15px";
    leftActionButtonsContainer.style.zIndex = "1000";
    document.body.appendChild(leftActionButtonsContainer);
    this.containers.left = leftActionButtonsContainer;
    const rightActionButtonsContainer = document.createElement("div");
    rightActionButtonsContainer.id = "mobile-action-buttons-right";
    rightActionButtonsContainer.style.position = "absolute";
    rightActionButtonsContainer.style.bottom = "170px";
    rightActionButtonsContainer.style.right = "20px";
    rightActionButtonsContainer.style.display = "flex";
    rightActionButtonsContainer.style.flexDirection = "column";
    rightActionButtonsContainer.style.gap = "15px";
    rightActionButtonsContainer.style.zIndex = "1000";
    document.body.appendChild(rightActionButtonsContainer);
    this.containers.right = rightActionButtonsContainer;
  }
  createFireButton() {
    this.buttons.fire = this.createActionButton(this.containers.left, "FIRE", "rgba(255, 80, 80, 0.8)");
    return this.buttons.fire;
  }
  createMineButton() {
    this.buttons.mine = this.createActionButton(this.containers.left, "MINE", "rgba(120, 220, 232, 0.8)");
    return this.buttons.mine;
  }
  createTargetButton() {
    this.buttons.target = this.createActionButton(this.containers.right, "TARGET", "rgba(255, 215, 0, 0.8)");
    return this.buttons.target;
  }
  createDockButton() {
    this.buttons.dock = this.createActionButton(null, "DOCK", "rgba(51, 153, 255, 0.8)");
    this.buttons.dock.style.position = "absolute";
    this.buttons.dock.style.top = "50%";
    this.buttons.dock.style.left = "50%";
    this.buttons.dock.style.transform = "translate(-50%, -50%)";
    this.buttons.dock.style.width = "100px";
    this.buttons.dock.style.height = "100px";
    this.buttons.dock.style.fontSize = "20px";
    this.buttons.dock.style.boxShadow = "0 0 25px rgba(51, 153, 255, 0.8)";
    this.buttons.dock.style.zIndex = "10000";
    this.buttons.dock.style.display = "none";
    document.body.appendChild(this.buttons.dock);
    return this.buttons.dock;
  }
  createDeployLaserButton() {
    this.buttons.deployLaser = this.createActionButton(this.containers.right, "DEPLOY", "rgba(255, 100, 100, 0.8)");
    return this.buttons.deployLaser;
  }
  createActionButton(parent, text, color) {
    const button = document.createElement("div");
    button.className = "mobile-action-button";
    button.textContent = text;
    button.style.width = "60px";
    button.style.height = "60px";
    button.style.borderRadius = "50%";
    button.style.backgroundColor = "rgba(10, 20, 30, 0.7)";
    button.style.border = `2px solid ${color}`;
    button.style.color = color;
    button.style.display = "flex";
    button.style.justifyContent = "center";
    button.style.alignItems = "center";
    button.style.fontFamily = '"Rajdhani", sans-serif';
    button.style.fontSize = "16px";
    button.style.fontWeight = "bold";
    button.style.boxShadow = `0 0 10px ${color}`;
    button.style.userSelect = "none";
    button.style.touchAction = "manipulation";
    button.style.cursor = "pointer";
    button.style.transform = "translateZ(0)";
    button.style.webkitTapHighlightColor = "transparent";
    button.style.backfaceVisibility = "hidden";
    if (parent) {
      parent.appendChild(button);
    }
    return button;
  }
  showDockButton() {
    if (this.buttons.dock) {
      this.buttons.dock.style.display = "flex";
      this.buttons.dock.style.zIndex = "10000";
      this.buttons.dock.style.position = "absolute";
      this.buttons.dock.style.top = "50%";
      this.buttons.dock.style.left = "50%";
      console.log("Showing dock button - near stargate");
      if (!this.buttons.dock.style.animation) {
        this.buttons.dock.style.animation = "pulse 1.5s infinite";
        if (!document.getElementById("mobile-pulse-animation")) {
          const style = document.createElement("style");
          style.id = "mobile-pulse-animation";
          style.textContent = `
                        @keyframes pulse {
                            0% { transform: translate(-50%, -50%) scale(1); }
                            50% { transform: translate(-50%, -50%) scale(1.1); }
                            100% { transform: translate(-50%, -50%) scale(1); }
                        }
                    `;
          document.head.appendChild(style);
        }
      }
      console.log("Dock button shown with styles:", {
        display: this.buttons.dock.style.display,
        zIndex: this.buttons.dock.style.zIndex,
        position: this.buttons.dock.style.position,
        width: this.buttons.dock.style.width,
        height: this.buttons.dock.style.height
      });
    }
  }
  hideDockButton() {
    if (this.buttons.dock) {
      this.buttons.dock.style.display = "none";
    }
  }
  hideButtons() {
    if (this.containers.left) this.containers.left.style.display = "none";
    if (this.containers.right) this.containers.right.style.display = "none";
    this.hideDockButton();
  }
  showButtons() {
    if (this.containers.left) this.containers.left.style.display = "flex";
    if (this.containers.right) this.containers.right.style.display = "flex";
  }
  // Helper method to add events to buttons
  addButtonEvents(button, startHandler, endHandler = null) {
    if (!button) {
      console.error("ActionButtons: Cannot add events to null button");
      return;
    }
    if (endHandler) {
      button.addEventListener("touchstart", (e) => {
        e.preventDefault();
        button.style.transform = "scale(0.95) translateZ(0)";
        startHandler();
      }, { passive: false });
      button.addEventListener("touchend", (e) => {
        e.preventDefault();
        button.style.transform = "scale(1) translateZ(0)";
        endHandler();
      }, { passive: false });
      button.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        if (e.pointerType === "touch") return;
        button.style.transform = "scale(0.95) translateZ(0)";
        startHandler();
      });
      button.addEventListener("pointerup", (e) => {
        e.preventDefault();
        if (e.pointerType === "touch") return;
        button.style.transform = "scale(1) translateZ(0)";
        endHandler();
      });
      button.addEventListener("mousedown", (e) => {
        button.style.transform = "scale(0.95) translateZ(0)";
        startHandler();
      });
      button.addEventListener("mouseup", (e) => {
        button.style.transform = "scale(1) translateZ(0)";
        endHandler();
      });
    } else {
      button.addEventListener("touchstart", (e) => {
        e.preventDefault();
        button.style.transform = "scale(0.95) translateZ(0)";
        if (button === this.buttons.dock) {
          console.log("Dock button touchstart event fired");
        }
      }, { passive: false });
      button.addEventListener("touchend", (e) => {
        e.preventDefault();
        button.style.transform = "scale(1) translateZ(0)";
        if (button === this.buttons.dock) {
          console.log("Dock button touchend event fired, calling handler");
        }
        startHandler();
      }, { passive: false });
      button.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        if (e.pointerType === "touch") return;
        button.style.transform = "scale(0.95) translateZ(0)";
        if (button === this.buttons.dock) {
          console.log("Dock button pointerdown event fired");
        }
      });
      button.addEventListener("pointerup", (e) => {
        e.preventDefault();
        if (e.pointerType === "touch") return;
        button.style.transform = "scale(1) translateZ(0)";
        if (button === this.buttons.dock) {
          console.log("Dock button pointerup event fired, calling handler");
        }
        startHandler();
      });
      button.addEventListener("mousedown", (e) => {
        button.style.transform = "scale(0.95) translateZ(0)";
      });
      button.addEventListener("mouseup", (e) => {
        button.style.transform = "scale(1) translateZ(0)";
        startHandler();
      });
    }
  }
}
class JoystickHandler {
  constructor(spaceship, physics) {
    this.spaceship = spaceship;
    this.physics = physics;
    this.leftJoystick = null;
    this.rightJoystick = null;
    this.threshold = 0.1;
    this.isNippleLoaded = false;
  }
  async loadNippleJS() {
    return new Promise((resolve, reject) => {
      if (window.nipplejs) {
        this.isNippleLoaded = true;
        resolve();
        return;
      }
      const script = document.createElement("script");
      script.src = "https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js";
      script.async = true;
      script.onload = () => {
        this.isNippleLoaded = true;
        resolve();
      };
      script.onerror = () => reject(new Error("Failed to load nipple.js"));
      document.head.appendChild(script);
    });
  }
  initializeJoysticks(leftZone, rightZone) {
    if (!window.nipplejs || !this.isNippleLoaded) {
      console.error("nipplejs is not loaded");
      return false;
    }
    this.leftJoystick = window.nipplejs.create({
      zone: leftZone,
      mode: "static",
      position: { left: "50%", top: "50%" },
      color: "rgba(120, 220, 232, 0.8)",
      size: 100,
      threshold: this.threshold,
      dynamicPage: true,
      // Better performance for scrolling
      fadeTime: 100,
      // Faster fade for better performance
      lockX: false,
      // Allow X-axis movement
      lockY: false
      // Allow Y-axis movement
    });
    this.rightJoystick = window.nipplejs.create({
      zone: rightZone,
      mode: "static",
      position: { left: "50%", top: "50%" },
      color: "rgba(120, 220, 232, 0.8)",
      size: 100,
      threshold: this.threshold,
      dynamicPage: true,
      // Better performance for scrolling
      fadeTime: 100,
      // Faster fade for better performance
      lockX: false,
      // Allow X-axis movement
      lockY: false
      // Allow Y-axis movement
    });
    this.setupJoystickEvents();
    return true;
  }
  setupJoystickEvents() {
    if (!this.leftJoystick || !this.rightJoystick) {
      console.error("Joysticks not initialized");
      return;
    }
    this.leftJoystick.on("move", (evt, data) => {
      this.handleThrustJoystick(data);
    }).on("end", () => {
      this.resetThrust();
    });
    this.rightJoystick.on("move", (evt, data) => {
      this.handleRotationJoystick(data);
    }).on("end", () => {
    });
  }
  handleThrustJoystick(data) {
    if (this.spaceship.isDocked) return;
    this.resetThrust();
    const force = data.force > 2 ? 2 : data.force;
    const angle = data.angle.radian;
    if (angle > 1 && angle < 2) {
      this.spaceship.thrust.forward = true;
    } else if (angle > 4 && angle < 5.5) {
      this.spaceship.thrust.backward = true;
    }
    if (angle > 2.5 && angle < 4) {
      this.spaceship.thrust.left = true;
    } else if (angle >= 0 && angle < 1 || angle > 5.5) {
      this.spaceship.thrust.right = true;
    }
    this.spaceship.thrust.boost = force > 1.5;
  }
  handleRotationJoystick(data) {
    if (this.spaceship.isDocked) return;
    const xMove = data.vector.x * data.force * 0.015;
    const yMove = -data.vector.y * data.force * 0.015;
    this.physics.updateRotation(xMove, yMove);
  }
  resetThrust() {
    if (!this.spaceship) return;
    this.spaceship.thrust.forward = false;
    this.spaceship.thrust.backward = false;
    this.spaceship.thrust.left = false;
    this.spaceship.thrust.right = false;
    this.spaceship.thrust.boost = false;
  }
  destroy() {
    if (this.leftJoystick) {
      this.leftJoystick.destroy();
      this.leftJoystick = null;
    }
    if (this.rightJoystick) {
      this.rightJoystick.destroy();
      this.rightJoystick = null;
    }
  }
}
class GestureDetector {
  constructor() {
    this.isEnabled = false;
    this.gestureCallbacks = /* @__PURE__ */ new Map();
    this.touchStartTime = 0;
    this.touchStartPos = { x: 0, y: 0 };
    this.touchEndPos = { x: 0, y: 0 };
    this.swipeThreshold = 50;
    this.tapTimeout = 300;
  }
  enable() {
    if (this.isEnabled) return;
    this.isEnabled = true;
    document.addEventListener("touchstart", this.handleTouchStart.bind(this), { passive: false });
    document.addEventListener("touchmove", this.handleTouchMove.bind(this), { passive: false });
    document.addEventListener("touchend", this.handleTouchEnd.bind(this), { passive: false });
  }
  disable() {
    if (!this.isEnabled) return;
    this.isEnabled = false;
    document.removeEventListener("touchstart", this.handleTouchStart.bind(this));
    document.removeEventListener("touchmove", this.handleTouchMove.bind(this));
    document.removeEventListener("touchend", this.handleTouchEnd.bind(this));
  }
  handleTouchStart(event) {
    if (!this.isEnabled) return;
    if (this.isTouchOnUIElement(event.target)) return;
    const touch = event.touches[0];
    this.touchStartTime = Date.now();
    this.touchStartPos = {
      x: touch.clientX,
      y: touch.clientY
    };
  }
  handleTouchMove(event) {
    if (!this.isEnabled) return;
    if (this.isTouchOnUIElement(event.target)) return;
    event.preventDefault();
  }
  handleTouchEnd(event) {
    if (!this.isEnabled) return;
    if (this.isTouchOnUIElement(event.target)) return;
    const touch = event.changedTouches[0];
    this.touchEndPos = {
      x: touch.clientX,
      y: touch.clientY
    };
    const touchDuration = Date.now() - this.touchStartTime;
    const distance = this.calculateDistance(this.touchStartPos, this.touchEndPos);
    if (touchDuration <= this.tapTimeout && distance < this.swipeThreshold) {
      this.triggerGesture("tap", {
        position: this.touchEndPos,
        duration: touchDuration
      });
    } else if (distance >= this.swipeThreshold) {
      const direction = this.getSwipeDirection(this.touchStartPos, this.touchEndPos);
      this.triggerGesture("swipe", {
        direction,
        distance,
        duration: touchDuration,
        startPos: this.touchStartPos,
        endPos: this.touchEndPos
      });
    }
  }
  isTouchOnUIElement(target) {
    const uiSelectors = [
      "#leftJoystickZone",
      "#rightJoystickZone",
      "#mobile-action-buttons-left",
      "#mobile-action-buttons-right",
      ".mobile-action-button"
    ];
    for (const selector of uiSelectors) {
      if (target.closest && target.closest(selector)) {
        return true;
      }
    }
    return false;
  }
  calculateDistance(pos1, pos2) {
    const dx = pos2.x - pos1.x;
    const dy = pos2.y - pos1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  getSwipeDirection(startPos, endPos) {
    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? "right" : "left";
    } else {
      return dy > 0 ? "down" : "up";
    }
  }
  triggerGesture(gestureType, data) {
    const callback = this.gestureCallbacks.get(gestureType);
    if (callback && typeof callback === "function") {
      callback(data);
    }
  }
  // Register callbacks for specific gestures
  onGesture(gestureType, callback) {
    this.gestureCallbacks.set(gestureType, callback);
  }
  // Remove gesture callback
  offGesture(gestureType) {
    this.gestureCallbacks.delete(gestureType);
  }
  // Clear all gesture callbacks
  clearGestures() {
    this.gestureCallbacks.clear();
  }
}
class MiningHandler {
  constructor(spaceship) {
    this.spaceship = spaceship;
    this.miningSystem = null;
    this.targetingSystem = null;
  }
  setMiningSystem(miningSystem) {
    this.miningSystem = miningSystem;
  }
  setTargetingSystem(targetingSystem) {
    this.targetingSystem = targetingSystem;
  }
  handleMiningStart() {
    try {
      console.log("MiningHandler: handleMiningStart called");
      if (!this.targetingSystem) {
        console.error("MiningHandler: Targeting system not available");
        return;
      }
      if (!this.miningSystem) {
        console.error("MiningHandler: Mining system not available");
        return;
      }
      let targetAsteroid = this.targetingSystem.getCurrentTarget();
      console.log("MiningHandler: Initial target:", targetAsteroid);
      if (!targetAsteroid) {
        console.log("MiningHandler: No target selected, enabling targeting and finding nearest target");
        if (!this.targetingSystem.isLockOnEnabled()) {
          this.targetingSystem.toggleLockOn();
        }
        targetAsteroid = this.targetingSystem.findNearestTarget();
        console.log("MiningHandler: Found nearest target:", targetAsteroid);
        if (!targetAsteroid) {
          console.log("MiningHandler: No targets in range after scan");
          return;
        }
      }
      if (!targetAsteroid || !targetAsteroid.mesh || !targetAsteroid.mesh.position) {
        console.error("MiningHandler: Target asteroid is missing required properties", targetAsteroid);
        const game = window.gameInstance || window.game;
        if (game && game.environment && game.environment.asteroids && game.environment.asteroids.length > 0) {
          console.log("MiningHandler: Attempting to get asteroid directly from environment");
          let closestDist = Infinity;
          let closestAsteroid = null;
          for (const asteroid of game.environment.asteroids) {
            if (asteroid && asteroid.mesh && asteroid.mesh.position && this.spaceship && this.spaceship.mesh) {
              const dist = asteroid.mesh.position.distanceTo(this.spaceship.mesh.position);
              if (dist < closestDist) {
                closestDist = dist;
                closestAsteroid = asteroid;
              }
            }
          }
          if (closestAsteroid) {
            console.log("MiningHandler: Found closest asteroid from environment:", closestAsteroid);
            targetAsteroid = closestAsteroid;
          } else {
            console.error("MiningHandler: Could not find any valid asteroids in environment");
            return;
          }
        } else {
          console.error("MiningHandler: Could not access environment to find asteroids");
          return;
        }
      }
      console.log("MiningHandler: Target asteroid found:", targetAsteroid);
      if (!targetAsteroid || !targetAsteroid.mesh || !targetAsteroid.mesh.position) {
        console.error("MiningHandler: Target asteroid is still invalid after fallback attempts");
        return;
      }
      this.miningSystem.setTargetAsteroid(targetAsteroid);
      console.log("MiningHandler: Target set for mining:", {
        resourceType: targetAsteroid.resourceType || "unknown",
        position: targetAsteroid.mesh ? targetAsteroid.mesh.position.toArray() : "no mesh",
        distance: targetAsteroid.mesh && this.spaceship && this.spaceship.mesh ? targetAsteroid.mesh.position.distanceTo(this.spaceship.mesh.position) : "unknown"
      });
      console.log("MiningHandler: Starting mining operation");
      this.miningSystem.startMining();
      console.log("MiningHandler: Mining started:", this.miningSystem.isMining);
    } catch (error) {
      console.error("MiningHandler: Error in handleMiningStart:", error);
    }
  }
  handleMiningEnd() {
    try {
      console.log("MiningHandler: handleMiningEnd called");
      if (!this.miningSystem) {
        console.error("MiningHandler: Mining system not available for stopping");
        return;
      }
      this.miningSystem.stopMining();
      console.log("MiningHandler: Mining stopped");
    } catch (e) {
      console.error("MiningHandler: Error stopping mining:", e);
    }
  }
}
class WeaponHandler {
  constructor() {
    this.weaponSystem = null;
  }
  setWeaponSystem(weaponSystem) {
    this.weaponSystem = weaponSystem;
  }
  handleFiringStart() {
    try {
      if (this.weaponSystem) {
        if (typeof this.weaponSystem.setFiring === "function") {
          this.weaponSystem.setFiring(true);
        } else {
          this.weaponSystem.isWeaponActive = true;
        }
        const game2 = window.gameInstance || window.game;
        if (game2 && game2.audio) {
          game2.audio.playSound("laser");
        }
        return;
      }
      const game = window.gameInstance || window.game;
      if (!game) {
        console.error("WeaponHandler: No game reference found");
        return;
      }
      if (game.combat) {
        game.combat.setFiring(true);
        if (game.audio) {
          game.audio.playSound("laser");
        }
        return;
      }
      if (game.weaponSystem) {
        if (typeof game.weaponSystem.setFiring === "function") {
          game.weaponSystem.setFiring(true);
        } else {
          game.weaponSystem.isWeaponActive = true;
        }
        if (game.audio) {
          game.audio.playSound("laser");
        }
        return;
      }
      if (game.controls && game.controls.weaponSystem) {
        if (typeof game.controls.weaponSystem.setFiring === "function") {
          game.controls.weaponSystem.setFiring(true);
        } else {
          game.controls.weaponSystem.isWeaponActive = true;
        }
        if (game.audio) {
          game.audio.playSound("laser");
        }
        return;
      }
      console.error("WeaponHandler: No weapon system or combat system found");
    } catch (e) {
      console.error("WeaponHandler: Error in handleFiringStart:", e);
    }
  }
  handleFiringEnd() {
    try {
      if (this.weaponSystem) {
        if (typeof this.weaponSystem.setFiring === "function") {
          this.weaponSystem.setFiring(false);
        } else {
          this.weaponSystem.isWeaponActive = false;
        }
        const game2 = window.gameInstance || window.game;
        if (game2 && game2.audio) {
          game2.audio.stopSound("laser");
        }
        return;
      }
      const game = window.gameInstance || window.game;
      if (!game) {
        console.error("WeaponHandler: No game reference found");
        return;
      }
      if (game.combat) {
        game.combat.setFiring(false);
        if (game.audio) {
          game.audio.stopSound("laser");
        }
        return;
      }
      if (game.weaponSystem) {
        if (typeof game.weaponSystem.setFiring === "function") {
          game.weaponSystem.setFiring(false);
        } else {
          game.weaponSystem.isWeaponActive = false;
        }
        if (game.audio) {
          game.audio.stopSound("laser");
        }
        return;
      }
      if (game.controls && game.controls.weaponSystem) {
        if (typeof game.controls.weaponSystem.setFiring === "function") {
          game.controls.weaponSystem.setFiring(false);
        } else {
          game.controls.weaponSystem.isWeaponActive = false;
        }
        if (game.audio) {
          game.audio.stopSound("laser");
        }
        return;
      }
      console.error("WeaponHandler: No weapon system or combat system found");
    } catch (e) {
      console.error("WeaponHandler: Error in handleFiringEnd:", e);
    }
  }
}
class SystemActions {
  constructor() {
    this.dockingSystem = null;
    this.targetingSystem = null;
  }
  setDockingSystem(dockingSystem) {
    this.dockingSystem = dockingSystem;
  }
  setTargetingSystem(targetingSystem) {
    this.targetingSystem = targetingSystem;
  }
  handleDocking() {
    if (!this.dockingSystem) {
      console.error("SystemActions: Docking system not available");
      return;
    }
    console.log("SystemActions: Dock button pressed, attempting to dock with stargate");
    this.dockingSystem.dockWithStargate();
  }
  handleTargeting() {
    if (!this.targetingSystem) {
      console.error("SystemActions: Targeting system not available");
      return;
    }
    this.targetingSystem.toggleLockOn();
  }
  /**
   * Handle deploying a laser turret
   */
  handleDeployLaser() {
    console.log("SystemActions: Deploying laser turret");
    if (window.mainMessageBus) {
      window.mainMessageBus.publish("input.deployLaser", {});
    }
  }
  // Helper method to check if dock should be visible
  shouldShowDock(spaceship) {
    if (!this.dockingSystem || !spaceship) {
      const game = window.gameInstance || window.game;
      if (game && game.controls && game.controls.dockingSystem && spaceship) {
        const dockingSystem = game.controls.dockingSystem;
        return dockingSystem.nearStargate && !spaceship.isDocked;
      }
      return false;
    }
    return this.dockingSystem.nearStargate && !spaceship.isDocked;
  }
}
let TouchControls$1 = class TouchControls {
  constructor(spaceship, physics) {
    this.spaceship = spaceship;
    this.physics = physics;
    this.isInitialized = false;
    this.joystickZones = new JoystickZones();
    this.actionButtons = new ActionButtons();
    this.joystickHandler = new JoystickHandler(spaceship, physics);
    this.gestureDetector = new GestureDetector();
    this.miningHandler = new MiningHandler(spaceship);
    this.weaponHandler = new WeaponHandler();
    this.systemActions = new SystemActions();
    this.createCrosshair();
    this.initializeAsync();
  }
  async initializeAsync() {
    try {
      await this.joystickHandler.loadNippleJS();
      this.setupTouchControls();
    } catch (err) {
      console.error("Failed to load nipple.js:", err);
    }
  }
  // Method to set the systems we need to interact with
  setControlSystems(controls) {
    console.log("TouchControls: Setting control systems");
    if (!controls) {
      console.error("TouchControls: Controls object is null or undefined");
      return;
    }
    this.miningHandler.setMiningSystem(controls.miningSystem);
    this.miningHandler.setTargetingSystem(controls.targetingSystem);
    this.weaponHandler.setWeaponSystem(controls.weaponSystem);
    this.systemActions.setDockingSystem(controls.dockingSystem);
    this.systemActions.setTargetingSystem(controls.targetingSystem);
    const systemStatus = {
      hasMiningSystem: !!controls.miningSystem,
      hasTargetingSystem: !!controls.targetingSystem,
      hasDockingSystem: !!controls.dockingSystem,
      hasWeaponSystem: !!controls.weaponSystem
    };
    console.log("TouchControls: Systems connected", systemStatus);
    if (!this.spaceship && controls.spaceship) {
      this.spaceship = controls.spaceship;
      console.log("TouchControls: Spaceship reference set from controls");
    }
    return this;
  }
  createCrosshair() {
    const crosshair = document.createElement("div");
    crosshair.id = "mobile-crosshair";
    crosshair.style.position = "absolute";
    crosshair.style.top = "50%";
    crosshair.style.left = "50%";
    crosshair.style.transform = "translate(-50%, -50%)";
    crosshair.style.width = "10px";
    crosshair.style.height = "10px";
    crosshair.style.pointerEvents = "none";
    crosshair.style.zIndex = "999";
    crosshair.innerHTML = `
            <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background-color: rgba(120, 220, 232, 0.8);"></div>
            <div style="position: absolute; top: 0; left: 50%; width: 1px; height: 100%; background-color: rgba(120, 220, 232, 0.8);"></div>
            <div style="position: absolute; top: 50%; left: 50%; width: 3px; height: 3px; background-color: rgba(120, 220, 232, 0.8); border-radius: 50%; transform: translate(-50%, -50%);"></div>
        `;
    document.body.appendChild(crosshair);
  }
  setupTouchControls() {
    const zones = this.joystickZones.createJoystickZones();
    const buttons = this.actionButtons.createActionButtons();
    setTimeout(() => {
      const success = this.joystickHandler.initializeJoysticks(zones.leftZone, zones.rightZone);
      if (success) {
        this.setupButtonEvents(buttons);
        this.isInitialized = true;
      }
    }, 100);
  }
  setupButtonEvents(buttons) {
    this.actionButtons.addButtonEvents(
      buttons.fire,
      () => this.weaponHandler.handleFiringStart(),
      () => this.weaponHandler.handleFiringEnd()
    );
    this.actionButtons.addButtonEvents(
      buttons.mine,
      () => this.miningHandler.handleMiningStart(),
      () => this.miningHandler.handleMiningEnd()
    );
    this.actionButtons.addButtonEvents(
      buttons.target,
      () => this.systemActions.handleTargeting()
    );
    this.actionButtons.addButtonEvents(
      buttons.dock,
      () => {
        this.systemActions.handleDocking();
        this.actionButtons.hideDockButton();
      }
    );
    this.actionButtons.addButtonEvents(
      buttons.deployLaser,
      () => this.systemActions.handleDeployLaser()
    );
  }
  hide() {
    this.joystickZones.hideZones();
    this.actionButtons.hideButtons();
    this.gestureDetector.disable();
  }
  show() {
    if (this.spaceship && this.spaceship.isDocked || window.game && window.game.introSequenceActive) {
      console.log("TouchControls: Not showing controls during docked state or intro sequence");
      return;
    }
    this.joystickZones.showZones();
    this.actionButtons.showButtons();
    this.gestureDetector.enable();
  }
  update() {
    if (this.systemActions.shouldShowDock(this.spaceship)) {
      this.actionButtons.showDockButton();
    } else {
      this.actionButtons.hideDockButton();
    }
  }
  // Compatibility methods for existing API
  showDockButton() {
    this.actionButtons.showDockButton();
  }
  hideDockButton() {
    this.actionButtons.hideDockButton();
  }
};
class TouchControls2 extends TouchControls$1 {
  constructor(spaceship, physics) {
    super(spaceship, physics);
    this.leftJoystick = null;
    this.rightJoystick = null;
    this.dockButton = null;
    this.mineButton = null;
    this.fireButton = null;
    this.targetButton = null;
    this.threshold = 0.1;
    this.miningSystem = null;
    this.targetingSystem = null;
    this.dockingSystem = null;
    this.weaponSystem = null;
  }
  // Override setControlSystems to maintain compatibility and store legacy references
  setControlSystems(controls) {
    const result = super.setControlSystems(controls);
    this.miningSystem = controls.miningSystem;
    this.targetingSystem = controls.targetingSystem;
    this.dockingSystem = controls.dockingSystem;
    this.weaponSystem = controls.weaponSystem;
    return result;
  }
}
class MobileDetector {
  /**
   * Check if the current device is a mobile device
   * @returns {boolean} True if the device is mobile
   */
  static isMobile() {
    if (this._isMobileCache !== void 0) {
      return this._isMobileCache;
    }
    const userAgentCheck = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet|Android|iP(ad|hone|od)/i.test(navigator.userAgent);
    const touchCheck = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.DocumentTouch && document instanceof DocumentTouch;
    const screenCheck = window.innerWidth < 900;
    const viewportCheck = (() => {
      const viewport = document.querySelector("meta[name=viewport]");
      if (viewport) {
        return viewport.content.includes("width=device-width");
      }
      return false;
    })();
    const mobileFeatureCheck = "orientation" in window || "onorientationchange" in window;
    const motionCheck = "DeviceMotionEvent" in window || "DeviceOrientationEvent" in window;
    const isTablet = (() => {
      const isIpad = navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
      const isAndroidTablet = /android/i.test(navigator.userAgent) && !/mobile/i.test(navigator.userAgent);
      return isIpad || isAndroidTablet;
    })();
    this._isMobileCache = userAgentCheck || touchCheck && (screenCheck || mobileFeatureCheck || motionCheck || viewportCheck || isTablet);
    console.log(`MobileDetector: Device detected as ${this._isMobileCache ? "mobile" : "desktop"}`);
    console.log(`- UA: ${userAgentCheck}, touch: ${touchCheck}, screen: ${screenCheck}`);
    console.log(`- features: ${mobileFeatureCheck}, motion: ${motionCheck}, tablet: ${isTablet}`);
    return this._isMobileCache;
  }
  /**
   * Reset the mobile detection cache (useful after device orientation changes)
   */
  static resetCache() {
    this._isMobileCache = void 0;
  }
  /**
   * Check if the device supports touch events
   * @returns {boolean} True if touch is supported
   */
  static hasTouch() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.DocumentTouch && document instanceof DocumentTouch;
  }
  /**
   * Get device orientation
   * @returns {string} 'portrait' or 'landscape'
   */
  static getOrientation() {
    return window.innerHeight > window.innerWidth ? "portrait" : "landscape";
  }
  /**
   * Add handler for orientation changes
   * @param {Function} handler Function to call when orientation changes
   */
  static addOrientationChangeHandler(handler) {
    let prevOrientation = this.getOrientation();
    const checkOrientation = () => {
      const currentOrientation = this.getOrientation();
      if (currentOrientation !== prevOrientation) {
        prevOrientation = currentOrientation;
        this.resetCache();
        handler(currentOrientation);
      }
    };
    window.addEventListener("resize", checkOrientation);
    if ("onorientationchange" in window) {
      window.addEventListener("orientationchange", checkOrientation);
    }
  }
}
class Controls {
  constructor(spaceship, physics, environment, ui) {
    console.log("Initializing controls systems...");
    this.spaceship = spaceship;
    this.physics = physics;
    this.environment = environment;
    this.ui = ui;
    this.isMobile = MobileDetector.isMobile();
    this._wasDocked = spaceship ? spaceship.isDocked : false;
    this.weaponSystem = null;
    this.scene = physics.scene;
    if (!this.isMobile) {
      console.log("Initializing keyboard/mouse controls");
      this.inputHandler = new InputHandler(spaceship, physics);
      console.log("Initializing gamepad support");
      this.gamepadHandler = new GamepadHandler(spaceship, physics, this);
    } else {
      console.log("Initializing touch controls for mobile");
      this.touchControls = new TouchControls2(spaceship, physics);
      this.inputHandler = {
        isLocked: () => false,
        exitPointerLock: () => {
        }
      };
    }
    this.miningSystem = new MiningSystem(spaceship, this.scene);
    this.targetingSystem = new TargetingSystem(spaceship, this.scene, environment);
    this.dockingSystem = new DockingSystem(spaceship, environment.stargate, ui);
    this.resources = this.miningSystem.resources;
    this.dockingSystem.setResources(this.resources);
    if (!this.resources.orbs) {
      this.resources.orbs = {
        common: 0,
        uncommon: 0,
        rare: 0,
        epic: 0,
        legendary: 0
      };
    }
    if (this.isMobile && this.touchControls) {
      this.touchControls.setControlSystems(this);
    }
    this.connectUpgradeEffects();
    this.setupEventHandlers();
    this.lastAnomalyCheck = 0;
    this.currentAnomaly = null;
    this.showingAnomalyNotification = false;
    console.log("Control systems initialized");
  }
  // New method to connect upgrade effects between systems
  connectUpgradeEffects() {
    this.dockingSystem.updateMiningSystem = () => {
      if (this.miningSystem && this.spaceship) {
        const efficiency = this.spaceship.miningEfficiency;
        Object.keys(this.miningSystem.miningSpeedByType).forEach((resourceType) => {
          if (!this.miningSystem._originalMiningSpeedByType) {
            this.miningSystem._originalMiningSpeedByType = { ...this.miningSystem.miningSpeedByType };
          }
          const originalSpeed = this.miningSystem._originalMiningSpeedByType[resourceType];
          this.miningSystem.miningSpeedByType[resourceType] = originalSpeed * efficiency;
        });
        console.log("Mining speeds updated with efficiency:", efficiency);
        if (this.miningSystem.targetAsteroid) {
          this.miningSystem.setTargetAsteroid(this.miningSystem.targetAsteroid);
        }
      }
    };
  }
  setupEventHandlers() {
    if (this.isMobile) {
      console.log("Mobile device detected, touch handlers are set in TouchControls class");
      return;
    }
    document.addEventListener("keydown", (e) => {
      switch (e.key.toLowerCase()) {
        case "e":
          this.targetingSystem.toggleLockOn();
          break;
        case "f7":
          if (this.gamepadHandler) {
            this.gamepadHandler.lookSensitivity = Math.max(0.2, this.gamepadHandler.lookSensitivity - 0.2);
            console.log(`Gamepad sensitivity: ${this.gamepadHandler.lookSensitivity.toFixed(1)}`);
            this.showSensitivityNotification(this.gamepadHandler.lookSensitivity);
          }
          e.preventDefault();
          break;
        case "f8":
          if (this.gamepadHandler) {
            this.gamepadHandler.lookSensitivity = Math.min(3, this.gamepadHandler.lookSensitivity + 0.2);
            console.log(`Gamepad sensitivity: ${this.gamepadHandler.lookSensitivity.toFixed(1)}`);
            this.showSensitivityNotification(this.gamepadHandler.lookSensitivity);
          }
          e.preventDefault();
          break;
        case "f9":
          if (this.gamepadHandler) {
            this.gamepadHandler.toggleDebug();
            console.log("Gamepad debug display toggled");
          }
          e.preventDefault();
          break;
        case "tab":
          if (this.targetingSystem.isLockOnEnabled()) {
            const target = this.targetingSystem.cycleLockOnTarget();
            if (target) {
              this.miningSystem.setTargetAsteroid(target);
            }
          }
          e.preventDefault();
          break;
        case "r":
          if (this.targetingSystem.isLockOnEnabled()) {
            const target = this.targetingSystem.getCurrentTarget();
            if (target) {
              this.miningSystem.setTargetAsteroid(target);
              if (this.miningSystem.isMining) {
                this.miningSystem.stopMining();
              } else {
                this.miningSystem.startMining();
              }
            }
          }
          break;
        case "t":
          console.log("Deploying laser turret");
          if (window.mainMessageBus) {
            window.mainMessageBus.publish("input.deployLaser", {});
          }
          break;
        case "g":
          console.log("Attempting to pick up an item");
          if (window.mainMessageBus) {
            window.mainMessageBus.publish("input.pickupInteract", {});
          }
          break;
      }
    });
    document.addEventListener("mousedown", (e) => {
      if (e.button === 0 && this.inputHandler.isLocked()) {
        if (window.game && window.game.combat) {
          window.game.combat.setFiring(true);
        }
      }
    });
    document.addEventListener("mouseup", (e) => {
      if (e.button === 0) {
        if (window.game && window.game.combat) {
          window.game.combat.setFiring(false);
        }
      }
    });
  }
  setupStargateUIControls() {
    if (this.dockingSystem) {
      this.dockingSystem.setupStargateUIControls();
    }
  }
  // Method to dock with stargate (called from main.js on game start)
  dockWithStargate() {
    if (this.dockingSystem) {
      this.dockingSystem.dockWithStargate();
      if (this.isMobile && this.touchControls) {
        this.touchControls.hide();
      }
    } else {
      console.error("Docking system not initialized");
    }
  }
  // Collect energy orb from space anomaly
  collectEnergyOrb() {
    if (!this.environment || !this.spaceship) return;
    const anomaly = this.environment.checkAnomalyCollision(this.spaceship.mesh.position);
    if (!anomaly) {
      return;
    }
    const orbData = this.environment.collectAnomalyOrb(anomaly);
    if (!orbData) {
      return;
    }
    if (!this.resources.orbs) {
      this.resources.orbs = {
        common: 0,
        uncommon: 0,
        rare: 0,
        epic: 0,
        legendary: 0
      };
    }
    this.resources.orbs[orbData.rarity]++;
    let rarityColor;
    switch (orbData.rarity) {
      case "legendary":
        rarityColor = "#ff0000";
        break;
      case "epic":
        rarityColor = "#ff6600";
        break;
      case "rare":
        rarityColor = "#9900ff";
        break;
      case "uncommon":
        rarityColor = "#0066ff";
        break;
      default:
        rarityColor = "#00ff66";
        break;
    }
    const capitalizedRarity = orbData.rarity.charAt(0).toUpperCase() + orbData.rarity.slice(1);
    this.showAnomalyMessage(
      `Collected ${capitalizedRarity} Energy Orb (${orbData.value} CR)`,
      rarityColor
    );
    this.triggerOrbCollectionEffect(anomaly);
    if (window.game && window.game.audio) {
      switch (orbData.rarity) {
        case "legendary":
          window.game.audio.playSoundEffect("powerup_legendary", 0.8);
          break;
        case "epic":
          window.game.audio.playSoundEffect("powerup_epic", 0.7);
          break;
        case "rare":
          window.game.audio.playSoundEffect("powerup_rare", 0.6);
          break;
        case "uncommon":
          window.game.audio.playSoundEffect("powerup_uncommon", 0.5);
          break;
        default:
          window.game.audio.playSoundEffect("powerup_common", 0.4);
          break;
      }
    }
  }
  // Create a visual effect when collecting an orb
  triggerOrbCollectionEffect(anomaly) {
    if (!this.scene || !anomaly) return;
    if (window.game && window.game.combat) {
      const position = anomaly.position.clone();
      window.game.combat.createExplosionEffect(position, 2e3, true);
      if (window.mainMessageBus) {
        window.mainMessageBus.publish("vfx.explosion", {
          position,
          color: anomaly.orb.color,
          size: anomaly.orb.size * 2,
          duration: 2e3
        });
      }
    }
  }
  // Show a notification when anomaly is found or orb is collected
  showAnomalyMessage(message, color) {
    if (this.showingAnomalyNotification) return;
    this.showingAnomalyNotification = true;
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = "30%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = color || "#ffffff";
    notification.style.padding = "15px 30px";
    notification.style.borderRadius = "10px";
    notification.style.border = `2px solid ${color || "#ffffff"}`;
    notification.style.boxShadow = `0 0 15px ${color || "#ffffff"}`;
    notification.style.fontFamily = "Courier New, monospace";
    notification.style.fontSize = "18px";
    notification.style.zIndex = "1000";
    notification.style.textAlign = "center";
    notification.style.pointerEvents = "none";
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 0.8s";
      setTimeout(() => {
        notification.remove();
        this.showingAnomalyNotification = false;
      }, 800);
    }, 3e3);
  }
  showSensitivityNotification(sensitivity) {
    const notification = document.createElement("div");
    notification.textContent = `Gamepad Sensitivity: ${sensitivity.toFixed(1)}`;
    notification.style.position = "fixed";
    notification.style.top = "100px";
    notification.style.left = "50%";
    notification.style.transform = "translateX(-50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#30cfd0";
    notification.style.padding = "10px 20px";
    notification.style.borderRadius = "5px";
    notification.style.border = "1px solid #30cfd0";
    notification.style.fontFamily = "monospace";
    notification.style.fontSize = "16px";
    notification.style.zIndex = "10000";
    notification.style.pointerEvents = "none";
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.transition = "opacity 0.5s";
      notification.style.opacity = "0";
      setTimeout(() => notification.remove(), 500);
    }, 2e3);
  }
  /**
   * Update control systems
   * @param {number} deltaTime Time since last update in seconds
   */
  update(deltaTime = 1 / 60) {
    if (window.game && window.game.introSequenceActive) {
      return;
    }
    if (this.spaceship) {
      const wasDocked = this._wasDocked;
      const isDocked = this.spaceship.isDocked;
      if (this.isMobile && this.touchControls && wasDocked !== isDocked) {
        if (isDocked) {
          this.touchControls.hide();
        } else {
          this.touchControls.show();
        }
        this._wasDocked = isDocked;
      }
    }
    if (this.spaceship && this.spaceship.isDocked) {
      if (this.dockingSystem) {
        this.dockingSystem.update();
      }
      return;
    }
    if (this.gamepadHandler) {
      this.gamepadHandler.update(deltaTime);
    }
    if (this.targetingSystem) {
      this.targetingSystem.update();
    }
    if (this.miningSystem) {
      this.miningSystem.update(deltaTime);
      const destroyedAsteroid = this.miningSystem.getLastDestroyedAsteroid();
      if (destroyedAsteroid && this.environment && this.environment.asteroidBelt) {
        this.environment.asteroidBelt.removeAsteroid(destroyedAsteroid);
      }
    }
    if (this.dockingSystem) {
      this.dockingSystem.update();
    }
    if (this.isMobile && this.touchControls) {
      this.touchControls.update();
    }
    if (this.deploymentSystem) {
      this.deploymentSystem.update();
    }
    this.checkForAnomalyOrbs();
  }
  // Check if the player is near an anomaly orb and collect it if close enough
  checkForAnomalyOrbs() {
    if (!this.environment || !this.spaceship) return;
    const now = performance.now();
    if (now - this.lastAnomalyCheck < 500) return;
    this.lastAnomalyCheck = now;
    const anomaly = this.environment.checkAnomalyCollision(this.spaceship.mesh.position);
    if (anomaly && !anomaly.orbCollected) {
      this.collectEnergyOrb();
      this.currentAnomaly = null;
    } else if (anomaly && anomaly !== this.currentAnomaly && anomaly.orbCollected) {
      this.currentAnomaly = anomaly;
      this.showAnomalyMessage("Energy orb already collected", "#ff3333");
    } else if (!anomaly) {
      this.currentAnomaly = null;
    }
  }
  // Getter for isMining status (used by UI)
  get isMining() {
    return this.miningSystem ? this.miningSystem.isMining : false;
  }
  // Getter for mining progress (used by UI)
  get miningProgress() {
    return this.miningSystem ? this.miningSystem.miningProgress : 0;
  }
}
class HUDStyles {
  static initializeStyles() {
    const fontLink = document.createElement("link");
    fontLink.href = "https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600&family=Electrolize&display=swap";
    fontLink.rel = "stylesheet";
    document.head.appendChild(fontLink);
    const style = document.createElement("style");
    style.textContent = `
            @keyframes pulse {
                0% { opacity: 0.7; }
                50% { opacity: 1; }
                100% { opacity: 0.7; }
            }
            
            @keyframes radar-ping {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.5; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
            }
            
            @keyframes text-flicker {
                0% { opacity: 1; }
                3% { opacity: 0.4; }
                6% { opacity: 1; }
                9% { opacity: 0.4; }
                12% { opacity: 1; }
                35% { opacity: 1; }
                38% { opacity: 0.4; }
                41% { opacity: 1; }
                100% { opacity: 1; }
            }
            
            @keyframes blink {
                0% { opacity: 1; }
                49% { opacity: 1; }
                50% { opacity: 0; }
                100% { opacity: 0; }
            }

            @keyframes pulse-horde {
                0% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.5); }
                50% { box-shadow: 0 0 10px rgba(255, 30, 30, 0.8); }
                100% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.5); }
            }
        `;
    document.head.appendChild(style);
  }
  static getMainContainerStyles() {
    return {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      fontFamily: '"Rajdhani", "Electrolize", sans-serif',
      fontWeight: "400",
      color: "rgba(120, 220, 232, 0.9)",
      textShadow: "0 0 10px rgba(120, 220, 232, 0.5)",
      opacity: "0",
      transition: "opacity 0.5s ease"
    };
  }
  static getPanelStyles() {
    return {
      backgroundColor: "rgba(6, 22, 31, 0.7)",
      backdropFilter: "blur(5px)",
      borderRadius: "10px",
      border: "1px solid rgba(120, 220, 232, 0.3)",
      boxShadow: "0 0 15px rgba(120, 220, 232, 0.2), inset 0 0 10px rgba(120, 220, 232, 0.1)",
      overflow: "hidden"
    };
  }
  static getPanelHeaderStyles() {
    return {
      fontWeight: "600",
      fontSize: "14px",
      textTransform: "uppercase",
      letterSpacing: "2px",
      marginBottom: "15px",
      paddingBottom: "8px",
      borderBottom: "1px solid rgba(120, 220, 232, 0.3)",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center"
    };
  }
  static getStatusIndicatorStyles() {
    return {
      width: "8px",
      height: "8px",
      borderRadius: "50%",
      backgroundColor: "rgba(120, 220, 232, 0.8)",
      boxShadow: "0 0 5px rgba(120, 220, 232, 0.8)",
      animation: "pulse 2s infinite"
    };
  }
  static getPanelRowStyles() {
    return {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      margin: "10px 0"
    };
  }
  static getButtonStyles() {
    return {
      width: "100%",
      marginTop: "15px",
      padding: "8px",
      backgroundColor: "rgba(120, 220, 232, 0.15)",
      border: "1px solid rgba(120, 220, 232, 0.5)",
      borderRadius: "5px",
      color: "rgba(120, 220, 232, 0.9)",
      fontSize: "12px",
      fontFamily: '"Rajdhani", sans-serif',
      cursor: "pointer",
      transition: "all 0.2s ease",
      textTransform: "uppercase",
      letterSpacing: "1px",
      fontWeight: "600",
      outline: "none",
      pointerEvents: "auto"
    };
  }
  static getBarContainerStyles() {
    return {
      height: "10px",
      backgroundColor: "rgba(10, 30, 40, 0.5)",
      borderRadius: "5px",
      overflow: "hidden"
    };
  }
  static getBarStyles() {
    return {
      width: "100%",
      height: "100%",
      boxShadow: "inset 0 0 5px rgba(255, 255, 255, 0.5)",
      transition: "width 0.3s ease"
    };
  }
  static getScanlineEffectStyles() {
    return {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      background: "linear-gradient(transparent 50%, rgba(120, 220, 232, 0.03) 50%)",
      backgroundSize: "100% 4px",
      zIndex: "1000",
      pointerEvents: "none",
      opacity: "0.5"
    };
  }
  static getActiveScanlineStyles() {
    return {
      position: "absolute",
      left: "0",
      width: "100%",
      height: "3px",
      background: "linear-gradient(90deg, transparent 0%, rgba(120, 220, 232, 0.1) 50%, transparent 100%)",
      boxShadow: "0 0 10px rgba(120, 220, 232, 0.3)",
      zIndex: "1001",
      top: "0",
      opacity: "0.7",
      pointerEvents: "none"
    };
  }
  static createGlitchAnimation() {
    const timestamp = Date.now();
    const glitchAnimation = `
            @keyframes glitch-${timestamp} {
                0% { transform: translate(0, 0) skew(0deg); filter: hue-rotate(0deg); }
                1% { transform: translate(2px, 2px) skew(1deg); filter: hue-rotate(90deg); }
                2% { transform: translate(-2px, -3px) skew(-1deg); filter: hue-rotate(180deg); }
                3% { transform: translate(0, 0) skew(0deg); filter: hue-rotate(0deg); }
                12% { clip-path: inset(0 0 0 0); }
                13% { clip-path: inset(10% 0 0 0); }
                14% { clip-path: inset(0 0 0 0); }
                15% { clip-path: inset(0 0 10% 0); }
                16% { clip-path: inset(0 0 0 0); }
                100% { transform: translate(0, 0) skew(0deg); filter: hue-rotate(0deg); }
            }
        `;
    const style = document.createElement("style");
    style.textContent = glitchAnimation;
    document.head.appendChild(style);
    return `glitch-${timestamp}`;
  }
  static applyStyles(element, styles) {
    Object.assign(element.style, styles);
  }
  static addCornerElements(panel) {
    const topLeft = document.createElement("div");
    HUDStyles.applyStyles(topLeft, {
      position: "absolute",
      top: "0",
      left: "0",
      width: "10px",
      height: "10px",
      borderTop: "2px solid rgba(120, 220, 232, 0.8)",
      borderLeft: "2px solid rgba(120, 220, 232, 0.8)"
    });
    panel.appendChild(topLeft);
    const topRight = document.createElement("div");
    HUDStyles.applyStyles(topRight, {
      position: "absolute",
      top: "0",
      right: "0",
      width: "10px",
      height: "10px",
      borderTop: "2px solid rgba(120, 220, 232, 0.8)",
      borderRight: "2px solid rgba(120, 220, 232, 0.8)"
    });
    panel.appendChild(topRight);
    const bottomLeft = document.createElement("div");
    HUDStyles.applyStyles(bottomLeft, {
      position: "absolute",
      bottom: "0",
      left: "0",
      width: "10px",
      height: "10px",
      borderBottom: "2px solid rgba(120, 220, 232, 0.8)",
      borderLeft: "2px solid rgba(120, 220, 232, 0.8)"
    });
    panel.appendChild(bottomLeft);
    const bottomRight = document.createElement("div");
    HUDStyles.applyStyles(bottomRight, {
      position: "absolute",
      bottom: "0",
      right: "0",
      width: "10px",
      height: "10px",
      borderBottom: "2px solid rgba(120, 220, 232, 0.8)",
      borderRight: "2px solid rgba(120, 220, 232, 0.8)"
    });
    panel.appendChild(bottomRight);
  }
}
class HUDDisplays {
  static createFlightPanel(parent) {
    const flightPanel = document.createElement("div");
    flightPanel.id = "flight-panel";
    flightPanel.className = "hud-panel";
    HUDStyles.applyStyles(flightPanel, {
      position: "absolute",
      bottom: "20px",
      left: "20px",
      width: "260px",
      padding: "15px",
      ...HUDStyles.getPanelStyles()
    });
    parent.appendChild(flightPanel);
    const panelHeader = document.createElement("div");
    panelHeader.className = "panel-header";
    panelHeader.innerHTML = "<span>FLIGHT SYSTEMS</span>";
    HUDStyles.applyStyles(panelHeader, HUDStyles.getPanelHeaderStyles());
    flightPanel.appendChild(panelHeader);
    const statusIndicator = document.createElement("div");
    statusIndicator.className = "status-indicator";
    HUDStyles.applyStyles(statusIndicator, HUDStyles.getStatusIndicatorStyles());
    panelHeader.appendChild(statusIndicator);
    HUDDisplays.createFuelGauge(flightPanel);
    HUDDisplays.createPanelRow(flightPanel, "CREDITS", "credits", "1000 CR");
    HUDDisplays.createControlsButton(flightPanel);
    HUDStyles.addCornerElements(flightPanel);
    return flightPanel;
  }
  static createStatusPanel(parent) {
    const statusPanel = document.createElement("div");
    statusPanel.id = "status-panel";
    statusPanel.className = "hud-panel";
    HUDStyles.applyStyles(statusPanel, {
      position: "absolute",
      bottom: "20px",
      right: "20px",
      width: "260px",
      padding: "15px",
      ...HUDStyles.getPanelStyles()
    });
    parent.appendChild(statusPanel);
    const panelHeader = document.createElement("div");
    panelHeader.className = "panel-header";
    panelHeader.innerHTML = "<span>SHIP STATUS</span>";
    HUDStyles.applyStyles(panelHeader, HUDStyles.getPanelHeaderStyles());
    statusPanel.appendChild(panelHeader);
    const statusIndicator = document.createElement("div");
    statusIndicator.className = "status-indicator";
    HUDStyles.applyStyles(statusIndicator, HUDStyles.getStatusIndicatorStyles());
    panelHeader.appendChild(statusIndicator);
    HUDDisplays.createShieldBar(statusPanel);
    HUDDisplays.createHullBar(statusPanel);
    HUDStyles.addCornerElements(statusPanel);
    HUDDisplays.createSoundToggleButton(statusPanel);
    return statusPanel;
  }
  static createLocationPanel(parent) {
    const locationPanel = document.createElement("div");
    locationPanel.id = "location-panel";
    locationPanel.className = "hud-panel";
    HUDStyles.applyStyles(locationPanel, {
      position: "absolute",
      top: "20px",
      left: "20px",
      padding: "10px 20px",
      backgroundColor: "rgba(6, 22, 31, 0.7)",
      backdropFilter: "blur(5px)",
      borderRadius: "8px",
      border: "1px solid rgba(120, 220, 232, 0.3)",
      boxShadow: "0 0 15px rgba(120, 220, 232, 0.2)",
      fontSize: "14px"
    });
    parent.appendChild(locationPanel);
    locationPanel.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C8.13 2 5 5.13 5 9C5 14.25 12 22 12 22C12 22 19 14.25 19 9C19 5.13 15.87 2 12 2ZM12 11.5C10.62 11.5 9.5 10.38 9.5 9C9.5 7.62 10.62 6.5 12 6.5C13.38 6.5 14.5 7.62 14.5 9C14.5 10.38 13.38 11.5 12 11.5Z" 
                          fill="rgba(120, 220, 232, 0.8)"/>
                </svg>
                <span id="current-system" style="font-weight:600; letter-spacing:1px;">SOLAR SYSTEM</span>
            </div>
            <div id="location-coordinates" style="margin-top:5px; font-size:12px; opacity:0.8;">X: 0 Y: 0 Z: 0</div>
            <div id="fps-display" style="margin-top:5px; font-size:12px; opacity:0.8;">FPS: 0</div>
            <div style="margin-top:5px; display:flex; align-items:center; gap:10px; font-size:12px; opacity:0.8;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" 
                          fill="rgba(120, 220, 232, 0.8)"/>
                    <path d="M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z" 
                          fill="rgba(120, 220, 232, 0.5)"/>
                </svg>
                <span>ANOMALIES: <span id="anomaly-count" style="font-weight:600;">0</span></span>
            </div>
        `;
    HUDStyles.addCornerElements(locationPanel);
    return locationPanel;
  }
  static createResourcePanel(parent) {
    const resourcePanel = document.createElement("div");
    resourcePanel.id = "resource-panel";
    resourcePanel.className = "hud-panel";
    HUDStyles.applyStyles(resourcePanel, {
      position: "absolute",
      top: "20px",
      right: "20px",
      width: "180px",
      padding: "10px 15px",
      backgroundColor: "rgba(6, 22, 31, 0.7)",
      backdropFilter: "blur(5px)",
      borderRadius: "8px",
      border: "1px solid rgba(120, 220, 232, 0.3)",
      boxShadow: "0 0 15px rgba(120, 220, 232, 0.2)",
      fontSize: "14px"
    });
    parent.appendChild(resourcePanel);
    const resourceHeader = document.createElement("div");
    resourceHeader.className = "panel-header";
    resourceHeader.innerHTML = "<span>CARGO BAY</span>";
    HUDStyles.applyStyles(resourceHeader, {
      fontWeight: "600",
      fontSize: "12px",
      textTransform: "uppercase",
      letterSpacing: "1px",
      marginBottom: "8px",
      paddingBottom: "5px",
      borderBottom: "1px solid rgba(120, 220, 232, 0.3)",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center"
    });
    resourcePanel.appendChild(resourceHeader);
    HUDDisplays.createResourceRow(resourcePanel, "IRON", "iron-amount", "rgba(180, 180, 180, 0.8)");
    HUDDisplays.createResourceRow(resourcePanel, "GOLD", "gold-amount", "rgba(255, 215, 0, 0.8)");
    HUDDisplays.createResourceRow(resourcePanel, "PLATINUM", "platinum-amount", "rgba(229, 228, 226, 0.8)");
    HUDDisplays.createCapacityMeter(resourcePanel);
    HUDStyles.addCornerElements(resourcePanel);
    return resourcePanel;
  }
  static createFuelGauge(panel) {
    const fuelRow = document.createElement("div");
    fuelRow.className = "panel-row";
    HUDStyles.applyStyles(fuelRow, HUDStyles.getPanelRowStyles());
    panel.appendChild(fuelRow);
    const fuelLabel = document.createElement("span");
    fuelLabel.className = "row-label";
    fuelLabel.textContent = "FUEL";
    fuelLabel.style.width = "40%";
    fuelRow.appendChild(fuelLabel);
    const fuelValue = document.createElement("span");
    fuelValue.id = "fuel-value";
    fuelValue.className = "row-value";
    fuelValue.textContent = "100 / 100";
    HUDStyles.applyStyles(fuelValue, {
      position: "absolute",
      right: "15px",
      top: "-18px",
      fontSize: "12px",
      color: "rgba(120, 220, 232, 0.9)"
    });
    const fuelBarContainer = document.createElement("div");
    HUDStyles.applyStyles(fuelBarContainer, {
      width: "60%",
      position: "relative",
      ...HUDStyles.getBarContainerStyles()
    });
    fuelBarContainer.appendChild(fuelValue);
    fuelRow.appendChild(fuelBarContainer);
    const fuelBar = document.createElement("div");
    fuelBar.id = "fuel-bar";
    HUDStyles.applyStyles(fuelBar, {
      backgroundColor: "rgba(120, 220, 232, 0.8)",
      ...HUDStyles.getBarStyles()
    });
    fuelBarContainer.appendChild(fuelBar);
  }
  static createShieldBar(panel) {
    const shieldRow = document.createElement("div");
    shieldRow.className = "panel-row";
    HUDStyles.applyStyles(shieldRow, HUDStyles.getPanelRowStyles());
    panel.appendChild(shieldRow);
    const shieldLabel = document.createElement("span");
    shieldLabel.className = "row-label";
    shieldLabel.textContent = "SHIELD";
    shieldLabel.style.width = "50%";
    shieldRow.appendChild(shieldLabel);
    const shieldBarContainer = document.createElement("div");
    HUDStyles.applyStyles(shieldBarContainer, {
      width: "50%",
      ...HUDStyles.getBarContainerStyles()
    });
    shieldRow.appendChild(shieldBarContainer);
    const shieldBar = document.createElement("div");
    shieldBar.id = "shield-bar";
    HUDStyles.applyStyles(shieldBar, {
      backgroundColor: "rgba(51, 153, 255, 0.8)",
      ...HUDStyles.getBarStyles()
    });
    shieldBarContainer.appendChild(shieldBar);
  }
  static createHullBar(panel) {
    const hullRow = document.createElement("div");
    hullRow.className = "panel-row";
    HUDStyles.applyStyles(hullRow, HUDStyles.getPanelRowStyles());
    panel.appendChild(hullRow);
    const hullLabel = document.createElement("span");
    hullLabel.className = "row-label";
    hullLabel.textContent = "HULL INTEGRITY";
    hullLabel.style.width = "50%";
    hullRow.appendChild(hullLabel);
    const hullBarContainer = document.createElement("div");
    HUDStyles.applyStyles(hullBarContainer, {
      width: "50%",
      ...HUDStyles.getBarContainerStyles()
    });
    hullRow.appendChild(hullBarContainer);
    const hullBar = document.createElement("div");
    hullBar.id = "hull-bar";
    HUDStyles.applyStyles(hullBar, {
      backgroundColor: "rgba(120, 220, 232, 0.8)",
      ...HUDStyles.getBarStyles()
    });
    hullBarContainer.appendChild(hullBar);
  }
  static createResourceRow(panel, name, id, hexColor) {
    const row = document.createElement("div");
    HUDStyles.applyStyles(row, {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      margin: "5px 0"
    });
    const hexIcon = document.createElement("div");
    HUDStyles.applyStyles(hexIcon, {
      width: "12px",
      height: "14px",
      clipPath: "polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)",
      backgroundColor: hexColor,
      marginRight: "8px"
    });
    const label = document.createElement("div");
    HUDStyles.applyStyles(label, {
      display: "flex",
      alignItems: "center",
      width: "50%",
      fontSize: "12px"
    });
    label.appendChild(hexIcon);
    label.appendChild(document.createTextNode(name));
    const value = document.createElement("div");
    value.id = id;
    HUDStyles.applyStyles(value, {
      width: "50%",
      textAlign: "right",
      fontWeight: "600",
      fontSize: "12px"
    });
    value.textContent = "0";
    row.appendChild(label);
    row.appendChild(value);
    panel.appendChild(row);
  }
  static createCapacityMeter(panel) {
    const capacityRow = document.createElement("div");
    HUDStyles.applyStyles(capacityRow, {
      marginTop: "8px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      borderTop: "1px solid rgba(120, 220, 232, 0.3)",
      paddingTop: "8px"
    });
    panel.appendChild(capacityRow);
    const capacityLabel = document.createElement("div");
    capacityLabel.textContent = "CAPACITY";
    capacityLabel.style.fontSize = "12px";
    capacityRow.appendChild(capacityLabel);
    const capacityValue = document.createElement("div");
    capacityValue.id = "cargo-capacity";
    capacityValue.textContent = "0 / 1000";
    HUDStyles.applyStyles(capacityValue, {
      fontSize: "12px",
      fontWeight: "600"
    });
    capacityRow.appendChild(capacityValue);
    const capacityBarContainer = document.createElement("div");
    HUDStyles.applyStyles(capacityBarContainer, {
      width: "100%",
      height: "5px",
      backgroundColor: "rgba(10, 30, 40, 0.5)",
      borderRadius: "3px",
      overflow: "hidden",
      marginTop: "5px"
    });
    panel.appendChild(capacityBarContainer);
    const capacityBar = document.createElement("div");
    capacityBar.id = "capacity-bar";
    HUDStyles.applyStyles(capacityBar, {
      width: "0%",
      height: "100%",
      backgroundColor: "rgba(120, 220, 232, 0.8)",
      transition: "width 0.3s ease"
    });
    capacityBarContainer.appendChild(capacityBar);
  }
  static createPanelRow(panel, label, id, defaultValue, isIndicator = false) {
    const row = document.createElement("div");
    row.className = "panel-row";
    HUDStyles.applyStyles(row, {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      margin: "8px 0"
    });
    panel.appendChild(row);
    const labelEl = document.createElement("span");
    labelEl.className = "row-label";
    labelEl.textContent = label;
    row.appendChild(labelEl);
    const valueEl = document.createElement("span");
    valueEl.id = id;
    valueEl.className = "row-value";
    valueEl.textContent = defaultValue;
    if (isIndicator && defaultValue === "ON") {
      valueEl.style.color = "#5fff8f";
    } else if (isIndicator && defaultValue === "OFF") {
      valueEl.style.color = "#ff7f7f";
    }
    row.appendChild(valueEl);
  }
  static createControlsButton(panel) {
    const controlsButton = document.createElement("button");
    controlsButton.id = "show-controls";
    controlsButton.textContent = "SYSTEM CONTROLS";
    HUDStyles.applyStyles(controlsButton, HUDStyles.getButtonStyles());
    controlsButton.addEventListener("mouseover", () => {
      HUDStyles.applyStyles(controlsButton, {
        backgroundColor: "rgba(120, 220, 232, 0.3)",
        boxShadow: "0 0 10px rgba(120, 220, 232, 0.5)"
      });
    });
    controlsButton.addEventListener("mouseout", () => {
      HUDStyles.applyStyles(controlsButton, {
        backgroundColor: "rgba(120, 220, 232, 0.15)",
        boxShadow: "none"
      });
    });
    panel.appendChild(controlsButton);
  }
  static createSoundToggleButton(panel) {
    const soundToggleBtn = document.createElement("button");
    soundToggleBtn.id = "sound-toggle";
    soundToggleBtn.textContent = "SOUND: ON";
    HUDStyles.applyStyles(soundToggleBtn, {
      background: "none",
      border: "1px solid rgba(120, 220, 232, 0.5)",
      color: "rgba(120, 220, 232, 0.9)",
      padding: "5px 10px",
      borderRadius: "5px",
      cursor: "pointer",
      fontFamily: '"Rajdhani", sans-serif',
      fontSize: "12px",
      marginLeft: "10px",
      marginTop: "10px",
      outline: "none",
      pointerEvents: "auto"
    });
    soundToggleBtn.addEventListener("click", () => {
      if (window.game && window.game.audio) {
        const isMuted = window.game.audio.toggleMute();
        soundToggleBtn.textContent = isMuted ? "SOUND: OFF" : "SOUND: ON";
      }
    });
    panel.appendChild(soundToggleBtn);
  }
}
class HUDNotifications {
  static createNotificationsArea(parent) {
    const notificationsArea = document.createElement("div");
    notificationsArea.id = "notifications-area";
    HUDStyles.applyStyles(notificationsArea, {
      position: "absolute",
      top: "20px",
      left: "50%",
      transform: "translateX(-50%)",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "10px"
    });
    parent.appendChild(notificationsArea);
    HUDNotifications.createHordeModeIndicator(notificationsArea);
    return notificationsArea;
  }
  static createHordeModeIndicator(parent) {
    const hordeIndicator = document.createElement("div");
    hordeIndicator.id = "horde-mode-indicator";
    hordeIndicator.className = "hud-panel";
    HUDStyles.applyStyles(hordeIndicator, {
      display: "none",
      // Hidden by default, will be changed to 'flex' when active
      padding: "8px 12px",
      backgroundColor: "rgba(51, 10, 10, 0.8)",
      backdropFilter: "blur(5px)",
      borderRadius: "8px",
      border: "1px solid #ff3030",
      boxShadow: "0 0 15px rgba(255, 48, 48, 0.5)",
      animation: "pulse-horde 2s infinite",
      marginBottom: "10px",
      fontSize: "18px",
      fontWeight: "600",
      letterSpacing: "1px"
    });
    const hordeContent = document.createElement("div");
    HUDStyles.applyStyles(hordeContent, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "10px"
    });
    const hordeLabel = document.createElement("span");
    HUDStyles.applyStyles(hordeLabel, {
      color: "#ff3030",
      textShadow: "0 0 5px rgba(255,48,48,0.5)"
    });
    hordeLabel.textContent = "HORDE MODE";
    const survivalTime = document.createElement("span");
    survivalTime.id = "horde-survival-time";
    HUDStyles.applyStyles(survivalTime, {
      color: "#ff9999",
      fontWeight: "bold"
    });
    survivalTime.textContent = "00:00";
    hordeContent.appendChild(hordeLabel);
    hordeContent.appendChild(survivalTime);
    hordeIndicator.appendChild(hordeContent);
    HUDStyles.addCornerElements(hordeIndicator);
    parent.appendChild(hordeIndicator);
    return hordeIndicator;
  }
  /**
   * Update the horde mode indicator and survival timer
   */
  static updateHordeModeDisplay() {
    const hordeIndicator = document.getElementById("horde-mode-indicator");
    const survivalTime = document.getElementById("horde-survival-time");
    if (!hordeIndicator || !survivalTime) return;
    if (window.game && window.game.isHordeActive) {
      if (hordeIndicator.style.display === "none") {
        hordeIndicator.style.display = "flex";
      }
      if (window.game.getFormattedHordeSurvivalTime) {
        survivalTime.textContent = window.game.getFormattedHordeSurvivalTime();
      } else {
        const totalSeconds = Math.floor(window.game.hordeSurvivalTime / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        survivalTime.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      }
      if (window.game.hordeSurvivalTime > 3 * 60 * 1e3) {
        const styleEl = document.createElement("style");
        styleEl.textContent = `
                    @keyframes pulse-horde {
                        0% { box-shadow: 0 0 8px rgba(255, 30, 30, 0.7); }
                        50% { box-shadow: 0 0 15px rgba(255, 30, 30, 1); }
                        100% { box-shadow: 0 0 8px rgba(255, 30, 30, 0.7); }
                    }
                `;
        document.head.appendChild(styleEl);
        hordeIndicator.style.animation = "pulse-horde 1s infinite";
      }
    } else {
      hordeIndicator.style.display = "none";
    }
  }
  /**
   * Show a temporary notification message
   */
  static showNotification(message, type = "info", duration = 3e3) {
    const notificationsArea = document.getElementById("notifications-area");
    if (!notificationsArea) return;
    const notification = document.createElement("div");
    notification.className = "hud-notification";
    let backgroundColor, borderColor;
    switch (type) {
      case "warning":
        backgroundColor = "rgba(255, 204, 0, 0.1)";
        borderColor = "rgba(255, 204, 0, 0.5)";
        break;
      case "error":
        backgroundColor = "rgba(255, 48, 48, 0.1)";
        borderColor = "rgba(255, 48, 48, 0.5)";
        break;
      case "success":
        backgroundColor = "rgba(95, 255, 143, 0.1)";
        borderColor = "rgba(95, 255, 143, 0.5)";
        break;
      default:
        backgroundColor = "rgba(120, 220, 232, 0.1)";
        borderColor = "rgba(120, 220, 232, 0.5)";
    }
    HUDStyles.applyStyles(notification, {
      padding: "8px 15px",
      backgroundColor,
      backdropFilter: "blur(5px)",
      borderRadius: "5px",
      border: `1px solid ${borderColor}`,
      fontSize: "14px",
      color: "rgba(255, 255, 255, 0.9)",
      textAlign: "center",
      animation: "fadeIn 0.3s ease-in-out",
      marginBottom: "5px",
      maxWidth: "300px",
      wordWrap: "break-word"
    });
    notification.textContent = message;
    notificationsArea.appendChild(notification);
    const fadeInStyle = document.createElement("style");
    fadeInStyle.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-10px); }
            }
        `;
    document.head.appendChild(fadeInStyle);
    setTimeout(() => {
      notification.style.animation = "fadeOut 0.3s ease-in-out";
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, duration);
  }
  /**
   * Show a critical alert that requires attention
   */
  static showCriticalAlert(message) {
    HUDNotifications.showNotification(message, "error", 5e3);
    const flashOverlay = document.createElement("div");
    HUDStyles.applyStyles(flashOverlay, {
      position: "fixed",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      backgroundColor: "rgba(255, 0, 0, 0.1)",
      pointerEvents: "none",
      zIndex: "9999",
      animation: "flash 0.5s ease-in-out"
    });
    const flashStyle = document.createElement("style");
    flashStyle.textContent = `
            @keyframes flash {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
    document.head.appendChild(flashStyle);
    document.body.appendChild(flashOverlay);
    setTimeout(() => {
      if (flashOverlay.parentNode) {
        flashOverlay.parentNode.removeChild(flashOverlay);
      }
      if (flashStyle.parentNode) {
        flashStyle.parentNode.removeChild(flashStyle);
      }
    }, 500);
  }
}
class HUDStatusIndicators {
  static createTargetingSystem(parent) {
    const targetingSystem = document.createElement("div");
    targetingSystem.id = "targeting-system";
    HUDStyles.applyStyles(targetingSystem, {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: "100px",
      height: "100px",
      zIndex: "100"
    });
    parent.appendChild(targetingSystem);
    const crosshair = document.createElement("div");
    crosshair.id = "crosshair";
    HUDStyles.applyStyles(crosshair, {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: "50px",
      height: "50px"
    });
    crosshair.innerHTML = `
            <svg width="50" height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="25" cy="25" r="20" stroke="rgba(120, 220, 232, 0.5)" stroke-width="1" stroke-dasharray="8 4"/>
                <circle cx="25" cy="25" r="3" stroke="rgba(120, 220, 232, 0.8)" stroke-width="1"/>
                <circle cx="25" cy="25" r="1" fill="rgba(120, 220, 232, 0.8)"/>
                <line x1="25" y1="10" x2="25" y2="18" stroke="rgba(120, 220, 232, 0.8)" stroke-width="1"/>
                <line x1="25" y1="32" x2="25" y2="40" stroke="rgba(120, 220, 232, 0.8)" stroke-width="1"/>
                <line x1="10" y1="25" x2="18" y2="25" stroke="rgba(120, 220, 232, 0.8)" stroke-width="1"/>
                <line x1="32" y1="25" x2="40" y2="25" stroke="rgba(120, 220, 232, 0.8)" stroke-width="1"/>
                <!-- Add a pulsing animation to the outer circle -->
                <circle cx="25" cy="25" r="24" stroke="rgba(120, 220, 232, 0.3)" stroke-width="1">
                    <animate attributeName="r" values="24;28;24" dur="3s" repeatCount="indefinite"/>
                    <animate attributeName="opacity" values="0.3;0.1;0.3" dur="3s" repeatCount="indefinite"/>
                </circle>
            </svg>
        `;
    targetingSystem.appendChild(crosshair);
    HUDStatusIndicators.createTargetInfoDisplay(parent);
    HUDStatusIndicators.createLaserBeam(parent);
    return targetingSystem;
  }
  static createTargetInfoDisplay(parent) {
    const targetInfo = document.createElement("div");
    targetInfo.id = "target-info";
    targetInfo.className = "hud-panel";
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.maxTouchPoints && navigator.maxTouchPoints > 2 || window.innerWidth <= 768;
    const positionStyles = isMobile ? {
      bottom: "15px",
      top: "auto"
    } : {
      top: "15px",
      bottom: "auto"
    };
    HUDStyles.applyStyles(targetInfo, {
      position: "fixed",
      left: "50%",
      transform: "translateX(-50%)",
      width: "280px",
      padding: "10px 15px",
      backgroundColor: "rgba(6, 22, 31, 0.7)",
      backdropFilter: "blur(5px)",
      borderRadius: "8px",
      fontSize: "14px",
      color: "rgba(120, 220, 232, 0.9)",
      border: "1px solid rgba(120, 220, 232, 0.3)",
      boxShadow: "0 0 15px rgba(120, 220, 232, 0.2)",
      textAlign: "center",
      display: "none",
      zIndex: "999",
      fontFamily: '"Rajdhani", "Electrolize", sans-serif',
      ...positionStyles
    });
    parent.appendChild(targetInfo);
    HUDStyles.addCornerElements(targetInfo);
    targetInfo.innerHTML = `
            <div id="target-name" style="font-weight:600; margin-bottom:5px;">NO TARGET</div>
            <div id="target-distance" style="margin-bottom:0;">DISTANCE: ---</div>
        `;
    return targetInfo;
  }
  static createLaserBeam(parent) {
    const laserBeam = document.createElement("div");
    laserBeam.id = "laser-beam";
    HUDStyles.applyStyles(laserBeam, {
      position: "absolute",
      top: "50%",
      left: "50%",
      width: "0px",
      height: "2px",
      backgroundColor: "rgba(255, 50, 50, 0.8)",
      boxShadow: "0 0 10px rgba(255, 50, 50, 0.8)",
      transformOrigin: "left",
      transform: "rotate(var(--angle, 0deg))",
      zIndex: "90",
      display: "none"
    });
    parent.appendChild(laserBeam);
    return laserBeam;
  }
  static createScanlineEffect(parent) {
    return null;
  }
  /**
   * Update shield display with current shield status
   */
  static updateShieldDisplay(spaceship) {
    const shieldBar = document.getElementById("shield-bar");
    if (!shieldBar) return;
    let shieldPercentage = 100;
    let shieldFound = false;
    try {
      if (window.game && window.game.world) {
        const players = window.game.world.getEntitiesByTag("player");
        if (players && players.length > 0) {
          const player = players[0];
          const health = player.getComponent("HealthComponent");
          if (health) {
            shieldPercentage = health.getShieldPercentage();
            if (spaceship) {
              if (health.shield > spaceship.shield) {
                spaceship.shield = health.shield;
                spaceship.maxShield = health.maxShield;
              } else if (spaceship.shield > health.shield) {
                health.shield = spaceship.shield;
                console.log(`Updated HealthComponent shield from spaceship: ${health.shield}`);
                shieldPercentage = health.getShieldPercentage();
              }
            }
            shieldFound = true;
          }
        }
      }
    } catch (e) {
      console.error("Error accessing player shield component:", e);
    }
    if (!shieldFound && spaceship && spaceship.shield !== void 0) {
      shieldPercentage = spaceship.shield / spaceship.maxShield * 100;
    }
    shieldBar.style.width = `${shieldPercentage}%`;
    if (shieldPercentage < 25) {
      shieldBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (shieldPercentage < 50) {
      shieldBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      shieldBar.style.backgroundColor = "rgba(51, 153, 255, 0.8)";
    }
  }
  /**
   * Update hull display with current hull status
   */
  static updateHullDisplay(spaceship) {
    const hullBar = document.getElementById("hull-bar");
    if (!hullBar) return;
    let hullPercentage = 100;
    let healthFound = false;
    try {
      if (window.game && window.game.world) {
        const players = window.game.world.getEntitiesByTag("player");
        if (players && players.length > 0) {
          const player = players[0];
          const health = player.getComponent("HealthComponent");
          if (health) {
            hullPercentage = health.getHealthPercentage();
            if (spaceship) {
              if (health.health > spaceship.hull) {
                spaceship.hull = health.health;
                spaceship.maxHull = health.maxHealth;
              } else if (spaceship.hull > health.health) {
                health.health = spaceship.hull;
                console.log(`Updated HealthComponent health from spaceship: ${health.health}`);
                hullPercentage = health.getHealthPercentage();
              }
            }
            healthFound = true;
          }
        }
      }
    } catch (e) {
      console.error("Error accessing player health component:", e);
    }
    if (!healthFound && spaceship && spaceship.hull !== void 0) {
      hullPercentage = spaceship.hull / spaceship.maxHull * 100;
    }
    hullBar.style.width = `${hullPercentage}%`;
    if (hullPercentage < 30) {
      hullBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (hullPercentage < 60) {
      hullBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      hullBar.style.backgroundColor = "rgba(120, 220, 232, 0.8)";
    }
  }
  /**
   * Update fuel display with current fuel status
   */
  static updateFuelDisplay(spaceship) {
    const fuelBar = document.getElementById("fuel-bar");
    const fuelValue = document.getElementById("fuel-value");
    if (!fuelBar || !spaceship) return;
    const fuelPercent = spaceship.maxFuel > 0 ? spaceship.fuel / spaceship.maxFuel * 100 : 0;
    fuelBar.style.width = `${fuelPercent}%`;
    if (fuelPercent < 20) {
      fuelBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (fuelPercent < 40) {
      fuelBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      fuelBar.style.backgroundColor = "rgba(120, 220, 232, 0.8)";
    }
    if (fuelValue) {
      fuelValue.textContent = `${Math.round(spaceship.fuel)} / ${Math.round(spaceship.maxFuel)}`;
    }
  }
  /**
   * Update credits display
   */
  static updateCreditsDisplay(spaceship) {
    const creditsDisplay = document.getElementById("credits-value");
    if (creditsDisplay && spaceship) {
      creditsDisplay.textContent = `${spaceship.credits} CR`;
    }
  }
  /**
   * Update location coordinates display
   */
  static updateCoordinates(x, y, z) {
    const coordsElement = document.getElementById("location-coordinates");
    if (coordsElement) {
      coordsElement.textContent = `X: ${Math.round(x)} Y: ${Math.round(y)} Z: ${Math.round(z)}`;
    }
  }
  /**
   * Update FPS display
   */
  static updateFPS(fps, cap) {
    const fpsElement = document.getElementById("fps-display");
    if (fpsElement) {
      if (cap) {
        fpsElement.textContent = `FPS: ${Math.round(fps)}/${cap}`;
        if (fps < cap * 0.9) {
          fpsElement.style.color = "rgba(255, 120, 120, 0.9)";
        } else {
          fpsElement.style.color = "rgba(120, 220, 232, 0.8)";
        }
      } else {
        fpsElement.textContent = `FPS: ${Math.round(fps)}`;
        fpsElement.style.color = "rgba(120, 220, 232, 0.8)";
      }
      if (window.game && window.game.ui && window.game.ui.settings && window.game.ui.settings.settings.frameRateCap === "auto") {
        window.game.ui.settings.monitorRefreshRate || 60;
        if (cap > 0) {
          fpsElement.textContent = `FPS: ${Math.round(fps)}/${cap} (Auto)`;
        } else {
          fpsElement.textContent = `FPS: ${Math.round(fps)} (Auto: Unlimited)`;
        }
      }
    }
  }
  /**
   * Update location display
   */
  static updateLocation(locationName, systemName = "Unknown System") {
    const currentSystem = document.getElementById("current-system");
    if (currentSystem) {
      currentSystem.textContent = systemName.toUpperCase();
    }
  }
}
class HUDEventHandlers {
  constructor() {
    this.animationFrames = [];
    this.glitchInterval = null;
    this.scanline = null;
  }
  /**
   * Initialize startup animation and effects
   */
  animateHudIn() {
    this.addStartupGlitchEffect();
    setTimeout(() => {
      if (this.scanline) {
        this.animateScanline();
      }
    }, 1500);
  }
  /**
   * Add startup glitch effect to show HUD is initializing
   */
  addStartupGlitchEffect() {
    const hudContainer = document.getElementById("hud-container");
    if (!hudContainer) return;
    setTimeout(() => {
      hudContainer.style.opacity = "0.3";
      this.addGlitch(hudContainer);
    }, 300);
    setTimeout(() => {
      hudContainer.style.opacity = "0.7";
      this.addGlitch(hudContainer);
    }, 800);
    setTimeout(() => {
      hudContainer.style.opacity = "1";
      this.addGlitch(hudContainer);
    }, 1200);
    this.glitchInterval = setInterval(() => {
      if (Math.random() > 0.7) {
        this.addGlitch(hudContainer);
      }
    }, 5e3);
  }
  /**
   * Add glitch effect to an element
   */
  addGlitch(element) {
    const animationName = HUDStyles.createGlitchAnimation();
    element.style.animation = `${animationName} 1s forwards`;
    setTimeout(() => {
      element.style.animation = "";
      const styles = document.querySelectorAll("style");
      styles.forEach((style) => {
        if (style.textContent.includes(animationName)) {
          style.remove();
        }
      });
    }, 1e3);
  }
  /**
   * Animate the scanline moving down the screen
   */
  animateScanline() {
    let position = 0;
    const height = window.innerHeight;
    const moveScanline = () => {
      if (!this.scanline) return;
      position = (position + 2) % height;
      this.scanline.style.top = `${position}px`;
      if (Math.random() > 0.97) {
        this.scanline.style.opacity = "0";
        setTimeout(() => {
          if (this.scanline) {
            this.scanline.style.opacity = "0.7";
          }
        }, 50);
      }
      this.animationFrames.push(requestAnimationFrame(moveScanline));
    };
    moveScanline();
  }
  /**
   * Set the scanline element reference
   */
  setScanline(scanlineElement) {
    this.scanline = scanlineElement;
  }
  /**
   * Handle location changes with glitch effect
   */
  handleLocationChange(locationName, systemName) {
    const locationPanel = document.getElementById("location-panel");
    if (locationPanel) {
      this.addGlitch(locationPanel);
    }
  }
  /**
   * Show HUD with animations
   */
  show() {
    const hudContainer = document.getElementById("hud-container");
    if (hudContainer) {
      hudContainer.style.opacity = "1";
    }
    if (this.scanline) {
      this.animateScanline();
    }
    if (!this.glitchInterval) {
      this.glitchInterval = setInterval(() => {
        if (Math.random() > 0.7) {
          this.addGlitch(hudContainer);
        }
      }, 5e3);
    }
  }
  /**
   * Hide HUD
   */
  hide() {
    const hudContainer = document.getElementById("hud-container");
    if (hudContainer) {
      hudContainer.style.opacity = "0";
    }
    this.animationFrames.forEach((frame) => cancelAnimationFrame(frame));
    this.animationFrames = [];
    if (this.glitchInterval) {
      clearInterval(this.glitchInterval);
      this.glitchInterval = null;
    }
  }
  /**
   * Clean up resources and event listeners
   */
  destroy() {
    this.animationFrames.forEach((frameId) => {
      cancelAnimationFrame(frameId);
    });
    this.animationFrames = [];
    if (this.glitchInterval) {
      clearInterval(this.glitchInterval);
      this.glitchInterval = null;
    }
    const controls = document.getElementById("show-controls");
    if (controls) {
      controls.removeEventListener("click", controls.clickHandler);
      controls.removeEventListener("mouseover", controls.mouseoverHandler);
      controls.removeEventListener("mouseout", controls.mouseoutHandler);
    }
    this.scanline = null;
  }
  /**
   * Handle window resize events
   */
  handleResize() {
    if (this.scanline) {
      this.animateScanline();
    }
  }
  /**
   * Handle performance monitoring
   */
  handlePerformanceUpdate(fps, frameTime) {
    if (fps < 30) {
      if (this.glitchInterval) {
        clearInterval(this.glitchInterval);
        this.glitchInterval = setInterval(() => {
          if (Math.random() > 0.9) {
            this.addGlitch(document.getElementById("hud-container"));
          }
        }, 1e4);
      }
    }
  }
  /**
   * Handle game state changes
   */
  handleGameStateChange(newState, oldState) {
    switch (newState) {
      case "playing":
        this.show();
        break;
      case "paused":
        const hudContainer = document.getElementById("hud-container");
        if (hudContainer) {
          hudContainer.style.opacity = "0.5";
        }
        break;
      case "game-over":
        this.hide();
        break;
    }
  }
  /**
   * Handle critical events that need immediate visual feedback
   */
  handleCriticalEvent(eventType, data) {
    const hudContainer = document.getElementById("hud-container");
    switch (eventType) {
      case "low-health":
        if (hudContainer) {
          hudContainer.style.filter = "hue-rotate(0deg) saturate(1.5)";
          setTimeout(() => {
            hudContainer.style.filter = "none";
          }, 200);
        }
        break;
      case "shield-down":
        if (hudContainer) {
          hudContainer.style.filter = "hue-rotate(240deg) saturate(1.5)";
          setTimeout(() => {
            hudContainer.style.filter = "none";
          }, 300);
        }
        break;
      case "low-fuel":
        if (hudContainer) {
          hudContainer.style.filter = "hue-rotate(60deg) saturate(1.5)";
          setTimeout(() => {
            hudContainer.style.filter = "none";
          }, 250);
        }
        break;
    }
  }
}
class HUDHelpers {
  /**
   * Format a number with appropriate units (K, M, B)
   */
  static formatNumber(num) {
    if (num >= 1e9) {
      return (num / 1e9).toFixed(1) + "B";
    }
    if (num >= 1e6) {
      return (num / 1e6).toFixed(1) + "M";
    }
    if (num >= 1e3) {
      return (num / 1e3).toFixed(1) + "K";
    }
    return num.toString();
  }
  /**
   * Format time in MM:SS format
   */
  static formatTime(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  /**
   * Format coordinates for display
   */
  static formatCoordinates(x, y, z) {
    return `X: ${Math.round(x)} Y: ${Math.round(y)} Z: ${Math.round(z)}`;
  }
  /**
   * Format distance with appropriate units
   */
  static formatDistance(distance) {
    if (distance >= 1e3) {
      return `${(distance / 1e3).toFixed(1)} km`;
    }
    return `${Math.round(distance)} m`;
  }
  /**
   * Format percentage for display
   */
  static formatPercentage(value, maxValue) {
    if (maxValue === 0) return 0;
    return Math.round(value / maxValue * 100);
  }
  /**
   * Get color based on percentage value (green to red)
   */
  static getStatusColor(percentage) {
    if (percentage >= 75) {
      return "rgba(95, 255, 143, 0.8)";
    } else if (percentage >= 50) {
      return "rgba(255, 255, 95, 0.8)";
    } else if (percentage >= 25) {
      return "rgba(255, 204, 0, 0.8)";
    } else {
      return "rgba(255, 80, 80, 0.8)";
    }
  }
  /**
   * Get fuel color based on fuel level
   */
  static getFuelColor(fuelPercent) {
    if (fuelPercent < 20) {
      return "rgba(255, 80, 80, 0.8)";
    } else if (fuelPercent < 40) {
      return "rgba(255, 204, 0, 0.8)";
    } else {
      return "rgba(120, 220, 232, 0.8)";
    }
  }
  /**
   * Get shield color based on shield level
   */
  static getShieldColor(shieldPercent) {
    if (shieldPercent < 25) {
      return "rgba(255, 80, 80, 0.8)";
    } else if (shieldPercent < 50) {
      return "rgba(255, 204, 0, 0.8)";
    } else {
      return "rgba(51, 153, 255, 0.8)";
    }
  }
  /**
   * Get hull color based on hull integrity
   */
  static getHullColor(hullPercent) {
    if (hullPercent < 30) {
      return "rgba(255, 80, 80, 0.8)";
    } else if (hullPercent < 60) {
      return "rgba(255, 204, 0, 0.8)";
    } else {
      return "rgba(120, 220, 232, 0.8)";
    }
  }
  /**
   * Check if device is mobile
   */
  static isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.maxTouchPoints && navigator.maxTouchPoints > 2 || window.innerWidth <= 768;
  }
  /**
   * Clamp a value between min and max
   */
  static clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  /**
   * Linear interpolation between two values
   */
  static lerp(start, end, factor) {
    return start + (end - start) * factor;
  }
  /**
   * Convert degrees to radians
   */
  static degToRad(degrees) {
    return degrees * (Math.PI / 180);
  }
  /**
   * Convert radians to degrees
   */
  static radToDeg(radians) {
    return radians * (180 / Math.PI);
  }
  /**
   * Get resource icon color based on type
   */
  static getResourceColor(resourceType) {
    switch (resourceType.toLowerCase()) {
      case "iron":
        return "rgba(180, 180, 180, 0.8)";
      case "gold":
        return "rgba(255, 215, 0, 0.8)";
      case "platinum":
        return "rgba(229, 228, 226, 0.8)";
      case "titanium":
        return "rgba(135, 135, 135, 0.8)";
      case "uranium":
        return "rgba(0, 255, 0, 0.8)";
      default:
        return "rgba(120, 220, 232, 0.8)";
    }
  }
  /**
   * Generate a random ID for temporary elements
   */
  static generateId(prefix = "hud") {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Debounce function to limit how often a function can be called
   */
  static debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  /**
   * Throttle function to limit how often a function can be called
   */
  static throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  /**
   * Safe access to nested object properties
   */
  static safeGet(obj, path, defaultValue = null) {
    try {
      return path.split(".").reduce((current, key) => current[key], obj) ?? defaultValue;
    } catch {
      return defaultValue;
    }
  }
  /**
   * Check if an element is visible in the viewport
   */
  static isElementVisible(element) {
    if (!element) return false;
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
  }
  /**
   * Get the current game state safely
   */
  static getGameState() {
    return HUDHelpers.safeGet(window, "game.state", "unknown");
  }
  /**
   * Get player data safely
   */
  static getPlayerData() {
    try {
      if (window.game && window.game.world) {
        const players = window.game.world.getEntitiesByTag("player");
        return players && players.length > 0 ? players[0] : null;
      }
    } catch (e) {
      console.error("Error accessing player data:", e);
    }
    return null;
  }
  /**
   * Get player health component safely
   */
  static getPlayerHealthComponent() {
    const player = HUDHelpers.getPlayerData();
    if (player) {
      try {
        return player.getComponent("HealthComponent");
      } catch (e) {
        console.error("Error accessing health component:", e);
      }
    }
    return null;
  }
  /**
   * Validate and sanitize user input
   */
  static sanitizeString(str) {
    if (typeof str !== "string") return "";
    return str.replace(/[<>'"&]/g, "");
  }
  /**
   * Check if a value is numeric
   */
  static isNumeric(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }
  /**
   * Get optimal text color for given background color
   */
  static getOptimalTextColor(backgroundColor) {
    const rgb = backgroundColor.match(/\d+/g);
    if (rgb && rgb.length >= 3) {
      const luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;
      return luminance > 0.5 ? "#000000" : "#ffffff";
    }
    return "#ffffff";
  }
}
class HUD {
  constructor(spaceship) {
    this.spaceship = spaceship;
    this.eventHandlers = new HUDEventHandlers();
    this.setupHUD();
    this.eventHandlers.animateHudIn();
  }
  setupHUD() {
    HUDStyles.initializeStyles();
    const hudContainer = this.createMainContainer();
    const scanline = HUDStatusIndicators.createScanlineEffect(hudContainer);
    this.eventHandlers.setScanline(scanline);
    HUDDisplays.createFlightPanel(hudContainer);
    HUDDisplays.createStatusPanel(hudContainer);
    HUDStatusIndicators.createTargetingSystem(hudContainer);
    HUDDisplays.createLocationPanel(hudContainer);
    HUDDisplays.createResourcePanel(hudContainer);
    HUDNotifications.createNotificationsArea(hudContainer);
  }
  createMainContainer() {
    const hudContainer = document.createElement("div");
    hudContainer.id = "hud-container";
    HUDStyles.applyStyles(hudContainer, HUDStyles.getMainContainerStyles());
    document.body.appendChild(hudContainer);
    return hudContainer;
  }
  update() {
    if (!this.spaceship) return;
    HUDStatusIndicators.updateShieldDisplay(this.spaceship);
    HUDStatusIndicators.updateHullDisplay(this.spaceship);
    HUDStatusIndicators.updateFuelDisplay(this.spaceship);
    HUDStatusIndicators.updateCreditsDisplay(this.spaceship);
    HUDNotifications.updateHordeModeDisplay();
  }
  updateLocation(locationName, systemName = "Unknown System") {
    HUDStatusIndicators.updateLocation(locationName, systemName);
    this.eventHandlers.handleLocationChange(locationName, systemName);
  }
  updateCoordinates(x, y, z) {
    HUDStatusIndicators.updateCoordinates(x, y, z);
  }
  updateFPS(fps, cap) {
    HUDStatusIndicators.updateFPS(fps, cap);
  }
  hide() {
    this.eventHandlers.hide();
  }
  show() {
    this.eventHandlers.show();
  }
  destroy() {
    this.eventHandlers.destroy();
    const hudContainer = document.getElementById("hud-container");
    if (hudContainer && hudContainer.parentNode) {
      hudContainer.parentNode.removeChild(hudContainer);
    }
    this.spaceship = null;
    this.eventHandlers = null;
  }
  // Backward compatibility methods
  updateShieldDisplay() {
    HUDStatusIndicators.updateShieldDisplay(this.spaceship);
  }
  updateHullDisplay() {
    HUDStatusIndicators.updateHullDisplay(this.spaceship);
  }
  updateHordeModeDisplay() {
    HUDNotifications.updateHordeModeDisplay();
  }
  // Utility methods for external access
  showNotification(message, type = "info", duration = 3e3) {
    HUDNotifications.showNotification(message, type, duration);
  }
  showCriticalAlert(message) {
    HUDNotifications.showCriticalAlert(message);
  }
  // Helper method access
  static get helpers() {
    return HUDHelpers;
  }
}
class MobileHUD {
  constructor(spaceship) {
    this.spaceship = spaceship;
    this.controls = null;
    this.setupMobileHUD();
  }
  setupMobileHUD() {
    const style = document.createElement("style");
    style.textContent = `
            @keyframes pulse-horde-mobile {
                0% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.5); }
                50% { box-shadow: 0 0 10px rgba(255, 30, 30, 0.8); }
                100% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.5); }
            }
        `;
    document.head.appendChild(style);
    const hudContainer = document.createElement("div");
    hudContainer.id = "mobile-hud-container";
    hudContainer.style.position = "absolute";
    hudContainer.style.top = "10px";
    hudContainer.style.right = "10px";
    hudContainer.style.width = "min(140px, 25vw)";
    hudContainer.style.backgroundColor = "rgba(6, 22, 31, 0.8)";
    hudContainer.style.backdropFilter = "blur(5px)";
    hudContainer.style.webkitBackdropFilter = "blur(5px)";
    hudContainer.style.borderRadius = "8px";
    hudContainer.style.border = "1px solid rgba(120, 220, 232, 0.3)";
    hudContainer.style.padding = "10px";
    hudContainer.style.color = "rgba(120, 220, 232, 0.9)";
    hudContainer.style.fontFamily = '"Rajdhani", "Electrolize", sans-serif';
    hudContainer.style.fontSize = "14px";
    hudContainer.style.boxShadow = "0 0 10px rgba(120, 220, 232, 0.2)";
    hudContainer.style.zIndex = "1000";
    hudContainer.style.transform = "translateZ(0)";
    hudContainer.style.backfaceVisibility = "hidden";
    document.body.appendChild(hudContainer);
    this.createStatusBar(hudContainer, "S", "shield-bar-mobile", "rgba(51, 153, 255, 0.8)");
    this.createStatusBar(hudContainer, "H", "hull-bar-mobile", "rgba(120, 220, 232, 0.8)");
    this.createStatusBar(hudContainer, "F", "fuel-bar-mobile", "rgba(120, 220, 232, 0.8)");
    this.createAnomalyDisplay(hudContainer);
    const cargoContainer = document.createElement("div");
    cargoContainer.style.display = "flex";
    cargoContainer.style.justifyContent = "space-between";
    cargoContainer.style.alignItems = "center";
    cargoContainer.style.marginTop = "10px";
    const cargoLabel = document.createElement("div");
    cargoLabel.textContent = "C";
    cargoLabel.style.marginRight = "10px";
    cargoLabel.style.fontSize = "14px";
    const cargoValue = document.createElement("div");
    cargoValue.id = "cargo-value-mobile";
    cargoValue.textContent = "0 / 1000";
    cargoValue.style.textAlign = "right";
    cargoValue.style.flexGrow = "1";
    cargoValue.style.fontSize = "14px";
    cargoContainer.appendChild(cargoLabel);
    cargoContainer.appendChild(cargoValue);
    hudContainer.appendChild(cargoContainer);
    const hordeContainer = document.createElement("div");
    hordeContainer.id = "mobile-horde-indicator";
    hordeContainer.style.display = "none";
    hordeContainer.style.marginTop = "10px";
    hordeContainer.style.padding = "5px";
    hordeContainer.style.backgroundColor = "rgba(255, 30, 30, 0.2)";
    hordeContainer.style.borderRadius = "4px";
    hordeContainer.style.border = "1px solid #ff3030";
    hordeContainer.style.animation = "pulse-horde-mobile 2s infinite";
    hordeContainer.style.fontSize = "12px";
    const hordeTimer = document.createElement("div");
    hordeTimer.id = "mobile-horde-timer";
    hordeTimer.textContent = "00:00";
    hordeTimer.style.textAlign = "center";
    hordeTimer.style.fontWeight = "bold";
    hordeTimer.style.color = "#ff3030";
    hordeContainer.appendChild(hordeTimer);
    hudContainer.appendChild(hordeContainer);
    this.addCornerElements(hudContainer);
  }
  createStatusBar(parent, label, id, color) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.marginBottom = "8px";
    const labelElement = document.createElement("div");
    labelElement.textContent = label;
    labelElement.style.marginRight = "8px";
    labelElement.style.width = "16px";
    labelElement.style.textAlign = "center";
    labelElement.style.fontSize = "14px";
    const barContainer = document.createElement("div");
    barContainer.style.flexGrow = "1";
    barContainer.style.height = "8px";
    barContainer.style.backgroundColor = "rgba(10, 30, 40, 0.5)";
    barContainer.style.borderRadius = "4px";
    barContainer.style.overflow = "hidden";
    barContainer.style.position = "relative";
    if (id === "fuel-bar-mobile") {
      const fuelValue = document.createElement("div");
      fuelValue.id = "fuel-value-mobile";
      fuelValue.style.position = "absolute";
      fuelValue.style.right = "0";
      fuelValue.style.top = "-14px";
      fuelValue.style.fontSize = "10px";
      fuelValue.style.color = "rgba(120, 220, 232, 0.9)";
      fuelValue.textContent = "100 / 100";
      barContainer.appendChild(fuelValue);
    }
    const bar = document.createElement("div");
    bar.id = id;
    bar.style.width = "100%";
    bar.style.height = "100%";
    bar.style.backgroundColor = color;
    bar.style.transition = "width 0.2s ease";
    barContainer.appendChild(bar);
    container.appendChild(labelElement);
    container.appendChild(barContainer);
    parent.appendChild(container);
  }
  createAnomalyDisplay(parent) {
    const anomalyContainer = document.createElement("div");
    anomalyContainer.style.display = "flex";
    anomalyContainer.style.justifyContent = "space-between";
    anomalyContainer.style.alignItems = "center";
    anomalyContainer.style.marginBottom = "8px";
    const anomalyLabel = document.createElement("div");
    anomalyLabel.textContent = "A";
    anomalyLabel.style.marginRight = "8px";
    anomalyLabel.style.width = "16px";
    anomalyLabel.style.textAlign = "center";
    anomalyLabel.style.fontSize = "14px";
    const anomalyCount = document.createElement("div");
    anomalyCount.id = "anomaly-count-mobile";
    anomalyCount.textContent = "0";
    anomalyCount.style.textAlign = "right";
    anomalyCount.style.flexGrow = "1";
    anomalyCount.style.fontSize = "14px";
    anomalyCount.style.fontWeight = "bold";
    anomalyCount.style.color = "rgba(120, 220, 232, 0.9)";
    anomalyContainer.appendChild(anomalyLabel);
    anomalyContainer.appendChild(anomalyCount);
    parent.appendChild(anomalyContainer);
  }
  addCornerElements(panel) {
    const topLeft = document.createElement("div");
    topLeft.style.position = "absolute";
    topLeft.style.top = "0";
    topLeft.style.left = "0";
    topLeft.style.width = "6px";
    topLeft.style.height = "6px";
    topLeft.style.borderTop = "1px solid rgba(120, 220, 232, 0.8)";
    topLeft.style.borderLeft = "1px solid rgba(120, 220, 232, 0.8)";
    panel.appendChild(topLeft);
    const topRight = document.createElement("div");
    topRight.style.position = "absolute";
    topRight.style.top = "0";
    topRight.style.right = "0";
    topRight.style.width = "6px";
    topRight.style.height = "6px";
    topRight.style.borderTop = "1px solid rgba(120, 220, 232, 0.8)";
    topRight.style.borderRight = "1px solid rgba(120, 220, 232, 0.8)";
    panel.appendChild(topRight);
    const bottomLeft = document.createElement("div");
    bottomLeft.style.position = "absolute";
    bottomLeft.style.bottom = "0";
    bottomLeft.style.left = "0";
    bottomLeft.style.width = "6px";
    bottomLeft.style.height = "6px";
    bottomLeft.style.borderBottom = "1px solid rgba(120, 220, 232, 0.8)";
    bottomLeft.style.borderLeft = "1px solid rgba(120, 220, 232, 0.8)";
    panel.appendChild(bottomLeft);
    const bottomRight = document.createElement("div");
    bottomRight.style.position = "absolute";
    bottomRight.style.bottom = "0";
    bottomRight.style.right = "0";
    bottomRight.style.width = "6px";
    bottomRight.style.height = "6px";
    bottomRight.style.borderBottom = "1px solid rgba(120, 220, 232, 0.8)";
    bottomRight.style.borderRight = "1px solid rgba(120, 220, 232, 0.8)";
    panel.appendChild(bottomRight);
  }
  update() {
    this.updateShieldDisplay();
    this.updateHullDisplay();
    this.updateFuelDisplay();
    this.updateCargoDisplay();
    this.updateAnomalyCount();
    this.updateHordeModeDisplay();
  }
  updateShieldDisplay() {
    const shieldBar = document.getElementById("shield-bar-mobile");
    if (!shieldBar) return;
    let shieldPercentage = 100;
    if (this.spaceship && typeof this.spaceship.shield !== "undefined") {
      shieldPercentage = this.spaceship.shield / this.spaceship.maxShield * 100;
    }
    shieldBar.style.width = `${shieldPercentage}%`;
    if (shieldPercentage < 25) {
      shieldBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (shieldPercentage < 50) {
      shieldBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      shieldBar.style.backgroundColor = "rgba(51, 153, 255, 0.8)";
    }
  }
  updateHullDisplay() {
    const hullBar = document.getElementById("hull-bar-mobile");
    if (!hullBar) return;
    let hullPercentage = 100;
    if (this.spaceship && typeof this.spaceship.hull !== "undefined") {
      hullPercentage = this.spaceship.hull / this.spaceship.maxHull * 100;
    }
    hullBar.style.width = `${hullPercentage}%`;
    if (hullPercentage < 30) {
      hullBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (hullPercentage < 60) {
      hullBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      hullBar.style.backgroundColor = "rgba(120, 220, 232, 0.8)";
    }
  }
  updateFuelDisplay() {
    const fuelBar = document.getElementById("fuel-bar-mobile");
    const fuelValue = document.getElementById("fuel-value-mobile");
    if (!fuelBar || !this.spaceship) return;
    const fuelPercent = this.spaceship.maxFuel > 0 ? this.spaceship.fuel / this.spaceship.maxFuel * 100 : 0;
    fuelBar.style.width = `${fuelPercent}%`;
    if (fuelPercent < 20) {
      fuelBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
    } else if (fuelPercent < 40) {
      fuelBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
    } else {
      fuelBar.style.backgroundColor = "rgba(120, 220, 232, 0.8)";
    }
    if (fuelValue) {
      fuelValue.textContent = `${Math.round(this.spaceship.fuel)} / ${Math.round(this.spaceship.maxFuel)}`;
    }
  }
  updateCargoDisplay() {
    const cargoValue = document.getElementById("cargo-value-mobile");
    if (!cargoValue) return;
    let resources = null;
    let maxCargo = 1e3;
    if (this.controls && this.controls.resources) {
      resources = this.controls.resources;
      if (this.spaceship && typeof this.spaceship.maxCargoCapacity !== "undefined") {
        maxCargo = this.spaceship.maxCargoCapacity;
      }
    } else if (this.spaceship && this.spaceship.cargoComponent && this.spaceship.cargoComponent.resources) {
      resources = this.spaceship.cargoComponent.resources;
      maxCargo = this.spaceship.cargoComponent.maxCapacity;
    } else if (this.spaceship && this.spaceship.resources) {
      resources = this.spaceship.resources;
    }
    if (!resources) return;
    let totalCargo = 0;
    for (const key in resources) {
      if (resources.hasOwnProperty(key)) {
        const amount = parseFloat(resources[key]) || 0;
        totalCargo += amount;
      }
    }
    totalCargo = Math.round(totalCargo);
    cargoValue.textContent = `${totalCargo} / ${maxCargo}`;
    if (totalCargo >= maxCargo * 0.9) {
      cargoValue.style.color = "rgba(255, 80, 80, 0.9)";
    } else if (totalCargo >= maxCargo * 0.7) {
      cargoValue.style.color = "rgba(255, 204, 0, 0.9)";
    } else {
      cargoValue.style.color = "rgba(120, 220, 232, 0.9)";
    }
  }
  updateAnomalyCount() {
    const anomalyCount = document.getElementById("anomaly-count-mobile");
    if (!anomalyCount) return;
    let count = 0;
    if (window.game && window.game.environment && window.game.environment.anomalyCount) {
      count = window.game.environment.anomalyCount;
    }
    anomalyCount.textContent = count.toString();
    if (count > 0) {
      anomalyCount.style.color = "rgba(255, 204, 0, 0.9)";
      anomalyCount.style.textShadow = "0 0 5px rgba(255, 204, 0, 0.5)";
    } else {
      anomalyCount.style.color = "rgba(120, 220, 232, 0.9)";
      anomalyCount.style.textShadow = "none";
    }
  }
  /**
   * Update the horde mode indicator and timer in the mobile HUD
   */
  updateHordeModeDisplay() {
    const hordeIndicator = document.getElementById("mobile-horde-indicator");
    const hordeTimer = document.getElementById("mobile-horde-timer");
    if (!hordeIndicator || !hordeTimer) return;
    if (window.game && window.game.isHordeActive) {
      if (hordeIndicator.style.display === "none") {
        hordeIndicator.style.display = "block";
        hordeIndicator.innerHTML = '<div style="text-align:center; color:#ff3030; font-weight:bold; margin-bottom:2px;">HORDE MODE</div>';
        hordeIndicator.appendChild(hordeTimer);
      }
      if (window.game.getFormattedHordeSurvivalTime) {
        hordeTimer.textContent = window.game.getFormattedHordeSurvivalTime();
      } else {
        const totalSeconds = Math.floor(window.game.hordeSurvivalTime / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        hordeTimer.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      }
      if (window.game.hordeSurvivalTime > 3 * 60 * 1e3) {
        const styleEl = document.createElement("style");
        styleEl.textContent = `
                    @keyframes pulse-horde-mobile {
                        0% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.7); }
                        50% { box-shadow: 0 0 10px rgba(255, 30, 30, 1); }
                        100% { box-shadow: 0 0 5px rgba(255, 30, 30, 0.7); }
                    }
                `;
        document.head.appendChild(styleEl);
        hordeIndicator.style.animation = "pulse-horde-mobile 0.8s infinite";
        hordeIndicator.style.backgroundColor = "rgba(255, 30, 30, 0.3)";
      }
    } else {
      hordeIndicator.style.display = "none";
    }
  }
  hide() {
    const container = document.getElementById("mobile-hud-container");
    if (container) {
      container.style.display = "none";
    }
  }
  show() {
    if (window.game && window.game.introSequenceActive) {
      console.log("MobileHUD: Not showing HUD during intro sequence");
      return;
    }
    const container = document.getElementById("mobile-hud-container");
    if (container) {
      container.style.display = "block";
    }
  }
  // Add method to set controls reference
  setControls(controls) {
    console.log("MobileHUD: Setting controls reference");
    this.controls = controls;
  }
  // Update to handle system name and anomaly count in a simpler way
  updateLocation(locationName, systemName = "Unknown System") {
    this.updateAnomalyCount();
  }
}
class MiningDisplay {
  constructor() {
    this.controls = null;
    this.setupMiningDisplay();
  }
  setControls(controls) {
    this.controls = controls;
  }
  setupMiningDisplay() {
  }
  update() {
    if (this.controls && this.controls.resources) {
      const ironAmount = document.getElementById("iron-amount");
      const goldAmount = document.getElementById("gold-amount");
      const platinumAmount = document.getElementById("platinum-amount");
      const cargoCapacity = document.getElementById("cargo-capacity");
      const capacityBar = document.getElementById("capacity-bar");
      if (ironAmount) ironAmount.textContent = this.controls.resources.iron || 0;
      if (goldAmount) goldAmount.textContent = this.controls.resources.gold || 0;
      if (platinumAmount) platinumAmount.textContent = this.controls.resources.platinum || 0;
      if (cargoCapacity && capacityBar && this.controls.spaceship) {
        const totalResources = (this.controls.resources.iron || 0) + (this.controls.resources.gold || 0) + (this.controls.resources.platinum || 0);
        const maxCapacity = this.controls.spaceship.maxCargoCapacity || 1e3;
        const capacityPercentage = totalResources / maxCapacity * 100;
        cargoCapacity.textContent = `${totalResources} / ${maxCapacity}`;
        capacityBar.style.width = `${capacityPercentage}%`;
        if (capacityPercentage > 90) {
          capacityBar.style.backgroundColor = "rgba(255, 80, 80, 0.8)";
        } else if (capacityPercentage > 75) {
          capacityBar.style.backgroundColor = "rgba(255, 204, 0, 0.8)";
        } else {
          capacityBar.style.backgroundColor = "rgba(120, 220, 232, 0.8)";
        }
      }
      this.updateMiningTimeEstimate();
    }
  }
  /**
   * Update the mining time estimate based on the targeted asteroid type and mining efficiency
   */
  updateMiningTimeEstimate() {
    const miningTimeElement = document.getElementById("mining-time");
    if (!miningTimeElement || !this.controls || !this.controls.miningSystem) return;
    const miningSystem = this.controls.miningSystem;
    if (miningSystem.targetAsteroid && miningSystem.targetAsteroid.resourceType) {
      const resourceType = miningSystem.targetAsteroid.resourceType.toLowerCase();
      const efficiency = miningSystem.getMiningEfficiency();
      const secondsRequired = Math.round(1 / (miningSystem.miningSpeedByType[resourceType] * efficiency));
      miningTimeElement.textContent = `Mining time: ${secondsRequired} seconds`;
      miningTimeElement.style.display = "block";
      if (resourceType === "platinum") {
        miningTimeElement.style.color = "#66ffff";
      } else if (resourceType === "gold") {
        miningTimeElement.style.color = "#ffcc00";
      } else {
        miningTimeElement.style.color = "#a0a0a0";
      }
    } else {
      miningTimeElement.style.display = "none";
    }
  }
  hide() {
    const targetInfo = document.getElementById("target-info");
    if (targetInfo) {
      targetInfo.style.display = "none";
    }
  }
  show() {
  }
}
class TargetingUI {
  constructor() {
    this.setupTargetingUI();
  }
  setupTargetingUI() {
    const lockOnDisplay = document.createElement("div");
    lockOnDisplay.id = "lock-on-display";
    lockOnDisplay.style.position = "absolute";
    lockOnDisplay.style.top = "50%";
    lockOnDisplay.style.left = "50%";
    lockOnDisplay.style.width = "150px";
    lockOnDisplay.style.height = "150px";
    lockOnDisplay.style.transform = "translate(-50%, -50%)";
    lockOnDisplay.style.border = "2px dashed #ff0000";
    lockOnDisplay.style.borderRadius = "50%";
    lockOnDisplay.style.boxSizing = "border-box";
    lockOnDisplay.style.display = "none";
    lockOnDisplay.style.zIndex = "997";
    lockOnDisplay.style.pointerEvents = "none";
    document.body.appendChild(lockOnDisplay);
    const diagonalLines = document.createElement("div");
    diagonalLines.style.position = "absolute";
    diagonalLines.style.width = "100%";
    diagonalLines.style.height = "100%";
    diagonalLines.style.top = "0";
    diagonalLines.style.left = "0";
    diagonalLines.innerHTML = `
            <div style="position: absolute; width: 2px; height: 30px; background-color: #ff0000; top: 0; left: 50%; transform: translateX(-50%);"></div>
            <div style="position: absolute; width: 2px; height: 30px; background-color: #ff0000; bottom: 0; left: 50%; transform: translateX(-50%);"></div>
            <div style="position: absolute; width: 30px; height: 2px; background-color: #ff0000; left: 0; top: 50%; transform: translateY(-50%);"></div>
            <div style="position: absolute; width: 30px; height: 2px; background-color: #ff0000; right: 0; top: 50%; transform: translateY(-50%);"></div>
        `;
    lockOnDisplay.appendChild(diagonalLines);
    const targetIndicator = document.createElement("div");
    targetIndicator.id = "target-indicator";
    targetIndicator.style.position = "absolute";
    targetIndicator.style.bottom = "120px";
    targetIndicator.style.left = "50%";
    targetIndicator.style.transform = "translateX(-50%)";
    targetIndicator.style.width = "200px";
    targetIndicator.style.textAlign = "center";
    targetIndicator.style.backgroundColor = "rgba(255, 50, 50, 0.4)";
    targetIndicator.style.border = "1px solid #ff3030";
    targetIndicator.style.borderRadius = "10px";
    targetIndicator.style.padding = "8px";
    targetIndicator.style.color = "#ffffff";
    targetIndicator.style.fontFamily = "monospace";
    targetIndicator.style.zIndex = "100";
    targetIndicator.style.display = "none";
    targetIndicator.style.boxShadow = "0 0 10px #ff3030";
    targetIndicator.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">◎ TARGET LOCKED ◎</div>
            <div id="target-type">Asteroid</div>
            <div id="target-distance">Distance: 0 units</div>
            <div id="target-resource" style="color: #ffcc00;">Resource: Unknown</div>
        `;
    document.body.appendChild(targetIndicator);
  }
  showLockOn() {
    const lockOnDisplay = document.getElementById("lock-on-display");
    if (lockOnDisplay) {
      lockOnDisplay.style.display = "block";
    }
  }
  hideLockOn() {
    const lockOnDisplay = document.getElementById("lock-on-display");
    if (lockOnDisplay) {
      lockOnDisplay.style.display = "none";
    }
  }
  updateTargetInfo(targetType, distance, resourceType) {
    const targetIndicator = document.getElementById("target-indicator");
    const targetTypeElement = document.getElementById("target-type");
    const targetDistanceElement = document.getElementById("target-distance");
    const targetResourceElement = document.getElementById("target-resource");
    if (targetIndicator && targetTypeElement && targetDistanceElement) {
      targetIndicator.style.display = "block";
      targetTypeElement.textContent = `${targetType}`;
      targetDistanceElement.textContent = `Distance: ${Math.round(distance)} units`;
      if (targetResourceElement && resourceType) {
        let resourceColor = "#cccccc";
        if (resourceType.toLowerCase() === "iron") {
          resourceColor = "#cccccc";
        } else if (resourceType.toLowerCase() === "gold") {
          resourceColor = "#ffcc00";
        } else if (resourceType.toLowerCase() === "platinum") {
          resourceColor = "#66ffff";
        }
        targetResourceElement.textContent = `Resource: ${resourceType}`;
        targetResourceElement.style.color = resourceColor;
      }
      this.addPulseEffect(targetIndicator);
    }
  }
  // Add a subtle pulse animation to the target indicator
  addPulseEffect(element) {
    element.style.animation = "none";
    void element.offsetWidth;
    element.style.animation = "targetPulse 2s infinite";
    if (!document.getElementById("targeting-keyframes")) {
      const style = document.createElement("style");
      style.id = "targeting-keyframes";
      style.textContent = `
                @keyframes targetPulse {
                    0% { box-shadow: 0 0 10px #ff3030; }
                    50% { box-shadow: 0 0 20px #ff3030; }
                    100% { box-shadow: 0 0 10px #ff3030; }
                }
            `;
      document.head.appendChild(style);
    }
  }
  hideTargetInfo() {
    const targetIndicator = document.getElementById("target-indicator");
    if (targetIndicator) {
      targetIndicator.style.display = "none";
    }
  }
}
class TerminalScreen {
  constructor() {
    this.isMobile = false;
  }
  setMobile(isMobile) {
    this.isMobile = isMobile;
  }
  createDockingPrompt() {
    const dockingPrompt = document.createElement("div");
    dockingPrompt.id = "docking-prompt";
    dockingPrompt.style.position = "absolute";
    dockingPrompt.style.top = "50%";
    dockingPrompt.style.left = "50%";
    dockingPrompt.style.transform = "translate(-50%, -50%)";
    dockingPrompt.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    dockingPrompt.style.color = "#33aaff";
    dockingPrompt.style.padding = "20px";
    dockingPrompt.style.borderRadius = "10px";
    dockingPrompt.style.border = "2px solid #33aaff";
    dockingPrompt.style.boxShadow = "0 0 20px #33aaff";
    dockingPrompt.style.fontFamily = "Courier New, monospace";
    dockingPrompt.style.fontSize = "18px";
    dockingPrompt.style.textAlign = "center";
    dockingPrompt.style.zIndex = "1000";
    dockingPrompt.style.display = "none";
    if (this.isMobile) {
      dockingPrompt.style.display = "none";
      dockingPrompt.dataset.alwaysHide = "true";
    } else {
      dockingPrompt.textContent = "Press Q to dock with Stargate";
    }
    document.body.appendChild(dockingPrompt);
    return dockingPrompt;
  }
  createMainUI() {
    const stargateUI = document.createElement("div");
    stargateUI.id = "stargate-ui";
    if (this.isMobile) {
      stargateUI.style.width = "95%";
      stargateUI.style.maxWidth = "95vw";
      stargateUI.style.webkitOverflowScrolling = "touch";
      stargateUI.style.touchAction = "pan-y";
      stargateUI.style.overscrollBehavior = "contain";
    }
    return stargateUI;
  }
  showDockingPrompt() {
    const dockingPrompt = document.getElementById("docking-prompt");
    if (dockingPrompt && dockingPrompt.dataset.alwaysHide !== "true") {
      dockingPrompt.style.display = "block";
    }
  }
  hideDockingPrompt() {
    const dockingPrompt = document.getElementById("docking-prompt");
    if (dockingPrompt) {
      dockingPrompt.style.display = "none";
    }
  }
  updateResourceDisplay(resource, value) {
    const element = document.getElementById(`ms-${resource}`);
    if (element) {
      element.textContent = value;
    }
  }
  updateStatusBar(barId, percentage) {
    const bar = document.getElementById(barId);
    if (bar) {
      bar.style.width = `${percentage}%`;
    }
  }
  updateCredits(credits) {
    const element = document.getElementById("ms-credits");
    if (element) {
      element.textContent = `${credits} CR`;
    }
  }
  updateOrbCount(rarity, count) {
    const element = document.getElementById(`orb-${rarity}-count`);
    if (element) {
      element.textContent = `${count} in inventory`;
    }
  }
  updateUpgradeLevel(upgradeType, level) {
    const element = document.getElementById(`current-${upgradeType}-level`);
    if (element) {
      element.textContent = level;
    }
  }
  updateUpgradeProgress(upgradeType, percentage) {
    const progressBar = document.getElementById(`${upgradeType}-upgrade-progress`);
    if (progressBar) {
      progressBar.style.width = `${percentage}%`;
    }
  }
  updateUpgradeCost(upgradeType, cost) {
    const element = document.getElementById(`${upgradeType}-upgrade-cost`);
    if (element) {
      element.textContent = cost;
    }
  }
  showUI() {
    const ui = document.getElementById("stargate-ui");
    if (ui) {
      ui.style.display = "block";
    }
  }
  hideUI() {
    const ui = document.getElementById("stargate-ui");
    if (ui) {
      ui.style.display = "none";
    }
  }
}
class TerminalEffects {
  constructor() {
    this.stylesInjected = false;
  }
  createStyles() {
    if (this.stylesInjected) return;
    const style = document.createElement("style");
    style.textContent = `
            @keyframes pulse-warning {
                0% { box-shadow: 0 0 15px rgba(255, 48, 48, 0.5); }
                50% { box-shadow: 0 0 25px rgba(255, 48, 48, 0.8); }
                100% { box-shadow: 0 0 15px rgba(255, 48, 48, 0.5); }
            }
            
            @keyframes pulse-glow {
                0%, 100% { opacity: 0.5; }
                50% { opacity: 1; }
            }
            
            /* Stargate Terminal Base Styles */
            #stargate-ui {
                --primary-bg: rgba(20, 30, 50, 0.9);
                --primary-border: #33aaff;
                --section-bg: rgba(10, 20, 35, 0.8);
                --accent-blue: #33aaff;
                --accent-green: #00cc33;
                --accent-orange: #ff9900;
                --accent-red: #ff3030;
                --accent-purple: #9933cc;
                --accent-cyan: #30cfd0;
                
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80%;
                max-width: 1000px;
                max-height: 90vh;
                background-color: var(--primary-bg);
                color: #fff;
                border-radius: 15px;
                border: 2px solid var(--primary-border);
                box-shadow: 0 0 30px var(--primary-border);
                font-family: 'Courier New', monospace;
                z-index: 1000;
                display: none;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 0;
            }
            
            /* Layout and Structure Styles */
            #stargate-header {
                background-color: rgba(30, 40, 60, 0.9);
                padding: 15px 20px;
                border-bottom: 1px solid var(--primary-border);
                position: sticky;
                top: 0;
                z-index: 10;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            #stargate-content {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .stargate-section {
                background-color: var(--section-bg);
                border-radius: 10px;
                padding: 15px;
                border: 1px solid rgba(51, 170, 255, 0.3);
            }
            
            .stargate-section h3 {
                color: var(--accent-blue);
                margin-top: 0;
                margin-bottom: 15px;
                padding-bottom: 8px;
                border-bottom: 1px solid rgba(51, 170, 255, 0.3);
                font-size: 1.2em;
            }
            
            ${this.getComponentStyles()}
            
            /* Resource Border Effects */
            .iron-border { 
                border: 1px solid #cc6633; 
                box-shadow: 0 0 10px rgba(204, 102, 51, 0.3); 
            }
            .gold-border { 
                border: 1px solid #ffcc33; 
                box-shadow: 0 0 10px rgba(255, 204, 51, 0.3); 
            }
            .platinum-border { 
                border: 1px solid #33ccff; 
                box-shadow: 0 0 10px rgba(51, 204, 255, 0.3); 
            }
            .common-border { 
                border: 1px solid #00ff66; 
                box-shadow: 0 0 10px rgba(0, 255, 102, 0.3); 
            }
            .uncommon-border { 
                border: 1px solid #0066ff; 
                box-shadow: 0 0 10px rgba(0, 102, 255, 0.3); 
            }
            .rare-border { 
                border: 1px solid #9900ff; 
                box-shadow: 0 0 10px rgba(153, 0, 255, 0.3); 
            }
            .epic-border { 
                border: 1px solid #ff6600; 
                box-shadow: 0 0 10px rgba(255, 102, 0, 0.3); 
            }
            .legendary-border { 
                border: 1px solid #ff0000; 
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.3); 
            }
            
            /* Undock Button Glow Effects */
            .btn-undock {
                background: linear-gradient(135deg, #00a8ff 0%, #0066cc 100%);
                font-size: 1.4em;
                font-weight: bold;
                letter-spacing: 3px;
                padding: 16px 40px;
                width: auto;
                min-width: 200px;
                margin-bottom: 15px;
                border: 2px solid #00d4ff;
                box-shadow: 0 0 20px rgba(0, 212, 255, 0.5), inset 0 0 20px rgba(0, 168, 255, 0.2);
                text-transform: uppercase;
                position: relative;
                overflow: hidden;
                transition: all 0.3s ease;
            }
            
            .btn-undock:hover {
                background: linear-gradient(135deg, #00d4ff 0%, #0088ff 100%);
                box-shadow: 0 0 30px rgba(0, 212, 255, 0.8), inset 0 0 20px rgba(0, 212, 255, 0.3);
                transform: translateY(-2px);
            }
            
            .btn-undock:active {
                transform: translateY(0);
            }
            
            .btn-undock::before {
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                background: linear-gradient(45deg, transparent, #00d4ff, transparent);
                z-index: -1;
                opacity: 0;
                transition: opacity 0.3s;
                animation: pulse-glow 2s infinite;
            }
            
            .btn-undock:hover::before {
                opacity: 1;
            }
            
            /* Horde Button Warning Effects */
            .btn-horde { 
                background: linear-gradient(135deg, #990000 0%, var(--accent-red) 100%);
                color: #fff;
                border: 2px solid var(--accent-red);
                box-shadow: 0 0 15px rgba(255, 48, 48, 0.5);
                animation: pulse-warning 2s infinite;
            }
        `;
    document.head.appendChild(style);
    this.stylesInjected = true;
  }
  applyGlowEffect(element, color = "#33aaff", intensity = 0.5) {
    if (!element) return;
    element.style.boxShadow = `0 0 20px rgba(${this.hexToRgb(color)}, ${intensity})`;
  }
  removeGlowEffect(element) {
    if (!element) return;
    element.style.boxShadow = "";
  }
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : "255, 255, 255";
  }
  addPulseAnimation(element, color = "#ff3030") {
    if (!element) return;
    element.style.animation = "pulse-warning 2s infinite";
    element.style.boxShadow = `0 0 15px rgba(${this.hexToRgb(color)}, 0.5)`;
  }
  removePulseAnimation(element) {
    if (!element) return;
    element.style.animation = "";
    element.style.boxShadow = "";
  }
  addBorderGlow(element, type) {
    if (!element) return;
    const glowClasses = [
      "iron-border",
      "gold-border",
      "platinum-border",
      "common-border",
      "uncommon-border",
      "rare-border",
      "epic-border",
      "legendary-border"
    ];
    element.classList.remove(...glowClasses);
    if (type && glowClasses.includes(`${type}-border`)) {
      element.classList.add(`${type}-border`);
    }
  }
  getComponentStyles() {
    return `
            /* Ship Status Section */
            #ship-status-section {
                grid-column: 1;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .resources-container {
                display: flex;
                gap: 5px;
                margin-bottom: 10px;
            }
            
            .resource-display {
                flex: 1;
                padding: 8px;
                background-color: rgba(15, 40, 55, 0.8);
                border-radius: 5px;
                text-align: center;
            }
            
            .status-bar-container {
                width: 100%;
                height: 15px;
                background-color: #222;
                border-radius: 10px;
                overflow: hidden;
                margin-bottom: 5px;
            }
            
            .status-bar {
                height: 100%;
                border-radius: 10px;
            }
            
            .status-label {
                display: flex;
                justify-content: space-between;
                margin-bottom: 5px;
                font-size: 0.9em;
            }
            
            /* Market Section */
            #market-section {
                grid-column: 2;
                grid-row: 1;
            }
            
            .sell-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 5px;
                margin-bottom: 15px;
            }
            
            .sell-btn {
                padding: 10px;
                background-color: rgba(15, 40, 55, 0.8);
                color: #fff;
                border-radius: 5px;
                cursor: pointer;
                text-align: center;
                transition: all 0.2s;
                border: none;
                font-family: 'Courier New', monospace;
            }
            
            .orb-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            
            /* Upgrades Section */
            #upgrades-section {
                grid-column: 3;
                grid-row: 1;
            }
            
            .upgrade-item {
                margin-bottom: 15px;
                border: 1px solid rgba(85, 85, 85, 0.5);
                border-radius: 8px;
                padding: 12px;
                background-color: rgba(0, 0, 0, 0.3);
            }
            
            .upgrade-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }
            
            .upgrade-progress {
                position: relative;
                height: 8px;
                background-color: #333;
                border-radius: 4px;
                margin-bottom: 12px;
            }
            
            .upgrade-progress-bar {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                width: 20%;
                border-radius: 4px;
            }
            
            .upgrade-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .upgrade-description {
                flex: 2;
                padding-right: 10px;
                font-size: 0.85em;
                opacity: 0.8;
            }
            
            /* Features Section */
            #features-section {
                grid-column: 1 / span 2;
                grid-row: 2;
            }
            
            .feature-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .feature-btn {
                padding: 15px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                font-weight: bold;
                font-size: 16px;
                color: #fff;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 80px;
            }
            
            .feature-btn small {
                font-size: 0.8em;
                opacity: 0.8;
                margin-top: 5px;
            }
            
            /* Challenge Section */
            #challenge-section {
                border-color: rgba(255, 48, 48, 0.5);
            }
            
            #challenge-section h3 {
                color: var(--accent-red);
                border-color: rgba(255, 48, 48, 0.3);
            }
            
            /* Common Button Styles */
            .action-btn {
                width: 100%;
                padding: 10px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                font-weight: bold;
                color: #000;
                margin-top: 5px;
            }
            
            /* Button color variations */
            .btn-fuel { background-color: var(--accent-green); }
            .btn-shield { background-color: var(--accent-blue); }
            .btn-hull { background-color: var(--accent-orange); }
            .btn-starmap { background-color: var(--accent-cyan); }
            .btn-blackjack { background-color: var(--accent-purple); }
            .btn-settings { background-color: var(--accent-blue); }
            
            /* Mobile Responsiveness */
            @media (max-width: 900px) {
                #stargate-ui {
                    width: 95%;
                    max-width: 95vw;
                    max-height: 85vh;
                    border-radius: 10px;
                }
                
                #stargate-content {
                    grid-template-columns: 1fr;
                    gap: 15px;
                    padding: 15px;
                }
                
                #ship-status-section,
                #market-section,
                #upgrades-section,
                #features-section {
                    grid-column: 1;
                }
                
                .feature-buttons {
                    grid-template-columns: 1fr;
                }
                
                .sell-buttons {
                    grid-template-columns: 1fr 1fr;
                }
                
                .action-btn {
                    padding: 12px;
                    min-height: 44px;
                }
            }
        `;
  }
}
class CommandParser {
  constructor() {
    this.commandHistory = [];
    this.historyIndex = -1;
    this.aliases = /* @__PURE__ */ new Map();
    this.setupAliases();
  }
  setupAliases() {
    this.aliases.set("ls", "list");
    this.aliases.set("dir", "list");
    this.aliases.set("h", "help");
    this.aliases.set("?", "help");
    this.aliases.set("q", "quit");
    this.aliases.set("exit", "quit");
    this.aliases.set("cls", "clear");
    this.aliases.set("clr", "clear");
    this.aliases.set("buy", "purchase");
    this.aliases.set("sell", "market");
    this.aliases.set("upgrade", "enhance");
    this.aliases.set("status", "info");
    this.aliases.set("stat", "info");
  }
  parseCommand(input) {
    var _a;
    if (!input || typeof input !== "string") {
      return { command: "", args: [], original: "" };
    }
    const trimmed = input.trim();
    if (!trimmed) {
      return { command: "", args: [], original: input };
    }
    if (this.commandHistory[this.commandHistory.length - 1] !== trimmed) {
      this.commandHistory.push(trimmed);
      if (this.commandHistory.length > 50) {
        this.commandHistory.shift();
      }
    }
    this.historyIndex = this.commandHistory.length;
    const parts = this.tokenize(trimmed);
    const rawCommand = ((_a = parts[0]) == null ? void 0 : _a.toLowerCase()) || "";
    const command = this.resolveAlias(rawCommand);
    const args = parts.slice(1);
    return {
      command,
      args,
      original: trimmed,
      raw: rawCommand
    };
  }
  tokenize(input) {
    const tokens = [];
    let current = "";
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if ((char === '"' || char === "'") && !inQuotes) {
        inQuotes = true;
        quoteChar = char;
      } else if (char === quoteChar && inQuotes) {
        inQuotes = false;
        quoteChar = "";
      } else if (char === " " && !inQuotes) {
        if (current) {
          tokens.push(current);
          current = "";
        }
      } else {
        current += char;
      }
    }
    if (current) {
      tokens.push(current);
    }
    return tokens;
  }
  resolveAlias(command) {
    return this.aliases.get(command) || command;
  }
  getCommandHistory() {
    return [...this.commandHistory];
  }
  getPreviousCommand() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      return this.commandHistory[this.historyIndex];
    }
    return null;
  }
  getNextCommand() {
    if (this.historyIndex < this.commandHistory.length - 1) {
      this.historyIndex++;
      return this.commandHistory[this.historyIndex];
    } else if (this.historyIndex === this.commandHistory.length - 1) {
      this.historyIndex++;
      return "";
    }
    return null;
  }
  validateCommand(command) {
    const validCommands = [
      "help",
      "list",
      "clear",
      "quit",
      "info",
      "status",
      "purchase",
      "market",
      "enhance",
      "upgrade",
      "refuel",
      "repair",
      "undock",
      "dock",
      "scan",
      "navigate",
      "starmap",
      "blackjack",
      "settings",
      "horde"
    ];
    return validCommands.includes(command);
  }
  getCommandSuggestions(partial) {
    const validCommands = [
      "help",
      "list",
      "clear",
      "quit",
      "info",
      "purchase",
      "market",
      "enhance",
      "refuel",
      "repair",
      "undock",
      "dock",
      "scan",
      "navigate",
      "starmap",
      "blackjack",
      "settings",
      "horde"
    ];
    return validCommands.filter(
      (cmd) => cmd.startsWith(partial.toLowerCase())
    );
  }
}
class CommandHandlers {
  constructor(stargateInterface) {
    this.stargate = stargateInterface;
    this.lastCommandTime = 0;
    this.commandCooldown = 100;
  }
  async executeCommand(parsedCommand) {
    const now = Date.now();
    if (now - this.lastCommandTime < this.commandCooldown) {
      return { success: false, message: "Command rate limit exceeded" };
    }
    this.lastCommandTime = now;
    const { command, args } = parsedCommand;
    try {
      switch (command) {
        case "help":
          return this.handleHelp(args);
        case "list":
          return this.handleList(args);
        case "clear":
          return this.handleClear();
        case "quit":
        case "undock":
          return this.handleUndock();
        case "info":
          return this.handleInfo(args);
        case "purchase":
          return this.handlePurchase(args);
        case "market":
          return this.handleMarket(args);
        case "enhance":
          return this.handleEnhance(args);
        case "refuel":
          return this.handleRefuel();
        case "repair":
          return this.handleRepair(args);
        case "scan":
          return this.handleScan();
        case "starmap":
          return this.handleStarmap();
        case "blackjack":
          return this.handleBlackjack();
        case "settings":
          return this.handleSettings();
        case "horde":
          return this.handleHorde();
        default:
          return {
            success: false,
            message: `Unknown command: ${command}. Type 'help' for available commands.`
          };
      }
    } catch (error) {
      console.error("Command execution error:", error);
      return {
        success: false,
        message: "Command execution failed. Please try again."
      };
    }
  }
  handleHelp(args) {
    const helpTopics = {
      general: `Available Commands:
• help [topic] - Show this help or specific topic help
• list - Show available services and features  
• info [system] - Display ship or system information
• market [item] - Access trading interface
• purchase <item> - Buy upgrades or services
• enhance <system> - Upgrade ship systems
• refuel - Refill fuel tanks
• repair [system] - Repair ship systems
• scan - Perform system scan
• starmap - Open navigation interface
• blackjack - Access gaming interface
• settings - Configure terminal preferences
• undock - Leave stargate terminal
• clear - Clear terminal display`,
      market: `Market Commands:
• market - Show all available items
• market resources - Show resource prices
• market orbs - Show energy orb values
• purchase fuel - Refuel ship (100 CR)
• purchase shield - Repair shields (150 CR)
• purchase hull - Repair hull (200 CR)`,
      upgrade: `Upgrade Commands:
• enhance fuel - Upgrade fuel tank capacity
• enhance engine - Improve ship speed
• enhance mining - Increase mining efficiency
• enhance hull - Strengthen ship structure
• enhance scanner - Extend detection range`
    };
    const topic = args[0] || "general";
    const helpText = helpTopics[topic] || helpTopics.general;
    return { success: true, message: helpText };
  }
  handleList() {
    return {
      success: true,
      message: `STARGATE SERVICES:
• Ship Maintenance & Repair
• Resource Trading Market
• Ship System Upgrades
• Navigation & Mapping
• Entertainment (Stellar Blackjack)
• System Configuration
• Challenge Modes

Type 'help [service]' for detailed information.`
    };
  }
  handleClear() {
    return { success: true, message: "", clearScreen: true };
  }
  handleUndock() {
    if (this.stargate && this.stargate.hide) {
      this.stargate.hide();
    }
    return {
      success: true,
      message: "Undocking from stargate terminal...",
      action: "undock"
    };
  }
  handleInfo(args) {
    const system = args[0] || "ship";
    return {
      success: true,
      message: `${system.toUpperCase()} STATUS:
System information would be displayed here.
Use the GUI panels for detailed status.`
    };
  }
  handlePurchase(args) {
    const item = args[0];
    if (!item) {
      return {
        success: false,
        message: 'Please specify an item to purchase. Use "market" to see available items.'
      };
    }
    return {
      success: true,
      message: `Attempting to purchase ${item}...`,
      action: "purchase",
      target: item
    };
  }
  handleMarket(args) {
    const category = args[0] || "all";
    return {
      success: true,
      message: `MARKET INTERFACE - ${category.toUpperCase()}
Use the market panel for transactions.
Type 'help market' for command-line trading.`
    };
  }
  handleEnhance(args) {
    const system = args[0];
    if (!system) {
      return {
        success: false,
        message: 'Please specify a system to enhance. Use "info" to see available systems.'
      };
    }
    return {
      success: true,
      message: `Initiating ${system} enhancement...`,
      action: "enhance",
      target: system
    };
  }
  handleRefuel() {
    return {
      success: true,
      message: "Initiating refueling sequence...",
      action: "refuel"
    };
  }
  handleRepair(args) {
    const system = args[0] || "all";
    return {
      success: true,
      message: `Initiating ${system} repair sequence...`,
      action: "repair",
      target: system
    };
  }
  handleScan() {
    return {
      success: true,
      message: "Performing system scan...\nScan results would appear here."
    };
  }
  handleStarmap() {
    return {
      success: true,
      message: "Opening stellar cartography interface...",
      action: "starmap"
    };
  }
  handleBlackjack() {
    return {
      success: true,
      message: "Accessing gaming interface...",
      action: "blackjack"
    };
  }
  handleSettings() {
    return {
      success: true,
      message: "Opening configuration interface...",
      action: "settings"
    };
  }
  handleHorde() {
    return {
      success: true,
      message: "WARNING: Prepare for extreme challenge mode...",
      action: "horde"
    };
  }
}
class TerminalMessages {
  constructor() {
    this.welcomeMessages = [
      "STARGATE TERMINAL ONLINE",
      "QUANTUM LINK ESTABLISHED",
      "NEURAL INTERFACE ACTIVE",
      "SYSTEM READY FOR COMMANDS"
    ];
  }
  getMainUIContent() {
    return `
            <!-- Header -->
            <div id="stargate-header">
                <button id="undock-btn" class="action-btn btn-undock" data-no-touch-overlay="true">
                    <span class="undock-text">◆ UNDOCK ◆</span>
                </button>
                <h2 style="text-align: center; color: #33aaff; margin: 0;">STARGATE TERMINAL</h2>
            </div>
            
            <!-- Main Content Grid -->
            <div id="stargate-content">
                <!-- Ship Status Section -->
                <div id="ship-status-section" class="stargate-section">
                    <h3>SHIP STATUS</h3>
                    ${this.getShipStatusContent()}
                </div>
                
                <!-- Market Section -->
                <div id="market-section" class="stargate-section">
                    <h3>MARKET</h3>
                    ${this.getMarketContent()}
                </div>
                
                <!-- Upgrades Section -->
                <div id="upgrades-section" class="stargate-section">
                    <h3>SHIP UPGRADES</h3>
                    ${this.getUpgradesContent()}
                </div>
                
                <!-- Features Section -->
                <div id="features-section" class="stargate-section">
                    <h3>SERVICES</h3>
                    ${this.getFeaturesContent()}
                </div>
                
                <!-- Challenge Section -->
                <div id="challenge-section" class="stargate-section">
                    <h3>EXTREME CHALLENGE</h3>
                    ${this.getChallengeContent()}
                </div>
            </div>
            
            <!-- Footer -->
            <div id="stargate-footer">
                <!-- Footer now empty, undock button moved to header -->
            </div>
        `;
  }
  getShipStatusContent() {
    return `
            <!-- Resources section -->
            <div>
                <h4 style="color: #33aaff; margin-top: 0; margin-bottom: 10px;">RESOURCES</h4>
                <div class="resources-container">
                    <div class="resource-display iron-border">
                        <div style="font-weight: bold; font-size: 14px;">IRON</div>
                        <div id="ms-iron" style="font-size: 18px; margin-top: 5px;">0</div>
                        <div style="font-size: 10px; opacity: 0.7;">UNITS</div>
                    </div>
                    <div class="resource-display gold-border">
                        <div style="font-weight: bold; font-size: 14px;">GOLD</div>
                        <div id="ms-gold" style="font-size: 18px; margin-top: 5px;">0</div>
                        <div style="font-size: 10px; opacity: 0.7;">UNITS</div>
                    </div>
                    <div class="resource-display platinum-border">
                        <div style="font-weight: bold; font-size: 14px;">PLATINUM</div>
                        <div id="ms-platinum" style="font-size: 18px; margin-top: 5px;">0</div>
                        <div style="font-size: 10px; opacity: 0.7;">UNITS</div>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4 style="color: #33aaff; margin-top: 0; margin-bottom: 10px;">CREDITS</h4>
                    <div id="ms-credits" style="font-size: 18px; font-weight: bold; color: #ffcc33; text-shadow: 0 0 5px rgba(255, 204, 51, 0.5);">0 CR</div>
                </div>
            </div>
            
            <!-- Fuel section -->
            <div>
                <div class="status-label">
                    <h4 style="color: #00cc33; margin: 0;">FUEL</h4>
                    <span><span id="fuel-level">100</span>%</span>
                </div>
                <div class="status-bar-container" id="fuel-gauge-container">
                    <div class="status-bar" id="fuel-gauge" style="background-color: #00cc33; width: 100%;"></div>
                </div>
                <button id="refuel-btn" class="action-btn btn-fuel">REFUEL (100 CR)</button>
            </div>
            
            <!-- Shield section -->
            <div>
                <div class="status-label">
                    <h4 style="color: #3399ff; margin: 0;">SHIELD</h4>
                    <span><span id="shield-level">100</span>%</span>
                </div>
                <div class="status-bar-container" id="shield-gauge-container">
                    <div class="status-bar" id="shield-gauge" style="background-color: #3399ff; width: 100%;"></div>
                </div>
                <button id="repair-shield-btn" class="action-btn btn-shield">REPAIR SHIELD (150 CR)</button>
            </div>
            
            <!-- Hull section -->
            <div>
                <div class="status-label">
                    <h4 style="color: #ff9900; margin: 0;">HULL INTEGRITY</h4>
                    <span><span id="hull-level">100</span>%</span>
                </div>
                <div class="status-bar-container" id="hull-gauge-container">
                    <div class="status-bar" id="hull-gauge" style="background-color: #ff9900; width: 100%;"></div>
                </div>
                <button id="repair-hull-btn" class="action-btn btn-hull">REPAIR HULL (200 CR)</button>
            </div>
        `;
  }
  getMarketContent() {
    return `
            <!-- Resources Market -->
            <h4 style="color: #33aaff; margin-top: 0; margin-bottom: 10px;">MATERIALS</h4>
            <div class="sell-buttons">
                <button id="sell-iron" class="sell-btn iron-border">
                    <div style="font-weight: bold;">SELL IRON</div>
                    <div style="font-size: 12px; margin-top: 3px;">(10 CR each)</div>
                </button>
                <button id="sell-gold" class="sell-btn gold-border">
                    <div style="font-weight: bold;">SELL GOLD</div>
                    <div style="font-size: 12px; margin-top: 3px;">(50 CR each)</div>
                </button>
                <button id="sell-platinum" class="sell-btn platinum-border">
                    <div style="font-weight: bold;">SELL PLATINUM</div>
                    <div style="font-size: 12px; margin-top: 3px;">(200 CR each)</div>
                </button>
            </div>
            
            <!-- Energy Orbs Market -->
            <h4 style="color: #33aaff; margin-top: 20px; margin-bottom: 10px;">ENERGY ORBS</h4>
            <div style="font-size: 14px; color: #aaa; margin-bottom: 10px;">
                Valuable artifacts collected from space anomalies. Increasing rarity yields higher value.
            </div>
            
            <div class="orb-buttons">
                ${this.getOrbButtons()}
            </div>
            
            <!-- Deployable Weapons Section -->
            <h4 style="color: #33aaff; margin-top: 20px; margin-bottom: 10px;">DEPLOYABLE WEAPONS</h4>
            <div class="upgrade-item">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div>
                        <strong style="color: #FF3333;">Laser Turrets:</strong> <span id="current-laser-count">0</span>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 2; padding-right: 10px;">
                        <p style="margin: 0; font-size: 12px;">Deployable laser turrets automatically target and fire at enemies within 1000m range.</p>
                    </div>
                    <button id="purchase-laser" style="flex: 1; padding: 10px; background-color: #FF3333; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold;">
                        PURCHASE (1000 CR)
                    </button>
                </div>
            </div>
        `;
  }
  getOrbButtons() {
    const orbs = [
      { type: "common", price: 100 },
      { type: "uncommon", price: 500 },
      { type: "rare", price: 1500 },
      { type: "epic", price: 5e3 },
      { type: "legendary", price: 15e3 }
    ];
    return orbs.map((orb) => `
            <button id="sell-orb-${orb.type}" class="sell-btn ${orb.type}-border">
                <div style="font-weight: bold;">${orb.type.toUpperCase()} ORB</div>
                <div id="orb-${orb.type}-count" style="font-size: 12px;">0 in inventory</div>
                <div style="font-size: 12px; margin-top: 3px;">(${orb.price.toLocaleString()} CR each)</div>
            </button>
        `).join("");
  }
  getUpgradesContent() {
    const upgrades = [
      { type: "fuel", name: "Fuel Tank", color: "#00cc33", description: "Increases maximum fuel capacity, allowing for longer journeys." },
      { type: "engine", name: "Engine", color: "#ff9900", description: "Enhances thruster power, increasing maximum velocity and maneuverability." },
      { type: "mining", name: "Mining Laser", color: "#ff3030", description: "Increases mining speed and extraction efficiency, allowing faster resource collection." },
      { type: "hull", name: "Hull", color: "#30cfd0", description: "Reinforces ship structure, improving collision resistance and reducing damage." },
      { type: "scanner", name: "Scanner", color: "#9933cc", description: "Extends scanner range for detecting asteroids and other objects at greater distances." }
    ];
    return upgrades.map((upgrade) => this.getUpgradeItemHTML(upgrade)).join("");
  }
  getUpgradeItemHTML(upgrade) {
    const buttonColor = upgrade.color === "#ff3030" || upgrade.color === "#9933cc" ? "#fff" : "#000";
    return `
            <div class="upgrade-item">
                <div class="upgrade-header">
                    <div>
                        <strong style="color: ${upgrade.color};">${upgrade.name} Level:</strong> <span id="current-${upgrade.type}-level">1</span>
                    </div>
                    <div style="text-align: right;">
                        <strong>Current:</strong> <span id="current-${upgrade.type}-capacity">--</span>
                        <br>
                        <small style="opacity: 0.8;">Next: <span id="next-${upgrade.type}-capacity">--</span></small>
                    </div>
                </div>
                <div class="upgrade-progress">
                    <div id="${upgrade.type}-upgrade-progress" class="upgrade-progress-bar" style="background-color: ${upgrade.color}; width: 20%;"></div>
                </div>
                <div class="upgrade-footer">
                    <div class="upgrade-description">
                        <p style="margin: 0; font-size: 12px;">${upgrade.description}</p>
                    </div>
                    <button id="upgrade-${upgrade.type}" style="flex: 1; padding: 10px; background-color: ${upgrade.color}; color: ${buttonColor}; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold;">
                        UPGRADE (<span id="${upgrade.type}-upgrade-cost">1000</span> CR)
                    </button>
                </div>
            </div>
        `;
  }
  getFeaturesContent() {
    return `
            <div class="feature-buttons">
                <button id="open-star-map" class="feature-btn" style="background-color: #30cfd0;">
                    STAR MAP
                    <small>Access star systems navigation</small>
                </button>
                <button id="create-custom-system" class="feature-btn" style="background: linear-gradient(135deg, #2c5a8c 0%, #4a76a8 100%); border: 1px solid #4a9dff; box-shadow: 0 0 10px rgba(74, 157, 255, 0.3);">
                    CREATE NEW SYSTEM
                    <small>Generate custom AI star systems</small>
                </button>
                <button id="open-blackjack" class="feature-btn" style="background-color: #9933cc;">
                    STELLAR BLACKJACK
                    <small>Wager resources in card games</small>
                </button>
                <button id="open-settings" class="feature-btn" style="background-color: #33aaff;">
                    SETTINGS
                    <small>Adjust graphics and audio options</small>
                </button>
            </div>
        `;
  }
  getChallengeContent() {
    return `
            <button id="unleash-horde" class="action-btn btn-horde">
                UNLEASH THE HORDE
            </button>
            <p style="font-size: 12px; color: #ff9999; margin: 10px 0 0 0;">WARNING: Activate extreme survival mode with infinitely scaling difficulty</p>
        `;
  }
  getRandomWelcomeMessage() {
    return this.welcomeMessages[Math.floor(Math.random() * this.welcomeMessages.length)];
  }
}
class TerminalAscii {
  constructor() {
    this.animationFrames = /* @__PURE__ */ new Map();
    this.currentAnimations = /* @__PURE__ */ new Map();
  }
  getStargateArt() {
    return `
    ╔════════════════════════════════════════════════════════════════╗
    ║                        STARGATE TERMINAL                       ║
    ║                      ┌─────────────────┐                      ║
    ║                      │  ◆ ◇ ◆ ◇ ◆ ◇ ◆  │                      ║
    ║                      │ ◇   QUANTUM   ◇ │                      ║
    ║                      │ ◆  LINK CORE  ◆ │                      ║
    ║                      │ ◇             ◇ │                      ║
    ║                      │  ◆ ◇ ◆ ◇ ◆ ◇ ◆  │                      ║
    ║                      └─────────────────┘                      ║
    ╚════════════════════════════════════════════════════════════════╝
        `;
  }
  getShipArt() {
    return `
              ▲
             ╱ ╲
            ╱───╲
           ╱     ╲
          │ ◆   ◆ │
          │   ▼   │
          ╲       ╱
           ╲─────╱
            ╲   ╱
             ╲ ╱
              ▼
        `;
  }
  getLoadingAnimation() {
    return [
      "⠋ Processing...",
      "⠙ Processing...",
      "⠹ Processing...",
      "⠸ Processing...",
      "⠼ Processing...",
      "⠴ Processing...",
      "⠦ Processing...",
      "⠧ Processing...",
      "⠇ Processing...",
      "⠏ Processing..."
    ];
  }
  getProgressBar(percentage, width = 20) {
    const filled = Math.floor(percentage / 100 * width);
    const empty = width - filled;
    return `[${"█".repeat(filled)}${"░".repeat(empty)}] ${percentage}%`;
  }
  getSystemStatus(systems) {
    const statusChars = {
      online: "●",
      offline: "○",
      warning: "◐",
      error: "◯"
    };
    let art = "    SYSTEM STATUS\n";
    art += "    ┌─────────────────┐\n";
    for (const [name, status] of Object.entries(systems)) {
      const char = statusChars[status] || "?";
      this.getStatusColor(status);
      art += `    │ ${char} ${name.padEnd(13)} │
`;
    }
    art += "    └─────────────────┘";
    return art;
  }
  getStatusColor(status) {
    const colors = {
      online: "#00ff00",
      offline: "#666666",
      warning: "#ffaa00",
      error: "#ff0000"
    };
    return colors[status] || "#ffffff";
  }
  getResourceMeter(resource, amount, max) {
    const percentage = Math.min(100, amount / max * 100);
    const bars = Math.floor(percentage / 10);
    const meter = "█".repeat(bars) + "░".repeat(10 - bars);
    return `${resource.toUpperCase().padEnd(8)} [${meter}] ${amount}/${max}`;
  }
  getBanner(text) {
    const width = Math.max(text.length + 4, 20);
    const line = "═".repeat(width);
    const padding = " ".repeat(Math.floor((width - text.length) / 2));
    return `
╔${line}╗
║${padding}${text}${padding}║
╚${line}╝`;
  }
  getAlert(message, type = "info") {
    const icons = {
      info: "ℹ",
      warning: "⚠",
      error: "✕",
      success: "✓"
    };
    const icon = icons[type] || "ℹ";
    const border = type === "error" ? "!" : type === "warning" ? "!" : "-";
    const line = border.repeat(message.length + 6);
    return `
${line}
${border} ${icon} ${message} ${border}
${line}`;
  }
  getConnectionAnimation() {
    return [
      "Connecting    .",
      "Connecting   ..",
      "Connecting  ...",
      "Connecting .... ",
      "Connecting....  ",
      "Connecting...   ",
      "Connecting..    ",
      "Connecting.     "
    ];
  }
  getQuantumPattern() {
    return `
    ◆ ◇ ◆ ◇ ◆ ◇ ◆ ◇ ◆
    ◇ ◆ ◇ ◆ ◇ ◆ ◇ ◆ ◇
    ◆ ◇ ◆ ◇ ◆ ◇ ◆ ◇ ◆
    ◇ ◆ ◇ ◆ ◇ ◆ ◇ ◆ ◇
    ◆ ◇ ◆ ◇ ◆ ◇ ◆ ◇ ◆
        `;
  }
  startAnimation(name, frames, interval = 500) {
    if (this.currentAnimations.has(name)) {
      this.stopAnimation(name);
    }
    let frameIndex = 0;
    const animation = setInterval(() => {
      frameIndex = (frameIndex + 1) % frames.length;
      this.animationFrames.set(name, frames[frameIndex]);
    }, interval);
    this.currentAnimations.set(name, animation);
    this.animationFrames.set(name, frames[0]);
  }
  stopAnimation(name) {
    const animation = this.currentAnimations.get(name);
    if (animation) {
      clearInterval(animation);
      this.currentAnimations.delete(name);
      this.animationFrames.delete(name);
    }
  }
  getAnimationFrame(name) {
    return this.animationFrames.get(name) || "";
  }
  createMatrix(rows, cols, char = "█") {
    let matrix = "";
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        matrix += Math.random() > 0.7 ? char : " ";
      }
      matrix += "\n";
    }
    return matrix;
  }
  getHordeWarning() {
    return `
██╗  ██╗ ██████╗ ██████╗ ██████╗ ███████╗
██║  ██║██╔═══██╗██╔══██╗██╔══██╗██╔════╝
███████║██║   ██║██████╔╝██║  ██║█████╗  
██╔══██║██║   ██║██╔══██╗██║  ██║██╔══╝  
██║  ██║╚██████╔╝██║  ██║██████╔╝███████╗
╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚══════╝
                                         
 ██╗    ██╗ █████╗ ██████╗ ███╗   ██╗██╗███╗   ██╗ ██████╗ 
 ██║    ██║██╔══██╗██╔══██╗████╗  ██║██║████╗  ██║██╔════╝ 
 ██║ █╗ ██║███████║██████╔╝██╔██╗ ██║██║██╔██╗ ██║██║  ███╗
 ██║███╗██║██╔══██║██╔══██╗██║╚██╗██║██║██║╚██╗██║██║   ██║
 ╚███╔███╔╝██║  ██║██║  ██║██║ ╚████║██║██║ ╚████║╚██████╔╝
  ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═══╝ ╚═════╝ 
        `;
  }
}
class TerminalKeyboard {
  constructor() {
    this.keyHandlers = /* @__PURE__ */ new Map();
    this.inputBuffer = "";
    this.isActive = false;
    this.modifiers = {
      shift: false,
      ctrl: false,
      alt: false
    };
    this.setupEventListeners();
  }
  setupEventListeners() {
    document.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.addEventListener("keyup", this.handleKeyUp.bind(this));
    document.addEventListener("keypress", this.handleKeyPress.bind(this));
  }
  handleKeyDown(event) {
    if (!this.isActive) return;
    this.updateModifiers(event, true);
    switch (event.code) {
      case "Enter":
        this.handleEnter(event);
        break;
      case "Escape":
        this.handleEscape(event);
        break;
      case "Tab":
        this.handleTab(event);
        break;
      case "ArrowUp":
        this.handleArrowUp(event);
        break;
      case "ArrowDown":
        this.handleArrowDown(event);
        break;
      case "Backspace":
        this.handleBackspace(event);
        break;
      case "Delete":
        this.handleDelete(event);
        break;
      case "Home":
        this.handleHome(event);
        break;
      case "End":
        this.handleEnd(event);
        break;
      default:
        if (event.code.startsWith("F")) {
          this.handleFunctionKey(event);
        }
        break;
    }
    if (this.modifiers.ctrl) {
      this.handleCtrlCombination(event);
    }
    if (this.modifiers.alt) {
      this.handleAltCombination(event);
    }
  }
  handleKeyUp(event) {
    this.updateModifiers(event, false);
  }
  handleKeyPress(event) {
    if (!this.isActive) return;
    if (event.charCode >= 32 && event.charCode <= 126) {
      this.handleCharacterInput(event.key);
    }
  }
  updateModifiers(event, pressed) {
    if (event.code === "ShiftLeft" || event.code === "ShiftRight") {
      this.modifiers.shift = pressed;
    }
    if (event.code === "ControlLeft" || event.code === "ControlRight") {
      this.modifiers.ctrl = pressed;
    }
    if (event.code === "AltLeft" || event.code === "AltRight") {
      this.modifiers.alt = pressed;
    }
  }
  handleEnter(event) {
    event.preventDefault();
    this.triggerHandler("enter", {
      input: this.inputBuffer,
      modifiers: { ...this.modifiers }
    });
    this.inputBuffer = "";
  }
  handleEscape(event) {
    event.preventDefault();
    this.triggerHandler("escape", {
      modifiers: { ...this.modifiers }
    });
    this.inputBuffer = "";
  }
  handleTab(event) {
    event.preventDefault();
    this.triggerHandler("tab", {
      input: this.inputBuffer,
      modifiers: { ...this.modifiers }
    });
  }
  handleArrowUp(event) {
    event.preventDefault();
    this.triggerHandler("arrowUp", {
      modifiers: { ...this.modifiers }
    });
  }
  handleArrowDown(event) {
    event.preventDefault();
    this.triggerHandler("arrowDown", {
      modifiers: { ...this.modifiers }
    });
  }
  handleBackspace(event) {
    event.preventDefault();
    if (this.inputBuffer.length > 0) {
      this.inputBuffer = this.inputBuffer.slice(0, -1);
      this.triggerHandler("backspace", {
        input: this.inputBuffer,
        modifiers: { ...this.modifiers }
      });
    }
  }
  handleDelete(event) {
    event.preventDefault();
    this.triggerHandler("delete", {
      input: this.inputBuffer,
      modifiers: { ...this.modifiers }
    });
  }
  handleHome(event) {
    event.preventDefault();
    this.triggerHandler("home", {
      modifiers: { ...this.modifiers }
    });
  }
  handleEnd(event) {
    event.preventDefault();
    this.triggerHandler("end", {
      modifiers: { ...this.modifiers }
    });
  }
  handleFunctionKey(event) {
    event.preventDefault();
    const functionNumber = parseInt(event.code.substring(1));
    this.triggerHandler("function", {
      functionNumber,
      modifiers: { ...this.modifiers }
    });
  }
  handleCtrlCombination(event) {
    switch (event.code) {
      case "KeyC":
        event.preventDefault();
        this.triggerHandler("ctrlC", {
          input: this.inputBuffer,
          modifiers: { ...this.modifiers }
        });
        break;
      case "KeyV":
        event.preventDefault();
        this.handlePaste();
        break;
      case "KeyA":
        event.preventDefault();
        this.triggerHandler("ctrlA", {
          input: this.inputBuffer,
          modifiers: { ...this.modifiers }
        });
        break;
      case "KeyL":
        event.preventDefault();
        this.triggerHandler("ctrlL", {
          modifiers: { ...this.modifiers }
        });
        break;
    }
  }
  handleAltCombination(event) {
    this.triggerHandler("alt", {
      key: event.code,
      modifiers: { ...this.modifiers }
    });
  }
  handleCharacterInput(character) {
    this.inputBuffer += character;
    this.triggerHandler("character", {
      character,
      input: this.inputBuffer,
      modifiers: { ...this.modifiers }
    });
  }
  async handlePaste() {
    try {
      const text = await navigator.clipboard.readText();
      this.inputBuffer += text;
      this.triggerHandler("paste", {
        text,
        input: this.inputBuffer,
        modifiers: { ...this.modifiers }
      });
    } catch (error) {
      console.warn("Clipboard access failed:", error);
    }
  }
  registerHandler(event, callback) {
    if (!this.keyHandlers.has(event)) {
      this.keyHandlers.set(event, []);
    }
    this.keyHandlers.get(event).push(callback);
  }
  unregisterHandler(event, callback) {
    const handlers = this.keyHandlers.get(event);
    if (handlers) {
      const index = handlers.indexOf(callback);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
  triggerHandler(event, data) {
    const handlers = this.keyHandlers.get(event);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in ${event} handler:`, error);
        }
      });
    }
  }
  activate() {
    this.isActive = true;
    this.inputBuffer = "";
  }
  deactivate() {
    this.isActive = false;
    this.inputBuffer = "";
  }
  clearInput() {
    this.inputBuffer = "";
  }
  getInput() {
    return this.inputBuffer;
  }
  setInput(text) {
    this.inputBuffer = text || "";
  }
}
class TerminalView {
  constructor() {
    this.isMobile = false;
    this.screen = new TerminalScreen();
    this.effects = new TerminalEffects();
    this.parser = new CommandParser();
    this.handlers = new CommandHandlers(this);
    this.messages = new TerminalMessages();
    this.ascii = new TerminalAscii();
    this.keyboard = new TerminalKeyboard();
    this.setupKeyboardHandlers();
  }
  setMobile(isMobile) {
    this.isMobile = isMobile;
    this.screen.setMobile(isMobile);
  }
  setupKeyboardHandlers() {
    this.keyboard.registerHandler("enter", (data) => {
      if (data.input.trim()) {
        this.handleCommand(data.input);
      }
    });
    this.keyboard.registerHandler("escape", () => {
      this.hide();
    });
    this.keyboard.registerHandler("ctrlL", () => {
      this.clearTerminal();
    });
  }
  async handleCommand(input) {
    const parsed = this.parser.parseCommand(input);
    const result = await this.handlers.executeCommand(parsed);
    if (result.clearScreen) {
      this.clearTerminal();
    } else if (result.message) {
      this.displayMessage(result.message);
    }
    if (result.action) {
      this.handleAction(result.action, result.target);
    }
  }
  handleAction(action, target) {
    switch (action) {
      case "undock":
        this.hide();
        break;
      case "refuel":
        this.triggerRefuel();
        break;
      case "repair":
        this.triggerRepair(target);
        break;
      case "enhance":
        this.triggerUpgrade(target);
        break;
      case "purchase":
        this.triggerPurchase(target);
        break;
    }
  }
  displayMessage(message) {
    console.log("Terminal:", message);
  }
  clearTerminal() {
    console.clear();
  }
  // Delegate methods to modules
  createStyles() {
    this.effects.createStyles();
  }
  createDockingPrompt() {
    return this.screen.createDockingPrompt();
  }
  createMainUI() {
    return this.screen.createMainUI();
  }
  getMainUIContent() {
    return this.messages.getMainUIContent();
  }
  getUpgradesContent() {
    return this.messages.getUpgradesContent();
  }
  showDockingPrompt() {
    this.screen.showDockingPrompt();
  }
  hideDockingPrompt() {
    this.screen.hideDockingPrompt();
  }
  show() {
    this.screen.showUI();
    this.keyboard.activate();
  }
  hide() {
    this.screen.hideUI();
    this.keyboard.deactivate();
  }
  // Event trigger methods for stargate interface integration
  triggerRefuel() {
    console.log("Refuel triggered");
  }
  triggerRepair(system) {
    console.log("Repair triggered for:", system);
  }
  triggerUpgrade(system) {
    console.log("Upgrade triggered for:", system);
  }
  triggerPurchase(item) {
    console.log("Purchase triggered for:", item);
  }
}
class SystemsView {
  constructor() {
    this.starMap = null;
    this.blackjackGame = null;
    this.settings = null;
  }
  setStarMap(starMap) {
    this.starMap = starMap;
  }
  setBlackjackGame(blackjackGame) {
    this.blackjackGame = blackjackGame;
  }
  setSettings(settings) {
    this.settings = settings;
  }
  setupStarMapButton() {
    const starMapButton = document.getElementById("open-star-map");
    if (starMapButton && this.starMap) {
      starMapButton.addEventListener("click", () => {
        console.log("Opening star map");
        this.hideStargateUI();
        this.starMap.show();
      });
    } else if (starMapButton) {
      starMapButton.disabled = true;
      starMapButton.style.backgroundColor = "#555";
      starMapButton.style.cursor = "not-allowed";
      starMapButton.title = "Star map not available";
    }
  }
  setupBlackjackButton() {
    const blackjackButton = document.getElementById("open-blackjack");
    if (blackjackButton && this.blackjackGame) {
      blackjackButton.addEventListener("click", () => {
        console.log("Opening blackjack game");
        this.hideStargateUI();
        this.blackjackGame.show();
      });
    } else if (blackjackButton) {
      blackjackButton.disabled = true;
      blackjackButton.style.backgroundColor = "#555";
      blackjackButton.style.cursor = "not-allowed";
      blackjackButton.title = "Blackjack game not available";
    }
  }
  setupSettingsButton() {
    if (!this.settings) return;
    const settingsButton = document.getElementById("open-settings");
    if (settingsButton) {
      settingsButton.addEventListener("click", () => {
        console.log("Opening settings");
        this.hideStargateUI();
        this.settings.show();
      });
    }
  }
  setupCustomSystemButton() {
    const customSystemBtn = document.getElementById("create-custom-system");
    if (customSystemBtn) {
      customSystemBtn.addEventListener("click", () => {
        if (window.game && window.game.environment && window.game.environment.customSystemCreator) {
          this.hideStargateUI();
          window.game.environment.customSystemCreator.show();
        } else {
          console.error("Custom system creator not available");
        }
      });
    }
  }
  hideStargateUI() {
    const stargateUI = document.getElementById("stargate-ui");
    if (stargateUI) {
      stargateUI.style.display = "none";
    }
  }
  setupAllSystemButtons() {
    this.setupStarMapButton();
    this.setupBlackjackButton();
    this.setupSettingsButton();
    this.setupCustomSystemButton();
  }
}
class TradingView {
  constructor() {
    this.spaceship = null;
    this.resources = null;
  }
  setGameReferences(spaceship, resources) {
    this.spaceship = spaceship;
    this.resources = resources;
  }
  // Sell an energy orb of the specified rarity
  sellEnergyOrb(rarity) {
    if (!this.spaceship || !this.resources) {
      console.error("Required game objects not available");
      return false;
    }
    if (!this.resources.orbs) {
      this.resources.orbs = {
        common: 0,
        uncommon: 0,
        rare: 0,
        epic: 0,
        legendary: 0
      };
      return false;
    }
    if (!this.resources.orbs[rarity] || this.resources.orbs[rarity] <= 0) {
      console.log(`No ${rarity} orbs available to sell`);
      return false;
    }
    let value = 0;
    switch (rarity) {
      case "common":
        value = 100;
        break;
      case "uncommon":
        value = 500;
        break;
      case "rare":
        value = 1500;
        break;
      case "epic":
        value = 5e3;
        break;
      case "legendary":
        value = 15e3;
        break;
      default:
        console.error(`Unknown orb rarity: ${rarity}`);
        return false;
    }
    this.resources.orbs[rarity]--;
    this.spaceship.credits += value;
    const capitalizedRarity = rarity.charAt(0).toUpperCase() + rarity.slice(1);
    this.showNotification(`Sold ${capitalizedRarity} Energy Orb for ${value} credits`, 3386111);
    if (window.game && window.game.audio) {
      window.game.audio.playSoundEffect("sell", 0.5);
    }
    return true;
  }
  /**
   * Purchase a deployable laser turret
   */
  purchaseLaserTurret() {
    console.log("Attempting to purchase laser turret");
    if (!this.spaceship) {
      console.error("Cannot purchase laser turret: spaceship not found");
      return;
    }
    if (this.spaceship.credits < 1e3) {
      console.log("Not enough credits to purchase laser turret");
      if (window.mainMessageBus) {
        window.mainMessageBus.publish("ui.notification", {
          message: "Not enough credits to purchase laser turret",
          type: "error",
          duration: 2
        });
      }
      return;
    }
    this.spaceship.credits -= 1e3;
    if (typeof this.spaceship.deployableLaserCount === "undefined") {
      this.spaceship.deployableLaserCount = 0;
    }
    this.spaceship.deployableLaserCount++;
    if (window.game && window.game.audio && window.game.audio.playSound) {
      window.game.audio.playSound("purchase");
    }
    if (window.mainMessageBus) {
      window.mainMessageBus.publish("ui.notification", {
        message: "Laser turret purchased",
        type: "success",
        duration: 2
      });
    }
    console.log("Laser turret purchased successfully");
  }
  // Helper method to show notifications
  showNotification(message, color = 3386111) {
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = "35%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#fff";
    notification.style.padding = "15px 30px";
    notification.style.borderRadius = "10px";
    notification.style.border = `2px solid #${color.toString(16).padStart(6, "0")}`;
    notification.style.boxShadow = `0 0 15px #${color.toString(16).padStart(6, "0")}`;
    notification.style.fontFamily = "Courier New, monospace";
    notification.style.fontSize = "16px";
    notification.style.zIndex = "1001";
    notification.style.textAlign = "center";
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 0.8s";
      setTimeout(() => {
        notification.remove();
      }, 800);
    }, 2e3);
  }
  updateOrbCounts() {
    if (!this.resources.orbs) {
      this.resources.orbs = {
        common: 0,
        uncommon: 0,
        rare: 0,
        epic: 0,
        legendary: 0
      };
    }
    document.getElementById("orb-common-count").textContent = this.resources.orbs.common > 0 ? `${this.resources.orbs.common} in inventory` : "0 in inventory";
    document.getElementById("orb-uncommon-count").textContent = this.resources.orbs.uncommon > 0 ? `${this.resources.orbs.uncommon} in inventory` : "0 in inventory";
    document.getElementById("orb-rare-count").textContent = this.resources.orbs.rare > 0 ? `${this.resources.orbs.rare} in inventory` : "0 in inventory";
    document.getElementById("orb-epic-count").textContent = this.resources.orbs.epic > 0 ? `${this.resources.orbs.epic} in inventory` : "0 in inventory";
    document.getElementById("orb-legendary-count").textContent = this.resources.orbs.legendary > 0 ? `${this.resources.orbs.legendary} in inventory` : "0 in inventory";
  }
  updateOrbSellButtons() {
    const updateOrbSellButton = (buttonId, orbCount, borderColor) => {
      const button = document.getElementById(buttonId);
      if (!button) return;
      if (orbCount === 0) {
        button.disabled = true;
        button.style.backgroundColor = "rgba(40, 40, 40, 0.8)";
        button.style.color = "#777";
        button.style.cursor = "not-allowed";
        button.style.boxShadow = "none";
      } else {
        button.disabled = false;
        button.style.backgroundColor = "rgba(15, 40, 55, 0.8)";
        button.style.color = "#fff";
        button.style.cursor = "pointer";
        button.style.boxShadow = `0 0 10px ${borderColor}`;
      }
    };
    if (!this.resources.orbs) return;
    updateOrbSellButton("sell-orb-common", this.resources.orbs.common, "rgba(0, 255, 102, 0.3)");
    updateOrbSellButton("sell-orb-uncommon", this.resources.orbs.uncommon, "rgba(0, 102, 255, 0.3)");
    updateOrbSellButton("sell-orb-rare", this.resources.orbs.rare, "rgba(153, 0, 255, 0.3)");
    updateOrbSellButton("sell-orb-epic", this.resources.orbs.epic, "rgba(255, 102, 0, 0.3)");
    updateOrbSellButton("sell-orb-legendary", this.resources.orbs.legendary, "rgba(255, 0, 0, 0.3)");
  }
  updateLaserTurretDisplay() {
    const laserCountElement = document.getElementById("current-laser-count");
    if (laserCountElement) {
      laserCountElement.textContent = this.spaceship.deployableLaserCount || 0;
    }
    const purchaseLaserBtn = document.getElementById("purchase-laser");
    if (purchaseLaserBtn) {
      if (this.spaceship.credits < 1e3) {
        purchaseLaserBtn.disabled = true;
        purchaseLaserBtn.style.backgroundColor = "#555";
        purchaseLaserBtn.style.cursor = "not-allowed";
      } else {
        purchaseLaserBtn.disabled = false;
        purchaseLaserBtn.style.backgroundColor = "#FF3333";
        purchaseLaserBtn.style.cursor = "pointer";
      }
    }
  }
  updateResourceSellButtons() {
    document.getElementById("sell-iron").disabled = this.resources.iron === 0;
    document.getElementById("sell-gold").disabled = this.resources.gold === 0;
    document.getElementById("sell-platinum").disabled = this.resources.platinum === 0;
    this.updateSellButtonStatus("sell-iron", this.resources.iron, "#cc6633");
    this.updateSellButtonStatus("sell-gold", this.resources.gold, "#ffcc33");
    this.updateSellButtonStatus("sell-platinum", this.resources.platinum, "#33ccff");
    document.querySelectorAll(".sell-btn").forEach((btn) => {
      if (btn.disabled) {
        btn.style.backgroundColor = "rgba(40, 40, 40, 0.8)";
        btn.style.color = "#777";
        btn.style.cursor = "not-allowed";
        btn.style.boxShadow = "none";
      }
    });
  }
  // Update sell button styles based on available resources
  updateSellButtonStatus(buttonId, resourceAmount, borderColor) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    if (resourceAmount === 0) {
      button.disabled = true;
      button.style.backgroundColor = "rgba(40, 40, 40, 0.8)";
      button.style.borderColor = "#555";
      button.style.color = "#777";
      button.style.boxShadow = "none";
      button.style.cursor = "not-allowed";
    } else {
      button.disabled = false;
      button.style.backgroundColor = "rgba(15, 40, 55, 0.8)";
      button.style.borderColor = borderColor;
      button.style.color = "#fff";
      button.style.boxShadow = `0 0 10px rgba(${parseInt(borderColor.slice(1, 3), 16)}, ${parseInt(borderColor.slice(3, 5), 16)}, ${parseInt(borderColor.slice(5, 7), 16)}, 0.3)`;
      button.style.cursor = "pointer";
    }
  }
}
class UpgradesView {
  constructor() {
    this.spaceship = null;
  }
  setSpaceship(spaceship) {
    this.spaceship = spaceship;
  }
  updateUpgradeDisplays() {
    if (!this.spaceship) return;
    document.getElementById("current-fuel-level").textContent = this.spaceship.fuelTankLevel;
    document.getElementById("current-fuel-capacity").textContent = this.spaceship.maxFuel;
    document.getElementById("next-fuel-capacity").textContent = this.spaceship.maxFuel * 2;
    document.getElementById("fuel-upgrade-cost").textContent = this.spaceship.fuelUpgradeCost;
    document.getElementById("fuel-upgrade-progress").style.width = `${Math.min(this.spaceship.fuelTankLevel * 20, 100)}%`;
    document.getElementById("current-engine-level").textContent = this.spaceship.engineLevel;
    document.getElementById("current-max-velocity").textContent = this.spaceship.maxVelocity.toFixed(2);
    document.getElementById("next-max-velocity").textContent = (this.spaceship.maxVelocity * 1.25).toFixed(2);
    document.getElementById("engine-upgrade-cost").textContent = this.spaceship.engineUpgradeCost;
    document.getElementById("engine-upgrade-progress").style.width = `${Math.min(this.spaceship.engineLevel * 20, 100)}%`;
    document.getElementById("current-mining-level").textContent = this.spaceship.miningLevel;
    document.getElementById("current-mining-efficiency").textContent = Math.round(this.spaceship.miningEfficiency * 100);
    document.getElementById("next-mining-efficiency").textContent = Math.round(this.spaceship.miningEfficiency * 130);
    document.getElementById("mining-upgrade-cost").textContent = this.spaceship.miningUpgradeCost;
    document.getElementById("mining-upgrade-progress").style.width = `${Math.min(this.spaceship.miningLevel * 20, 100)}%`;
    document.getElementById("current-hull-level").textContent = this.spaceship.hullLevel;
    document.getElementById("current-hull-resistance").textContent = Math.round(this.spaceship.collisionResistance * 100);
    document.getElementById("next-hull-resistance").textContent = Math.round(this.spaceship.collisionResistance * 125);
    document.getElementById("hull-upgrade-cost").textContent = this.spaceship.hullUpgradeCost;
    document.getElementById("hull-upgrade-progress").style.width = `${Math.min(this.spaceship.hullLevel * 20, 100)}%`;
    document.getElementById("current-scanner-level").textContent = this.spaceship.scannerLevel;
    document.getElementById("current-scanner-range").textContent = Math.round(this.spaceship.scanRange);
    document.getElementById("next-scanner-range").textContent = Math.round(this.spaceship.scanRange * 1.2);
    document.getElementById("scanner-upgrade-cost").textContent = this.spaceship.scannerUpgradeCost;
    document.getElementById("scanner-upgrade-progress").style.width = `${Math.min(this.spaceship.scannerLevel * 20, 100)}%`;
    this.updateUpgradeButtonStatus("upgrade-fuel-tank", this.spaceship.credits, this.spaceship.fuelUpgradeCost, "#00cc33");
    this.updateUpgradeButtonStatus("upgrade-engine", this.spaceship.credits, this.spaceship.engineUpgradeCost, "#ff9900");
    this.updateUpgradeButtonStatus("upgrade-mining", this.spaceship.credits, this.spaceship.miningUpgradeCost, "#ff3030");
    this.updateUpgradeButtonStatus("upgrade-hull", this.spaceship.credits, this.spaceship.hullUpgradeCost, "#30cfd0");
    this.updateUpgradeButtonStatus("upgrade-scanner", this.spaceship.credits, this.spaceship.scannerUpgradeCost, "#9933cc");
  }
  // Helper method to update upgrade button status
  updateUpgradeButtonStatus(buttonId, currentCredits, cost, activeColor) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    if (currentCredits < cost) {
      button.disabled = true;
      button.style.backgroundColor = "#555";
      button.style.color = "#777";
      button.style.cursor = "not-allowed";
    } else {
      button.disabled = false;
      button.style.backgroundColor = activeColor;
      button.style.color = activeColor === "#ff9900" || activeColor === "#30cfd0" ? "#000" : "#fff";
      button.style.cursor = "pointer";
    }
  }
}
class MissionsView {
  constructor() {
    this.hideStargateUICallback = null;
  }
  setHideCallback(callback) {
    this.hideStargateUICallback = callback;
  }
  setupHordeButton() {
    const hordeButton = document.getElementById("unleash-horde");
    if (hordeButton) {
      hordeButton.addEventListener("click", () => {
        const dronesHaveSpawned = window.game && window.game.ecsWorld && window.game.ecsWorld.enemySystem && window.game.ecsWorld.enemySystem.initialSpawnComplete;
        if (dronesHaveSpawned) {
          console.log("HORDE MODE: Button clicked, showing confirmation");
          this.showHordeConfirmation();
        } else {
          console.log("HORDE MODE: Button clicked but spectral drones haven't appeared yet");
          this.showNotification("Horde mode is only available after spectral drones appear in the sector.", 16724016);
        }
      });
    }
  }
  /**
   * Show confirmation dialog for activating horde mode
   */
  showHordeConfirmation() {
    const modal = document.createElement("div");
    modal.id = "horde-confirm-modal";
    const content = document.createElement("div");
    content.id = "horde-confirm-content";
    const title = document.createElement("div");
    title.className = "horde-confirm-title";
    title.textContent = "UNLEASH THE HORDE?";
    content.appendChild(title);
    const text = document.createElement("div");
    text.className = "horde-confirm-text";
    text.innerHTML = `
            <p>You are about to activate EXTREME SURVIVAL MODE.</p>
            <p>Enemies will continuously spawn with increasing:</p>
            <ul style="text-align: left; padding-left: 30px; margin: 15px 0;">
                <li>Numbers (starting at 50, scaling upward)</li>
                <li>Speed (progressively faster movement)</li>
                <li>Health (gradually becoming tougher)</li>
                <li>Damage (increasingly lethal hits)</li>
            </ul>
            <p>Difficulty will scale <strong>infinitely</strong> until you are overwhelmed.</p>
            <p style="color: #ff9999;">This is a test of survival. How long can you last?</p>
        `;
    content.appendChild(text);
    const buttons = document.createElement("div");
    buttons.className = "horde-confirm-buttons";
    const yesBtn = document.createElement("button");
    yesBtn.className = "horde-confirm-btn horde-confirm-yes";
    yesBtn.textContent = "UNLEASH THEM";
    yesBtn.addEventListener("click", () => {
      document.body.removeChild(modal);
      if (this.hideStargateUICallback) {
        this.hideStargateUICallback();
      }
      if (window.game && typeof window.game.activateHordeMode === "function") {
        window.game.activateHordeMode();
        console.log("HORDE MODE: Activated via stargateInterface");
      } else {
        console.error("HORDE MODE: Failed to activate - game.activateHordeMode not available");
      }
    });
    const noBtn = document.createElement("button");
    noBtn.className = "horde-confirm-btn horde-confirm-no";
    noBtn.textContent = "CANCEL";
    noBtn.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    buttons.appendChild(noBtn);
    buttons.appendChild(yesBtn);
    content.appendChild(buttons);
    modal.appendChild(content);
    document.body.appendChild(modal);
  }
  // Helper method to show notifications
  showNotification(message, color = 3386111) {
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = "35%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#fff";
    notification.style.padding = "15px 30px";
    notification.style.borderRadius = "10px";
    notification.style.border = `2px solid #${color.toString(16).padStart(6, "0")}`;
    notification.style.boxShadow = `0 0 15px #${color.toString(16).padStart(6, "0")}`;
    notification.style.fontFamily = "Courier New, monospace";
    notification.style.fontSize = "16px";
    notification.style.zIndex = "1001";
    notification.style.textAlign = "center";
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 0.8s";
      setTimeout(() => {
        notification.remove();
      }, 800);
    }, 2e3);
  }
}
class EventHandlers {
  constructor() {
    this.tradingView = null;
    this.isMobile = false;
  }
  setTradingView(tradingView) {
    this.tradingView = tradingView;
  }
  setMobile(isMobile) {
    this.isMobile = isMobile;
  }
  setupOrbSellHandlers(updateUICallback) {
    document.getElementById("sell-orb-common").addEventListener("click", () => {
      if (this.tradingView && this.tradingView.sellEnergyOrb("common")) {
        updateUICallback();
      }
    });
    document.getElementById("sell-orb-uncommon").addEventListener("click", () => {
      if (this.tradingView && this.tradingView.sellEnergyOrb("uncommon")) {
        updateUICallback();
      }
    });
    document.getElementById("sell-orb-rare").addEventListener("click", () => {
      if (this.tradingView && this.tradingView.sellEnergyOrb("rare")) {
        updateUICallback();
      }
    });
    document.getElementById("sell-orb-epic").addEventListener("click", () => {
      if (this.tradingView && this.tradingView.sellEnergyOrb("epic")) {
        updateUICallback();
      }
    });
    document.getElementById("sell-orb-legendary").addEventListener("click", () => {
      if (this.tradingView && this.tradingView.sellEnergyOrb("legendary")) {
        updateUICallback();
      }
    });
  }
  setupLaserPurchaseHandler(updateUICallback) {
    const purchaseLaserBtn = document.getElementById("purchase-laser");
    if (purchaseLaserBtn) {
      purchaseLaserBtn.addEventListener("click", () => {
        if (this.tradingView) {
          this.tradingView.purchaseLaserTurret();
          updateUICallback();
        }
      });
    }
  }
  // Add a new method for setting up touch events
  setupTouchEvents() {
    if (!this.isMobile) return;
    const stargateUI = document.getElementById("stargate-ui");
    if (!stargateUI) return;
    console.log("Setting up touch events for stargate UI");
    const undockBtn = document.getElementById("undock-btn");
    if (undockBtn) {
      undockBtn.style.touchAction = "manipulation";
      undockBtn.style.webkitTapHighlightColor = "transparent";
      undockBtn.style.position = "relative";
      undockBtn.style.zIndex = "9999";
      undockBtn.addEventListener("touchstart", (e) => {
        console.log("Touch start on undock button");
        undockBtn.style.backgroundColor = "#1b88db";
        undockBtn.style.transform = "scale(0.98)";
        e.stopPropagation();
      }, { passive: false });
      undockBtn.addEventListener("touchend", (e) => {
        console.log("Touch end on undock button");
        undockBtn.style.backgroundColor = "#33aaff";
        undockBtn.style.transform = "scale(1)";
        e.stopPropagation();
      }, { passive: false });
    }
    stargateUI.addEventListener("touchmove", (e) => {
      e.stopPropagation();
    }, { passive: true });
    stargateUI.addEventListener("touchstart", (e) => {
      const scrollTop = stargateUI.scrollTop;
      if (scrollTop <= 0 && e.touches[0].screenY < e.touches[0].clientY) {
        e.preventDefault();
      }
    }, { passive: false });
    const tabButtons = stargateUI.querySelectorAll(".tablinks");
    if (tabButtons.length > 0) {
      tabButtons.forEach((button) => {
        button.addEventListener("touchend", (e) => {
          e.preventDefault();
          button.click();
        });
      });
    }
    const allButtons = stargateUI.querySelectorAll("button");
    allButtons.forEach((button) => {
      if (button !== undockBtn) {
        button.style.touchAction = "manipulation";
        button.style.webkitTapHighlightColor = "transparent";
        button.addEventListener("touchstart", () => {
          button.style.transform = "scale(0.98)";
        }, { passive: true });
        button.addEventListener("touchend", () => {
          button.style.transform = "scale(1)";
        }, { passive: true });
      }
    });
  }
}
class StargateHelpers {
  static updateResourceDisplays(resources) {
    document.getElementById("ms-iron").textContent = resources.iron;
    document.getElementById("ms-gold").textContent = resources.gold;
    document.getElementById("ms-platinum").textContent = resources.platinum;
  }
  static updateCreditsDisplay(spaceship) {
    document.getElementById("ms-credits").textContent = `${spaceship.credits} CR`;
  }
  static updateStatusGauges(spaceship) {
    document.getElementById("fuel-gauge").style.width = `${spaceship.fuel / spaceship.maxFuel * 100}%`;
    document.getElementById("fuel-level").textContent = Math.round(spaceship.fuel / spaceship.maxFuel * 100);
    document.getElementById("shield-gauge").style.width = `${spaceship.shield / spaceship.maxShield * 100}%`;
    document.getElementById("shield-level").textContent = Math.round(spaceship.shield / spaceship.maxShield * 100);
    document.getElementById("hull-gauge").style.width = `${spaceship.hull / spaceship.maxHull * 100}%`;
    document.getElementById("hull-level").textContent = Math.round(spaceship.hull / spaceship.maxHull * 100);
  }
  static updateServiceButtons(spaceship) {
    const refuelBtn = document.getElementById("refuel-btn");
    if (spaceship.credits < 100 || spaceship.fuel >= spaceship.maxFuel * 0.999) {
      refuelBtn.disabled = true;
      refuelBtn.style.backgroundColor = "#555";
      refuelBtn.style.cursor = "not-allowed";
    } else {
      refuelBtn.disabled = false;
      refuelBtn.style.backgroundColor = "#00cc33";
      refuelBtn.style.cursor = "pointer";
    }
    const repairShieldBtn = document.getElementById("repair-shield-btn");
    if (spaceship.credits < 150 || spaceship.shield >= spaceship.maxShield * 0.999) {
      repairShieldBtn.disabled = true;
      repairShieldBtn.style.backgroundColor = "#555";
      repairShieldBtn.style.cursor = "not-allowed";
    } else {
      repairShieldBtn.disabled = false;
      repairShieldBtn.style.backgroundColor = "#3399ff";
      repairShieldBtn.style.cursor = "pointer";
    }
    const repairHullBtn = document.getElementById("repair-hull-btn");
    if (spaceship.credits < 200 || spaceship.hull >= spaceship.maxHull * 0.999) {
      repairHullBtn.disabled = true;
      repairHullBtn.style.backgroundColor = "#555";
      repairHullBtn.style.cursor = "not-allowed";
    } else {
      repairHullBtn.disabled = false;
      repairHullBtn.style.backgroundColor = "#ff9900";
      repairHullBtn.style.cursor = "pointer";
    }
  }
  static configureMobileUI(stargateUI, isMobile) {
    if (!isMobile) return;
    stargateUI.style.width = "92%";
    stargateUI.style.maxWidth = "92vw";
    stargateUI.style.maxHeight = "85vh";
    stargateUI.style.webkitOverflowScrolling = "touch";
    stargateUI.style.touchAction = "pan-y";
    stargateUI.style.overscrollBehavior = "auto";
    stargateUI.style.position = "absolute";
    stargateUI.style.top = "50%";
    stargateUI.style.left = "50%";
    stargateUI.style.transform = "translate(-50%, -50%)";
    stargateUI.style.zIndex = "1000";
    document.body.classList.remove("undocking", "modal-open");
  }
  static syncWithGameResources() {
    if (window.game && window.game.controls) {
      const spaceship = window.game.spaceship;
      const resources = window.game.controls.resources;
      if (spaceship && resources) {
        console.log("Syncing stargate UI with game resources:", resources);
        return { spaceship, resources };
      }
    }
    return null;
  }
}
class StargateInterface {
  constructor() {
    this.starMap = null;
    this.blackjackGame = null;
    this.settings = null;
    this.isMobile = MobileDetector.isMobile();
    this.terminalView = new TerminalView();
    this.systemsView = new SystemsView();
    this.tradingView = new TradingView();
    this.upgradesView = new UpgradesView();
    this.missionsView = new MissionsView();
    this.eventHandlers = new EventHandlers();
    this.terminalView.setMobile(this.isMobile);
    this.eventHandlers.setMobile(this.isMobile);
    this.eventHandlers.setTradingView(this.tradingView);
    this.missionsView.setHideCallback(() => this.hideStargateUI());
    this.setupStargateUI();
    this.setupEventHandlers();
  }
  setStarMap(starMap) {
    this.starMap = starMap;
    this.systemsView.setStarMap(starMap);
  }
  setBlackjackGame(blackjackGame) {
    this.blackjackGame = blackjackGame;
    this.systemsView.setBlackjackGame(blackjackGame);
  }
  setSettings(settings) {
    this.settings = settings;
    this.systemsView.setSettings(settings);
    if (this.settings) {
      this.settings.setStargateInterface(this);
    }
  }
  setupStargateUI() {
    this.terminalView.createStyles();
    this.terminalView.createDockingPrompt();
    const stargateUI = this.terminalView.createMainUI();
    stargateUI.innerHTML = this.terminalView.getMainUIContent();
    document.body.appendChild(stargateUI);
  }
  showDockingPrompt() {
    this.terminalView.showDockingPrompt();
  }
  hideDockingPrompt() {
    this.terminalView.hideDockingPrompt();
  }
  showStargateUI() {
    const stargateUI = document.getElementById("stargate-ui");
    if (stargateUI) {
      console.log("Showing stargate UI on " + (this.isMobile ? "mobile" : "desktop"));
      stargateUI.style.display = "block";
      stargateUI.style.backgroundColor = "rgba(20, 30, 50, 0.9)";
      if (this.isMobile) {
        StargateHelpers.configureMobileUI(stargateUI, this.isMobile);
      }
    }
    this.hideDockingPrompt();
    this.systemsView.setupAllSystemButtons();
    if (this.isMobile) {
      this.eventHandlers.setupTouchEvents();
    }
    const gameData = StargateHelpers.syncWithGameResources();
    if (gameData) {
      this.updateStargateUI(gameData.spaceship, gameData.resources);
    }
  }
  hideStargateUI() {
    const stargateUI = document.getElementById("stargate-ui");
    if (stargateUI) {
      stargateUI.style.display = "none";
    }
  }
  // Add alias for compatibility
  hide() {
    this.hideStargateUI();
  }
  updateStargateUI(spaceship, resources) {
    this.tradingView.setGameReferences(spaceship, resources);
    this.upgradesView.setSpaceship(spaceship);
    StargateHelpers.updateResourceDisplays(resources);
    StargateHelpers.updateCreditsDisplay(spaceship);
    StargateHelpers.updateStatusGauges(spaceship);
    StargateHelpers.updateServiceButtons(spaceship);
    this.upgradesView.updateUpgradeDisplays();
    this.tradingView.updateResourceSellButtons();
    this.tradingView.updateOrbCounts();
    this.tradingView.updateOrbSellButtons();
    this.tradingView.updateLaserTurretDisplay();
  }
  setupEventHandlers() {
    const updateUICallback = () => {
      const gameData = StargateHelpers.syncWithGameResources();
      if (gameData) {
        this.updateStargateUI(gameData.spaceship, gameData.resources);
      }
    };
    this.eventHandlers.setupOrbSellHandlers(updateUICallback);
    this.eventHandlers.setupLaserPurchaseHandler(updateUICallback);
    this.missionsView.setupHordeButton();
  }
}
class GameOverScreen {
  constructor() {
    this.isVisible = false;
    this.setupGameOverScreen();
  }
  // Helper method to handle paths for GitHub Pages and local development
  getPath(relativePath) {
    return getAbsolutePath(relativePath);
  }
  setupGameOverScreen() {
    const gameOverContainer = document.createElement("div");
    gameOverContainer.id = "game-over-container";
    gameOverContainer.style.position = "absolute";
    gameOverContainer.style.top = "0";
    gameOverContainer.style.left = "0";
    gameOverContainer.style.width = "100%";
    gameOverContainer.style.height = "100%";
    gameOverContainer.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    gameOverContainer.style.display = "flex";
    gameOverContainer.style.flexDirection = "column";
    gameOverContainer.style.alignItems = "center";
    gameOverContainer.style.justifyContent = "center";
    gameOverContainer.style.color = "#fff";
    gameOverContainer.style.fontFamily = "Courier New, monospace";
    gameOverContainer.style.zIndex = "1000";
    gameOverContainer.style.display = "none";
    document.body.appendChild(gameOverContainer);
    const gameOverTitle = document.createElement("h1");
    gameOverTitle.textContent = "GAME OVER";
    gameOverTitle.style.fontSize = "50px";
    gameOverTitle.style.color = "#ff0000";
    gameOverTitle.style.textShadow = "0 0 10px #ff0000";
    gameOverTitle.style.marginBottom = "20px";
    gameOverContainer.appendChild(gameOverTitle);
    const gameOverMessage = document.createElement("p");
    gameOverMessage.id = "game-over-message";
    gameOverMessage.textContent = "Your ship was destroyed by asteroid collision";
    gameOverMessage.style.fontSize = "18px";
    gameOverMessage.style.marginBottom = "40px";
    gameOverContainer.appendChild(gameOverMessage);
    this.setupRestartButton(gameOverContainer);
    const resourcesSummary = document.createElement("div");
    resourcesSummary.id = "resources-summary";
    resourcesSummary.style.marginTop = "30px";
    resourcesSummary.style.fontSize = "16px";
    resourcesSummary.style.textAlign = "center";
    gameOverContainer.appendChild(resourcesSummary);
  }
  setupRestartButton(container) {
    const restartButton = document.createElement("button");
    restartButton.id = "restart-game-button";
    restartButton.textContent = "RESTART MISSION";
    restartButton.style.backgroundColor = "rgba(120, 220, 232, 0.2)";
    restartButton.style.color = "#fff";
    restartButton.style.border = "1px solid rgba(120, 220, 232, 0.5)";
    restartButton.style.borderRadius = "5px";
    restartButton.style.padding = "15px 30px";
    restartButton.style.fontSize = "20px";
    restartButton.style.fontFamily = '"Rajdhani", sans-serif';
    restartButton.style.cursor = "pointer";
    restartButton.style.marginTop = "30px";
    restartButton.style.transition = "all 0.2s ease";
    restartButton.addEventListener("mouseover", () => {
      restartButton.style.backgroundColor = "rgba(120, 220, 232, 0.4)";
      restartButton.style.boxShadow = "0 0 15px rgba(120, 220, 232, 0.5)";
    });
    restartButton.addEventListener("mouseout", () => {
      restartButton.style.backgroundColor = "rgba(120, 220, 232, 0.2)";
      restartButton.style.boxShadow = "none";
    });
    restartButton.addEventListener("click", () => {
      if (this.audio) {
        this.audio.playSound("uiClick");
      }
      const loadingStatus = document.createElement("div");
      loadingStatus.textContent = "Restarting mission...";
      loadingStatus.style.color = "rgba(120, 220, 232, 0.9)";
      loadingStatus.style.marginTop = "10px";
      container.appendChild(loadingStatus);
      restartButton.disabled = true;
      restartButton.style.opacity = "0.5";
      restartButton.style.cursor = "default";
      if (window.game) {
        if (window.game.difficultyManager) {
          window.game.difficultyManager.gameTime = 0;
          window.game.difficultyManager.currentLevel = 1;
          console.log("Reset difficulty level to 1");
        }
        window.game.gameTime = 0;
      }
      setTimeout(() => {
        location.reload();
      }, 500);
    });
    container.appendChild(restartButton);
  }
  show(resources, message) {
    console.log("GameOverScreen: Showing game over screen");
    const gameOverContainer = document.getElementById("game-over-container");
    gameOverContainer.style.display = "flex";
    const gameOverMessage = document.getElementById("game-over-message");
    if (gameOverMessage) {
      let displayMessage = "Your journey has ended.";
      if (typeof message === "object" && message.data && message.data.type) {
        const reasonType = message.data.type;
        switch (reasonType) {
          case "FUEL_DEPLETED":
            displayMessage = "Your ship drifted into the void after running out of fuel.";
            break;
          case "COLLISION_ASTEROID":
            displayMessage = "Your ship was destroyed by an asteroid collision.";
            break;
          case "COLLISION_PLANET":
            displayMessage = "Your ship crashed into a planet!";
            break;
          case "COMBAT_DEATH":
            displayMessage = "Your ship was destroyed in combat.";
            break;
          case "SUN_DEATH":
            displayMessage = "Your ship was incinerated by the sun's heat!";
            break;
          default:
            if (message.data.reason) {
              displayMessage = message.data.reason;
            }
        }
      } else if (message) {
        if (message.includes("fuel")) {
          displayMessage = "Your ship drifted into the void after running out of fuel.";
        } else if (message.includes("asteroid")) {
          displayMessage = "Your ship was destroyed by an asteroid collision.";
        } else if (message.includes("combat")) {
          displayMessage = "Your ship was destroyed in combat.";
        } else if (message.includes("sun")) {
          displayMessage = "Your ship was incinerated by the sun's heat!";
        } else if (message.includes("planet")) {
          displayMessage = "Your ship crashed into a planet!";
        } else {
          displayMessage = message;
        }
      }
      gameOverMessage.textContent = displayMessage;
    }
    let wasHordeMode = false;
    let hordeSurvivalTime = "00:00";
    let rawSurvivalTime = 0;
    if (resources && resources.hordeMode) {
      wasHordeMode = resources.hordeMode.active;
      hordeSurvivalTime = resources.hordeMode.survivalTime || "00:00";
      rawSurvivalTime = resources.hordeMode.rawSurvivalTime || 0;
    }
    let resourceData = resources;
    if (resources && resources.resources) {
      console.log("GameOverScreen: Using nested resources data structure");
      resourceData = resources.resources;
    }
    const iron = resourceData && resourceData.iron ? resourceData.iron : 0;
    const gold = resourceData && resourceData.gold ? resourceData.gold : 0;
    const platinum = resourceData && resourceData.platinum ? resourceData.platinum : 0;
    const resourcesSummary = document.getElementById("resources-summary");
    if (resourcesSummary) {
      if (wasHordeMode) {
        const minutes = Math.floor(rawSurvivalTime / 1e3 / 60);
        let hordeMessage = "You fought valiantly against overwhelming odds.";
        if (minutes >= 10) {
          hordeMessage = "LEGENDARY! Few have survived the horde this long!";
        } else if (minutes >= 5) {
          hordeMessage = "IMPRESSIVE! You showed exceptional combat skills!";
        } else if (minutes >= 3) {
          hordeMessage = "Well done! You held back the horde longer than most!";
        }
        resourcesSummary.innerHTML = `
                    <div style="margin-bottom:20px; padding:15px; background-color:rgba(255,48,48,0.2); border:1px solid #ff3030; border-radius:5px;">
                        <h3 style="color:#ff3030; margin-top:0; text-shadow:0 0 5px rgba(255,48,48,0.5);">HORDE MODE</h3>
                        <p style="font-size:18px; font-weight:bold;">SURVIVED: <span style="color:#ff9999; text-shadow:0 0 5px rgba(255,48,48,0.3);">${hordeSurvivalTime}</span></p>
                        <p>${hordeMessage}</p>
                    </div>
                    <p>Resources collected:</p>
                    <p>IRON: ${iron} | GOLD: ${gold} | PLATINUM: ${platinum}</p>
                `;
      } else {
        resourcesSummary.innerHTML = `
                    <p>Resources collected:</p>
                    <p>IRON: ${iron} | GOLD: ${gold} | PLATINUM: ${platinum}</p>
                `;
      }
    }
    try {
      console.log("GameOverScreen: Attempting simple audio playback");
      const boinkSound = new Audio(this.getPath("sounds/effects/boink.wav"));
      boinkSound.volume = 0.8;
      setTimeout(() => {
        boinkSound.play().catch((err) => {
          console.warn("GameOverScreen: Simple sound failed:", err);
        });
      }, 100);
    } catch (err) {
      console.error("GameOverScreen: Error with simple sound approach:", err);
    }
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  }
}
class ControlsMenu {
  constructor() {
    this.setupControlsMenu();
  }
  setupControlsMenu() {
    const controlsMenu = document.createElement("div");
    controlsMenu.id = "controls-menu";
    controlsMenu.style.position = "absolute";
    controlsMenu.style.top = "50%";
    controlsMenu.style.left = "50%";
    controlsMenu.style.transform = "translate(-50%, -50%)";
    controlsMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    controlsMenu.style.padding = "15px";
    controlsMenu.style.borderRadius = "10px";
    controlsMenu.style.border = "1px solid #30cfd0";
    controlsMenu.style.boxShadow = "0 0 10px #30cfd0";
    controlsMenu.style.zIndex = "1000";
    controlsMenu.style.display = "none";
    document.body.appendChild(controlsMenu);
    const controlsTitle = document.createElement("div");
    controlsTitle.className = "help-title";
    controlsTitle.innerHTML = 'CONTROLS <span id="close-controls" style="float: right; cursor: pointer; font-weight: bold;">X</span>';
    controlsMenu.appendChild(controlsTitle);
    const createControlRow = (keyText, actionText) => {
      const row = document.createElement("div");
      row.className = "control-row";
      row.style.display = "flex";
      row.style.justifyContent = "space-between";
      row.style.marginBottom = "5px";
      const keySpan = document.createElement("span");
      if (keyText !== "Mouse") {
        keySpan.className = "key";
        keySpan.style.backgroundColor = "rgba(48, 207, 208, 0.2)";
        keySpan.style.border = "1px solid #30cfd0";
        keySpan.style.borderRadius = "4px";
        keySpan.style.padding = "0 5px";
        keySpan.style.minWidth = "20px";
        keySpan.style.textAlign = "center";
      }
      keySpan.textContent = keyText;
      row.appendChild(keySpan);
      const actionSpan = document.createElement("span");
      actionSpan.textContent = actionText;
      row.appendChild(actionSpan);
      return row;
    };
    controlsMenu.appendChild(createControlRow("W", "Forward Thrust"));
    controlsMenu.appendChild(createControlRow("S", "Backward Thrust"));
    controlsMenu.appendChild(createControlRow("A", "Left Thrust"));
    controlsMenu.appendChild(createControlRow("D", "Right Thrust"));
    controlsMenu.appendChild(createControlRow("SHIFT", "Boost"));
    controlsMenu.appendChild(createControlRow("Mouse", "Ship Rotation"));
    controlsMenu.appendChild(createControlRow("Click", "Fire Particle Cannon"));
    controlsMenu.appendChild(createControlRow("E", "Target Lock-On"));
    controlsMenu.appendChild(createControlRow("TAB", "Cycle Targets"));
    controlsMenu.appendChild(createControlRow("R", "Toggle Mining"));
    controlsMenu.appendChild(createControlRow("T", "Deploy Laser Turret"));
    controlsMenu.appendChild(createControlRow("Q", "Dock with Stargate"));
    document.getElementById("close-controls").addEventListener("click", () => {
      this.hide();
    });
    document.addEventListener("click", (e) => {
      const controlsMenu2 = document.getElementById("controls-menu");
      const showControlsButton = document.getElementById("show-controls");
      if (controlsMenu2.style.display === "block" && !controlsMenu2.contains(e.target) && e.target !== showControlsButton) {
        this.hide();
      }
    });
  }
  show() {
    const controlsMenu = document.getElementById("controls-menu");
    if (controlsMenu) {
      controlsMenu.style.display = "block";
    }
  }
  hide() {
    const controlsMenu = document.getElementById("controls-menu");
    if (controlsMenu) {
      controlsMenu.style.display = "none";
    }
  }
  setupButtonHandler() {
    const showControlsButton = document.getElementById("show-controls");
    if (showControlsButton) {
      showControlsButton.addEventListener("click", (e) => {
        this.show();
        e.stopPropagation();
      });
    }
  }
}
class CanvasRenderer {
  constructor(isMobile) {
    this.isMobile = isMobile;
  }
  // Draw the star map on the canvas
  updateCanvas(starSystemGenerator) {
    const canvas = document.getElementById("star-map-canvas");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const systems = starSystemGenerator.getAllSystems();
    const currentSystem = starSystemGenerator.currentSystem;
    const connections = starSystemGenerator.warpGates;
    this.drawConnections(ctx, centerX, centerY, systems, connections);
    this.drawCurrentSystemConnections(ctx, centerX, centerY, systems, currentSystem);
    this.drawSystems(ctx, centerX, centerY, systems, currentSystem);
  }
  drawConnections(ctx, centerX, centerY, systems, connections) {
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(48, 207, 208, 0.4)";
    for (const [systemId, connectedSystems] of Object.entries(connections)) {
      const system = systems[systemId];
      if (!system) continue;
      const x1 = centerX + system.position.x;
      const y1 = centerY + system.position.y;
      for (const connectedId of connectedSystems) {
        const connectedSystem = systems[connectedId];
        if (!connectedSystem) continue;
        const x2 = centerX + connectedSystem.position.x;
        const y2 = centerY + connectedSystem.position.y;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
  }
  drawCurrentSystemConnections(ctx, centerX, centerY, systems, currentSystem) {
    if (currentSystem && systems[currentSystem]) {
      const currentSystemData = systems[currentSystem];
      const x1 = centerX + currentSystemData.position.x;
      const y1 = centerY + currentSystemData.position.y;
      ctx.lineWidth = this.isMobile ? 3 : 2;
      ctx.strokeStyle = "rgba(48, 207, 208, 0.8)";
      for (const connectedId of currentSystemData.connections) {
        const connectedSystem = systems[connectedId];
        if (!connectedSystem) continue;
        const x2 = centerX + connectedSystem.position.x;
        const y2 = centerY + connectedSystem.position.y;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
  }
  drawSystems(ctx, centerX, centerY, systems, currentSystem, selectedSystem = null) {
    for (const [systemId, system] of Object.entries(systems)) {
      const x = centerX + system.position.x;
      const y = centerY + system.position.y;
      const isCurrent = systemId === currentSystem;
      const isSelected = systemId === selectedSystem;
      const isConnected = currentSystem && systems[currentSystem] && systems[currentSystem].connections.includes(systemId);
      ctx.beginPath();
      let radius;
      if (this.isMobile) {
        radius = isCurrent ? 18 : isSelected ? 15 : 10;
      } else {
        radius = isCurrent ? 15 : isSelected ? 12 : 8;
      }
      ctx.fillStyle = system.starColor ? `#${system.starColor.toString(16).padStart(6, "0")}` : "#ffffff";
      if (isCurrent || isSelected) {
        ctx.shadowBlur = this.isMobile ? 20 : 15;
        ctx.shadowColor = isCurrent ? "#30cfd0" : "#ffffff";
      } else {
        ctx.shadowBlur = 0;
      }
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      if (isConnected && !isCurrent) {
        ctx.strokeStyle = "#30cfd0";
        ctx.lineWidth = this.isMobile ? 3 : 2;
        ctx.beginPath();
        ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.fillStyle = isCurrent ? "#30cfd0" : isSelected ? "#ffffff" : "#aaaaaa";
      ctx.font = isCurrent ? this.isMobile ? "bold 14px Courier New" : "bold 12px Courier New" : this.isMobile ? "12px Courier New" : "10px Courier New";
      ctx.textAlign = "center";
      ctx.fillText(system.name, x, y + radius + (this.isMobile ? 18 : 15));
    }
  }
  // Find which system was clicked (if any)
  findSystemAtPosition(x, y, starSystemGenerator) {
    const systems = starSystemGenerator.getAllSystems();
    const currentSystem = starSystemGenerator.currentSystem;
    const centerX = 250;
    const centerY = 250;
    for (const [systemId, system] of Object.entries(systems)) {
      const canvasX = centerX + system.position.x;
      const canvasY = centerY + system.position.y;
      const dx = x - canvasX;
      const dy = y - canvasY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const radius = systemId === currentSystem ? this.isMobile ? 20 : 15 : this.isMobile ? 15 : 10;
      if (distance <= radius) {
        return systemId;
      }
    }
    return null;
  }
}
class NavigationLogic {
  constructor(starSystemGenerator, dockingSystem, stargateInterface) {
    this.starSystemGenerator = starSystemGenerator;
    this.dockingSystem = dockingSystem;
    this.stargateInterface = stargateInterface;
    this.selectedSystem = null;
    this.isTraveling = false;
  }
  // Select a system and update the UI
  selectSystem(systemId, isMobile, updateSelectedSystemCallback, updateTravelButtonCallback) {
    console.log(`Selecting system: ${systemId}`);
    this.selectedSystem = systemId;
    if (!systemId) {
      updateSelectedSystemCallback(null, isMobile);
      updateTravelButtonCallback(null, false, false);
      return;
    }
    const system = this.starSystemGenerator.getAllSystems()[systemId];
    const currentSystem = this.starSystemGenerator.currentSystem;
    updateSelectedSystemCallback(system, isMobile);
    const isConnected = this.starSystemGenerator.getCurrentSystemConnections().includes(systemId);
    const isCurrentSystem = systemId === currentSystem;
    updateTravelButtonCallback(systemId, isCurrentSystem, isConnected);
  }
  // Handle travel to selected system
  handleTravel(hideCallback) {
    if (this.selectedSystem && this.selectedSystem !== this.starSystemGenerator.currentSystem) {
      console.log(`Initiating travel to system: ${this.selectedSystem}`);
      this.isTraveling = true;
      hideCallback();
      const environment = window.game.environment;
      if (environment && environment.travelToSystem) {
        const success = environment.travelToSystem(this.selectedSystem);
        console.log(`Travel to ${this.selectedSystem} initiated: ${success}`);
        setTimeout(() => {
          this.isTraveling = false;
        }, 5e3);
      } else {
        const success = this.starSystemGenerator.travelToSystem(this.selectedSystem);
        if (success) {
          this.selectSystem(null);
          this.showTravelNotification(this.starSystemGenerator.getCurrentSystemData().name);
          this.isTraveling = false;
        }
      }
    }
  }
  // Show travel notification
  showTravelNotification(systemName, isMobile) {
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = isMobile ? "30%" : "20%";
    notification.style.left = "50%";
    notification.style.transform = "translate(-50%, -50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    notification.style.color = "#30cfd0";
    notification.style.padding = isMobile ? "15px 30px" : "20px 40px";
    notification.style.borderRadius = "10px";
    notification.style.border = "2px solid #30cfd0";
    notification.style.boxShadow = "0 0 30px #30cfd0";
    notification.style.fontFamily = "Courier New, monospace";
    notification.style.fontSize = isMobile ? "18px" : "20px";
    notification.style.fontWeight = "bold";
    notification.style.zIndex = "9999";
    notification.style.textAlign = "center";
    notification.textContent = `ARRIVED AT ${systemName}`;
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 1s";
      setTimeout(() => {
        notification.remove();
      }, 1e3);
    }, 3e3);
  }
  getSelectedSystem() {
    return this.selectedSystem;
  }
  isTravelingToSystem() {
    return this.isTraveling;
  }
}
class DataManager {
  constructor(starSystemGenerator) {
    this.starSystemGenerator = starSystemGenerator;
  }
  // Update the current system information
  updateCurrentSystemInfo(isMobile) {
    const system = this.starSystemGenerator.getCurrentSystemData();
    if (!system) return;
    document.getElementById("current-system-name").textContent = system.name;
    document.getElementById("current-system-class").textContent = `Class ${system.starClass} - ${system.classification}`;
    document.getElementById("current-iron-indicator").style.width = `${system.resourceMultipliers.iron * 50}%`;
    document.getElementById("current-gold-indicator").style.width = `${system.resourceMultipliers.gold * 50}%`;
    document.getElementById("current-platinum-indicator").style.width = `${system.resourceMultipliers.platinum * 50}%`;
    document.getElementById("current-system-description").textContent = system.description;
    document.getElementById("current-system-features").textContent = `Special Features: ${system.specialFeatures.join(", ")}`;
  }
  // Update selected system info card
  updateSelectedSystemInfo(system, isMobile) {
    const selectedCard = document.getElementById("selected-system-card");
    if (!selectedCard) return;
    if (!system) {
      selectedCard.innerHTML = `
                <div class="empty-selection" style="color: #777; text-align: center; padding: 20px;">
                    No system selected.<br>${isMobile ? "Tap" : "Click"} on a star system in the map to select it.
                </div>
            `;
      return;
    }
    selectedCard.innerHTML = `
            <div id="selected-system-name" style="font-size: ${isMobile ? "16px" : "18px"}; font-weight: bold; color: #fff; margin-bottom: 5px;">${system.name}</div>
            <div id="selected-system-class" style="font-size: ${isMobile ? "12px" : "14px"}; color: #aaa; margin-bottom: 10px;">Class ${system.starClass} - ${system.classification}</div>
            <div id="selected-system-resources" style="margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Iron:</span>
                    <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; width: ${system.resourceMultipliers.iron * 50}%; background: #aaa;"></div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Gold:</span>
                    <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; width: ${system.resourceMultipliers.gold * 50}%; background: #FFD700;"></div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Platinum:</span>
                    <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; width: ${system.resourceMultipliers.platinum * 50}%; background: #E5E4E2;"></div>
                    </div>
                </div>
            </div>
            <div style="font-size: ${isMobile ? "11px" : "12px"}; color: #ccc; margin-bottom: 10px;">
                ${system.description}
            </div>
            <div style="font-size: ${isMobile ? "11px" : "12px"}; color: #30cfd0;">
                Special Features: ${system.specialFeatures.join(", ")}
            </div>
        `;
    if (isMobile) {
      const infoPanel = document.getElementById("system-info-panel");
      if (infoPanel) {
        infoPanel.scrollTop = selectedCard.offsetTop - infoPanel.offsetTop;
      }
    }
  }
  // Update travel button state
  updateTravelButton(systemId, isCurrentSystem, isConnected) {
    const travelButton = document.getElementById("travel-button");
    if (!travelButton) return;
    if (!systemId) {
      travelButton.disabled = true;
      travelButton.style.cursor = "not-allowed";
      travelButton.style.opacity = "0.5";
      travelButton.textContent = "TRAVEL TO SYSTEM";
      return;
    }
    travelButton.disabled = isCurrentSystem || !isConnected;
    travelButton.style.cursor = isCurrentSystem || !isConnected ? "not-allowed" : "pointer";
    travelButton.style.opacity = isCurrentSystem || !isConnected ? "0.5" : "1";
    travelButton.textContent = isCurrentSystem ? "CURRENT LOCATION" : !isConnected ? "NO DIRECT ROUTE" : "TRAVEL TO SYSTEM";
  }
  getCurrentSystemData() {
    return this.starSystemGenerator.getCurrentSystemData();
  }
  getAllSystems() {
    return this.starSystemGenerator.getAllSystems();
  }
  getCurrentSystem() {
    return this.starSystemGenerator.currentSystem;
  }
}
class UICreator {
  constructor(isMobile) {
    this.isMobile = isMobile;
  }
  // Create star map UI
  setupStarMapUI() {
    const starMap = document.createElement("div");
    starMap.id = "star-map";
    starMap.style.position = "absolute";
    starMap.style.top = "50%";
    starMap.style.left = "50%";
    starMap.style.transform = "translate(-50%, -50%)";
    if (this.isMobile) {
      starMap.style.width = "95%";
      starMap.style.height = "85vh";
      starMap.style.maxHeight = "700px";
    } else {
      starMap.style.width = "900px";
      starMap.style.height = "700px";
    }
    starMap.style.backgroundColor = "rgba(10, 15, 30, 0.95)";
    starMap.style.color = "#fff";
    starMap.style.padding = this.isMobile ? "15px" : "30px";
    starMap.style.borderRadius = "10px";
    starMap.style.border = "2px solid #30cfd0";
    starMap.style.boxShadow = "0 0 30px #30cfd0";
    starMap.style.fontFamily = "Courier New, monospace";
    starMap.style.zIndex = "1500";
    starMap.style.display = "none";
    starMap.style.overflow = "hidden";
    const title = document.createElement("h2");
    title.textContent = "STAR MAP";
    title.style.textAlign = "center";
    title.style.color = "#30cfd0";
    title.style.margin = "0 0 20px 0";
    title.style.fontSize = this.isMobile ? "24px" : "28px";
    starMap.appendChild(title);
    const content = document.createElement("div");
    content.style.display = "flex";
    content.style.flexDirection = this.isMobile ? "column" : "row";
    content.style.height = this.isMobile ? "calc(100% - 120px)" : "calc(100% - 100px)";
    content.style.gap = this.isMobile ? "15px" : "0";
    const mapContainer = this.createMapContainer();
    const infoPanel = this.createInfoPanel();
    content.appendChild(mapContainer);
    content.appendChild(infoPanel);
    starMap.appendChild(content);
    const closeButton = this.createCloseButton();
    starMap.appendChild(closeButton);
    document.body.appendChild(starMap);
  }
  createMapContainer() {
    const mapContainer = document.createElement("div");
    mapContainer.id = "star-map-visual";
    mapContainer.style.flex = "1";
    mapContainer.style.background = "rgba(0, 0, 0, 0.7)";
    mapContainer.style.borderRadius = "10px";
    mapContainer.style.border = "1px solid #30cfd0";
    mapContainer.style.position = "relative";
    mapContainer.style.overflow = "hidden";
    mapContainer.style.height = this.isMobile ? "40%" : "100%";
    mapContainer.style.minHeight = this.isMobile ? "250px" : "auto";
    const canvas = document.createElement("canvas");
    canvas.id = "star-map-canvas";
    canvas.width = 500;
    canvas.height = 500;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    mapContainer.appendChild(canvas);
    return mapContainer;
  }
  createInfoPanel() {
    const infoPanel = document.createElement("div");
    infoPanel.id = "system-info-panel";
    infoPanel.style.width = this.isMobile ? "100%" : "350px";
    infoPanel.style.marginLeft = this.isMobile ? "0" : "20px";
    infoPanel.style.overflowY = "auto";
    infoPanel.style.height = this.isMobile ? "60%" : "100%";
    infoPanel.style.webkitOverflowScrolling = "touch";
    const currentSystem = this.createCurrentSystemSection();
    infoPanel.appendChild(currentSystem);
    const selectedSystem = this.createSelectedSystemSection();
    infoPanel.appendChild(selectedSystem);
    return infoPanel;
  }
  createCurrentSystemSection() {
    const currentSystem = document.createElement("div");
    currentSystem.id = "current-system-info";
    currentSystem.innerHTML = `
            <h3 style="color: #30cfd0; margin-top: 0; font-size: ${this.isMobile ? "16px" : "18px"};">CURRENT SYSTEM</h3>
            <div class="system-card" style="background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 5px; border: 1px solid #30cfd0; margin-bottom: 20px;">
                <div id="current-system-name" style="font-size: ${this.isMobile ? "16px" : "18px"}; font-weight: bold; color: #fff; margin-bottom: 5px;">Solar System</div>
                <div id="current-system-class" style="font-size: ${this.isMobile ? "12px" : "14px"}; color: #aaa; margin-bottom: 10px;">Class G - Home System</div>
                <div id="current-system-resources" style="margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>Iron:</span>
                        <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                            <div id="current-iron-indicator" style="height: 100%; width: 50%; background: #aaa;"></div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>Gold:</span>
                        <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                            <div id="current-gold-indicator" style="height: 100%; width: 50%; background: #FFD700;"></div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Platinum:</span>
                        <div class="resource-indicator" style="width: 100px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                            <div id="current-platinum-indicator" style="height: 100%; width: 50%; background: #E5E4E2;"></div>
                        </div>
                    </div>
                </div>
                <div id="current-system-description" style="font-size: ${this.isMobile ? "11px" : "12px"}; color: #ccc; margin-bottom: 10px;">
                    Our home system, with Earth as the starting location.
                </div>
                <div id="current-system-features" style="font-size: ${this.isMobile ? "11px" : "12px"}; color: #30cfd0;">
                    Special Features: Earth
                </div>
            </div>
        `;
    return currentSystem;
  }
  createSelectedSystemSection() {
    const selectedSystem = document.createElement("div");
    selectedSystem.id = "selected-system-info";
    selectedSystem.innerHTML = `
            <h3 style="color: #30cfd0; font-size: ${this.isMobile ? "16px" : "18px"};">SELECTED SYSTEM</h3>
            <div id="selected-system-card" class="system-card" style="background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 5px; border: 1px solid #555; margin-bottom: 20px;">
                <div class="empty-selection" style="color: #777; text-align: center; padding: 20px;">
                    No system selected.<br>
                    ${this.isMobile ? "Tap" : "Click"} on a star system in the map to select it.
                </div>
            </div>
            <button id="travel-button" disabled style="width: 100%; padding: ${this.isMobile ? "15px" : "12px"}; background-color: #30cfd0; color: #000; border: none; border-radius: 5px; cursor: not-allowed; font-family: 'Courier New', monospace; font-weight: bold; font-size: ${this.isMobile ? "18px" : "16px"}; opacity: 0.5;">
                TRAVEL TO SYSTEM
            </button>
        `;
    return selectedSystem;
  }
  createCloseButton() {
    const closeButton = document.createElement("button");
    closeButton.id = "close-star-map";
    closeButton.textContent = "RETURN TO STARGATE";
    closeButton.style.width = "100%";
    closeButton.style.padding = this.isMobile ? "15px" : "12px";
    closeButton.style.marginTop = "20px";
    closeButton.style.backgroundColor = "#555";
    closeButton.style.color = "#fff";
    closeButton.style.border = "none";
    closeButton.style.borderRadius = "5px";
    closeButton.style.cursor = "pointer";
    closeButton.style.fontFamily = "Courier New, monospace";
    closeButton.style.fontWeight = "bold";
    closeButton.style.fontSize = this.isMobile ? "18px" : "16px";
    if (this.isMobile) {
      closeButton.style.backgroundColor = "#30cfd0";
      closeButton.style.color = "#000";
      closeButton.style.boxShadow = "0 0 15px rgba(48, 207, 208, 0.7)";
    }
    return closeButton;
  }
}
class StarMap {
  constructor(starSystemGenerator, dockingSystem, stargateInterface) {
    this.starSystemGenerator = starSystemGenerator;
    this.dockingSystem = dockingSystem;
    this.stargateInterface = stargateInterface;
    this.isVisible = false;
    this.isMobile = MobileDetector.isMobile();
    console.log("StarMap constructor - isMobile:", this.isMobile);
    this.canvasRenderer = new CanvasRenderer(this.isMobile);
    this.navigationLogic = new NavigationLogic(starSystemGenerator, dockingSystem, stargateInterface);
    this.dataManager = new DataManager(starSystemGenerator);
    this.uiCreator = new UICreator(this.isMobile);
    this.uiCreator.setupStarMapUI();
    this.setupEventHandlers();
  }
  setupEventHandlers() {
    const closeButton = document.getElementById("close-star-map");
    if (closeButton) {
      closeButton.addEventListener("click", () => {
        if (window.game && window.game.audio) {
          window.game.audio.playSound("boink");
        }
        this.hide();
      });
      if (this.isMobile) {
        closeButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          if (window.game && window.game.audio) {
            console.log("Mobile: Playing sound on star map close button");
            window.game.audio.playSound("boink");
            setTimeout(() => this.hide(), 50);
          } else {
            this.hide();
          }
        });
      }
    }
    const canvas = document.getElementById("star-map-canvas");
    if (canvas) {
      canvas.addEventListener("click", (e) => {
        this.handleMapInteraction(e);
      });
      if (this.isMobile) {
        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          this.handleMapInteraction(e.changedTouches[0]);
        });
      }
    }
    const travelButton = document.getElementById("travel-button");
    if (travelButton) {
      const travelHandler = () => {
        this.navigationLogic.handleTravel(() => this.hide());
      };
      travelButton.addEventListener("click", travelHandler);
      if (this.isMobile) {
        travelButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          travelHandler();
        });
      }
    }
  }
  // Handler for map interactions (click or touch)
  handleMapInteraction(event) {
    const canvas = document.getElementById("star-map-canvas");
    const rect = canvas.getBoundingClientRect();
    const x = (event.clientX - rect.left) * (canvas.width / rect.width);
    const y = (event.clientY - rect.top) * (canvas.height / rect.height);
    const clickedSystem = this.canvasRenderer.findSystemAtPosition(x, y, this.starSystemGenerator);
    if (clickedSystem) {
      this.selectSystem(clickedSystem);
      this.updateCanvas();
    }
  }
  // Select a system and update the UI
  selectSystem(systemId) {
    this.navigationLogic.selectSystem(
      systemId,
      this.isMobile,
      (system, isMobile) => this.dataManager.updateSelectedSystemInfo(system, isMobile),
      (systemId2, isCurrentSystem, isConnected) => this.dataManager.updateTravelButton(systemId2, isCurrentSystem, isConnected)
    );
  }
  // Draw the star map on the canvas
  updateCanvas() {
    this.canvasRenderer.updateCanvas(this.starSystemGenerator);
    this.canvasRenderer.drawSystems(
      document.getElementById("star-map-canvas").getContext("2d"),
      250,
      250,
      // center coordinates
      this.dataManager.getAllSystems(),
      this.dataManager.getCurrentSystem(),
      this.navigationLogic.getSelectedSystem()
    );
  }
  // Update the current system information
  updateCurrentSystemInfo() {
    this.dataManager.updateCurrentSystemInfo(this.isMobile);
  }
  // Show the star map
  show() {
    this.updateCurrentSystemInfo();
    this.updateCanvas();
    this.selectSystem(null);
    if (this.isMobile && window.game && window.game.audio) {
      setTimeout(() => {
        console.log("Mobile: Attempting to play initial sound in StarMap");
        window.game.audio.playSound("boink");
      }, 100);
    }
    const starMap = document.getElementById("star-map");
    if (starMap) {
      starMap.style.display = "block";
      this.isVisible = true;
    }
  }
  // Hide the star map
  hide() {
    const starMap = document.getElementById("star-map");
    if (starMap) {
      starMap.style.display = "none";
      this.isVisible = false;
      if (this.stargateInterface) {
        this.stargateInterface.showStargateUI();
      } else if (window.game && window.game.ui && window.game.ui.stargateInterface) {
        window.game.ui.stargateInterface.showStargateUI();
      } else {
        const stargateUI = document.getElementById("stargate-ui");
        if (stargateUI) {
          stargateUI.style.display = "block";
        }
      }
    }
  }
  // Toggle map visibility
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
}
class BlackjackStyles {
  constructor(isMobile = false) {
    this.isMobile = isMobile;
  }
  /**
   * Get main game UI styles
   */
  getGameUIStyles() {
    return {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: this.isMobile ? "95%" : "900px",
      maxWidth: this.isMobile ? "600px" : "none",
      height: this.isMobile ? "auto" : "650px",
      maxHeight: this.isMobile ? "85vh" : "none",
      backgroundColor: "rgba(6, 22, 31, 0.85)",
      backdropFilter: "blur(10px)",
      border: "2px solid #33aaff",
      borderRadius: "15px",
      boxShadow: "0 0 30px rgba(51, 170, 255, 0.5)",
      padding: this.isMobile ? "15px" : "25px",
      zIndex: "1000",
      display: "none",
      fontFamily: "Courier New, monospace",
      color: "#fff",
      userSelect: "none",
      overflowY: this.isMobile ? "auto" : "hidden"
    };
  }
  /**
   * Get mobile-specific styles
   */
  getMobileStyles() {
    if (!this.isMobile) return {};
    return {
      webkitOverflowScrolling: "touch",
      touchAction: "pan-y",
      overscrollBehavior: "contain"
    };
  }
  /**
   * Get scanline effect styles
   */
  getScanlineStyles() {
    return {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      backgroundImage: "linear-gradient(transparent 50%, rgba(0, 0, 0, 0.1) 50%)",
      backgroundSize: "100% 4px",
      pointerEvents: "none",
      zIndex: "1001",
      opacity: "0.15"
    };
  }
  /**
   * Get header styles
   */
  getHeaderStyles() {
    return {
      textAlign: "center",
      marginBottom: "20px",
      position: "relative"
    };
  }
  /**
   * Get title styles
   */
  getTitleStyles() {
    return {
      color: "#30cfd0",
      textShadow: "0 0 10px rgba(48, 207, 208, 0.7)",
      margin: "0 0 5px 0",
      fontSize: this.isMobile ? "24px" : "32px"
    };
  }
  /**
   * Get subtitle styles
   */
  getSubtitleStyles() {
    return {
      color: "rgba(255, 255, 255, 0.6)",
      fontSize: this.isMobile ? "12px" : "14px",
      letterSpacing: "2px"
    };
  }
  /**
   * Get close button styles
   */
  getCloseButtonStyles() {
    const baseStyles = {
      position: "absolute",
      top: "0",
      right: "0",
      backgroundColor: "transparent",
      border: "none",
      color: "#33aaff",
      fontSize: "32px",
      cursor: "pointer",
      outline: "none",
      padding: "0 10px",
      lineHeight: "1"
    };
    if (this.isMobile) {
      return {
        ...baseStyles,
        fontSize: "42px",
        padding: "5px 15px",
        backgroundColor: "rgba(0, 0, 0, 0.3)",
        borderRadius: "50%",
        width: "50px",
        height: "50px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        boxShadow: "0 0 10px rgba(51, 170, 255, 0.5)",
        right: "5px",
        top: "5px"
      };
    }
    return baseStyles;
  }
  /**
   * Get game area styles
   */
  getGameAreaStyles() {
    return {
      display: "flex",
      flexDirection: "column",
      height: this.isMobile ? "auto" : "calc(100% - 80px)"
    };
  }
  /**
   * Get dealer/player area styles
   */
  getPlayerAreaStyles() {
    return {
      flex: "1",
      border: "1px solid rgba(51, 170, 255, 0.3)",
      borderRadius: "8px",
      padding: "15px",
      marginBottom: "15px",
      background: "linear-gradient(to bottom, rgba(9, 30, 42, 0.4), rgba(9, 30, 42, 0.6))"
    };
  }
  /**
   * Get dealer area styles
   */
  getDealerAreaStyles() {
    return {
      ...this.getPlayerAreaStyles(),
      background: "linear-gradient(to bottom, rgba(9, 30, 42, 0.6), rgba(9, 30, 42, 0.4))"
    };
  }
  /**
   * Get area header styles
   */
  getAreaHeaderStyles() {
    return {
      display: "flex",
      justifyContent: "space-between",
      marginBottom: "10px"
    };
  }
  /**
   * Get dealer title styles
   */
  getDealerTitleStyles() {
    return {
      color: "#33aaff",
      fontWeight: "bold"
    };
  }
  /**
   * Get player title styles
   */
  getPlayerTitleStyles() {
    return {
      color: "#30cfd0",
      fontWeight: "bold"
    };
  }
  /**
   * Get score display styles
   */
  getScoreStyles(isPlayer = false) {
    return {
      color: "#fff",
      fontWeight: "bold",
      backgroundColor: isPlayer ? "rgba(48, 207, 208, 0.2)" : "rgba(51, 170, 255, 0.2)",
      padding: "0 10px",
      borderRadius: "4px"
    };
  }
  /**
   * Get cards container styles
   */
  getCardsContainerStyles() {
    return {
      display: "flex",
      gap: "15px",
      flexWrap: "wrap",
      height: this.isMobile ? "auto" : "130px",
      minHeight: this.isMobile ? "120px" : "130px"
    };
  }
  /**
   * Get card element styles
   */
  getCardStyles(faceDown = false) {
    return {
      width: this.isMobile ? "70px" : "100px",
      height: this.isMobile ? "105px" : "150px",
      fontSize: this.isMobile ? "80%" : "100%",
      backgroundColor: faceDown ? "rgba(9, 30, 42, 0.8)" : "rgba(15, 35, 50, 0.9)",
      border: faceDown ? "2px solid rgba(51, 170, 255, 0.3)" : "2px solid rgba(51, 170, 255, 0.7)",
      borderRadius: "10px",
      boxShadow: faceDown ? "0 0 5px rgba(51, 170, 255, 0.3)" : "0 0 10px rgba(51, 170, 255, 0.5)",
      position: "relative",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      overflow: "hidden",
      transition: "transform 0.3s ease"
    };
  }
  /**
   * Get card value styles
   */
  getCardValueStyles(position = "top") {
    const baseStyles = {
      position: "absolute",
      fontSize: this.isMobile ? "14px" : "20px",
      fontWeight: "bold"
    };
    if (position === "top") {
      return {
        ...baseStyles,
        top: "8px",
        left: "8px"
      };
    } else {
      return {
        ...baseStyles,
        bottom: "8px",
        right: "8px",
        transform: "rotate(180deg)"
      };
    }
  }
  /**
   * Get card suit styles
   */
  getCardSuitStyles(position = "top") {
    const baseStyles = {
      position: "absolute",
      fontSize: this.isMobile ? "12px" : "16px"
    };
    if (position === "top") {
      return {
        ...baseStyles,
        top: "8px",
        right: "8px"
      };
    } else {
      return {
        ...baseStyles,
        bottom: "8px",
        left: "8px",
        transform: "rotate(180deg)"
      };
    }
  }
  /**
   * Get center symbol styles
   */
  getCenterSymbolStyles() {
    return {
      fontSize: this.isMobile ? "28px" : "40px",
      lineHeight: "1",
      opacity: "0.9"
    };
  }
  /**
   * Get card color based on suit
   */
  getCardColor(suit) {
    return ["hearts", "diamonds"].includes(suit) ? "#e55c8a" : "#30cfd0";
  }
  /**
   * Get speech bubble styles
   */
  getSpeechBubbleStyles() {
    return {
      position: this.isMobile ? "relative" : "absolute",
      bottom: this.isMobile ? "auto" : "15px",
      right: this.isMobile ? "auto" : "15px",
      marginTop: this.isMobile ? "10px" : "0",
      backgroundColor: "rgba(15, 40, 55, 0.9)",
      border: "1px solid #33aaff",
      borderRadius: "8px",
      padding: "10px 15px",
      maxWidth: this.isMobile ? "100%" : "300px",
      fontStyle: "italic",
      color: "#fff",
      boxShadow: "0 0 10px rgba(51, 170, 255, 0.3)",
      display: "none"
    };
  }
  /**
   * Get status area styles
   */
  getStatusAreaStyles() {
    return {
      height: "60px",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      marginBottom: "15px"
    };
  }
  /**
   * Get game status styles
   */
  getGameStatusStyles() {
    return {
      padding: "8px 20px",
      borderRadius: "20px",
      backgroundColor: "rgba(51, 170, 255, 0.2)",
      border: "1px solid rgba(51, 170, 255, 0.4)",
      color: "#fff",
      textAlign: "center",
      fontWeight: "bold",
      letterSpacing: "1px",
      fontSize: this.isMobile ? "12px" : "14px",
      width: this.isMobile ? "100%" : "auto"
    };
  }
  /**
   * Get controls area styles
   */
  getControlsAreaStyles() {
    return {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      height: "auto",
      flexDirection: this.isMobile ? "column" : "row",
      gap: this.isMobile ? "15px" : "0"
    };
  }
  /**
   * Get betting controls styles
   */
  getBettingControlsStyles() {
    return {
      display: "flex",
      flexDirection: "column",
      width: this.isMobile ? "100%" : "250px"
    };
  }
  /**
   * Get betting title styles
   */
  getBettingTitleStyles() {
    return {
      marginBottom: "10px",
      color: "rgba(255, 255, 255, 0.8)",
      fontWeight: "bold"
    };
  }
  /**
   * Get resource options styles
   */
  getResourceOptionsStyles() {
    return {
      display: "flex",
      gap: "10px"
    };
  }
  /**
   * Get resource button styles
   */
  getResourceButtonStyles(color) {
    return {
      flex: "1",
      padding: this.isMobile ? "10px 5px" : "8px 5px",
      backgroundColor: "rgba(15, 40, 55, 0.8)",
      border: `1px solid ${color}`,
      borderRadius: "5px",
      color: "#fff",
      boxShadow: `0 0 10px rgba(${color.split("(")[1].split(")")[0]}, 0.3)`,
      cursor: "pointer",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      transition: "background-color 0.2s, box-shadow 0.2s"
    };
  }
  /**
   * Get resource button hover styles
   */
  getResourceButtonHoverStyles(color) {
    return {
      backgroundColor: "rgba(25, 60, 80, 0.8)",
      boxShadow: `0 0 15px ${color}`
    };
  }
  /**
   * Get bet amount controls styles
   */
  getBetAmountControlsStyles() {
    return {
      display: "flex",
      marginTop: "10px",
      gap: "10px"
    };
  }
  /**
   * Get bet amount display styles
   */
  getBetAmountDisplayStyles() {
    return {
      flex: "1",
      backgroundColor: "rgba(15, 40, 55, 0.8)",
      border: "1px solid rgba(51, 170, 255, 0.5)",
      borderRadius: "5px",
      padding: "8px 10px",
      textAlign: "center",
      fontWeight: "bold"
    };
  }
  /**
   * Get control button styles
   */
  getControlButtonStyles() {
    return {
      width: this.isMobile ? "50px" : "40px",
      height: this.isMobile ? "40px" : "auto",
      backgroundColor: "rgba(15, 40, 55, 0.8)",
      border: "1px solid rgba(51, 170, 255, 0.5)",
      borderRadius: "5px",
      color: "#fff",
      cursor: "pointer",
      fontSize: this.isMobile ? "20px" : "16px"
    };
  }
  /**
   * Get control button hover styles
   */
  getControlButtonHoverStyles() {
    return {
      backgroundColor: "rgba(25, 60, 80, 0.8)",
      boxShadow: "0 0 10px rgba(51, 170, 255, 0.3)"
    };
  }
  /**
   * Get game actions styles
   */
  getGameActionsStyles() {
    return {
      display: "flex",
      gap: "15px",
      flexWrap: this.isMobile ? "wrap" : "nowrap",
      justifyContent: this.isMobile ? "center" : "flex-end",
      width: this.isMobile ? "100%" : "auto"
    };
  }
  /**
   * Get action button styles
   */
  getActionButtonStyles(color) {
    return {
      padding: this.isMobile ? "15px 20px" : "12px 18px",
      backgroundColor: "rgba(15, 40, 55, 0.8)",
      border: `2px solid ${color}`,
      borderRadius: "5px",
      color: "#fff",
      fontWeight: "bold",
      cursor: "pointer",
      boxShadow: `0 0 10px ${color}`,
      transition: "all 0.2s",
      minWidth: this.isMobile ? "80px" : "auto",
      flex: this.isMobile ? "1" : "none"
    };
  }
  /**
   * Get action button hover styles
   */
  getActionButtonHoverStyles(color) {
    return {
      backgroundColor: "rgba(25, 60, 80, 0.8)",
      boxShadow: `0 0 15px ${color}`
    };
  }
  /**
   * Apply styles to an element
   */
  applyStyles(element, styles) {
    Object.assign(element.style, styles);
  }
}
class BlackjackGameView {
  constructor(isMobile = false) {
    this.isMobile = isMobile;
    this.styles = new BlackjackStyles(isMobile);
    this.cardSymbols = {
      spades: "♠",
      // Asteroid symbol
      hearts: "♥",
      // Planet symbol
      clubs: "♣",
      // Star symbol
      diamonds: "♦"
      // Nebula symbol
    };
  }
  /**
   * Create the main game UI container
   */
  createGameUI() {
    const gameUI = document.createElement("div");
    gameUI.id = "blackjack-game";
    this.styles.applyStyles(gameUI, this.styles.getGameUIStyles());
    this.styles.applyStyles(gameUI, this.styles.getMobileStyles());
    const scanlines = document.createElement("div");
    this.styles.applyStyles(scanlines, this.styles.getScanlineStyles());
    gameUI.appendChild(scanlines);
    const header = this.createHeader();
    gameUI.appendChild(header);
    const gameArea = this.createGameArea();
    gameUI.appendChild(gameArea);
    document.body.appendChild(gameUI);
    return gameUI;
  }
  /**
   * Create the header section
   */
  createHeader() {
    const header = document.createElement("div");
    this.styles.applyStyles(header, this.styles.getHeaderStyles());
    const title = document.createElement("h2");
    title.textContent = "STELLAR BLACKJACK";
    this.styles.applyStyles(title, this.styles.getTitleStyles());
    header.appendChild(title);
    const subtitle = document.createElement("div");
    subtitle.textContent = "WAGER RESOURCES • WIN BIG • BEAT THE DEALER";
    this.styles.applyStyles(subtitle, this.styles.getSubtitleStyles());
    header.appendChild(subtitle);
    const closeBtn = this.createCloseButton();
    header.appendChild(closeBtn);
    return header;
  }
  /**
   * Create the close button
   */
  createCloseButton() {
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "×";
    this.styles.applyStyles(closeBtn, this.styles.getCloseButtonStyles());
    return closeBtn;
  }
  /**
   * Create the main game area
   */
  createGameArea() {
    const gameArea = document.createElement("div");
    this.styles.applyStyles(gameArea, this.styles.getGameAreaStyles());
    const dealerArea = this.createDealerArea();
    gameArea.appendChild(dealerArea);
    const statusArea = this.createStatusArea();
    gameArea.appendChild(statusArea);
    const playerArea = this.createPlayerArea();
    gameArea.appendChild(playerArea);
    const controlsArea = this.createControlsArea();
    gameArea.appendChild(controlsArea);
    return gameArea;
  }
  /**
   * Create the dealer area
   */
  createDealerArea() {
    const dealerArea = document.createElement("div");
    this.styles.applyStyles(dealerArea, this.styles.getDealerAreaStyles());
    const dealerHeader = this.createAreaHeader("DEALER", "dealer-score", false);
    dealerArea.appendChild(dealerHeader);
    const dealerCards = document.createElement("div");
    dealerCards.id = "dealer-cards";
    this.styles.applyStyles(dealerCards, this.styles.getCardsContainerStyles());
    dealerArea.appendChild(dealerCards);
    const speechBubble = document.createElement("div");
    speechBubble.id = "dealer-speech";
    this.styles.applyStyles(speechBubble, this.styles.getSpeechBubbleStyles());
    dealerArea.appendChild(speechBubble);
    return dealerArea;
  }
  /**
   * Create the player area
   */
  createPlayerArea() {
    const playerArea = document.createElement("div");
    this.styles.applyStyles(playerArea, this.styles.getPlayerAreaStyles());
    const playerHeader = this.createAreaHeader("YOUR HAND", "player-score", true);
    playerArea.appendChild(playerHeader);
    const playerCards = document.createElement("div");
    playerCards.id = "player-cards";
    this.styles.applyStyles(playerCards, this.styles.getCardsContainerStyles());
    playerArea.appendChild(playerCards);
    return playerArea;
  }
  /**
   * Create area header (dealer/player)
   */
  createAreaHeader(title, scoreId, isPlayer) {
    const header = document.createElement("div");
    header.className = isPlayer ? "player-header" : "dealer-header";
    this.styles.applyStyles(header, this.styles.getAreaHeaderStyles());
    const titleElement = document.createElement("div");
    titleElement.textContent = title;
    this.styles.applyStyles(titleElement, isPlayer ? this.styles.getPlayerTitleStyles() : this.styles.getDealerTitleStyles());
    header.appendChild(titleElement);
    const score = document.createElement("div");
    score.id = scoreId;
    score.textContent = "0";
    this.styles.applyStyles(score, this.styles.getScoreStyles(isPlayer));
    header.appendChild(score);
    return header;
  }
  /**
   * Create the status area
   */
  createStatusArea() {
    const statusArea = document.createElement("div");
    this.styles.applyStyles(statusArea, this.styles.getStatusAreaStyles());
    const gameStatus = document.createElement("div");
    gameStatus.id = "game-status";
    gameStatus.textContent = "PLACE YOUR BET TO BEGIN";
    this.styles.applyStyles(gameStatus, this.styles.getGameStatusStyles());
    statusArea.appendChild(gameStatus);
    return statusArea;
  }
  /**
   * Create the controls area
   */
  createControlsArea() {
    const controlsArea = document.createElement("div");
    this.styles.applyStyles(controlsArea, this.styles.getControlsAreaStyles());
    const bettingControls = this.createBettingControls();
    controlsArea.appendChild(bettingControls);
    const gameActions = this.createGameActions();
    controlsArea.appendChild(gameActions);
    return controlsArea;
  }
  /**
   * Create betting controls
   */
  createBettingControls() {
    const bettingControls = document.createElement("div");
    bettingControls.id = "betting-controls";
    this.styles.applyStyles(bettingControls, this.styles.getBettingControlsStyles());
    const bettingTitle = document.createElement("div");
    bettingTitle.textContent = "PLACE YOUR BET";
    this.styles.applyStyles(bettingTitle, this.styles.getBettingTitleStyles());
    bettingControls.appendChild(bettingTitle);
    const resourceOptions = this.createResourceOptions();
    bettingControls.appendChild(resourceOptions);
    const betAmountControls = this.createBetAmountControls();
    bettingControls.appendChild(betAmountControls);
    return bettingControls;
  }
  /**
   * Create resource selection buttons
   */
  createResourceOptions() {
    const resourceOptions = document.createElement("div");
    this.styles.applyStyles(resourceOptions, this.styles.getResourceOptionsStyles());
    const resources = [
      { name: "iron", color: "rgba(150, 150, 150, 1)" },
      { name: "gold", color: "rgba(255, 215, 0, 1)" },
      { name: "platinum", color: "rgba(229, 228, 226, 1)" }
    ];
    resources.forEach((resource) => {
      const btn = this.createResourceButton(resource.name, resource.color);
      resourceOptions.appendChild(btn);
    });
    return resourceOptions;
  }
  /**
   * Create a resource button
   */
  createResourceButton(resource, color) {
    const btn = document.createElement("button");
    btn.className = "resource-btn";
    btn.dataset.resource = resource;
    this.styles.applyStyles(btn, this.styles.getResourceButtonStyles(color));
    const resourceName = document.createElement("span");
    resourceName.textContent = resource.toUpperCase();
    resourceName.style.fontWeight = "bold";
    resourceName.style.fontSize = "12px";
    btn.appendChild(resourceName);
    const resourceAmount = document.createElement("span");
    resourceAmount.className = `${resource}-amount`;
    resourceAmount.textContent = "0 UNITS";
    resourceAmount.style.fontSize = "10px";
    resourceAmount.style.marginTop = "3px";
    resourceAmount.style.opacity = "0.7";
    btn.appendChild(resourceAmount);
    return btn;
  }
  /**
   * Create bet amount controls
   */
  createBetAmountControls() {
    const betAmountControls = document.createElement("div");
    this.styles.applyStyles(betAmountControls, this.styles.getBetAmountControlsStyles());
    const betAmountDisplay = document.createElement("div");
    betAmountDisplay.id = "bet-amount";
    betAmountDisplay.textContent = "0";
    this.styles.applyStyles(betAmountDisplay, this.styles.getBetAmountDisplayStyles());
    betAmountControls.appendChild(betAmountDisplay);
    const decreaseBtn = document.createElement("button");
    decreaseBtn.textContent = "-";
    decreaseBtn.id = "decrease-bet-btn";
    this.styles.applyStyles(decreaseBtn, this.styles.getControlButtonStyles());
    betAmountControls.appendChild(decreaseBtn);
    const increaseBtn = document.createElement("button");
    increaseBtn.textContent = "+";
    increaseBtn.id = "increase-bet-btn";
    this.styles.applyStyles(increaseBtn, this.styles.getControlButtonStyles());
    betAmountControls.appendChild(increaseBtn);
    return betAmountControls;
  }
  /**
   * Create game action buttons
   */
  createGameActions() {
    const gameActions = document.createElement("div");
    this.styles.applyStyles(gameActions, this.styles.getGameActionsStyles());
    const actionButtons = [
      { id: "deal-btn", text: "DEAL", color: "#30cfd0" },
      { id: "hit-btn", text: "HIT", color: "#ff9e3d" },
      { id: "stand-btn", text: "STAND", color: "#e55c8a" },
      { id: "double-btn", text: "DOUBLE", color: "#a281ff" }
    ];
    actionButtons.forEach((btn) => {
      const button = this.createActionButton(btn.id, btn.text, btn.color);
      gameActions.appendChild(button);
    });
    return gameActions;
  }
  /**
   * Create an action button
   */
  createActionButton(id, text, color) {
    const button = document.createElement("button");
    button.id = id;
    button.textContent = text;
    this.styles.applyStyles(button, this.styles.getActionButtonStyles(color));
    button.disabled = true;
    button.style.opacity = "0.5";
    return button;
  }
  /**
   * Create a visual card element
   */
  createCardElement(card, faceDown = false) {
    const cardEl = document.createElement("div");
    cardEl.className = "card";
    this.styles.applyStyles(cardEl, this.styles.getCardStyles(faceDown));
    if (!faceDown) {
      this.createFaceUpCard(cardEl, card);
    } else {
      this.createFaceDownCard(cardEl);
    }
    return cardEl;
  }
  /**
   * Create face-up card content
   */
  createFaceUpCard(cardEl, card) {
    const color = this.styles.getCardColor(card.suit);
    const topValue = document.createElement("div");
    topValue.textContent = card.value;
    topValue.style.color = color;
    this.styles.applyStyles(topValue, this.styles.getCardValueStyles("top"));
    cardEl.appendChild(topValue);
    const topSuit = document.createElement("div");
    topSuit.textContent = this.cardSymbols[card.suit];
    topSuit.style.color = color;
    this.styles.applyStyles(topSuit, this.styles.getCardSuitStyles("top"));
    cardEl.appendChild(topSuit);
    const centerSymbol = document.createElement("div");
    centerSymbol.textContent = this.cardSymbols[card.suit];
    centerSymbol.style.color = color;
    this.styles.applyStyles(centerSymbol, this.styles.getCenterSymbolStyles());
    cardEl.appendChild(centerSymbol);
    const bottomValue = document.createElement("div");
    bottomValue.textContent = card.value;
    bottomValue.style.color = color;
    this.styles.applyStyles(bottomValue, this.styles.getCardValueStyles("bottom"));
    cardEl.appendChild(bottomValue);
    const bottomSuit = document.createElement("div");
    bottomSuit.textContent = this.cardSymbols[card.suit];
    bottomSuit.style.color = color;
    this.styles.applyStyles(bottomSuit, this.styles.getCardSuitStyles("bottom"));
    cardEl.appendChild(bottomSuit);
    const pattern = document.createElement("div");
    pattern.style.position = "absolute";
    pattern.style.inset = "0";
    pattern.style.opacity = "0.05";
    pattern.style.backgroundImage = "radial-gradient(circle, #fff 1px, transparent 1px)";
    pattern.style.backgroundSize = "10px 10px";
    pattern.style.pointerEvents = "none";
    cardEl.appendChild(pattern);
    const holoEffect = document.createElement("div");
    holoEffect.style.position = "absolute";
    holoEffect.style.inset = "0";
    holoEffect.style.background = "linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.1) 100%)";
    holoEffect.style.pointerEvents = "none";
    cardEl.appendChild(holoEffect);
  }
  /**
   * Create face-down card content
   */
  createFaceDownCard(cardEl) {
    const backDesign = document.createElement("div");
    backDesign.style.width = "80%";
    backDesign.style.height = "80%";
    backDesign.style.border = "2px solid rgba(51, 170, 255, 0.4)";
    backDesign.style.borderRadius = "5px";
    backDesign.style.backgroundImage = "radial-gradient(circle, rgba(51, 170, 255, 0.2) 10%, transparent 10%)";
    backDesign.style.backgroundSize = "10px 10px";
    cardEl.appendChild(backDesign);
    const logo = document.createElement("div");
    logo.style.position = "absolute";
    logo.style.fontWeight = "bold";
    logo.style.fontSize = this.isMobile ? "12px" : "14px";
    logo.style.color = "rgba(51, 170, 255, 0.7)";
    logo.textContent = "BJ";
    cardEl.appendChild(logo);
  }
  /**
   * Show the game UI
   */
  show(gameUI) {
    if (gameUI) {
      gameUI.style.display = "block";
    }
  }
  /**
   * Hide the game UI
   */
  hide(gameUI) {
    if (gameUI) {
      gameUI.style.display = "none";
    }
  }
  /**
   * Update resource display
   */
  updateResourceDisplay(spaceship) {
    if (spaceship && spaceship.cargo) {
      if (spaceship.cargo.iron === void 0) spaceship.cargo.iron = 0;
      if (spaceship.cargo.gold === void 0) spaceship.cargo.gold = 0;
      if (spaceship.cargo.platinum === void 0) spaceship.cargo.platinum = 0;
      const ironElement = document.querySelector(".iron-amount");
      if (ironElement) {
        ironElement.textContent = `${spaceship.cargo.iron} UNITS`;
      }
      const goldElement = document.querySelector(".gold-amount");
      if (goldElement) {
        goldElement.textContent = `${spaceship.cargo.gold} UNITS`;
      }
      const platinumElement = document.querySelector(".platinum-amount");
      if (platinumElement) {
        platinumElement.textContent = `${spaceship.cargo.platinum} UNITS`;
      }
    }
  }
  /**
   * Update score display
   */
  updateScore(score, isPlayer = true) {
    const scoreElement = document.getElementById(isPlayer ? "player-score" : "dealer-score");
    if (scoreElement) {
      scoreElement.textContent = score;
    }
  }
  /**
   * Update game status
   */
  updateGameStatus(message) {
    const statusElement = document.getElementById("game-status");
    if (statusElement) {
      statusElement.textContent = message;
    }
  }
  /**
   * Update bet amount display
   */
  updateBetAmount(amount) {
    const betElement = document.getElementById("bet-amount");
    if (betElement) {
      betElement.textContent = amount;
    }
  }
  /**
   * Clear cards from an area
   */
  clearCards(isPlayer = true) {
    const cardsContainer = document.getElementById(isPlayer ? "player-cards" : "dealer-cards");
    if (cardsContainer) {
      cardsContainer.innerHTML = "";
    }
  }
  /**
   * Add card to an area
   */
  addCard(card, faceDown = false, isPlayer = true) {
    const cardsContainer = document.getElementById(isPlayer ? "player-cards" : "dealer-cards");
    if (cardsContainer) {
      const cardEl = this.createCardElement(card, faceDown);
      if (faceDown) {
        cardEl.id = "face-down-card";
      }
      cardsContainer.appendChild(cardEl);
      setTimeout(() => {
        cardEl.style.transform = "translateY(-5px)";
      }, 50);
      return cardEl;
    }
    return null;
  }
  /**
   * Show dealer speech
   */
  showDealerSpeech(message, duration = 4e3) {
    const speechBubble = document.getElementById("dealer-speech");
    if (speechBubble) {
      speechBubble.textContent = message;
      speechBubble.style.display = "block";
      setTimeout(() => {
        speechBubble.style.display = "none";
      }, duration);
    }
  }
  /**
   * Reveal dealer's face-down card
   */
  revealDealerCard(card) {
    const faceDownEl = document.getElementById("face-down-card");
    if (faceDownEl) {
      faceDownEl.remove();
      const cardEl = this.createCardElement(card);
      const dealerCards = document.getElementById("dealer-cards");
      if (dealerCards) {
        dealerCards.appendChild(cardEl);
        setTimeout(() => {
          cardEl.style.transform = "translateY(-5px)";
        }, 50);
        return cardEl;
      }
    }
    return null;
  }
}
class BlackjackCardDeck {
  constructor() {
    this.deck = [];
    this.createDeck();
  }
  /**
   * Create a fresh deck of cards
   */
  createDeck() {
    const suits = ["hearts", "diamonds", "clubs", "spades"];
    const values = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
    this.deck = [];
    for (let suit of suits) {
      for (let value of values) {
        this.deck.push({
          suit,
          value
        });
      }
    }
    this.shuffle();
  }
  /**
   * Shuffle the deck using Fisher-Yates algorithm
   */
  shuffle() {
    for (let i = this.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
    }
  }
  /**
   * Draw a card from the deck
   * @returns {Object} A card object
   */
  drawCard() {
    if (this.deck.length === 0) {
      this.createDeck();
    }
    return this.deck.pop();
  }
  /**
   * Get the value of a card
   * @param {Object} card - The card object
   * @returns {number} The value of the card in Blackjack
   */
  getCardValue(card) {
    if (card.value === "A") {
      return 11;
    } else if (["J", "Q", "K"].includes(card.value)) {
      return 10;
    } else {
      return parseInt(card.value);
    }
  }
  /**
   * Check if deck is empty
   * @returns {boolean} True if deck is empty
   */
  isEmpty() {
    return this.deck.length === 0;
  }
  /**
   * Get remaining cards count
   * @returns {number} Number of cards left in deck
   */
  getRemainingCards() {
    return this.deck.length;
  }
  /**
   * Reset deck (create new and shuffle)
   */
  reset() {
    this.createDeck();
  }
}
class BlackjackGameLogic {
  constructor() {
    this.gameActive = false;
    this.playerHand = [];
    this.dealerHand = [];
    this.gameResult = null;
    this.dealerPhrases = {
      win: [
        "Yarr! The cosmos favors ye today!",
        "By the stars! Ye've bested me!",
        "Void take me! Ye've got luck in yer tanks!",
        "Stellar victory, spacer!",
        "Blast me thrusters! Ye win this round!"
      ],
      lose: [
        "The black hole claims another victim!",
        "Better luck in the next galaxy, rookie!",
        "Space is cold, and so is defeat!",
        "Yarr! The dealer always wins, spacer!",
        "Back to the asteroid mines with ye!"
      ],
      blackjack: [
        "SUPERNOVA! A cosmic blackjack!",
        "By the void! A perfect 21!",
        "The stars aligned for ye today!",
        "Quantum perfection! A blackjack!"
      ],
      push: [
        "A cosmic stalemate, eh?",
        "The universe remains in balance.",
        "Neither winner nor loser in the void.",
        "We split the cosmic dust this time."
      ]
    };
  }
  /**
   * Calculate the score of a hand, adjusting for aces
   * @param {Array} hand - Array of card objects
   * @returns {number} The total score of the hand
   */
  calculateScore(hand) {
    let score = 0;
    let aces = 0;
    for (let card of hand) {
      if (card.value === "A") {
        aces++;
        score += 11;
      } else if (["J", "Q", "K"].includes(card.value)) {
        score += 10;
      } else {
        score += parseInt(card.value);
      }
    }
    while (score > 21 && aces > 0) {
      score -= 10;
      aces--;
    }
    return score;
  }
  /**
   * Calculate the dealer's visible score (excluding face-down card)
   * @returns {number} The visible score
   */
  calculateVisibleDealerScore() {
    if (this.dealerHand.length <= 1) {
      return this.dealerHand.length ? this.getCardValue(this.dealerHand[0]) : 0;
    }
    return this.calculateScore(this.dealerHand.slice(0, -1));
  }
  /**
   * Get the value of a card
   * @param {Object} card - The card object
   * @returns {number} The value of the card in Blackjack
   */
  getCardValue(card) {
    if (card.value === "A") {
      return 11;
    } else if (["J", "Q", "K"].includes(card.value)) {
      return 10;
    } else {
      return parseInt(card.value);
    }
  }
  /**
   * Check if a hand is a blackjack (21 with 2 cards)
   * @param {Array} hand - Array of card objects
   * @returns {boolean} True if hand is blackjack
   */
  isBlackjack(hand) {
    return hand.length === 2 && this.calculateScore(hand) === 21;
  }
  /**
   * Check if a hand is bust (over 21)
   * @param {Array} hand - Array of card objects
   * @returns {boolean} True if hand is bust
   */
  isBust(hand) {
    return this.calculateScore(hand) > 21;
  }
  /**
   * Check for natural blackjack
   * @returns {string|null} Game result or null if game continues
   */
  checkForNaturalBlackjack() {
    const playerScore = this.calculateScore(this.playerHand);
    const dealerScore = this.calculateScore(this.dealerHand);
    if (playerScore === 21 || dealerScore === 21) {
      if (playerScore === 21 && dealerScore === 21) {
        return "push";
      } else if (playerScore === 21) {
        return "blackjack";
      } else {
        return "lose";
      }
    }
    return null;
  }
  /**
   * Determine if dealer should hit (dealer hits on soft 17)
   * @returns {boolean} True if dealer should hit
   */
  shouldDealerHit() {
    const dealerScore = this.calculateScore(this.dealerHand);
    return dealerScore < 17;
  }
  /**
   * Determine the outcome of the game
   * @returns {string} Game result
   */
  determineOutcome() {
    const playerScore = this.calculateScore(this.playerHand);
    const dealerScore = this.calculateScore(this.dealerHand);
    if (dealerScore > 21) {
      return "win";
    } else if (playerScore > dealerScore) {
      return "win";
    } else if (dealerScore > playerScore) {
      return "lose";
    } else {
      return "push";
    }
  }
  /**
   * Check if player can double down
   * @param {number} currentBetAmount - Current bet amount
   * @param {number} maxBetAmount - Maximum possible bet amount
   * @returns {boolean} True if can double down
   */
  canDoubleDown(currentBetAmount, maxBetAmount) {
    return this.playerHand.length === 2 && currentBetAmount * 2 <= maxBetAmount;
  }
  /**
   * Get a random dealer phrase
   * @param {string} type - Type of phrase (win, lose, blackjack, push)
   * @returns {string} Random phrase
   */
  getDealerPhrase(type) {
    const phrases = this.dealerPhrases[type];
    if (phrases && phrases.length > 0) {
      return phrases[Math.floor(Math.random() * phrases.length)];
    }
    return "";
  }
  /**
   * Reset game state
   */
  reset() {
    this.gameActive = false;
    this.playerHand = [];
    this.dealerHand = [];
    this.gameResult = null;
  }
  /**
   * Start a new game
   */
  startGame() {
    this.gameActive = true;
    this.playerHand = [];
    this.dealerHand = [];
    this.gameResult = null;
  }
  /**
   * Add card to player hand
   * @param {Object} card - Card object
   */
  addCardToPlayer(card) {
    this.playerHand.push(card);
  }
  /**
   * Add card to dealer hand
   * @param {Object} card - Card object
   */
  addCardToDealer(card) {
    this.dealerHand.push(card);
  }
  /**
   * End the game
   * @param {string} result - Game result
   */
  endGame(result) {
    this.gameActive = false;
    this.gameResult = result;
  }
  /**
   * Get player score
   * @returns {number} Player's current score
   */
  getPlayerScore() {
    return this.calculateScore(this.playerHand);
  }
  /**
   * Get dealer score
   * @returns {number} Dealer's current score
   */
  getDealerScore() {
    return this.calculateScore(this.dealerHand);
  }
  /**
   * Get player hand
   * @returns {Array} Player's hand
   */
  getPlayerHand() {
    return [...this.playerHand];
  }
  /**
   * Get dealer hand
   * @returns {Array} Dealer's hand
   */
  getDealerHand() {
    return [...this.dealerHand];
  }
  /**
   * Get last card in dealer hand (usually the face-down card)
   * @returns {Object|null} Last dealer card
   */
  getLastDealerCard() {
    return this.dealerHand.length > 0 ? this.dealerHand[this.dealerHand.length - 1] : null;
  }
  /**
   * Check if game is active
   * @returns {boolean} True if game is active
   */
  isGameActive() {
    return this.gameActive;
  }
  /**
   * Get game result
   * @returns {string|null} Game result
   */
  getGameResult() {
    return this.gameResult;
  }
}
class BlackjackAnimations {
  constructor(audio = null) {
    this.audio = audio;
  }
  /**
   * Animate card being dealt
   * @param {HTMLElement} cardElement - The card element to animate
   * @param {number} delay - Animation delay in ms
   */
  animateCardDeal(cardElement, delay = 50) {
    if (!cardElement) return;
    cardElement.style.transform = "translateY(0px) scale(0.8)";
    cardElement.style.opacity = "0";
    setTimeout(() => {
      cardElement.style.transition = "transform 0.3s ease, opacity 0.3s ease";
      cardElement.style.transform = "translateY(-5px) scale(1)";
      cardElement.style.opacity = "1";
    }, delay);
  }
  /**
   * Animate card flip (for revealing dealer's face-down card)
   * @param {HTMLElement} cardElement - The card element to animate
   * @param {Function} callback - Callback to execute at flip midpoint
   */
  animateCardFlip(cardElement, callback = null) {
    if (!cardElement) return;
    cardElement.style.transition = "transform 0.2s ease";
    cardElement.style.transform = "rotateY(90deg) translateY(-5px)";
    setTimeout(() => {
      if (callback) callback();
      cardElement.style.transform = "rotateY(0deg) translateY(-5px)";
    }, 200);
  }
  /**
   * Animate button press
   * @param {HTMLElement} buttonElement - The button element to animate
   */
  animateButtonPress(buttonElement) {
    if (!buttonElement) return;
    buttonElement.style.transition = "transform 0.1s ease";
    buttonElement.style.transform = "scale(0.95)";
    setTimeout(() => {
      buttonElement.style.transform = "scale(1)";
    }, 100);
  }
  /**
   * Animate resource button selection
   * @param {HTMLElement} buttonElement - The button element to animate
   */
  animateResourceSelection(buttonElement) {
    if (!buttonElement) return;
    buttonElement.style.transition = "transform 0.2s ease, border-width 0.2s ease";
    buttonElement.style.transform = "scale(1.05)";
    buttonElement.style.borderWidth = "2px";
  }
  /**
   * Remove resource button selection animation
   * @param {HTMLElement} buttonElement - The button element to reset
   */
  removeResourceSelection(buttonElement) {
    if (!buttonElement) return;
    buttonElement.style.transform = "scale(1)";
    buttonElement.style.borderWidth = "1px";
  }
  /**
   * Animate bet amount change
   * @param {HTMLElement} betElement - The bet display element
   * @param {string} newAmount - The new amount to display
   */
  animateBetChange(betElement, newAmount) {
    if (!betElement) return;
    betElement.style.transition = "transform 0.15s ease";
    betElement.style.transform = "scale(1.1)";
    setTimeout(() => {
      betElement.textContent = newAmount;
      betElement.style.transform = "scale(1)";
    }, 75);
  }
  /**
   * Animate score update
   * @param {HTMLElement} scoreElement - The score display element
   * @param {string} newScore - The new score to display
   * @param {boolean} isBust - Whether this score is a bust
   */
  animateScoreUpdate(scoreElement, newScore, isBust = false) {
    if (!scoreElement) return;
    const originalColor = scoreElement.style.color;
    const flashColor = isBust ? "#ff6b6b" : "#30cfd0";
    scoreElement.style.transition = "color 0.2s ease, transform 0.2s ease";
    scoreElement.style.color = flashColor;
    scoreElement.style.transform = "scale(1.1)";
    scoreElement.textContent = newScore;
    setTimeout(() => {
      scoreElement.style.color = originalColor;
      scoreElement.style.transform = "scale(1)";
    }, 200);
  }
  /**
   * Animate game status message
   * @param {HTMLElement} statusElement - The status display element
   * @param {string} message - The new status message
   * @param {string} type - Type of message (win, lose, push, etc.)
   */
  animateStatusUpdate(statusElement, message, type = "normal") {
    if (!statusElement) return;
    let bgColor = "rgba(51, 170, 255, 0.2)";
    let borderColor = "rgba(51, 170, 255, 0.4)";
    switch (type) {
      case "win":
      case "blackjack":
        bgColor = "rgba(48, 207, 208, 0.3)";
        borderColor = "rgba(48, 207, 208, 0.6)";
        break;
      case "lose":
      case "bust":
        bgColor = "rgba(255, 107, 107, 0.3)";
        borderColor = "rgba(255, 107, 107, 0.6)";
        break;
      case "push":
        bgColor = "rgba(255, 193, 7, 0.3)";
        borderColor = "rgba(255, 193, 7, 0.6)";
        break;
    }
    statusElement.style.transition = "background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease";
    statusElement.style.backgroundColor = bgColor;
    statusElement.style.borderColor = borderColor;
    statusElement.style.transform = "scale(1.05)";
    statusElement.textContent = message;
    setTimeout(() => {
      statusElement.style.transform = "scale(1)";
    }, 300);
  }
  /**
   * Animate speech bubble appearance
   * @param {HTMLElement} speechElement - The speech bubble element
   * @param {string} message - The message to display
   */
  animateSpeechBubble(speechElement, message) {
    if (!speechElement) return;
    speechElement.textContent = message;
    speechElement.style.opacity = "0";
    speechElement.style.transform = "translateY(10px) scale(0.9)";
    speechElement.style.display = "block";
    setTimeout(() => {
      speechElement.style.transition = "opacity 0.3s ease, transform 0.3s ease";
      speechElement.style.opacity = "1";
      speechElement.style.transform = "translateY(0px) scale(1)";
    }, 50);
  }
  /**
   * Animate speech bubble disappearance
   * @param {HTMLElement} speechElement - The speech bubble element
   */
  hideSpeechBubble(speechElement) {
    if (!speechElement) return;
    speechElement.style.transition = "opacity 0.3s ease, transform 0.3s ease";
    speechElement.style.opacity = "0";
    speechElement.style.transform = "translateY(-10px) scale(0.9)";
    setTimeout(() => {
      speechElement.style.display = "none";
    }, 300);
  }
  /**
   * Animate win celebration
   * @param {HTMLElement} gameUI - The main game UI element
   */
  animateWinCelebration(gameUI) {
    if (!gameUI) return;
    gameUI.style.transition = "box-shadow 0.5s ease";
    gameUI.style.boxShadow = "0 0 50px rgba(48, 207, 208, 0.8)";
    setTimeout(() => {
      gameUI.style.boxShadow = "0 0 30px rgba(51, 170, 255, 0.5)";
    }, 2e3);
  }
  /**
   * Animate lose effect
   * @param {HTMLElement} gameUI - The main game UI element
   */
  animateLoseEffect(gameUI) {
    if (!gameUI) return;
    gameUI.style.transition = "box-shadow 0.5s ease";
    gameUI.style.boxShadow = "0 0 50px rgba(255, 107, 107, 0.6)";
    setTimeout(() => {
      gameUI.style.boxShadow = "0 0 30px rgba(51, 170, 255, 0.5)";
    }, 2e3);
  }
  /**
   * Animate blackjack celebration
   * @param {HTMLElement} gameUI - The main game UI element
   */
  animateBlackjackCelebration(gameUI) {
    if (!gameUI) return;
    gameUI.style.transition = "box-shadow 0.5s ease, transform 0.5s ease";
    gameUI.style.boxShadow = "0 0 80px rgba(48, 207, 208, 1)";
    gameUI.style.transform = "translate(-50%, -50%) scale(1.02)";
    setTimeout(() => {
      gameUI.style.boxShadow = "0 0 30px rgba(51, 170, 255, 0.5)";
      gameUI.style.transform = "translate(-50%, -50%) scale(1)";
    }, 3e3);
  }
  /**
   * Animate card hover effect
   * @param {HTMLElement} cardElement - The card element
   * @param {boolean} isHovering - Whether mouse is hovering
   */
  animateCardHover(cardElement, isHovering) {
    if (!cardElement) return;
    if (isHovering) {
      cardElement.style.transition = "transform 0.2s ease, box-shadow 0.2s ease";
      cardElement.style.transform = "translateY(-10px) scale(1.05)";
      cardElement.style.boxShadow = "0 0 20px rgba(51, 170, 255, 0.8)";
    } else {
      cardElement.style.transform = "translateY(-5px) scale(1)";
      cardElement.style.boxShadow = "0 0 10px rgba(51, 170, 255, 0.5)";
    }
  }
  /**
   * Play card game sound with audio context
   * @param {string} type - The type of sound to play
   */
  playCardSound(type) {
    if (!this.audio) return;
    switch (type) {
      case "deal":
        this.audio.playSound("boink");
        break;
      case "hit":
        this.audio.playSound("boink");
        break;
      case "stand":
        this.audio.playSound("boink");
        break;
      case "double":
        this.audio.playSound("boink");
        setTimeout(() => this.audio.playSound("boink"), 150);
        break;
      case "flip":
        this.audio.playSound("boink");
        break;
      case "win":
        this.audio.playSound("phaserUp");
        break;
      case "blackjack":
        this.audio.playSound("phaserUp");
        setTimeout(() => this.audio.playSound("phaserUp"), 300);
        break;
      case "lose":
        this.audio.playSound("phaserDown");
        break;
      case "bust":
        this.audio.playSound("phaserDown");
        break;
      case "push":
        this.audio.playSound("boink");
        break;
    }
  }
  /**
   * Chain multiple animations with delays
   * @param {Array} animations - Array of animation functions
   * @param {number} delay - Delay between animations
   */
  chainAnimations(animations, delay = 300) {
    animations.forEach((animation, index) => {
      setTimeout(() => {
        if (typeof animation === "function") {
          animation();
        }
      }, index * delay);
    });
  }
  /**
   * Reset all animations on an element
   * @param {HTMLElement} element - The element to reset
   */
  resetAnimations(element) {
    if (!element) return;
    element.style.transition = "";
    element.style.transform = "";
    element.style.opacity = "";
    element.style.boxShadow = "";
  }
}
class BlackjackBetting {
  constructor(spaceship = null) {
    this.spaceship = spaceship;
    this.currentBet = {
      resource: null,
      amount: 0
    };
  }
  /**
   * Set the spaceship reference for resource management
   * @param {Object} spaceship - Spaceship object with cargo
   */
  setSpaceship(spaceship) {
    this.spaceship = spaceship;
  }
  /**
   * Select a resource for betting
   * @param {string} resource - The resource type (iron, gold, platinum)
   */
  selectBetResource(resource) {
    this.currentBet.resource = resource;
    this.currentBet.amount = 1;
  }
  /**
   * Increase the bet amount
   * @returns {boolean} True if bet was increased, false if at maximum
   */
  increaseBet() {
    const maxAmount = this.getMaxBet();
    if (this.currentBet.amount < maxAmount) {
      this.currentBet.amount++;
      return true;
    }
    return false;
  }
  /**
   * Decrease the bet amount
   * @returns {boolean} True if bet was decreased, false if at minimum
   */
  decreaseBet() {
    if (this.currentBet.amount > 1) {
      this.currentBet.amount--;
      return true;
    }
    return false;
  }
  /**
   * Get the maximum possible bet amount for the selected resource
   * @returns {number} The maximum bet amount
   */
  getMaxBet() {
    if (!this.currentBet.resource || !this.spaceship || !this.spaceship.cargo) {
      return 0;
    }
    return this.spaceship.cargo[this.currentBet.resource] || 0;
  }
  /**
   * Get current bet information
   * @returns {Object} Current bet object
   */
  getCurrentBet() {
    return { ...this.currentBet };
  }
  /**
   * Check if a valid bet is selected
   * @returns {boolean} True if valid bet exists
   */
  hasValidBet() {
    return this.currentBet.resource && this.currentBet.amount > 0;
  }
  /**
   * Check if player has enough resources for the current bet
   * @returns {boolean} True if player can afford the bet
   */
  canAffordBet() {
    if (!this.hasValidBet() || !this.spaceship || !this.spaceship.cargo) {
      return false;
    }
    const available = this.spaceship.cargo[this.currentBet.resource] || 0;
    return available >= this.currentBet.amount;
  }
  /**
   * Check if player can afford to double down
   * @returns {boolean} True if player can double the current bet
   */
  canAffordDoubleDown() {
    if (!this.hasValidBet() || !this.spaceship || !this.spaceship.cargo) {
      return false;
    }
    const available = this.spaceship.cargo[this.currentBet.resource] || 0;
    return available >= this.currentBet.amount;
  }
  /**
   * Place the bet (deduct resources)
   * @returns {boolean} True if bet was successfully placed
   */
  placeBet() {
    if (!this.canAffordBet()) {
      return false;
    }
    this.spaceship.cargo[this.currentBet.resource] -= this.currentBet.amount;
    if (window.game && window.game.controls && window.game.controls.resources) {
      window.game.controls.resources[this.currentBet.resource] = this.spaceship.cargo[this.currentBet.resource];
    }
    return true;
  }
  /**
   * Double down (double the current bet)
   * @returns {boolean} True if double down was successful
   */
  doubleDown() {
    if (!this.canAffordDoubleDown()) {
      return false;
    }
    this.spaceship.cargo[this.currentBet.resource] -= this.currentBet.amount;
    this.currentBet.amount *= 2;
    if (window.game && window.game.controls && window.game.controls.resources) {
      window.game.controls.resources[this.currentBet.resource] = this.spaceship.cargo[this.currentBet.resource];
    }
    return true;
  }
  /**
   * Calculate payout for a win (2x bet)
   * @returns {number} Payout amount
   */
  calculateWinPayout() {
    return this.currentBet.amount * 2;
  }
  /**
   * Calculate payout for a blackjack (3x bet)
   * @returns {number} Payout amount
   */
  calculateBlackjackPayout() {
    return this.currentBet.amount * 3;
  }
  /**
   * Calculate payout for a push (return bet)
   * @returns {number} Payout amount
   */
  calculatePushPayout() {
    return this.currentBet.amount;
  }
  /**
   * Pay out winnings to player
   * @param {number} amount - Amount to pay out
   */
  payOut(amount) {
    if (!this.spaceship || !this.spaceship.cargo || !this.currentBet.resource) {
      return;
    }
    this.spaceship.cargo[this.currentBet.resource] += amount;
    if (window.game && window.game.controls && window.game.controls.resources) {
      window.game.controls.resources[this.currentBet.resource] = this.spaceship.cargo[this.currentBet.resource];
    }
  }
  /**
   * Handle win payout
   */
  handleWin() {
    const payout = this.calculateWinPayout();
    this.payOut(payout);
    return payout;
  }
  /**
   * Handle blackjack payout
   */
  handleBlackjack() {
    const payout = this.calculateBlackjackPayout();
    this.payOut(payout);
    return payout;
  }
  /**
   * Handle push (return bet)
   */
  handlePush() {
    const payout = this.calculatePushPayout();
    this.payOut(payout);
    return payout;
  }
  /**
   * Reset betting state
   */
  reset() {
    this.currentBet = {
      resource: null,
      amount: 0
    };
  }
  /**
   * Get resource amounts for display
   * @returns {Object} Resource amounts
   */
  getResourceAmounts() {
    if (!this.spaceship || !this.spaceship.cargo) {
      return { iron: 0, gold: 0, platinum: 0 };
    }
    return {
      iron: this.spaceship.cargo.iron || 0,
      gold: this.spaceship.cargo.gold || 0,
      platinum: this.spaceship.cargo.platinum || 0
    };
  }
  /**
   * Initialize cargo if needed
   */
  initializeCargo() {
    if (!this.spaceship) {
      console.error("No spaceship object available");
      return false;
    }
    if (!this.spaceship.cargo) {
      console.warn("Creating cargo object for spaceship");
      this.spaceship.cargo = { iron: 0, gold: 0, platinum: 0 };
    }
    if (this.spaceship.cargo.iron === void 0) this.spaceship.cargo.iron = 0;
    if (this.spaceship.cargo.gold === void 0) this.spaceship.cargo.gold = 0;
    if (this.spaceship.cargo.platinum === void 0) this.spaceship.cargo.platinum = 0;
    return true;
  }
  /**
   * Sync with game resources
   */
  syncWithGameResources() {
    if (window.game && window.game.controls && window.game.controls.resources) {
      const gameResources = window.game.controls.resources;
      if (!this.spaceship.cargo) {
        this.spaceship.cargo = {};
      }
      this.spaceship.cargo.iron = gameResources.iron || 0;
      this.spaceship.cargo.gold = gameResources.gold || 0;
      this.spaceship.cargo.platinum = gameResources.platinum || 0;
    }
  }
  /**
   * Get bet amount display string
   * @returns {string} Formatted bet amount
   */
  getBetDisplayString() {
    if (!this.hasValidBet()) {
      return "0";
    }
    return `${this.currentBet.amount} ${this.currentBet.resource.toUpperCase()}`;
  }
  /**
   * Get resource color for UI
   * @param {string} resource - Resource type
   * @returns {string} CSS color string
   */
  getResourceColor(resource) {
    switch (resource) {
      case "iron":
        return "rgba(150, 150, 150, 1)";
      case "gold":
        return "rgba(255, 215, 0, 1)";
      case "platinum":
        return "rgba(229, 228, 226, 1)";
      default:
        return "rgba(255, 255, 255, 1)";
    }
  }
}
class BlackjackEventHandlers {
  constructor(game, isMobile = false) {
    this.game = game;
    this.isMobile = isMobile;
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  /**
   * Set up all event handlers for the game
   */
  setupEventHandlers() {
    this.setupCloseButtonHandler();
    this.setupResourceButtonHandlers();
    this.setupBetControlHandlers();
    this.setupActionButtonHandlers();
    this.setupMobileEventHandlers();
  }
  /**
   * Setup close button event handler
   */
  setupCloseButtonHandler() {
    const closeBtn = document.querySelector("#blackjack-game button");
    if (closeBtn) {
      const handler = () => this.game.hide();
      this.addEventHandler(closeBtn, "click", handler);
    }
  }
  /**
   * Setup resource button event handlers
   */
  setupResourceButtonHandlers() {
    const resourceButtons = document.querySelectorAll(".resource-btn");
    resourceButtons.forEach((btn) => {
      const resource = btn.dataset.resource;
      const addHoverEffect = () => {
        if (this.game.gameLogic.isGameActive()) return;
        const color = this.game.betting.getResourceColor(resource);
        btn.style.backgroundColor = "rgba(25, 60, 80, 0.8)";
        btn.style.boxShadow = `0 0 15px ${color}`;
      };
      const removeHoverEffect = () => {
        if (this.game.gameLogic.isGameActive()) return;
        const color = this.game.betting.getResourceColor(resource);
        btn.style.backgroundColor = "rgba(15, 40, 55, 0.8)";
        btn.style.boxShadow = `0 0 10px rgba(${color.split("(")[1].split(")")[0]}, 0.3)`;
      };
      const clickHandler = () => {
        if (!this.game.gameLogic.isGameActive()) {
          this.game.selectBetResource(resource);
          this.game.animations.playCardSound("boink");
          document.querySelectorAll(".resource-btn").forEach((button) => {
            this.game.animations.removeResourceSelection(button);
          });
          this.game.animations.animateResourceSelection(btn);
        }
      };
      this.addEventHandler(btn, "mouseover", addHoverEffect);
      this.addEventHandler(btn, "mouseout", removeHoverEffect);
      this.addEventHandler(btn, "click", clickHandler);
      if (this.isMobile) {
        this.addEventHandler(btn, "touchstart", addHoverEffect, { passive: true });
        this.addEventHandler(btn, "touchend", (e) => {
          removeHoverEffect();
          e.preventDefault();
          clickHandler();
        });
      }
    });
  }
  /**
   * Setup bet control event handlers (+ and - buttons)
   */
  setupBetControlHandlers() {
    const decreaseBtn = document.getElementById("decrease-bet-btn");
    const increaseBtn = document.getElementById("increase-bet-btn");
    if (decreaseBtn) {
      const handler = () => {
        if (!this.game.gameLogic.isGameActive() && this.game.betting.getCurrentBet().resource) {
          if (this.game.betting.decreaseBet()) {
            this.game.view.updateBetAmount(this.game.betting.getCurrentBet().amount);
            this.game.animations.animateBetChange(
              document.getElementById("bet-amount"),
              this.game.betting.getCurrentBet().amount
            );
            this.game.animations.playCardSound("boink");
          }
        }
      };
      this.setupControlButton(decreaseBtn, handler);
    }
    if (increaseBtn) {
      const handler = () => {
        if (!this.game.gameLogic.isGameActive() && this.game.betting.getCurrentBet().resource) {
          if (this.game.betting.increaseBet()) {
            this.game.view.updateBetAmount(this.game.betting.getCurrentBet().amount);
            this.game.animations.animateBetChange(
              document.getElementById("bet-amount"),
              this.game.betting.getCurrentBet().amount
            );
            this.game.animations.playCardSound("boink");
          }
        }
      };
      this.setupControlButton(increaseBtn, handler);
    }
  }
  /**
   * Setup action button event handlers (Deal, Hit, Stand, Double)
   */
  setupActionButtonHandlers() {
    const actionButtons = [
      { id: "deal-btn", handler: () => this.game.startGame() },
      { id: "hit-btn", handler: () => this.game.hit() },
      { id: "stand-btn", handler: () => this.game.stand() },
      { id: "double-btn", handler: () => this.game.doubleDown() }
    ];
    actionButtons.forEach((action) => {
      const button = document.getElementById(action.id);
      if (button) {
        const clickHandler = () => {
          if (!button.disabled) {
            this.game.animations.animateButtonPress(button);
            action.handler();
            this.game.animations.playCardSound("boink");
          }
        };
        this.setupActionButton(button, clickHandler);
      }
    });
  }
  /**
   * Setup mobile-specific event handlers
   */
  setupMobileEventHandlers() {
    if (!this.isMobile) return;
    const gameUI = document.getElementById("blackjack-game");
    if (gameUI) {
      this.addEventHandler(gameUI, "touchmove", (e) => {
        e.preventDefault();
      }, { passive: false });
    }
    this.addEventHandler(window, "orientationchange", () => {
      setTimeout(() => {
        this.game.view.updateResourceDisplay(this.game.spaceship);
      }, 100);
    });
  }
  /**
   * Setup control button with hover and touch effects
   */
  setupControlButton(button, clickHandler) {
    const addHoverEffect = () => {
      if (!button.disabled) {
        const hoverStyles = this.game.view.styles.getControlButtonHoverStyles();
        Object.assign(button.style, hoverStyles);
      }
    };
    const removeHoverEffect = () => {
      if (!button.disabled) {
        button.style.backgroundColor = "rgba(15, 40, 55, 0.8)";
        button.style.boxShadow = "none";
      }
    };
    this.addEventHandler(button, "mouseover", addHoverEffect);
    this.addEventHandler(button, "mouseout", removeHoverEffect);
    this.addEventHandler(button, "click", clickHandler);
    if (this.isMobile) {
      this.addEventHandler(button, "touchstart", addHoverEffect, { passive: true });
      this.addEventHandler(button, "touchend", (e) => {
        removeHoverEffect();
        e.preventDefault();
        clickHandler();
      });
    }
  }
  /**
   * Setup action button with hover and touch effects
   */
  setupActionButton(button, clickHandler) {
    const color = this.getButtonColor(button.id);
    const enableHoverEffects = () => {
      if (!button.disabled) {
        const hoverStyles = this.game.view.styles.getActionButtonHoverStyles(color);
        Object.assign(button.style, hoverStyles);
      }
    };
    const disableHoverEffects = () => {
      if (!button.disabled) {
        button.style.backgroundColor = "rgba(15, 40, 55, 0.8)";
        button.style.boxShadow = `0 0 10px ${color}`;
      }
    };
    this.addEventHandler(button, "mouseover", enableHoverEffects);
    this.addEventHandler(button, "mouseout", disableHoverEffects);
    this.addEventHandler(button, "click", clickHandler);
    if (this.isMobile) {
      this.addEventHandler(button, "touchstart", enableHoverEffects, { passive: true });
      this.addEventHandler(button, "touchend", (e) => {
        disableHoverEffects();
        e.preventDefault();
        clickHandler();
      });
    }
  }
  /**
   * Get button color based on button ID
   */
  getButtonColor(buttonId) {
    switch (buttonId) {
      case "deal-btn":
        return "#30cfd0";
      case "hit-btn":
        return "#ff9e3d";
      case "stand-btn":
        return "#e55c8a";
      case "double-btn":
        return "#a281ff";
      default:
        return "#33aaff";
    }
  }
  /**
   * Add event listener and track it for cleanup
   */
  addEventHandler(element, event, handler, options = false) {
    element.addEventListener(event, handler, options);
    const key = `${element.id || element.className}_${event}`;
    if (!this.eventListeners.has(key)) {
      this.eventListeners.set(key, []);
    }
    this.eventListeners.get(key).push({ element, event, handler, options });
  }
  /**
   * Remove all event listeners
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.forEach(({ element, event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
    });
    this.eventListeners.clear();
  }
  /**
   * Update button states based on game state
   */
  updateButtonStates() {
    const dealBtn = document.getElementById("deal-btn");
    const hitBtn = document.getElementById("hit-btn");
    const standBtn = document.getElementById("stand-btn");
    const doubleBtn = document.getElementById("double-btn");
    [dealBtn, hitBtn, standBtn, doubleBtn].forEach((btn) => {
      if (btn) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.cursor = "default";
      }
    });
    if (!this.game.gameLogic.isGameActive()) {
      const canDeal = this.game.betting.hasValidBet();
      if (dealBtn) {
        dealBtn.disabled = !canDeal;
        dealBtn.style.opacity = canDeal ? "1" : "0.5";
        dealBtn.style.cursor = canDeal ? "pointer" : "default";
      }
    } else {
      if (hitBtn) {
        hitBtn.disabled = false;
        hitBtn.style.opacity = "1";
        hitBtn.style.cursor = "pointer";
      }
      if (standBtn) {
        standBtn.disabled = false;
        standBtn.style.opacity = "1";
        standBtn.style.cursor = "pointer";
      }
      const playerHand = this.game.gameLogic.getPlayerHand();
      const canDouble = playerHand.length === 2 && this.game.betting.canAffordDoubleDown();
      if (doubleBtn) {
        doubleBtn.disabled = !canDouble;
        doubleBtn.style.opacity = canDouble ? "1" : "0.5";
        doubleBtn.style.cursor = canDouble ? "pointer" : "default";
      }
    }
  }
  /**
   * Handle keyboard events
   */
  setupKeyboardHandlers() {
    const keyHandler = (e) => {
      if (this.game.gameUI.style.display === "none") return;
      switch (e.key.toLowerCase()) {
        case "escape":
          this.game.hide();
          break;
        case "enter":
        case " ":
          if (!this.game.gameLogic.isGameActive() && this.game.betting.hasValidBet()) {
            this.game.startGame();
          }
          break;
        case "h":
          if (this.game.gameLogic.isGameActive()) {
            this.game.hit();
          }
          break;
        case "s":
          if (this.game.gameLogic.isGameActive()) {
            this.game.stand();
          }
          break;
        case "d":
          if (this.game.gameLogic.isGameActive()) {
            this.game.doubleDown();
          }
          break;
        case "1":
          this.selectResource("iron");
          break;
        case "2":
          this.selectResource("gold");
          break;
        case "3":
          this.selectResource("platinum");
          break;
        case "arrowup":
        case "+":
          if (!this.game.gameLogic.isGameActive() && this.game.betting.getCurrentBet().resource) {
            if (this.game.betting.increaseBet()) {
              this.game.view.updateBetAmount(this.game.betting.getCurrentBet().amount);
            }
          }
          e.preventDefault();
          break;
        case "arrowdown":
        case "-":
          if (!this.game.gameLogic.isGameActive() && this.game.betting.getCurrentBet().resource) {
            if (this.game.betting.decreaseBet()) {
              this.game.view.updateBetAmount(this.game.betting.getCurrentBet().amount);
            }
          }
          e.preventDefault();
          break;
      }
    };
    this.addEventHandler(document, "keydown", keyHandler);
  }
  /**
   * Select resource by name (helper for keyboard events)
   */
  selectResource(resource) {
    if (!this.game.gameLogic.isGameActive()) {
      const button = document.querySelector(`[data-resource="${resource}"]`);
      if (button) {
        button.click();
      }
    }
  }
  /**
   * Handle window resize events
   */
  setupResizeHandler() {
    const resizeHandler = () => {
      this.isMobile = window.innerWidth <= 768 || window.innerHeight <= 600;
      if (this.game.view) {
        this.game.view.isMobile = this.isMobile;
      }
    };
    this.addEventHandler(window, "resize", resizeHandler);
  }
  /**
   * Setup all handlers at once
   */
  initialize() {
    this.setupEventHandlers();
    this.setupKeyboardHandlers();
    this.setupResizeHandler();
  }
  /**
   * Cleanup method to remove all event listeners
   */
  destroy() {
    this.removeAllEventListeners();
  }
}
class BlackjackGame {
  constructor(scene, spaceship, audio) {
    this.scene = scene;
    this.spaceship = spaceship;
    this.audio = audio;
    this.isMobile = MobileDetector.isMobile();
    console.log("BlackjackGame constructor - spaceship:", this.spaceship);
    console.log("BlackjackGame constructor - cargo:", this.spaceship ? this.spaceship.cargo : null);
    console.log("BlackjackGame constructor - isMobile:", this.isMobile);
    this.view = new BlackjackGameView(this.isMobile);
    this.deck = new BlackjackCardDeck();
    this.gameLogic = new BlackjackGameLogic();
    this.animations = new BlackjackAnimations(this.audio);
    this.betting = new BlackjackBetting(this.spaceship);
    this.eventHandlers = new BlackjackEventHandlers(this, this.isMobile);
    this.gameUI = null;
  }
  /**
   * Initialize the game UI
   */
  init() {
    if (!this.gameUI) {
      this.createGameUI();
    }
  }
  /**
   * Create the game UI elements
   */
  createGameUI() {
    this.gameUI = this.view.createGameUI();
    this.eventHandlers.initialize();
    this.updateControls();
  }
  /**
   * Show the game UI and sync with current game resources
   */
  show() {
    if (window.game && window.game.introSequenceActive) {
      console.log("BlackjackGame: Not showing game UI during intro sequence");
      return;
    }
    if (this.gameUI) {
      this.view.show(this.gameUI);
      this.reset();
      if (this.audio && this.isMobile) {
        setTimeout(() => {
          console.log("Mobile: Attempting to play initial sound in BlackjackGame");
          this.audio.playSound("boink");
        }, 100);
      }
      this.betting.syncWithGameResources();
      this.view.updateResourceDisplay(this.spaceship);
      this.animations.playCardSound("boink");
    } else {
      this.init();
      this.show();
    }
  }
  /**
   * Hide the game UI and return to the stargate interface
   */
  hide() {
    if (this.gameUI) {
      this.view.hide(this.gameUI);
      this.animations.playCardSound("boink");
      const stargateUI = document.getElementById("stargate-ui");
      if (stargateUI) {
        stargateUI.style.display = "block";
      }
    }
  }
  /**
   * Reset the game state
   */
  reset() {
    this.gameLogic.reset();
    this.betting.reset();
    this.view.clearCards(true);
    this.view.clearCards(false);
    this.view.updateScore(0, true);
    this.view.updateScore(0, false);
    this.view.updateGameStatus("PLACE YOUR BET TO BEGIN");
    this.view.updateBetAmount("0");
    const speechBubble = document.getElementById("dealer-speech");
    if (speechBubble) {
      speechBubble.style.display = "none";
    }
    document.querySelectorAll(".resource-btn").forEach((btn) => {
      this.animations.removeResourceSelection(btn);
    });
    this.updateControls();
  }
  /**
   * Select a resource for betting
   */
  selectBetResource(resource) {
    this.betting.selectBetResource(resource);
    this.view.updateBetAmount(this.betting.getCurrentBet().amount);
    this.updateControls();
  }
  /**
   * Update the game controls based on the current state
   */
  updateControls() {
    this.eventHandlers.updateButtonStates();
  }
  /**
   * Start a new game
   */
  startGame() {
    console.log("Starting game with bet:", this.betting.getCurrentBet());
    if (!this.betting.hasValidBet()) {
      console.log("No valid bet selected");
      return;
    }
    if (!this.betting.initializeCargo()) {
      this.view.updateGameStatus("ERROR: GAME DATA MISSING");
      return;
    }
    if (!this.betting.canAffordBet()) {
      this.view.updateGameStatus("NOT ENOUGH RESOURCES");
      return;
    }
    if (!this.betting.placeBet()) {
      this.view.updateGameStatus("BET FAILED");
      return;
    }
    this.view.updateResourceDisplay(this.spaceship);
    this.deck.reset();
    this.gameLogic.startGame();
    this.view.clearCards(true);
    this.view.clearCards(false);
    this.dealCardToPlayer();
    this.dealCardToPlayer();
    this.dealCardToDealer();
    this.dealCardToDealer(true);
    const naturalResult = this.gameLogic.checkForNaturalBlackjack();
    if (naturalResult) {
      this.handleGameEnd(naturalResult);
    } else {
      this.view.updateGameStatus("YOUR MOVE");
    }
    this.updateControls();
    this.animations.playCardSound("deal");
  }
  /**
   * Deal a card to the player
   */
  dealCardToPlayer() {
    const card = this.deck.drawCard();
    this.gameLogic.addCardToPlayer(card);
    const cardEl = this.view.addCard(card, false, true);
    this.animations.animateCardDeal(cardEl);
    const score = this.gameLogic.getPlayerScore();
    this.view.updateScore(score, true);
    if (this.gameLogic.isBust(this.gameLogic.getPlayerHand())) {
      this.handleGameEnd("bust");
    }
  }
  /**
   * Deal a card to the dealer
   */
  dealCardToDealer(faceDown = false) {
    const card = this.deck.drawCard();
    this.gameLogic.addCardToDealer(card);
    const cardEl = this.view.addCard(card, faceDown, false);
    this.animations.animateCardDeal(cardEl);
    if (!faceDown) {
      const visibleScore = this.gameLogic.calculateVisibleDealerScore();
      this.view.updateScore(visibleScore, false);
    }
  }
  /**
   * Player action: Hit (take another card)
   */
  hit() {
    if (this.gameLogic.isGameActive()) {
      this.dealCardToPlayer();
      this.animations.playCardSound("hit");
      this.updateControls();
    }
  }
  /**
   * Player action: Stand (end turn)
   */
  stand() {
    if (this.gameLogic.isGameActive()) {
      this.animations.playCardSound("stand");
      this.dealerPlay();
    }
  }
  /**
   * Player action: Double Down
   */
  doubleDown() {
    if (this.gameLogic.isGameActive() && this.gameLogic.getPlayerHand().length === 2) {
      if (!this.betting.canAffordDoubleDown()) {
        this.view.updateGameStatus("NOT ENOUGH RESOURCES FOR DOUBLE DOWN");
        return;
      }
      this.betting.doubleDown();
      this.view.updateResourceDisplay(this.spaceship);
      this.dealCardToPlayer();
      if (!this.gameLogic.isBust(this.gameLogic.getPlayerHand())) {
        this.dealerPlay();
      }
      this.animations.playCardSound("double");
    }
  }
  /**
   * Dealer's turn to play
   */
  dealerPlay() {
    const lastCard = this.gameLogic.getLastDealerCard();
    if (lastCard) {
      this.animations.animateCardFlip(
        document.getElementById("face-down-card"),
        () => {
          this.view.revealDealerCard(lastCard);
          this.view.updateScore(this.gameLogic.getDealerScore(), false);
        }
      );
    }
    const dealerPlayNextCard = () => {
      if (this.gameLogic.shouldDealerHit()) {
        this.dealCardToDealer();
        this.animations.playCardSound("hit");
        setTimeout(() => {
          dealerPlayNextCard();
        }, 800);
      } else {
        const result = this.gameLogic.determineOutcome();
        this.handleGameEnd(result);
      }
    };
    setTimeout(dealerPlayNextCard, 800);
  }
  /**
   * Handle game end with result
   */
  handleGameEnd(result) {
    this.gameLogic.endGame(result);
    let statusMessage = "";
    let speechType = result;
    switch (result) {
      case "win":
        this.betting.handleWin();
        statusMessage = "YOU WIN!";
        this.animations.animateWinCelebration(this.gameUI);
        this.animations.playCardSound("win");
        break;
      case "blackjack":
        this.betting.handleBlackjack();
        statusMessage = "BLACKJACK! TRIPLE PAYOUT!";
        this.animations.animateBlackjackCelebration(this.gameUI);
        this.animations.playCardSound("blackjack");
        break;
      case "lose":
      case "bust":
        statusMessage = result === "bust" ? "BUST! YOU LOSE" : "DEALER WINS";
        this.animations.animateLoseEffect(this.gameUI);
        this.animations.playCardSound(result);
        speechType = "lose";
        break;
      case "push":
        this.betting.handlePush();
        statusMessage = "PUSH - BETS RETURNED";
        this.animations.playCardSound("push");
        break;
    }
    this.view.updateGameStatus(statusMessage);
    this.view.updateResourceDisplay(this.spaceship);
    const phrase = this.gameLogic.getDealerPhrase(speechType);
    if (phrase) {
      this.view.showDealerSpeech(phrase);
    }
    this.updateControls();
  }
  /**
   * Cleanup method for destroying the game
   */
  destroy() {
    if (this.eventHandlers) {
      this.eventHandlers.destroy();
    }
    if (this.gameUI && this.gameUI.parentNode) {
      this.gameUI.parentNode.removeChild(this.gameUI);
    }
    this.gameUI = null;
  }
}
class SettingsStyles {
  constructor(isMobile) {
    this.isMobile = isMobile;
  }
  /**
   * Creates the main settings container with responsive styling
   */
  createSettingsContainer() {
    const settingsContainer = document.createElement("div");
    settingsContainer.id = "settings-container";
    settingsContainer.style.position = "absolute";
    settingsContainer.style.top = "50%";
    settingsContainer.style.left = "50%";
    settingsContainer.style.transform = "translate(-50%, -50%)";
    if (this.isMobile) {
      settingsContainer.style.width = "95%";
      settingsContainer.style.maxWidth = "600px";
      settingsContainer.style.height = "90vh";
    } else {
      settingsContainer.style.width = "700px";
      settingsContainer.style.maxHeight = "90vh";
    }
    settingsContainer.style.overflowY = "auto";
    settingsContainer.style.backgroundColor = "rgba(20, 30, 50, 0.9)";
    settingsContainer.style.color = "#fff";
    settingsContainer.style.padding = this.isMobile ? "20px" : "30px";
    settingsContainer.style.borderRadius = "15px";
    settingsContainer.style.border = "2px solid #33aaff";
    settingsContainer.style.boxShadow = "0 0 30px #33aaff";
    settingsContainer.style.fontFamily = "Courier New, monospace";
    settingsContainer.style.zIndex = "1000";
    settingsContainer.style.display = "none";
    if (this.isMobile) {
      settingsContainer.style.webkitOverflowScrolling = "touch";
      settingsContainer.style.touchAction = "pan-y";
      settingsContainer.style.overscrollBehavior = "contain";
    }
    return settingsContainer;
  }
  /**
   * Gets responsive styles for settings rows
   */
  getSettingsRowStyle() {
    return `display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-direction: ${this.isMobile ? "column" : "row"}; align-items: ${this.isMobile ? "flex-start" : "center"};`;
  }
  /**
   * Gets styles for setting labels
   */
  getSettingLabelStyle() {
    return `margin-bottom: ${this.isMobile ? "8px" : "0"}; ${this.isMobile ? "width: 100%" : ""}`;
  }
  /**
   * Gets styles for setting controls
   */
  getSettingControlStyle() {
    return `${this.isMobile ? "width: 100%" : ""}`;
  }
  /**
   * Gets styles for toggle controls
   */
  getToggleControlStyle() {
    return `${this.isMobile ? "width: 100%; display: flex; justify-content: flex-end;" : ""}`;
  }
  /**
   * Gets styles for label text
   */
  getLabelTextStyle() {
    return `font-weight: bold; font-size: ${this.isMobile ? "15px" : "inherit"};`;
  }
  /**
   * Gets styles for description text
   */
  getDescriptionTextStyle() {
    return `margin: 5px 0 0 0; font-size: ${this.isMobile ? "11px" : "12px"}; color: #aaa;`;
  }
  /**
   * Gets styles for select elements
   */
  getSelectStyle() {
    return `background-color: #2a3a5a; color: white; border: 1px solid #33aaff; padding: ${this.isMobile ? "10px" : "8px"}; border-radius: 5px; width: ${this.isMobile ? "100%" : "auto"}; font-size: ${this.isMobile ? "16px" : "inherit"};`;
  }
  /**
   * Gets styles for toggle switches
   */
  getToggleStyle() {
    return `display: inline-block; position: relative; width: ${this.isMobile ? "70px" : "60px"}; height: ${this.isMobile ? "34px" : "30px"};`;
  }
  /**
   * Gets styles for toggle inputs
   */
  getToggleInputStyle() {
    return "opacity: 0; width: 0; height: 0;";
  }
  /**
   * Gets styles for toggle sliders
   */
  getToggleSliderStyle() {
    return `position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: ${this.isMobile ? "17px" : "15px"}; transition: .4s;`;
  }
  /**
   * Gets styles for section headers
   */
  getSectionHeaderStyle() {
    return `color: #33aaff; border-bottom: 1px solid #33aaff; padding-bottom: 10px; font-size: ${this.isMobile ? "18px" : "20px"};`;
  }
  /**
   * Gets styles for main title
   */
  getMainTitleStyle() {
    return `text-align: center; color: #33aaff; margin-top: 0; font-size: ${this.isMobile ? "24px" : "28px"};`;
  }
  /**
   * Gets styles for preset buttons container
   */
  getPresetContainerStyle() {
    return `display: flex; justify-content: space-between; margin-bottom: 20px; flex-direction: ${this.isMobile ? "column" : "row"}; gap: ${this.isMobile ? "10px" : "0"};`;
  }
  /**
   * Gets styles for preset buttons
   */
  getPresetButtonStyle() {
    return `flex: 1; margin-right: ${this.isMobile ? "0" : "10px"}; padding: ${this.isMobile ? "15px" : "10px"}; background-color: #2a3a5a; color: white; border: 1px solid #33aaff; border-radius: 5px; cursor: pointer; font-size: ${this.isMobile ? "16px" : "inherit"};`;
  }
  /**
   * Gets styles for action buttons container
   */
  getActionButtonsContainerStyle() {
    return `display: flex; justify-content: space-between; flex-direction: ${this.isMobile ? "column" : "row"}; gap: ${this.isMobile ? "15px" : "0"};`;
  }
  /**
   * Gets styles for apply button
   */
  getApplyButtonStyle() {
    return `flex: 1; margin-right: ${this.isMobile ? "0" : "10px"}; padding: ${this.isMobile ? "20px" : "15px"}; background-color: #33aaff; color: black; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold; font-size: ${this.isMobile ? "18px" : "16px"};`;
  }
  /**
   * Gets styles for back button
   */
  getBackButtonStyle() {
    return `flex: 1; padding: ${this.isMobile ? "20px" : "15px"}; background-color: #555; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold; font-size: ${this.isMobile ? "18px" : "16px"};`;
  }
  /**
   * Gets styles for notification
   */
  getNotificationStyle() {
    return {
      position: "fixed",
      top: this.isMobile ? "25%" : "20%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      color: "#33aaff",
      padding: this.isMobile ? "20px 40px" : "15px 30px",
      borderRadius: "10px",
      fontFamily: "Courier New, monospace",
      fontSize: this.isMobile ? "18px" : "16px",
      zIndex: "9999",
      textAlign: "center"
    };
  }
  /**
   * Injects toggle slider CSS into the document head
   */
  injectToggleCSS() {
    const style = document.createElement("style");
    style.textContent = `
            .slider:before {
                position: absolute;
                content: "";
                height: ${this.isMobile ? "26px" : "22px"};
                width: ${this.isMobile ? "26px" : "22px"};
                left: 4px;
                bottom: 4px;
                background-color: white;
                border-radius: 50%;
                transition: .4s;
            }
            
            input:checked + .slider {
                background-color: #33aaff;
            }
            
            input:checked + .slider:before {
                transform: translateX(${this.isMobile ? "36px" : "30px"});
            }
        `;
    document.head.appendChild(style);
  }
  /**
   * Creates a settings row with label and control
   */
  createSettingRow(labelText, description, controlHtml) {
    return `
            <div class="settings-row" style="${this.getSettingsRowStyle()}">
                <div style="${this.getSettingLabelStyle()}">
                    <label style="${this.getLabelTextStyle()}">${labelText}</label>
                    <p style="${this.getDescriptionTextStyle()}">${description}</p>
                </div>
                <div style="${this.getSettingControlStyle()}">
                    ${controlHtml}
                </div>
            </div>
        `;
  }
  /**
   * Creates a toggle settings row
   */
  createToggleRow(labelText, description, inputId) {
    const toggleHtml = `
            <label class="toggle" style="${this.getToggleStyle()}">
                <input type="checkbox" id="${inputId}" style="${this.getToggleInputStyle()}">
                <span class="slider" style="${this.getToggleSliderStyle()}"></span>
            </label>
        `;
    return `
            <div class="settings-row" style="${this.getSettingsRowStyle()}">
                <div style="${this.getSettingLabelStyle()}">
                    <label style="${this.getLabelTextStyle()}">${labelText}</label>
                    <p style="${this.getDescriptionTextStyle()}">${description}</p>
                </div>
                <div style="${this.getToggleControlStyle()}">
                    ${toggleHtml}
                </div>
            </div>
        `;
  }
  /**
   * Creates a select dropdown settings row
   */
  createSelectRow(labelText, description, selectId, options) {
    const optionsHtml = options.map(
      (option) => `<option value="${option.value}">${option.text}</option>`
    ).join("");
    const selectHtml = `
            <select id="${selectId}" style="${this.getSelectStyle()}">
                ${optionsHtml}
            </select>
        `;
    return this.createSettingRow(labelText, description, selectHtml);
  }
}
class AudioSettings {
  constructor(game, styles) {
    this.game = game;
    this.styles = styles;
  }
  /**
   * Creates the audio settings section HTML
   */
  createAudioSettingsHTML() {
    return `
            <div style="margin-bottom: 20px;">
                <h3 style="${this.styles.getSectionHeaderStyle()}">AUDIO SETTINGS</h3>
                
                ${this.styles.createToggleRow(
      "Spatial Audio",
      "3D positional sound effects",
      "spatial-audio"
    )}
            </div>
        `;
  }
  /**
   * Applies audio settings to the game
   */
  applyAudioSettings(settings) {
    if (!this.game.audio) return;
    const audio = this.game.audio;
    if (audio.spatialAudio !== void 0) {
      audio.spatialAudio = settings.spatialAudio;
    }
  }
  /**
   * Updates audio-related UI elements with current settings
   */
  updateAudioUI(settings) {
    const spatialAudioElement = document.getElementById("spatial-audio");
    if (spatialAudioElement) {
      spatialAudioElement.checked = settings.spatialAudio;
    }
  }
  /**
   * Reads audio settings from UI elements
   */
  readAudioSettings() {
    const spatialAudioElement = document.getElementById("spatial-audio");
    return {
      spatialAudio: spatialAudioElement ? spatialAudioElement.checked : true
    };
  }
  /**
   * Applies audio preset settings
   */
  applyAudioPreset(preset, settings) {
    switch (preset) {
      case "performance":
        settings.spatialAudio = false;
        break;
      case "balanced":
      case "quality":
        settings.spatialAudio = true;
        break;
    }
    return settings;
  }
}
class GraphicsSettings {
  constructor(game, styles) {
    this.game = game;
    this.styles = styles;
  }
  /**
   * Creates the graphics settings section HTML
   */
  createGraphicsSettingsHTML() {
    return `
            <div style="margin-bottom: 20px;">
                <h3 style="${this.styles.getSectionHeaderStyle()}">GRAPHICS SETTINGS</h3>
                
                ${this.styles.createSelectRow(
      "Graphical Quality",
      "Affects overall visual fidelity and performance",
      "graphical-quality",
      [
        { value: "low", text: "Low" },
        { value: "medium", text: "Medium" },
        { value: "high", text: "High" }
      ]
    )}
                
                ${this.styles.createToggleRow(
      "Post-processing Effects",
      "Bloom, anti-aliasing, and visual effects",
      "post-processing"
    )}
                
                ${this.styles.createToggleRow(
      "Volumetric Light Rays",
      "Enable sunlight rays effect",
      "god-rays-enabled"
    )}
                
                ${this.styles.createSelectRow(
      "Light Ray Type",
      "Choose light ray effect style",
      "god-rays-type",
      [
        { value: "standard", text: "Standard God Rays" },
        { value: "claude", text: "Claude Rays" }
      ]
    )}
                
                ${this.styles.createSelectRow(
      "Asteroid Detail",
      "Affects asteroid count and model complexity",
      "asteroid-detail",
      [
        { value: "low", text: "Low" },
        { value: "medium", text: "Medium" },
        { value: "high", text: "High" }
      ]
    )}
                
                ${this.styles.createSelectRow(
      "Lighting Quality",
      "Affects light sources and shadows",
      "lighting-quality",
      [
        { value: "low", text: "Low" },
        { value: "medium", text: "Medium" },
        { value: "high", text: "High" }
      ]
    )}
                
                ${this.styles.createSelectRow(
      "Particle Effects",
      "Affects thruster, explosion, and other particle effects",
      "particle-effects",
      [
        { value: "low", text: "Low" },
        { value: "medium", text: "Medium" },
        { value: "high", text: "High" }
      ]
    )}
                
                ${this.styles.createSelectRow(
      "Resolution Scale",
      "Adjusts rendering resolution",
      "resolution-scale",
      [
        { value: "low", text: "Low (75%)" },
        { value: "medium", text: "Medium (100%)" },
        { value: "high", text: "High (125%)" }
      ]
    )}
            </div>
        `;
  }
  /**
   * Applies graphics settings to the game renderer
   */
  applyGraphicsSettings(settings) {
    if (!this.game) return;
    this.applyRendererSettings(settings);
    this.applyEnvironmentSettings(settings);
    console.log("Graphics settings applied successfully");
  }
  /**
   * Applies renderer-specific graphics settings
   */
  applyRendererSettings(settings) {
    if (!this.game.renderer) return;
    const renderer = this.game.renderer;
    switch (settings.graphicalQuality) {
      case "low":
        if (renderer.renderer) {
          renderer.renderer.antialias = false;
        }
        if (renderer.renderer && renderer.renderer.shadowMap) {
          renderer.renderer.shadowMap.enabled = false;
        }
        break;
      case "medium":
        if (renderer.renderer) {
          renderer.renderer.antialias = true;
        }
        if (renderer.renderer && renderer.renderer.shadowMap) {
          renderer.renderer.shadowMap.enabled = true;
          renderer.renderer.shadowMap.type = PCFShadowMap;
        }
        break;
      case "high":
        if (renderer.renderer) {
          renderer.renderer.antialias = true;
        }
        if (renderer.renderer && renderer.renderer.shadowMap) {
          renderer.renderer.shadowMap.enabled = true;
          renderer.renderer.shadowMap.type = PCFSoftShadowMap;
        }
        break;
    }
    if (renderer.composer) {
      renderer.useBasicRendering = !settings.postProcessing;
    }
    if (renderer.setRayType) {
      const useClaudeRays = settings.godRaysType === "claude";
      renderer.setRayType(useClaudeRays);
    }
    if (renderer.setVolumetricLightEnabled) {
      renderer.setVolumetricLightEnabled(settings.godRaysEnabled);
      if (renderer.adjustLightingForRayType) {
        renderer.adjustLightingForRayType();
      }
    }
    if (renderer.setVolumetricLightIntensity) {
      let intensity;
      switch (settings.graphicalQuality) {
        case "low":
          intensity = 0.4;
          break;
        case "medium":
          intensity = 0.65;
          break;
        case "high":
          intensity = 0.85;
          break;
        default:
          intensity = 0.65;
      }
      renderer.setVolumetricLightIntensity(intensity);
    }
    if (renderer.bloomPass) {
      switch (settings.graphicalQuality) {
        case "low":
          renderer.adjustBloom(0.4, 0.3, 0.9);
          break;
        case "medium":
          renderer.adjustBloom(0.6, 0.4, 0.85);
          break;
        case "high":
          renderer.adjustBloom(0.8, 0.5, 0.8);
          break;
      }
    }
    if (renderer.renderer) {
      let pixelRatio = window.devicePixelRatio || 1;
      switch (settings.resolutionScale) {
        case "low":
          pixelRatio *= 0.75;
          break;
        case "medium":
          break;
        case "high":
          pixelRatio *= 1.25;
          break;
      }
      renderer.renderer.setPixelRatio(pixelRatio);
      renderer.handleResize();
    }
  }
  /**
   * Applies environment-related graphics settings
   */
  applyEnvironmentSettings(settings) {
    if (!this.game.environment) return;
    const environment = this.game.environment;
    if (environment.asteroidBelt && environment.asteroidBelt.updateDensity) {
      switch (settings.asteroidDetail) {
        case "low":
          environment.asteroidBelt.updateDensity(0.5);
          break;
        case "medium":
          environment.asteroidBelt.updateDensity(1);
          break;
        case "high":
          environment.asteroidBelt.updateDensity(1.5);
          break;
      }
    }
  }
  /**
   * Applies physics settings related to graphics
   */
  applyPhysicsSettings(settings) {
    if (this.game.physics) {
      const physics = this.game.physics;
      switch (settings.asteroidDetail) {
        case "low":
          physics.collisionDistance = 10;
          break;
        case "medium":
          physics.collisionDistance = 15;
          break;
        case "high":
          physics.collisionDistance = 20;
          break;
      }
    }
  }
  /**
   * Updates graphics-related UI elements with current settings
   */
  updateGraphicsUI(settings) {
    const elements = {
      "graphical-quality": settings.graphicalQuality,
      "post-processing": settings.postProcessing,
      "asteroid-detail": settings.asteroidDetail,
      "lighting-quality": settings.lightingQuality,
      "particle-effects": settings.particleEffects,
      "resolution-scale": settings.resolutionScale,
      "god-rays-enabled": settings.godRaysEnabled,
      "god-rays-type": settings.godRaysType
    };
    for (const [elementId, value] of Object.entries(elements)) {
      const element = document.getElementById(elementId);
      if (element) {
        if (element.type === "checkbox") {
          element.checked = value;
        } else {
          element.value = value;
        }
      }
    }
  }
  /**
   * Reads graphics settings from UI elements
   */
  readGraphicsSettings() {
    return {
      graphicalQuality: this.getElementValue("graphical-quality", "medium"),
      postProcessing: this.getElementChecked("post-processing", true),
      asteroidDetail: this.getElementValue("asteroid-detail", "medium"),
      lightingQuality: this.getElementValue("lighting-quality", "medium"),
      particleEffects: this.getElementValue("particle-effects", "medium"),
      resolutionScale: this.getElementValue("resolution-scale", "medium"),
      godRaysEnabled: this.getElementChecked("god-rays-enabled", false),
      godRaysType: this.getElementValue("god-rays-type", "standard")
    };
  }
  /**
   * Helper to get element value with fallback
   */
  getElementValue(elementId, defaultValue) {
    const element = document.getElementById(elementId);
    return element ? element.value : defaultValue;
  }
  /**
   * Helper to get element checked state with fallback
   */
  getElementChecked(elementId, defaultValue) {
    const element = document.getElementById(elementId);
    return element ? element.checked : defaultValue;
  }
  /**
   * Applies graphics preset settings
   */
  applyGraphicsPreset(preset, settings) {
    switch (preset) {
      case "performance":
        settings.graphicalQuality = "low";
        settings.postProcessing = false;
        settings.asteroidDetail = "low";
        settings.lightingQuality = "low";
        settings.particleEffects = "low";
        settings.resolutionScale = "low";
        settings.godRaysEnabled = false;
        break;
      case "balanced":
        settings.graphicalQuality = "medium";
        settings.postProcessing = true;
        settings.asteroidDetail = "medium";
        settings.lightingQuality = "medium";
        settings.particleEffects = "medium";
        settings.resolutionScale = "medium";
        settings.godRaysEnabled = true;
        settings.godRaysType = "standard";
        break;
      case "quality":
        settings.graphicalQuality = "high";
        settings.postProcessing = true;
        settings.asteroidDetail = "high";
        settings.lightingQuality = "high";
        settings.particleEffects = "high";
        settings.resolutionScale = "high";
        settings.godRaysEnabled = true;
        settings.godRaysType = "claude";
        break;
    }
    return settings;
  }
}
class SettingsView {
  constructor(styles, graphicsSettings, audioSettings, helpers) {
    this.styles = styles;
    this.graphicsSettings = graphicsSettings;
    this.audioSettings = audioSettings;
    this.helpers = helpers;
  }
  /**
   * Creates the complete settings UI
   */
  createSettingsUI() {
    const settingsContainer = this.styles.createSettingsContainer();
    settingsContainer.innerHTML = this.createSettingsHTML();
    this.styles.injectToggleCSS();
    document.body.appendChild(settingsContainer);
    return settingsContainer;
  }
  /**
   * Creates the complete settings HTML content
   */
  createSettingsHTML() {
    return `
            <h2 style="${this.styles.getMainTitleStyle()}">GAME SETTINGS</h2>
            
            ${this.graphicsSettings.createGraphicsSettingsHTML()}
            
            ${this.createPerformanceSettingsHTML()}
            
            ${this.audioSettings.createAudioSettingsHTML()}
            
            ${this.createPresetsHTML()}
            
            ${this.createActionButtonsHTML()}
        `;
  }
  /**
   * Creates the performance settings section HTML
   */
  createPerformanceSettingsHTML() {
    return `
            <div style="margin-bottom: 20px;">
                <h3 style="${this.styles.getSectionHeaderStyle()}">PERFORMANCE SETTINGS</h3>
                
                ${this.styles.createSelectRow(
      "Frame Rate Cap",
      "Limits maximum frame rate",
      "frame-rate-cap",
      [
        { value: "30", text: "30 FPS" },
        { value: "60", text: "60 FPS" },
        { value: "auto", text: `Monitor Refresh Rate (60Hz)` },
        { value: "0", text: "Unlimited" }
      ]
    )}
                
                ${this.styles.createToggleRow(
      "Show FPS Counter",
      "Display current frame rate",
      "show-fps"
    )}
                
                ${this.styles.createToggleRow(
      "Auto-Adjust Quality",
      "Automatically adjusts settings based on performance",
      "auto-quality"
    )}
            </div>
        `;
  }
  /**
   * Creates the presets section HTML
   */
  createPresetsHTML() {
    return `
            <div style="margin-bottom: 20px;">
                <h3 style="${this.styles.getSectionHeaderStyle()}">PRESETS</h3>
                
                <div style="${this.styles.getPresetContainerStyle()}">
                    <button id="preset-performance" style="${this.styles.getPresetButtonStyle()}">
                        PERFORMANCE
                    </button>
                    <button id="preset-balanced" style="${this.styles.getPresetButtonStyle()}">
                        BALANCED
                    </button>
                    <button id="preset-quality" style="${this.styles.getPresetButtonStyle()}">
                        QUALITY
                    </button>
                </div>
            </div>
        `;
  }
  /**
   * Creates the action buttons HTML
   */
  createActionButtonsHTML() {
    return `
            <div style="${this.styles.getActionButtonsContainerStyle()}">
                <button id="apply-settings" style="${this.styles.getApplyButtonStyle()}">
                    APPLY
                </button>
                <button id="settings-back" style="${this.styles.getBackButtonStyle()}">
                    BACK
                </button>
            </div>
        `;
  }
  /**
   * Shows the settings panel
   */
  show() {
    const settingsContainer = document.getElementById("settings-container");
    if (settingsContainer) {
      settingsContainer.style.display = "block";
      return true;
    }
    return false;
  }
  /**
   * Hides the settings panel
   */
  hide() {
    const settingsContainer = document.getElementById("settings-container");
    if (settingsContainer) {
      settingsContainer.style.display = "none";
      return true;
    }
    return false;
  }
  /**
   * Updates the refresh rate display in the frame rate cap dropdown
   */
  updateRefreshRateDisplay(refreshRate) {
    const frameRateSelect = document.getElementById("frame-rate-cap");
    if (frameRateSelect) {
      const autoOption = frameRateSelect.querySelector('option[value="auto"]');
      if (autoOption) {
        autoOption.textContent = `Monitor Refresh Rate (${refreshRate}Hz)`;
      }
    }
  }
  /**
   * Shows a settings applied notification
   */
  showSettingsApplied() {
    const notification = document.createElement("div");
    const notificationStyles = this.styles.getNotificationStyle();
    Object.assign(notification.style, notificationStyles);
    notification.textContent = "Settings applied and saved";
    document.body.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transition = "opacity 0.5s";
      setTimeout(() => {
        notification.remove();
      }, 500);
    }, 1500);
  }
}
class SettingsPersistence {
  constructor() {
    this.storageKey = "asteroidMinerSettings";
  }
  /**
   * Gets default settings object
   */
  getDefaultSettings() {
    return {
      graphicalQuality: "medium",
      // low, medium, high
      postProcessing: true,
      // true, false
      asteroidDetail: "medium",
      // low, medium, high
      lightingQuality: "medium",
      // low, medium, high
      particleEffects: "medium",
      // low, medium, high
      resolutionScale: "medium",
      // low, medium, high
      frameRateCap: "auto",
      // 30, 60, auto (monitor refresh rate), 0 (unlimited)
      showFPS: false,
      // Show FPS counter
      spatialAudio: true,
      // Enable spatial audio
      autoQuality: true,
      // Automatically adjust quality based on performance
      godRaysEnabled: false,
      // Enable/disable volumetric lighting effects
      godRaysType: "standard"
      // 'standard' (new god rays) or 'claude' (Claude Rays)
    };
  }
  /**
   * Loads settings from localStorage
   */
  loadSettings() {
    try {
      const savedSettings = localStorage.getItem(this.storageKey);
      if (savedSettings) {
        const parsedSettings = JSON.parse(savedSettings);
        const defaultSettings = this.getDefaultSettings();
        const mergedSettings = { ...defaultSettings, ...parsedSettings };
        console.log("Settings loaded from localStorage:", mergedSettings);
        return mergedSettings;
      }
    } catch (error) {
      console.error("Error loading settings:", error);
    }
    return this.getDefaultSettings();
  }
  /**
   * Saves settings to localStorage
   */
  saveSettings(settings) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(settings));
      console.log("Settings saved to localStorage");
      return true;
    } catch (error) {
      console.error("Error saving settings:", error);
      return false;
    }
  }
  /**
   * Validates settings object to ensure all required properties exist
   */
  validateSettings(settings) {
    const defaults = this.getDefaultSettings();
    const validatedSettings = { ...defaults };
    for (const key in defaults) {
      if (settings.hasOwnProperty(key)) {
        validatedSettings[key] = settings[key];
      }
    }
    return validatedSettings;
  }
  /**
   * Clears saved settings (resets to defaults)
   */
  clearSettings() {
    try {
      localStorage.removeItem(this.storageKey);
      console.log("Settings cleared from localStorage");
      return true;
    } catch (error) {
      console.error("Error clearing settings:", error);
      return false;
    }
  }
  /**
   * Exports settings as JSON string
   */
  exportSettings(settings) {
    try {
      return JSON.stringify(settings, null, 2);
    } catch (error) {
      console.error("Error exporting settings:", error);
      return null;
    }
  }
  /**
   * Imports settings from JSON string
   */
  importSettings(jsonString) {
    try {
      const importedSettings = JSON.parse(jsonString);
      return this.validateSettings(importedSettings);
    } catch (error) {
      console.error("Error importing settings:", error);
      return null;
    }
  }
  /**
   * Backs up current settings with timestamp
   */
  backupSettings(settings) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const backupKey = `${this.storageKey}_backup_${timestamp}`;
    try {
      localStorage.setItem(backupKey, JSON.stringify({
        timestamp,
        settings
      }));
      console.log(`Settings backed up with key: ${backupKey}`);
      return backupKey;
    } catch (error) {
      console.error("Error backing up settings:", error);
      return null;
    }
  }
  /**
   * Lists available setting backups
   */
  listBackups() {
    const backups = [];
    const backupPrefix = `${this.storageKey}_backup_`;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(backupPrefix)) {
          const backupData = JSON.parse(localStorage.getItem(key));
          backups.push({
            key,
            timestamp: backupData.timestamp,
            date: new Date(backupData.timestamp)
          });
        }
      }
      backups.sort((a, b) => b.date - a.date);
      return backups;
    } catch (error) {
      console.error("Error listing backups:", error);
      return [];
    }
  }
  /**
   * Restores settings from a backup
   */
  restoreFromBackup(backupKey) {
    try {
      const backupData = localStorage.getItem(backupKey);
      if (backupData) {
        const parsedBackup = JSON.parse(backupData);
        return this.validateSettings(parsedBackup.settings);
      }
    } catch (error) {
      console.error("Error restoring from backup:", error);
    }
    return null;
  }
  /**
   * Cleans up old backups (keeps only the most recent N backups)
   */
  cleanupBackups(keepCount = 5) {
    const backups = this.listBackups();
    for (let i = keepCount; i < backups.length; i++) {
      try {
        localStorage.removeItem(backups[i].key);
        console.log(`Removed old backup: ${backups[i].key}`);
      } catch (error) {
        console.error(`Error removing backup ${backups[i].key}:`, error);
      }
    }
  }
}
class SettingsEventHandlers {
  constructor(settings, isMobile) {
    this.settings = settings;
    this.isMobile = isMobile;
  }
  /**
   * Sets up all event listeners for the settings UI
   */
  setupEventListeners() {
    this.setupBackButton();
    this.setupApplyButton();
    this.setupPresetButtons();
  }
  /**
   * Sets up the back button event listeners
   */
  setupBackButton() {
    const backButton = document.getElementById("settings-back");
    if (backButton) {
      backButton.addEventListener("click", () => {
        this.settings.hide();
      });
      if (this.isMobile) {
        backButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          this.settings.hide();
        });
      }
    }
  }
  /**
   * Sets up the apply button event listeners
   */
  setupApplyButton() {
    const applyButton = document.getElementById("apply-settings");
    if (applyButton) {
      const applyHandler = () => {
        this.settings.updateSettings();
        this.settings.saveSettings();
        this.settings.applyAllSettings();
        this.settings.showSettingsApplied();
      };
      applyButton.addEventListener("click", applyHandler);
      if (this.isMobile) {
        applyButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          applyHandler();
        });
      }
    }
  }
  /**
   * Sets up preset button event listeners
   */
  setupPresetButtons() {
    this.setupPresetButton("preset-performance", "performance");
    this.setupPresetButton("preset-balanced", "balanced");
    this.setupPresetButton("preset-quality", "quality");
  }
  /**
   * Sets up a single preset button with event listeners and effects
   */
  setupPresetButton(buttonId, presetName) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    const presetHandler = () => {
      this.settings.applyPreset(presetName);
    };
    button.addEventListener("click", presetHandler);
    if (this.isMobile) {
      button.addEventListener("touchend", (e) => {
        e.preventDefault();
        presetHandler();
      });
    }
    this.setupButtonEffects(button);
  }
  /**
   * Sets up visual effects for buttons (hover/touch feedback)
   */
  setupButtonEffects(button) {
    if (this.isMobile) {
      button.addEventListener("touchstart", () => {
        button.style.backgroundColor = "#3a4b6a";
        button.style.boxShadow = "0 0 10px #33aaff";
      }, { passive: true });
      button.addEventListener("touchend", () => {
        button.style.backgroundColor = "#2a3a5a";
        button.style.boxShadow = "none";
      }, { passive: true });
    } else {
      button.addEventListener("mouseover", () => {
        button.style.backgroundColor = "#3a4b6a";
        button.style.boxShadow = "0 0 10px #33aaff";
      });
      button.addEventListener("mouseout", () => {
        button.style.backgroundColor = "#2a3a5a";
        button.style.boxShadow = "none";
      });
    }
  }
  /**
   * Sets up keyboard navigation for settings (optional enhancement)
   */
  setupKeyboardNavigation() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.settings.isVisible) {
        this.settings.hide();
        e.preventDefault();
      }
      if (e.key === "Enter" && this.settings.isVisible && e.ctrlKey) {
        const applyButton = document.getElementById("apply-settings");
        if (applyButton) {
          applyButton.click();
          e.preventDefault();
        }
      }
    });
  }
  /**
   * Removes all event listeners (cleanup)
   */
  removeEventListeners() {
    const buttons = [
      "settings-back",
      "apply-settings",
      "preset-performance",
      "preset-balanced",
      "preset-quality"
    ];
    buttons.forEach((buttonId) => {
      const button = document.getElementById(buttonId);
      if (button) {
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
      }
    });
  }
  /**
   * Validates form inputs before applying settings
   */
  validateSettingsForm() {
    return true;
  }
  /**
   * Handles setting changes in real-time (optional)
   */
  setupRealTimeUpdates() {
    const settingElements = [
      "graphical-quality",
      "post-processing",
      "asteroid-detail",
      "lighting-quality",
      "particle-effects",
      "resolution-scale",
      "frame-rate-cap",
      "show-fps",
      "spatial-audio",
      "auto-quality",
      "god-rays-enabled",
      "god-rays-type"
    ];
    settingElements.forEach((elementId) => {
      const element = document.getElementById(elementId);
      if (element) {
        element.addEventListener("change", () => {
        });
      }
    });
  }
}
class SettingsHelpers {
  constructor() {
    this.monitorRefreshRate = 60;
  }
  /**
   * Detects system capabilities for auto-configuration
   */
  detectSystemCapabilities() {
    const performance2 = {};
    performance2.highDPI = window.devicePixelRatio > 1;
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2");
    performance2.webgl2 = !!gl;
    if (gl) {
      const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      if (debugInfo) {
        performance2.gpu = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
      }
    }
    performance2.modernBrowser = "IntersectionObserver" in window && "requestAnimationFrame" in window && "localStorage" in window;
    if (performance2.webgl2 && performance2.highDPI && performance2.modernBrowser) {
      return "high";
    } else if (performance2.webgl2 && performance2.modernBrowser) {
      return "medium";
    } else {
      return "low";
    }
  }
  /**
   * Detects monitor refresh rate
   */
  detectMonitorRefreshRate() {
    this.monitorRefreshRate = 60;
    try {
      if ("getScreenDetails" in window && window.getScreenDetails) {
        window.getScreenDetails().then((details) => {
          var _a;
          if (details && details.currentScreen && details.currentScreen.refreshRate) {
            this.monitorRefreshRate = Math.round(details.currentScreen.refreshRate);
            console.log(`Using getScreenDetails API: ${this.monitorRefreshRate}Hz`);
            (_a = this.updateRefreshRateCallback) == null ? void 0 : _a.call(this);
          }
        }).catch((err) => {
          console.log("getScreenDetails not available, falling back to other methods");
        });
      }
      if (window.screen && typeof window.screen.refresh === "number" && window.screen.refresh > 0) {
        this.monitorRefreshRate = Math.round(window.screen.refresh);
        console.log(`Using screen.refresh value: ${this.monitorRefreshRate}Hz`);
        return;
      }
      const quickMeasure = this.quickRefreshRateMeasure();
      if (quickMeasure > 0) {
        this.monitorRefreshRate = quickMeasure;
        console.log(`Quick measure refresh rate: ${this.monitorRefreshRate}Hz`);
      }
      this.startAccurateRefreshDetection();
    } catch (error) {
      console.warn("Error detecting refresh rate:", error);
    }
  }
  /**
   * Quick refresh rate measurement
   */
  quickRefreshRateMeasure() {
    if (window.screen && typeof window.screen.refresh === "number" && window.screen.refresh > 0) {
      return Math.round(window.screen.refresh);
    }
    const userAgent = navigator.userAgent.toLowerCase();
    const isGaming = userAgent.includes("gaming") || userAgent.includes("rog");
    const isHighEnd = window.screen && window.screen.width > 2560;
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    if (isMobile) {
      return 60;
    } else if (isGaming || isHighEnd) {
      return 144;
    }
    return 60;
  }
  /**
   * Starts accurate refresh rate detection over time
   */
  startAccurateRefreshDetection() {
    let warmupFrames = 5;
    let frameCount = 0;
    const timestamps = [];
    const startTime = performance.now();
    const detectFrame = (timestamp) => {
      frameCount++;
      if (frameCount <= warmupFrames) {
        requestAnimationFrame(detectFrame);
        return;
      }
      timestamps.push(timestamp);
      if (timestamps.length < 120 && performance.now() - startTime < 1e3) {
        requestAnimationFrame(detectFrame);
      } else {
        this.processRefreshRateSamples(timestamps);
      }
    };
    requestAnimationFrame(detectFrame);
  }
  /**
   * Processes refresh rate samples to determine accurate rate
   */
  processRefreshRateSamples(timestamps) {
    var _a;
    if (timestamps.length < 2) return;
    const intervals = [];
    for (let i = 1; i < timestamps.length; i++) {
      const delta = timestamps[i] - timestamps[i - 1];
      if (delta > 0) {
        intervals.push(1e3 / delta);
      }
    }
    if (intervals.length === 0) return;
    intervals.sort((a, b) => a - b);
    const q1 = intervals[Math.floor(intervals.length * 0.25)];
    const q3 = intervals[Math.floor(intervals.length * 0.75)];
    const iqr = q3 - q1;
    const validRates = intervals.filter(
      (rate) => rate >= q1 - 1.5 * iqr && rate <= q3 + 1.5 * iqr
    );
    if (validRates.length > 0) {
      const avg = validRates.reduce((a, b) => a + b, 0) / validRates.length;
      const newRate = this.roundToCommonRefreshRate(avg);
      if (Math.abs(newRate - this.monitorRefreshRate) >= 5) {
        console.log(`Refined refresh rate: ${this.monitorRefreshRate}Hz -> ${newRate}Hz`);
        this.monitorRefreshRate = newRate;
        (_a = this.updateRefreshRateCallback) == null ? void 0 : _a.call(this);
      }
    }
  }
  /**
   * Rounds measured rate to common refresh rates
   */
  roundToCommonRefreshRate(rate) {
    const commonRates = [24, 30, 48, 50, 60, 72, 75, 90, 100, 120, 144, 165, 180, 240, 360, 480];
    let closest = 60;
    let minDiff = Math.abs(rate - 60);
    for (const commonRate of commonRates) {
      const diff = Math.abs(rate - commonRate);
      if (diff < minDiff) {
        minDiff = diff;
        closest = commonRate;
      }
    }
    if (minDiff / closest < 0.1) {
      return closest;
    }
    return Math.round(rate);
  }
  /**
   * Gets the current monitor refresh rate
   */
  getMonitorRefreshRate() {
    return this.monitorRefreshRate;
  }
  /**
   * Sets a callback to be called when refresh rate is updated
   */
  setRefreshRateUpdateCallback(callback) {
    this.updateRefreshRateCallback = callback;
  }
  /**
   * Validates a settings object
   */
  validateSettings(settings) {
    const validationRules = {
      graphicalQuality: ["low", "medium", "high"],
      asteroidDetail: ["low", "medium", "high"],
      lightingQuality: ["low", "medium", "high"],
      particleEffects: ["low", "medium", "high"],
      resolutionScale: ["low", "medium", "high"],
      frameRateCap: ["30", "60", "auto", "0"],
      godRaysType: ["standard", "claude"]
    };
    const errors = [];
    for (const [key, validValues] of Object.entries(validationRules)) {
      if (settings[key] && !validValues.includes(settings[key])) {
        errors.push(`Invalid value for ${key}: ${settings[key]}`);
      }
    }
    const booleanSettings = ["postProcessing", "showFPS", "spatialAudio", "autoQuality", "godRaysEnabled"];
    booleanSettings.forEach((key) => {
      if (settings[key] !== void 0 && typeof settings[key] !== "boolean") {
        errors.push(`Invalid value for ${key}: must be boolean`);
      }
    });
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Gets performance recommendation based on system capabilities
   */
  getPerformanceRecommendation() {
    const capability = this.detectSystemCapabilities();
    const recommendations = {
      low: {
        graphicalQuality: "low",
        postProcessing: false,
        asteroidDetail: "low",
        lightingQuality: "low",
        particleEffects: "low",
        resolutionScale: "low",
        frameRateCap: "30",
        godRaysEnabled: false
      },
      medium: {
        graphicalQuality: "medium",
        postProcessing: true,
        asteroidDetail: "medium",
        lightingQuality: "medium",
        particleEffects: "medium",
        resolutionScale: "medium",
        frameRateCap: "60",
        godRaysEnabled: true,
        godRaysType: "standard"
      },
      high: {
        graphicalQuality: "high",
        postProcessing: true,
        asteroidDetail: "high",
        lightingQuality: "high",
        particleEffects: "high",
        resolutionScale: "high",
        frameRateCap: "auto",
        godRaysEnabled: true,
        godRaysType: "claude"
      }
    };
    return recommendations[capability] || recommendations.medium;
  }
  /**
   * Formats settings for display
   */
  formatSettingsForDisplay(settings) {
    const formatted = {};
    for (const [key, value] of Object.entries(settings)) {
      if (typeof value === "boolean") {
        formatted[key] = value ? "Enabled" : "Disabled";
      } else if (key === "frameRateCap") {
        if (value === "0") {
          formatted[key] = "Unlimited";
        } else if (value === "auto") {
          formatted[key] = `Monitor Refresh Rate (${this.monitorRefreshRate}Hz)`;
        } else {
          formatted[key] = `${value} FPS`;
        }
      } else {
        formatted[key] = value.charAt(0).toUpperCase() + value.slice(1);
      }
    }
    return formatted;
  }
  /**
   * Calculates estimated performance impact of settings
   */
  calculatePerformanceImpact(settings) {
    let impact = 0;
    const qualityMap = { low: 1, medium: 2, high: 3 };
    impact += qualityMap[settings.graphicalQuality] || 2;
    impact += qualityMap[settings.asteroidDetail] || 2;
    impact += qualityMap[settings.lightingQuality] || 2;
    impact += qualityMap[settings.particleEffects] || 2;
    impact += qualityMap[settings.resolutionScale] || 2;
    if (settings.postProcessing) impact += 1;
    if (settings.godRaysEnabled) impact += 2;
    const maxImpact = 17;
    return Math.round(impact / maxImpact * 100);
  }
}
class Settings {
  constructor(game) {
    this.game = game;
    this.stargateInterface = null;
    this.isVisible = false;
    this.isMobile = MobileDetector.isMobile();
    console.log("Settings constructor - isMobile:", this.isMobile);
    this.styles = new SettingsStyles(this.isMobile);
    this.helpers = new SettingsHelpers();
    this.persistence = new SettingsPersistence();
    this.graphicsSettings = new GraphicsSettings(this.game, this.styles);
    this.audioSettings = new AudioSettings(this.game, this.styles);
    this.settingsView = new SettingsView(this.styles, this.graphicsSettings, this.audioSettings, this.helpers);
    this.eventHandlers = new SettingsEventHandlers(this, this.isMobile);
    this.helpers.setRefreshRateUpdateCallback(() => {
      this.settingsView.updateRefreshRateDisplay(this.helpers.getMonitorRefreshRate());
    });
    this.helpers.detectMonitorRefreshRate();
    this.settings = this.persistence.loadSettings();
    this.setupSettingsUI();
    this.applyAllSettings();
    setTimeout(() => this.applyUISettings(), 100);
  }
  setStargateInterface(stargateInterface) {
    this.stargateInterface = stargateInterface;
  }
  loadSettings() {
    this.settings = this.persistence.loadSettings();
  }
  saveSettings() {
    this.persistence.saveSettings(this.settings);
  }
  setupSettingsUI() {
    this.settingsView.createSettingsUI();
    this.eventHandlers.setupEventListeners();
  }
  updateSettings() {
    const graphicsSettings = this.graphicsSettings.readGraphicsSettings();
    Object.assign(this.settings, graphicsSettings);
    const audioSettings = this.audioSettings.readAudioSettings();
    Object.assign(this.settings, audioSettings);
    const frameRateCapElement = document.getElementById("frame-rate-cap");
    const showFPSElement = document.getElementById("show-fps");
    const autoQualityElement = document.getElementById("auto-quality");
    if (frameRateCapElement) this.settings.frameRateCap = frameRateCapElement.value;
    if (showFPSElement) this.settings.showFPS = showFPSElement.checked;
    if (autoQualityElement) this.settings.autoQuality = autoQualityElement.checked;
  }
  updateUI() {
    this.graphicsSettings.updateGraphicsUI(this.settings);
    this.audioSettings.updateAudioUI(this.settings);
    const frameRateCapElement = document.getElementById("frame-rate-cap");
    const showFPSElement = document.getElementById("show-fps");
    const autoQualityElement = document.getElementById("auto-quality");
    if (frameRateCapElement) frameRateCapElement.value = this.settings.frameRateCap;
    if (showFPSElement) showFPSElement.checked = this.settings.showFPS;
    if (autoQualityElement) autoQualityElement.checked = this.settings.autoQuality;
  }
  applyPreset(preset) {
    console.log(`Applying ${preset} preset`);
    this.settings = this.graphicsSettings.applyGraphicsPreset(preset, this.settings);
    this.settings = this.audioSettings.applyAudioPreset(preset, this.settings);
    switch (preset) {
      case "performance":
        this.settings.frameRateCap = "60";
        break;
      case "balanced":
        this.settings.frameRateCap = "auto";
        break;
      case "quality":
        this.settings.frameRateCap = "0";
        break;
    }
    this.updateUI();
    this.showSettingsApplied();
  }
  applyAllSettings() {
    if (!this.game) return;
    this.graphicsSettings.applyGraphicsSettings(this.settings);
    this.graphicsSettings.applyPhysicsSettings(this.settings);
    this.audioSettings.applyAudioSettings(this.settings);
    this.applyUISettings();
    console.log("All settings applied successfully");
  }
  applyGraphicsSettings() {
    if (!this.game) return;
    this.graphicsSettings.applyGraphicsSettings(this.settings);
    console.log("Graphics settings applied successfully");
  }
  applyUISettings() {
    const fpsElement = document.getElementById("fps-display");
    if (fpsElement) {
      if (this.settings.showFPS) {
        fpsElement.style.display = "block";
        if (this.game && this.game.currentFPS) {
          fpsElement.textContent = `FPS: ${Math.round(this.game.currentFPS)}`;
        }
      } else {
        fpsElement.style.display = "none";
      }
    } else {
      console.warn("FPS display element not found in HUD. It should have ID 'fps-display'");
    }
    if (this.game) {
      const oldCap = this.game.frameRateCap;
      const monitorRefreshRate = this.helpers.getMonitorRefreshRate();
      if (this.settings.frameRateCap === "auto") {
        if (monitorRefreshRate > 65) {
          this.game.frameRateCap = 0;
          console.log(`Using unlimited frame rate (refresh rate ${monitorRefreshRate}Hz > 65Hz)`);
        } else {
          this.game.frameRateCap = monitorRefreshRate;
          console.log(`Setting frame rate cap to monitor refresh rate: ${monitorRefreshRate}Hz`);
        }
      } else {
        this.game.frameRateCap = parseInt(this.settings.frameRateCap) || 0;
      }
      if (oldCap === 0 && this.game.frameRateCap > 0 || oldCap > 0 && this.game.frameRateCap === 0) {
        this.game.lastFrameTime = 0;
      }
      console.log(`Frame rate cap changed from ${oldCap} to ${this.game.frameRateCap}`);
    }
  }
  showSettingsApplied() {
    this.settingsView.showSettingsApplied();
  }
  show() {
    this.updateUI();
    if (this.settingsView.show()) {
      this.isVisible = true;
    }
  }
  hide() {
    if (this.settingsView.hide()) {
      this.isVisible = false;
      if (this.stargateInterface) {
        this.stargateInterface.showStargateUI();
      }
    }
  }
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
}
class StartScreen {
  constructor(game, ui) {
    this.game = game;
    this.ui = ui;
    this.isVisible = false;
    this.setupStartScreen();
  }
  setupStartScreen() {
    const startScreen = document.createElement("div");
    startScreen.id = "start-screen";
    startScreen.className = "start-screen";
    startScreen.style.display = "none";
    startScreen.innerHTML = `
            <div class="start-screen-inner">
                <h1 class="game-title">Solar System Asteroid Miner</h1>
                <div class="button-container">
                    <button id="play-button" class="start-button">Play</button>
                    <button id="how-to-play-button" class="start-button">How to Play</button>
                </div>
                <div class="version">v0.5.8</div>
            </div>
            
            <div id="how-to-play-modal" class="modal">
                <div class="modal-content">
                    <h2>How to Play</h2>
                    
                    <div class="gameplay-section">
                        <h3>Game Overview</h3>
                        <p>Welcome to Solar System Asteroid Miner! Your mission is to mine asteroids, collect resources, and upgrade your ship.</p>
                        
                        <h4>Core Objectives:</h4>
                        <ul>
                            <li><strong>Mining:</strong> Target asteroids (E key), then use your mining laser (R key) to extract resources.</li>
                            <li><strong>Trading:</strong> Dock at stargates (Q key) to sell resources and purchase ship upgrades.</li>
                            <li><strong>Combat:</strong> Defend yourself against enemy ships using your weapons.</li>
                            <li><strong>Exploration:</strong> Travel between star systems through stargates to discover new resources.</li>
                            <li><strong>Anomalies:</strong> Find and collect energy orbs from space anomalies for credits.</li>
                            <li><strong>Defense:</strong> Deploy autonomous laser turrets (T key) to protect mining operations.</li>
                        </ul>
                        
                        <h4>Horde Mode:</h4>
                        <p>Work toward activating the ultimate challenge - Horde Mode:</p>
                        <ul>
                            <li><strong>Endless Survival:</strong> Face waves of increasingly difficult enemies that never stop coming.</li>
                            <li><strong>Escalating Difficulty:</strong> Enemy health, damage, speed, and spawn rates increase over time.</li>
                            <li><strong>Preparation:</strong> Upgrade your ship's weapons, shields, and hull before activating.</li>
                            <li><strong>Strategy:</strong> Deploy multiple laser turrets (T key) around your position to create defensive perimeters.</li>
                            <li><strong>High Score:</strong> How long can you survive as difficulty scales to infinity?</li>
                        </ul>
                    </div>
                    
                    <div class="control-section">
                        <h3>Movement</h3>
                        <div class="control-row"><span class="key">W</span> <span>Forward</span></div>
                        <div class="control-row"><span class="key">S</span> <span>Backward</span></div>
                        <div class="control-row"><span class="key">A</span> <span>Left</span></div>
                        <div class="control-row"><span class="key">D</span> <span>Right</span></div>
                        <div class="control-row"><span class="key">SHIFT</span> <span>Boost</span></div>
                        <div class="control-row"><span class="key">Mouse</span> <span>Ship Rotation</span></div>
                    </div>
                    
                    <div class="control-section">
                        <h3>Combat & Mining</h3>
                        <div class="control-row"><span class="key">LMB</span> <span>Fire Weapons</span></div>
                        <div class="control-row"><span class="key">E</span> <span>Toggle Target Lock-On</span></div>
                        <div class="control-row"><span class="key">R</span> <span>Toggle Mining Laser</span></div>
                        <div class="control-row"><span class="key">TAB</span> <span>Cycle Targets</span></div>
                    </div>
                    
                    <div class="control-section">
                        <h3>Special</h3>
                        <div class="control-row"><span class="key">T</span> <span>Deploy Laser Turret</span></div>
                        <div class="control-row"><span class="key">Q</span> <span>Dock/Undock at Stargate</span></div>
                        <div class="control-row"><span class="key">ESC</span> <span>Pause Game</span></div>
                    </div>
                    
                    <button id="close-how-to-play" class="modal-close-button">Close</button>
                </div>
            </div>
        `;
    document.body.appendChild(startScreen);
    this.setupEventListeners();
  }
  setupEventListeners() {
    const playButton = document.getElementById("play-button");
    if (playButton) {
      playButton.addEventListener("click", () => {
        console.log("Play button clicked");
        console.log("Game object:", this.game);
        console.log("Game methods available:", Object.getOwnPropertyNames(Object.getPrototypeOf(this.game)));
        this.hide();
        const introPlayed = localStorage.getItem("introPlayed") === "true";
        console.log("Intro played before:", introPlayed);
        if (introPlayed) {
          console.log("Starting game in docked state for returning player");
          if (this.game && this.game.startDocked) {
            this.game.startDocked();
          } else {
            console.error("Game.startDocked not found", this.game);
          }
        } else {
          console.log("Starting intro sequence for new player");
          if (this.game && this.game.startIntroSequence) {
            this.game.startIntroSequence();
          } else {
            console.error("Game.startIntroSequence not found", this.game);
          }
        }
      });
    }
    const howToPlayButton = document.getElementById("how-to-play-button");
    const howToPlayModal = document.getElementById("how-to-play-modal");
    const closeHowToPlayButton = document.getElementById("close-how-to-play");
    if (howToPlayButton && howToPlayModal) {
      howToPlayButton.addEventListener("click", () => {
        howToPlayModal.style.display = "flex";
      });
    }
    if (closeHowToPlayButton && howToPlayModal) {
      closeHowToPlayButton.addEventListener("click", () => {
        howToPlayModal.style.display = "none";
      });
      howToPlayModal.addEventListener("click", (e) => {
        if (e.target === howToPlayModal) {
          howToPlayModal.style.display = "none";
        }
      });
    }
  }
  show() {
    const startScreen = document.getElementById("start-screen");
    if (startScreen) {
      startScreen.style.display = "flex";
      this.isVisible = true;
      if (window.initialTimestamp) {
        const timeToStartScreen = performance.now() - window.initialTimestamp;
        console.log(`Time to start screen visible: ${timeToStartScreen.toFixed(2)}ms`);
      }
    }
  }
  hide() {
    const startScreen = document.getElementById("start-screen");
    if (startScreen) {
      startScreen.style.display = "none";
      this.isVisible = false;
    }
    const howToPlayModal = document.getElementById("how-to-play-modal");
    if (howToPlayModal) {
      howToPlayModal.style.display = "none";
    }
  }
}
class UI {
  constructor(spaceship, environment) {
    this.spaceship = spaceship;
    this.environment = environment;
    this.controls = null;
    this.audio = null;
    this.isMobile = MobileDetector.isMobile();
    console.log(`Initializing UI components for ${this.isMobile ? "mobile" : "desktop"} device...`);
    if (this.isMobile) {
      this.loadMobileCSS();
    }
    if (this.isMobile) {
      this.hud = new MobileHUD(spaceship);
    } else {
      this.hud = new HUD(spaceship);
    }
    this.miningDisplay = new MiningDisplay();
    this.targetingUI = new TargetingUI();
    this.stargateInterface = new StargateInterface();
    this.gameOverScreen = new GameOverScreen();
    this.controlsMenu = new ControlsMenu();
    this.starMap = new StarMap(this.environment.starSystemGenerator, null, this.stargateInterface);
    this.blackjackGame = null;
    this.settings = null;
    this.stargateInterface.setStarMap(this.starMap);
    this.startScreen = null;
    if (window.DEBUG_MODE) {
      this.initializePerformanceMonitor();
    }
    console.log("UI components initialized");
  }
  loadMobileCSS() {
    const mobileCSS = document.createElement("link");
    mobileCSS.rel = "stylesheet";
    mobileCSS.href = "css/mobile.css";
    mobileCSS.type = "text/css";
    document.head.appendChild(mobileCSS);
    console.log("Mobile CSS loaded");
  }
  setAudio(audio) {
    console.log("Setting audio reference in UI");
    this.audio = audio;
    if (this.audio) {
      if (this.spaceship && !this.spaceship.cargo) {
        this.spaceship.cargo = { iron: 0, gold: 0, platinum: 0 };
        console.warn("UI: Created empty cargo object for spaceship");
      }
      this.blackjackGame = new BlackjackGame(null, this.spaceship, this.audio);
      console.log("UI: Created BlackjackGame with spaceship:", this.spaceship);
      this.stargateInterface.setBlackjackGame(this.blackjackGame);
    }
  }
  setControls(controls) {
    console.log("Setting controls reference in UI");
    this.controls = controls;
    if (this.miningDisplay.setControls) {
      this.miningDisplay.setControls(this.controls);
    }
    if (this.isMobile && this.hud && this.hud.setControls) {
      this.hud.setControls(this.controls);
    }
    if (this.starMap && this.controls.dockingSystem) {
      this.starMap.dockingSystem = this.controls.dockingSystem;
    }
    this.setupEventHandlers();
  }
  // Initialize settings with the game instance
  initializeSettings(game) {
    if (!game) {
      console.error("Cannot initialize settings without game instance");
      return;
    }
    this.settings = new Settings(game);
    this.stargateInterface.setSettings(this.settings);
    this.startScreen = new StartScreen(game, this);
    console.log("Settings and StartScreen initialized with game instance");
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    console.log("Setting up UI event handlers");
    if (this.controlsMenu && this.controlsMenu.setupButtonHandler) {
      this.controlsMenu.setupButtonHandler();
    }
    if (this.controls && this.controls.setupStargateUIControls) {
      this.controls.setupStargateUIControls();
    }
    window.mainMessageBus.subscribe("ui.notification", this.handleNotification.bind(this));
    window.addEventListener("resize", () => {
      const wasMobile = this.isMobile;
      this.isMobile = MobileDetector.isMobile();
      if (wasMobile !== this.isMobile) {
        console.log(`Device type changed from ${wasMobile ? "mobile" : "desktop"} to ${this.isMobile ? "mobile" : "desktop"}`);
        location.reload();
      }
    });
  }
  /**
   * Handle UI notification events
   * @param {Object} message The notification message
   */
  handleNotification(message) {
    if (message && message.data) {
      const content = message.data.message || "System notification";
      const duration = message.data.duration || 3e3;
      this.showNotification(content, duration);
    }
  }
  /**
   * Handle game over event
   * @param {Object} message Event data
   */
  handleGameOver(message) {
  }
  update() {
    if (this.hud && this.hud.update) {
      this.hud.update();
    }
    if (this.miningDisplay && this.miningDisplay.update) {
      this.miningDisplay.update();
    }
    if (this.isMobile && this.controls && this.controls.touchControls) {
      this.controls.touchControls.update();
    }
  }
  updateLocation(locationName) {
    let systemName = "Unknown System";
    if (this.environment && this.environment.starSystemGenerator) {
      const systemData = this.environment.starSystemGenerator.getCurrentSystemData();
      systemName = systemData ? systemData.name : "Unknown System";
    }
    if (this.hud && this.hud.updateLocation) {
      this.hud.updateLocation(null, systemName);
    }
  }
  updateCoordinates(x, y, z) {
    if (this.hud && this.hud.updateCoordinates) {
      this.hud.updateCoordinates(x, y, z);
    }
  }
  updateFPS(fps, cap) {
    if (this.hud && this.hud.updateFPS) {
      this.hud.updateFPS(fps, cap);
      if (this.settings && this.settings.settings) {
        const fpsDisplay = document.getElementById("fps-display");
        if (fpsDisplay) {
          fpsDisplay.style.display = this.settings.settings.showFPS ? "block" : "none";
        }
      }
    }
  }
  /**
   * Show a notification message to the user
   * @param {string} message - The message to display
   * @param {number} duration - Time in milliseconds to show the notification
   */
  showNotification(message, duration = 3e3) {
    const notificationsArea = document.getElementById("notifications-area");
    if (!notificationsArea) return;
    const notification = document.createElement("div");
    notification.className = "notification";
    notification.textContent = message;
    notification.style.backgroundColor = "rgba(6, 22, 31, 0.7)";
    notification.style.backdropFilter = "blur(5px)";
    notification.style.color = "rgba(120, 220, 232, 0.9)";
    notification.style.padding = "8px 15px";
    notification.style.borderRadius = "5px";
    notification.style.marginBottom = "10px";
    notification.style.border = "1px solid rgba(120, 220, 232, 0.3)";
    notification.style.boxShadow = "0 0 10px rgba(120, 220, 232, 0.2)";
    notification.style.textAlign = "center";
    notification.style.opacity = "0";
    notification.style.transition = "opacity 0.3s";
    notificationsArea.appendChild(notification);
    setTimeout(() => {
      notification.style.opacity = "1";
    }, 10);
    setTimeout(() => {
      notification.style.opacity = "0";
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, duration);
  }
  showGameOver(resources, message) {
    console.log("Showing game over screen");
    console.log("Resources data:", resources);
    if (this.gameOverScreen && this.gameOverScreen.show) {
      if (!document.getElementById("game-over-container")) {
        console.warn("Game over container not found in DOM, recreating");
        this.gameOverScreen.setupGameOverScreen();
      }
      if (this.audio) {
        this.gameOverScreen.audio = this.audio;
      }
      this.gameOverScreen.show(resources, message);
    } else {
      console.error("Game over screen not properly initialized");
      const fallbackOverlay = document.createElement("div");
      fallbackOverlay.id = "fallback-overlay";
      fallbackOverlay.style.position = "fixed";
      fallbackOverlay.style.top = "0";
      fallbackOverlay.style.left = "0";
      fallbackOverlay.style.width = "100%";
      fallbackOverlay.style.height = "100%";
      fallbackOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
      fallbackOverlay.style.display = "flex";
      fallbackOverlay.style.justifyContent = "center";
      fallbackOverlay.style.alignItems = "center";
      fallbackOverlay.style.zIndex = "9999";
      const messageText = typeof message === "string" ? message : message && message.data && message.data.reason ? message.data.reason : "Your ship was destroyed!";
      const content = document.createElement("div");
      content.innerHTML = `
                <h1 style="color: #ff3030; font-size: 48px; margin-bottom: 20px;">GAME OVER</h1>
                <p style="color: #fff; font-size: 24px; margin-bottom: 30px;">${messageText}</p>
                <button id="restart-btn" style="padding: 15px 30px; background-color: #ff3030; color: #fff; border: none; 
                    font-size: 24px; cursor: pointer; border-radius: 5px;">RESTART GAME</button>
            `;
      fallbackOverlay.appendChild(content);
      document.body.appendChild(fallbackOverlay);
      document.getElementById("restart-btn").addEventListener("click", () => {
        location.reload();
      });
    }
    this.hideUI();
  }
  hideUI() {
    console.log("Hiding UI elements");
    if (window.game && window.game.introSequenceActive) {
      console.log("Intro sequence active - forcing ALL UI elements to be hidden");
      const elements = [
        document.getElementById("hud-container"),
        document.getElementById("mobile-hud-container"),
        document.getElementById("pointer-lock-instructions"),
        document.getElementById("notifications-area")
      ];
      elements.forEach((element) => {
        if (element) {
          element.style.display = "none";
        }
      });
      const allPanels = document.querySelectorAll(".ui-panel, .panel, .hud-panel, .status-panel");
      allPanels.forEach((panel) => {
        panel.style.display = "none";
      });
      return;
    }
    if (this.hud && this.hud.hide) {
      this.hud.hide();
    }
    if (this.miningDisplay && this.miningDisplay.hide) {
      this.miningDisplay.hide();
    }
    if (this.targetingUI && this.targetingUI.hideLockOn) {
      this.targetingUI.hideLockOn();
    }
    if (this.targetingUI && this.targetingUI.hideTargetInfo) {
      this.targetingUI.hideTargetInfo();
    }
    if (this.stargateInterface && this.stargateInterface.hideDockingPrompt) {
      this.stargateInterface.hideDockingPrompt();
    }
    if (this.isMobile && this.controls && this.controls.touchControls) {
      this.controls.touchControls.hide();
    }
  }
  showUI() {
    console.log("Showing UI elements");
    if (window.game && window.game.introSequenceActive) {
      console.warn("showUI called while intro is still active - not showing UI elements");
      return;
    }
    if (this.startScreen && this.startScreen.isVisible) {
      console.warn("showUI called while start screen is visible - not showing UI elements");
      return;
    }
    if (this.hud && this.hud.show) {
      console.log("Calling hud.show()");
      this.hud.show();
    }
    if (this.miningDisplay && this.miningDisplay.show) {
      this.miningDisplay.show();
    }
    if (this.isMobile && this.controls && this.controls.touchControls) {
      this.controls.touchControls.show();
    }
    if (window.game && window.game.introSequenceActive) {
      return;
    }
    console.log("Forcing all UI elements to be displayed");
    const hudContainer = document.getElementById("hud-container");
    if (hudContainer) {
      console.log("Setting hudContainer to display:block");
      hudContainer.style.display = "block";
      hudContainer.style.visibility = "visible";
    } else {
      console.warn("HUD container not found - could not make visible");
    }
    const mobileHudContainer = document.getElementById("mobile-hud-container");
    if (mobileHudContainer) {
      mobileHudContainer.style.display = "block";
      mobileHudContainer.style.visibility = "visible";
    }
    const pointerLockInstructions = document.getElementById("pointer-lock-instructions");
    if (pointerLockInstructions && !document.pointerLockElement) {
      pointerLockInstructions.style.display = "block";
      pointerLockInstructions.style.visibility = "visible";
    }
    const notificationsArea = document.getElementById("notifications-area");
    if (notificationsArea) {
      notificationsArea.style.display = "block";
      notificationsArea.style.visibility = "visible";
    }
    const allPanels = document.querySelectorAll(".ui-panel, .panel, .hud-panel, .status-panel");
    allPanels.forEach((panel) => {
      if (panel.id !== "target-info") {
        panel.style.display = "block";
      }
      panel.style.visibility = "visible";
    });
  }
  /**
   * Initialize performance monitor for debugging
   */
  initializePerformanceMonitor() {
    const statsContainer = document.createElement("div");
    statsContainer.id = "performance-stats";
    statsContainer.style.position = "fixed";
    statsContainer.style.bottom = "10px";
    statsContainer.style.right = "10px";
    statsContainer.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    statsContainer.style.color = "#0ff";
    statsContainer.style.padding = "10px";
    statsContainer.style.fontFamily = "monospace";
    statsContainer.style.fontSize = "12px";
    statsContainer.style.borderRadius = "4px";
    statsContainer.style.zIndex = "1000";
    statsContainer.style.maxWidth = "300px";
    statsContainer.style.maxHeight = "200px";
    statsContainer.style.overflow = "auto";
    const memoryStats = document.createElement("div");
    memoryStats.id = "memory-stats";
    statsContainer.appendChild(memoryStats);
    const fpsCounter = document.createElement("div");
    fpsCounter.id = "fps-counter";
    statsContainer.appendChild(fpsCounter);
    document.body.appendChild(statsContainer);
    this.statsInterval = setInterval(() => {
      memoryStats.innerHTML = MemoryStats.getReport().replace(/\n/g, "<br>");
      if (window.game && window.game.currentFPS) {
        fpsCounter.innerHTML = `FPS: ${Math.round(window.game.currentFPS)}`;
      }
    }, 1e3);
  }
  // Make sure to clean up stats interval when necessary
  onDisabled() {
    if (this.statsInterval) {
      clearInterval(this.statsInterval);
      this.statsInterval = null;
    }
  }
}
class AudioContext {
  constructor() {
    this.audioContext = null;
    this.activeNodes = /* @__PURE__ */ new Set();
    this.gcInterval = null;
    this.initializeContext();
    this.setupGarbageCollection();
  }
  // Initialize Web Audio API context with compatibility
  initializeContext() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      console.log("Web Audio API context created successfully");
    } catch (error) {
      console.error("Failed to create Web Audio API context:", error);
    }
  }
  // Resume audio context on user interaction
  resumeAudioContext() {
    if (this.audioContext && this.audioContext.state === "suspended") {
      return this.audioContext.resume().then(() => {
        console.log("AudioContext resumed successfully");
      }).catch((error) => {
        console.error("Failed to resume AudioContext:", error);
      });
    }
    return Promise.resolve();
  }
  // Get the audio context instance
  getContext() {
    return this.audioContext;
  }
  // Check if context is available and ready
  isReady() {
    return this.audioContext && this.audioContext.state !== "closed";
  }
  // Set up regular garbage collection for unused audio nodes
  setupGarbageCollection() {
    this.gcInterval = setInterval(() => this.cleanupInactiveNodes(), 3e4);
    console.log("Audio garbage collection scheduled");
  }
  // Clean up inactive audio nodes to prevent memory leaks
  cleanupInactiveNodes() {
    let count = 0;
    this.activeNodes.forEach((node) => {
      if (node._inactive || node.disposed === true) {
        this.activeNodes.delete(node);
        count++;
      }
    });
    if (count > 0) {
      console.log(`Audio context: cleaned up ${count} inactive audio objects`);
    }
  }
  // Track an audio node for garbage collection
  trackNode(node) {
    if (node) {
      this.activeNodes.add(node);
    }
    return node;
  }
  // Initialize a minimal Tone.js compatibility layer for the intro sequence
  initializeToneCompatibility() {
    this.masterEQ = {
      // Dummy connect method that returns the input
      connect: function(node) {
        return node;
      }
    };
    console.log("Audio compatibility layer initialized for intro sequence");
    return this.masterEQ;
  }
  // Clean up context and resources
  cleanup() {
    console.log("Cleaning up AudioContext resources...");
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
      this.gcInterval = null;
    }
    if (this.audioContext) {
      return this.audioContext.close().then(() => {
        console.log("AudioContext closed successfully");
        this.audioContext = null;
      }).catch((error) => {
        console.error("Error closing AudioContext:", error);
      });
    }
    return Promise.resolve();
  }
}
class AudioLoader {
  constructor(audioContextManager) {
    this.audioContextManager = audioContextManager;
    this.sounds = {};
  }
  // Helper method to handle paths correctly for both local and GitHub Pages deployment
  getPath(relativePath) {
    return getAbsolutePath(relativePath);
  }
  // Load and decode a sound file using Web Audio API
  async loadAndDecodeSound(name, url) {
    try {
      console.log(`Loading and decoding sound: ${name} from ${url}`);
      const audioContext = this.audioContextManager.getContext();
      if (!audioContext) {
        throw new Error("AudioContext not available");
      }
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch sound ${name}: ${response.status} ${response.statusText}`);
      }
      const audioData = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(audioData);
      this.sounds[name] = audioBuffer;
      console.log(`Sound ${name} loaded and decoded successfully`);
      return audioBuffer;
    } catch (error) {
      console.error(`Error loading and decoding sound ${name}:`, error);
      this.sounds[name] = null;
      throw error;
    }
  }
  // Pre-decode only essential UI sounds for quick startup
  async preDecodeEssentialSounds() {
    try {
      console.log("Pre-decoding essential UI sounds...");
      const essentialSounds = [
        { name: "boink", path: "sounds/effects/boink.wav" },
        { name: "phaserUp", path: "sounds/effects/phaserUp.wav" },
        { name: "phaserDown", path: "sounds/effects/phaserDown.wav" }
      ];
      const loadPromises = essentialSounds.map(
        (sound) => this.loadAndDecodeSound(sound.name, this.getPath(sound.path))
      );
      await Promise.all(loadPromises);
      console.log("Essential UI sounds pre-decoded successfully");
    } catch (error) {
      console.error("Error pre-decoding essential sounds:", error);
      this.createDummySounds();
    }
  }
  // Load remaining gameplay sounds in the background
  async loadGameplaySounds() {
    try {
      console.log("Loading gameplay sounds in background...");
      const gameplaySounds = [
        { name: "thrust", path: "sounds/effects/thrust.wav" },
        { name: "laser", path: "sounds/effects/laser.wav" },
        { name: "mining-laser", path: "sounds/effects/mining-laser.wav" },
        { name: "explosion", path: "sounds/effects/explosion.wav" }
      ];
      for (const sound of gameplaySounds) {
        try {
          await this.loadAndDecodeSound(sound.name, this.getPath(sound.path));
        } catch (err) {
          console.warn(`Could not load gameplay sound ${sound.name}:`, err);
        }
      }
      if (this.sounds.laser && !this.sounds.projectile) {
        console.log("Setting up projectile sound using laser sound buffer");
        this.sounds.projectile = this.sounds.laser;
      }
      console.log("All gameplay sounds loaded successfully");
    } catch (error) {
      console.error("Error loading gameplay sounds:", error);
    }
  }
  // Create dummy sounds if loading fails
  createDummySounds() {
    console.warn("Creating dummy silent AudioBuffers as fallback");
    const soundEffects = ["laser", "thrust", "explosion", "boink", "phaserUp", "phaserDown", "mining-laser", "projectile"];
    const audioContext = this.audioContextManager.getContext();
    for (const name of soundEffects) {
      if (audioContext) {
        try {
          const buffer = audioContext.createBuffer(
            2,
            // stereo
            audioContext.sampleRate * 0.1,
            // 0.1 seconds
            audioContext.sampleRate
          );
          this.sounds[name] = buffer;
        } catch (error) {
          console.error(`Failed to create dummy buffer for ${name}:`, error);
          this.sounds[name] = null;
        }
      } else {
        this.sounds[name] = null;
      }
    }
  }
  // Helper method to check if a file exists
  async checkFileExists(path) {
    console.log(`Checking if file/directory exists: ${path}`);
    try {
      const response = await fetch(path, {
        method: "HEAD",
        cache: "no-cache"
        // Avoid caching issues
      });
      console.log(`Fetch response for ${path}: status=${response.status}, ok=${response.ok}`);
      return {
        path,
        exists: response.ok
      };
    } catch (err) {
      console.error(`Error checking if file exists (${path}):`, err);
      return { path, exists: false };
    }
  }
  // Check if the required sound directories exist and notify user if they don't
  async checkSoundDirectories() {
    const soundsDirExists = await this.checkFileExists(this.getPath("sounds"));
    if (!soundsDirExists.exists) {
      console.warn("Sounds directory not found, but will attempt to load files directly anyway.");
    }
    const soundtrackDirExists = await this.checkFileExists(this.getPath("sounds/soundtrack"));
    if (!soundtrackDirExists.exists) {
      console.warn("Soundtrack directory not found, but will attempt to load files directly anyway.");
    }
    const effectsDirExists = await this.checkFileExists(this.getPath("sounds/effects"));
    if (!effectsDirExists.exists) {
      console.warn("Sound effects directory not found. Some sounds may not play correctly.");
    }
    return true;
  }
  // Get a loaded sound buffer
  getSound(name) {
    return this.sounds[name];
  }
  // Get all loaded sounds
  getAllSounds() {
    return this.sounds;
  }
}
class MusicPlaylist {
  constructor() {
    this.music = [];
    this.musicVolume = 0.21;
  }
  // Helper method to handle paths correctly for both local and GitHub Pages deployment
  getPath(relativePath) {
    return getAbsolutePath(relativePath);
  }
  // Fisher-Yates shuffle algorithm for arrays
  shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex > 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
  }
  // Helper method to check if a file exists
  async checkFileExists(path) {
    console.log(`Checking if file/directory exists: ${path}`);
    try {
      const response = await fetch(path, {
        method: "HEAD",
        cache: "no-cache"
        // Avoid caching issues
      });
      console.log(`Fetch response for ${path}: status=${response.status}, ok=${response.ok}`);
      return {
        path,
        exists: response.ok
      };
    } catch (err) {
      console.error(`Error checking if file exists (${path}):`, err);
      return { path, exists: false };
    }
  }
  // Load all music files from the soundtrack folder
  async loadBackgroundMusic() {
    try {
      console.log("Loading soundtrack files...");
      const soundtrackFiles = [
        this.getPath("sounds/soundtrack/The Sound of Lightyears.wav"),
        this.getPath("sounds/soundtrack/Aurora Drifts.wav"),
        this.getPath("sounds/soundtrack/Tidal Lock.wav"),
        this.getPath("sounds/soundtrack/Solar Drift.wav"),
        this.getPath("sounds/soundtrack/Orbital Resonance.wav"),
        this.getPath("sounds/soundtrack/Starlight Trails.wav"),
        this.getPath("sounds/soundtrack/Orbit Bloom.wav")
      ];
      console.log(`Loading ${soundtrackFiles.length} soundtrack files...`);
      await this.loadMusicFiles(soundtrackFiles);
    } catch (error) {
      console.error("Error loading background music:", error);
      console.warn("Falling back to a dummy silent track");
      const dummyAudio = new Audio();
      dummyAudio.loop = true;
      this.music.push(dummyAudio);
    }
  }
  // Helper method to load music files
  async loadMusicFiles(files) {
    console.log(`Found ${files.length} music files:`, files);
    const shuffledFiles = [...files];
    this.shuffleArray(shuffledFiles);
    console.log(`Randomized playlist order:`, shuffledFiles.map((file) => file.split("/").pop()));
    let anyFilesExist = false;
    for (const file of shuffledFiles) {
      const fileExists = await this.checkFileExists(file);
      if (fileExists.exists) {
        anyFilesExist = true;
        break;
      }
    }
    if (!anyFilesExist) {
      console.warn("None of the music files could be found. Using fallback audio.");
      this.createDummyTrack();
      return;
    }
    for (const file of shuffledFiles) {
      try {
        console.log(`Attempting to load audio file: ${file}`);
        const audio = new Audio(file);
        audio.loop = false;
        audio.volume = this.musicVolume;
        audio.addEventListener("error", (e) => {
          console.error(`Error loading music file ${file}:`, e);
        });
        audio.addEventListener("canplaythrough", () => {
          console.log(`Successfully loaded music file: ${file}`);
        });
        this.music.push(audio);
        console.log(`Added music track to playlist: ${file}`);
      } catch (err) {
        console.error(`Failed to load music file ${file}:`, err);
      }
    }
    console.log(`Loaded ${this.music.length} music tracks in randomized order`);
    if (this.music.length === 0) {
      console.warn("No music files could be loaded, creating a dummy track");
      this.createDummyTrack();
    }
  }
  // Create dummy track if loading fails
  createDummyTrack() {
    const dummyAudio = new Audio();
    dummyAudio.loop = true;
    this.music.push(dummyAudio);
  }
  // Play the next music track in the playlist
  playNextTrack() {
    if (this.music.length === 0) return null;
    const currentTrack = this.music.shift();
    this.music.push(currentTrack);
    return this.getCurrentTrack();
  }
  // Get the current track (first in queue)
  getCurrentTrack() {
    return this.music.length > 0 ? this.music[0] : null;
  }
  // Get all tracks
  getTracks() {
    return this.music;
  }
  // Set volume for all tracks
  setVolume(volume) {
    this.musicVolume = volume;
    for (const track of this.music) {
      track.volume = volume;
    }
  }
  // Get current volume
  getVolume() {
    return this.musicVolume;
  }
  // Check if playlist has tracks
  hasTracks() {
    return this.music.length > 0;
  }
}
class MusicPlayer {
  constructor(playlist) {
    this.playlist = playlist;
    this.currentMusic = null;
    this.muted = false;
  }
  // Start playing background music
  playBackgroundMusic(userHasInteracted) {
    if (!this.playlist.hasTracks() || this.muted) return;
    if (!userHasInteracted) {
      console.log("Deferring music playback until user interaction");
      return;
    }
    const track = this.playlist.getCurrentTrack();
    if (!track) return;
    console.log(`Starting to play track: ${track.src.split("/").pop()}`);
    if (!track.hasEndedListener) {
      track.addEventListener("ended", () => this.playNextTrack(userHasInteracted));
      track.hasEndedListener = true;
    }
    track.currentTime = 0;
    const playPromise = track.play();
    if (playPromise !== void 0) {
      playPromise.then(() => {
        console.log("Started playing background music");
        this.currentMusic = track;
      }).catch((err) => {
        if (err.name === "NotAllowedError") {
          console.log("Autoplay prevented by browser. Music will play after user interaction.");
        } else {
          console.error("Error playing background music:", err);
        }
      });
    } else {
      this.currentMusic = track;
    }
  }
  // Play the next track in the playlist
  playNextTrack(userHasInteracted) {
    const nextTrack = this.playlist.playNextTrack();
    if (nextTrack && userHasInteracted) {
      this.playBackgroundMusic(userHasInteracted);
    }
  }
  // Toggle mute for music
  toggleMute() {
    this.muted = !this.muted;
    const tracks = this.playlist.getTracks();
    for (const track of tracks) {
      track.volume = this.muted ? 0 : this.playlist.getVolume();
    }
    console.log(`Music ${this.muted ? "muted" : "unmuted"}`);
    return this.muted;
  }
  // Set music volume
  setVolume(volume) {
    this.playlist.setVolume(this.muted ? 0 : volume);
  }
  // Get current music volume
  getVolume() {
    return this.playlist.getVolume();
  }
  // Check if music is muted
  isMuted() {
    return this.muted;
  }
  // Pause all music
  pauseAll() {
    const tracks = this.playlist.getTracks();
    for (const track of tracks) {
      track.pause();
    }
    this.currentMusic = null;
  }
  // Get current playing track
  getCurrentTrack() {
    return this.currentMusic;
  }
}
class SoundPlayer {
  constructor(audioContextManager, audioLoader) {
    this.audioContextManager = audioContextManager;
    this.audioLoader = audioLoader;
    this.sfxVolume = 0.5;
    this.muted = false;
    this.activeSounds = {
      laser: null,
      thrust: null,
      "mining-laser": null
    };
  }
  // Play a sound effect using Web Audio API
  playSound(name, userHasInteracted) {
    console.log(`Attempting to play sound: ${name}`);
    if (this.muted) {
      console.log(`Sound ${name} not played: audio is muted`);
      return;
    }
    if (!userHasInteracted) {
      console.log(`Sound ${name} not played: waiting for user interaction`);
      return;
    }
    const audioContext = this.audioContextManager.getContext();
    if (audioContext && audioContext.state === "suspended") {
      this.audioContextManager.resumeAudioContext();
    }
    if (name === "weapon" || name === "fire" || name === "shoot") {
      console.log(`Mapping ${name} sound to projectile sound`);
      name = "projectile";
      const sounds = this.audioLoader.getAllSounds();
      if (!sounds.projectile && sounds.laser) {
        console.log("Using laser sound for projectile");
        sounds.projectile = sounds.laser;
      }
    }
    const soundBuffer = this.audioLoader.getSound(name);
    if (!soundBuffer) {
      console.warn(`Sound "${name}" not found in loaded sounds`);
      return;
    }
    try {
      if (name === "laser" || name === "thrust" || name === "mining-laser") {
        if (!this.activeSounds[name]) {
          const sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = soundBuffer;
          sourceNode.loop = true;
          const gainNode = audioContext.createGain();
          gainNode.gain.value = this.sfxVolume * (name === "thrust" ? 1.5 : 1);
          sourceNode.connect(gainNode);
          gainNode.connect(audioContext.destination);
          sourceNode.start(0);
          this.activeSounds[name] = {
            source: sourceNode,
            gain: gainNode
          };
          this.audioContextManager.trackNode(sourceNode);
          this.audioContextManager.trackNode(gainNode);
        }
      } else {
        const sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = soundBuffer;
        const gainNode = audioContext.createGain();
        const volumeMultiplier = name === "projectile" ? 0.7 : 0.5;
        gainNode.gain.value = this.sfxVolume * volumeMultiplier;
        sourceNode.connect(gainNode);
        gainNode.connect(audioContext.destination);
        sourceNode.start(0);
        sourceNode.onended = () => {
          sourceNode._inactive = true;
          gainNode._inactive = true;
        };
        this.audioContextManager.trackNode(sourceNode);
        this.audioContextManager.trackNode(gainNode);
        console.log(`Started playback of one-shot sound: ${name}`);
      }
    } catch (err) {
      console.error(`Error playing sound ${name}:`, err);
    }
  }
  // Stop a continuous sound effect
  stopSound(name) {
    if (!this.activeSounds[name]) return;
    try {
      if (name === "laser" || name === "thrust" || name === "mining-laser") {
        if (this.activeSounds[name]) {
          const nodes = this.activeSounds[name];
          if (nodes.source) {
            try {
              nodes.source.stop();
            } catch (e) {
            }
            nodes.source._inactive = true;
          }
          if (nodes.gain) {
            nodes.gain._inactive = true;
          }
          this.activeSounds[name] = null;
        }
      }
    } catch (err) {
      console.error(`Error stopping sound ${name}:`, err);
    }
  }
  // Set the volume for thrust sound based on thrust level
  setThrustVolume(thrustLevel) {
    if (!this.activeSounds.thrust || !this.activeSounds.thrust.gain) return;
    const volume = Math.min(1, Math.max(0.1, thrustLevel)) * this.sfxVolume * 1.5;
    try {
      this.activeSounds.thrust.gain.gain.value = volume;
    } catch (err) {
      console.error("Error setting thrust volume:", err);
    }
  }
  // Play weapon firing sound - dedicated method for weapon sounds
  playWeaponSound(userHasInteracted) {
    console.log("Playing weapon firing sound");
    if (this.muted || !userHasInteracted) {
      return;
    }
    const audioContext = this.audioContextManager.getContext();
    if (audioContext && audioContext.state === "suspended") {
      this.audioContextManager.resumeAudioContext();
    }
    const sounds = this.audioLoader.getAllSounds();
    if (!sounds.projectile && sounds.laser) {
      console.log("Using laser sound for projectile in playWeaponSound");
      sounds.projectile = sounds.laser;
    }
    if (!sounds.projectile) {
      console.warn("Projectile sound not found");
      return;
    }
    try {
      const sourceNode = audioContext.createBufferSource();
      sourceNode.buffer = sounds.projectile;
      const gainNode = audioContext.createGain();
      gainNode.gain.value = this.sfxVolume * 0.8;
      sourceNode.connect(gainNode);
      gainNode.connect(audioContext.destination);
      sourceNode.start(0);
      sourceNode.onended = () => {
        sourceNode._inactive = true;
        gainNode._inactive = true;
      };
      this.audioContextManager.trackNode(sourceNode);
      this.audioContextManager.trackNode(gainNode);
      console.log("Weapon sound started playing");
    } catch (err) {
      console.error("Error playing weapon sound:", err);
    }
  }
  // Toggle mute for sound effects
  toggleMute() {
    this.muted = !this.muted;
    if (this.muted) {
      this.stopSound("laser");
      this.stopSound("thrust");
      this.stopSound("mining-laser");
    }
    console.log(`Sound effects ${this.muted ? "muted" : "unmuted"}`);
    return this.muted;
  }
  // Set sound effects volume
  setVolume(volume) {
    this.sfxVolume = volume;
  }
  // Get sound effects volume
  getVolume() {
    return this.sfxVolume;
  }
  // Check if sound effects are muted
  isMuted() {
    return this.muted;
  }
  // Stop all active sounds
  stopAllSounds() {
    this.stopSound("laser");
    this.stopSound("thrust");
    this.stopSound("mining-laser");
  }
}
class MobileAudioEnabler {
  constructor(audioContextManager, musicPlayer) {
    this.audioContextManager = audioContextManager;
    this.musicPlayer = musicPlayer;
    this.userHasInteracted = false;
    this.setupUserInteractionListener();
  }
  // Check if user has interacted
  hasUserInteracted() {
    return this.userHasInteracted;
  }
  // Show a notification to the user when a directory is missing
  showDirectoryMissingNotification(directory) {
    console.warn(`Directory not found: ${directory}`);
    const notification = document.createElement("div");
    notification.style.position = "fixed";
    notification.style.top = "20px";
    notification.style.left = "50%";
    notification.style.transform = "translateX(-50%)";
    notification.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    notification.style.color = "#ff4400";
    notification.style.padding = "10px 15px";
    notification.style.borderRadius = "5px";
    notification.style.zIndex = "9999";
    notification.style.fontSize = "14px";
    notification.style.maxWidth = "80%";
    notification.style.textAlign = "center";
    notification.innerHTML = `
            <div style="margin-bottom: 5px;">
                <strong>Note:</strong> ${directory} directory not found.
            </div>
            <div style="font-size: 12px; color: #aaa;">
                Game will continue with limited audio. This is normal when running on GitHub Pages.
            </div>
        `;
    const closeButton = document.createElement("div");
    closeButton.style.position = "absolute";
    closeButton.style.top = "5px";
    closeButton.style.right = "10px";
    closeButton.style.cursor = "pointer";
    closeButton.style.color = "#aaa";
    closeButton.textContent = "✕";
    closeButton.addEventListener("click", () => notification.remove());
    notification.appendChild(closeButton);
    document.body.appendChild(notification);
    setTimeout(() => {
      if (document.body.contains(notification)) {
        notification.style.opacity = "0";
        notification.style.transition = "opacity 0.5s ease";
        setTimeout(() => {
          if (document.body.contains(notification)) {
            notification.remove();
          }
        }, 500);
      }
    }, 5e3);
  }
  // Set up a listener to detect the first user interaction
  setupUserInteractionListener() {
    const handleInteraction = () => {
      if (!this.userHasInteracted) {
        this.userHasInteracted = true;
        console.log("User interaction detected, enabling audio playback");
        this.audioContextManager.resumeAudioContext();
        this.musicPlayer.playBackgroundMusic(true);
        document.removeEventListener("click", handleInteraction);
        document.removeEventListener("keydown", handleInteraction);
        document.removeEventListener("touchstart", handleInteraction);
      }
    };
    document.addEventListener("click", handleInteraction);
    document.addEventListener("keydown", handleInteraction);
    document.addEventListener("touchstart", handleInteraction);
    if ("ontouchstart" in window || navigator.maxTouchPoints > 0) {
      console.log("Mobile device detected - adding additional audio handlers");
      const forceAudioResume = () => {
        this.userHasInteracted = true;
        this.audioContextManager.resumeAudioContext();
        const playlist = this.musicPlayer.playlist;
        if (playlist.hasTracks() && !this.musicPlayer.isMuted()) {
          const currentTrack = playlist.getCurrentTrack();
          if (currentTrack && currentTrack.paused) {
            console.log("Mobile: Forcing background music playback");
            this.musicPlayer.playBackgroundMusic(true);
          }
        }
      };
      document.addEventListener("touchend", forceAudioResume, { passive: true });
      const attachToButtons = () => {
        let attempts = 0;
        const interval = setInterval(() => {
          attempts++;
          const actionButtons = document.querySelectorAll("button");
          if (actionButtons.length > 0) {
            console.log(`Mobile: Found ${actionButtons.length} buttons to attach audio handlers`);
            actionButtons.forEach((button) => {
              if (!button.hasAudioHandler) {
                button.addEventListener("touchend", forceAudioResume, { passive: true });
                button.hasAudioHandler = true;
              }
            });
          }
          if (attempts >= 10) {
            clearInterval(interval);
          }
        }, 500);
      };
      attachToButtons();
      if (document.readyState === "complete") {
        attachToButtons();
      } else {
        window.addEventListener("load", attachToButtons);
      }
    }
  }
  // Clean up event listeners
  cleanup() {
    this.userHasInteracted = false;
    console.log("Mobile audio enabler cleanup complete");
  }
}
class AudioManager {
  constructor() {
    this.audioContextManager = new AudioContext();
    this.audioLoader = new AudioLoader(this.audioContextManager);
    this.musicPlaylist = new MusicPlaylist();
    this.musicPlayer = new MusicPlayer(this.musicPlaylist);
    this.soundPlayer = new SoundPlayer(this.audioContextManager, this.audioLoader);
    this.mobileEnabler = new MobileAudioEnabler(this.audioContextManager, this.musicPlayer);
    this.sounds = this.audioLoader.getAllSounds();
    this.soundSources = {};
    this.backgroundMusic = [];
    this.currentMusicIndex = 0;
    this.currentMusic = null;
    this.music = this.musicPlaylist.getTracks();
    this.activeNodes = this.audioContextManager.activeNodes;
    this.activeSounds = this.soundPlayer.activeSounds;
    this.masterEQ = this.audioContextManager.initializeToneCompatibility();
    console.log("Initializing audio manager with Web Audio API...");
  }
  // Getter/setter for volume properties
  get isMuted() {
    return this.soundPlayer.isMuted() || this.musicPlayer.isMuted();
  }
  set isMuted(value) {
    if (value !== this.isMuted) {
      this.toggleMute();
    }
  }
  get muted() {
    return this.isMuted;
  }
  set muted(value) {
    this.isMuted = value;
  }
  get musicVolume() {
    return this.musicPlayer.getVolume();
  }
  set musicVolume(value) {
    this.musicPlayer.setVolume(value);
  }
  get sfxVolume() {
    return this.soundPlayer.getVolume();
  }
  set sfxVolume(value) {
    this.soundPlayer.setVolume(value);
  }
  get userHasInteracted() {
    return this.mobileEnabler.hasUserInteracted();
  }
  get audioContext() {
    return this.audioContextManager.getContext();
  }
  // Initialize audio - load all sounds and music
  async initialize() {
    try {
      console.log("Loading audio files...");
      if (this.audioContext && this.audioContext.state === "suspended") {
        this.audioContextManager.resumeAudioContext();
      }
      await this.audioLoader.checkSoundDirectories();
      await this.audioLoader.preDecodeEssentialSounds();
      this.musicPlaylist.loadBackgroundMusic().catch((error) => {
        console.error("Error loading background music:", error);
      });
      console.log("Essential audio initialization complete");
      if (this.userHasInteracted) {
        this.musicPlayer.playBackgroundMusic(true);
      } else {
        console.log("Music playback waiting for user interaction.");
      }
      setTimeout(() => {
        this.audioLoader.loadGameplaySounds();
      }, 1e3);
      return true;
    } catch (error) {
      console.error("Error initializing audio:", error);
      return false;
    }
  }
  // Legacy method for compatibility
  async preDecodeAllSoundEffects() {
    console.log("Using optimized sound loading path instead of preDecodeAllSoundEffects");
    await this.audioLoader.preDecodeEssentialSounds();
    await this.audioLoader.loadGameplaySounds();
  }
  // Resume audio context on user interaction
  resumeAudioContext() {
    return this.audioContextManager.resumeAudioContext();
  }
  // Start playing background music
  playBackgroundMusic() {
    this.musicPlayer.playBackgroundMusic(this.userHasInteracted);
  }
  // Play the next music track in the playlist
  playNextTrack() {
    this.musicPlayer.playNextTrack(this.userHasInteracted);
  }
  // Play a sound effect
  playSound(name) {
    this.soundPlayer.playSound(name, this.userHasInteracted);
  }
  // Stop a continuous sound effect
  stopSound(name) {
    this.soundPlayer.stopSound(name);
  }
  // Set the volume for thrust sound based on thrust level
  setThrustVolume(thrustLevel) {
    this.soundPlayer.setThrustVolume(thrustLevel);
  }
  // Play weapon firing sound
  playWeaponSound() {
    this.soundPlayer.playWeaponSound(this.userHasInteracted);
  }
  // Toggle mute for all audio
  toggleMute() {
    const soundMuted = this.soundPlayer.toggleMute();
    const musicMuted = this.musicPlayer.toggleMute();
    const overallMuted = soundMuted || musicMuted;
    console.log(`Audio ${overallMuted ? "muted" : "unmuted"}`);
    return overallMuted;
  }
  // Track an audio node for garbage collection (legacy compatibility)
  trackNode(node) {
    return this.audioContextManager.trackNode(node);
  }
  // Clean up inactive audio nodes (legacy compatibility)
  cleanupInactiveNodes() {
    this.audioContextManager.cleanupInactiveNodes();
  }
  // Setup garbage collection (legacy compatibility)
  setupGarbageCollection() {
    console.log("Garbage collection already set up in context manager");
  }
  // Setup user interaction listener (legacy compatibility)
  setupUserInteractionListener() {
    console.log("User interaction listener already set up in mobile enabler");
  }
  // Initialize tone compatibility (legacy compatibility)
  initializeToneCompatibility() {
    return this.masterEQ;
  }
  // Clean up resources when destroying the audio manager
  cleanup() {
    console.log("Cleaning up AudioManager resources...");
    this.soundPlayer.stopAllSounds();
    this.musicPlayer.pauseAll();
    this.mobileEnabler.cleanup();
    this.audioContextManager.cleanup();
    console.log("AudioManager cleanup complete");
  }
}
export {
  AudioManager as A,
  ColorCorrectionShader as C,
  EffectComposer as E,
  FXAAShader as F,
  GLTFLoader as G,
  Physics as P,
  RenderPass as R,
  ShaderPass as S,
  UnrealBloomPass as U,
  VignetteShader as V,
  WebGL as W,
  __vitePreload as _,
  FilmShader as a,
  Renderer as b,
  Environment as c,
  Spaceship as d,
  UI as e,
  Controls as f,
  getAbsolutePath as g,
  System as h,
  combat as i
};
//# sourceMappingURL=modules-BnzCGJKr.js.map
