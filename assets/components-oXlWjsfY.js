import{_ as u}from"./game-modules-DrL_oOTa.js";import{C as o}from"./combat-Bzyirpe1.js";import{b as s,E as m,Q as y,m as d}from"./three-DEtojxaq.js";class f extends o{constructor(e=100,t=0){super(),this.maxHealth=e,this.health=e,this.maxShield=t,this.shield=t,this.shieldRegenRate=5,this.shieldRegenDelay=3,this.timeSinceLastDamage=this.shieldRegenDelay,this.damageResistance=0,this.isDestroyed=!1,this.isInvulnerable=!1,console.log(`Created health component with ${e} max health and ${t} max shield`)}onAttached(){this.entity&&this.entity.hasTag&&this.entity.hasTag("player")&&(console.log("HealthComponent attached to player entity - subscribing to sync events"),this.entity.world&&this.entity.world.messageBus?(this.entity.world.messageBus.subscribe("player.syncHealth",this.handleSyncHealth.bind(this)),this.entity.world.messageBus.subscribe("player.undocked",this.handleSyncHealth.bind(this)),console.log("Subscribed to player.syncHealth and player.undocked events")):window.mainMessageBus&&(window.mainMessageBus.subscribe("player.syncHealth",this.handleSyncHealth.bind(this)),window.mainMessageBus.subscribe("player.undocked",this.handleSyncHealth.bind(this)),console.log("Subscribed to player.syncHealth and player.undocked events via mainMessageBus")))}handleSyncHealth(e){if(!this.entity||!this.entity.hasTag||!this.entity.hasTag("player"))return;console.log("HealthComponent received syncHealth event:",e);const t=e.data||e;if(console.log("Extracted sync data:",t),t.shield!==void 0){const i=this.shield;console.log(`SHIELD SYNC: HealthComponent shield was ${i}, spaceship shield is ${t.shield}`),this.shield=t.shield,console.log(`Updated shield: ${i} → ${this.shield}`)}else console.warn("Shield value not provided in sync data");if(t.maxShield!==void 0){const i=this.maxShield;this.maxShield=t.maxShield,console.log(`Updated maxShield: ${i} → ${this.maxShield}`)}else console.warn("MaxShield value not provided in sync data");if(t.hull!==void 0){const i=this.health;this.health=t.hull,console.log(`Updated health: ${i} → ${this.health}`)}else console.warn("Hull value not provided in sync data");if(t.maxHull!==void 0){const i=this.maxHealth;this.maxHealth=t.maxHull,console.log(`Updated maxHealth: ${i} → ${this.maxHealth}`)}else console.warn("MaxHull value not provided in sync data");console.log(`HealthComponent synced: Health ${this.health}/${this.maxHealth}, Shield ${this.shield}/${this.maxShield}`)}applyDamage(e,t="projectile",i=null){if(console.log(`HealthComponent: Applying ${e} damage of type ${t} to entity ${this.entity?this.entity.id:"unknown"}`),console.log(`Current health: ${this.health}/${this.maxHealth}, Shield: ${this.shield}/${this.maxShield}`),this.isDestroyed||this.isInvulnerable)return console.log("Entity is destroyed or invulnerable, damage not applied"),{damageApplied:0,shieldDamage:0,healthDamage:0,destroyed:!1};const h=e*(1-this.damageResistance);let a=0,n=0;return this.timeSinceLastDamage=0,this.shield>0?h<=this.shield?(this.shield-=h,a=h):(a=this.shield,n=h-this.shield,this.shield=0,this.health-=n):(this.health-=h,n=h),this.health<0&&(this.health=0),this.health<=0&&!this.isDestroyed&&(this.isDestroyed=!0,this.entity&&this.entity.world&&(this.entity.world.messageBus.publish("entity.destroyed",{entity:this.entity,source:i,damageType:t}),this.entity.hasTag&&this.entity.hasTag("player")&&(console.log("PLAYER HEALTH COMPONENT DESTROYED - TRIGGERING GAME OVER"),console.log("HealthComponent: Initiating game over sequence"),this.entity&&this.entity.world&&this.entity.world.messageBus?(console.log("HealthComponent: Publishing game.over via world.messageBus"),this.entity.world.messageBus.publish("game.over",{reason:"You were pwned by a space alien!",source:"health"})):u(()=>import("./core-AGMxUAyq.js").then(l=>l.m),[]).then(l=>{const c=l.MessageBus;console.log("HealthComponent: Using MessageBus.triggerGameOver"),c.triggerGameOver("You were pwned by a space alien!","health")}).catch(l=>{console.error("Error importing MessageBus:",l)})))),this.entity&&this.entity.world&&this.entity.world.messageBus.publish("entity.damaged",{entity:this.entity,source:i,damageType:t,amount:h,shieldDamage:a,healthDamage:n}),console.log(`After damage: Health: ${this.health}/${this.maxHealth}, Shield: ${this.shield}/${this.maxShield}`),console.log(`Entity destroyed: ${this.isDestroyed}`),{damageApplied:h,shieldDamage:a,healthDamage:n,destroyed:this.isDestroyed}}heal(e){if(this.isDestroyed)return 0;const t=this.health;this.health=Math.min(this.health+e,this.maxHealth);const i=this.health-t;return i>0&&this.entity&&this.entity.world&&this.entity.world.messageBus.publish("entity.healed",{entity:this.entity,amount:i}),i}rechargeShield(e){if(this.isDestroyed)return 0;const t=this.shield;this.shield=Math.min(this.shield+e,this.maxShield);const i=this.shield-t;return i>0&&this.entity&&this.entity.world&&this.entity.world.messageBus.publish("entity.shieldRecharged",{entity:this.entity,amount:i}),i}update(e){if(!this.isDestroyed){if(this.timeSinceLastDamage+=e,this.timeSinceLastDamage>=this.shieldRegenDelay&&this.shield<this.maxShield){const t=this.shieldRegenRate*e;this.rechargeShield(t)}if(this.entity&&this.entity.hasTag("player")&&this.health<this.maxHealth){const i=this.maxHealth*.05*e;this.heal(i)}}}getHealthPercentage(){return this.health/this.maxHealth*100}getShieldPercentage(){return this.maxShield>0?this.shield/this.maxShield*100:0}upgradeHealth(e=1.25){const t=this.maxHealth;return this.maxHealth*=e,this.health=this.maxHealth,console.log(`Upgraded health from ${t.toFixed(1)} to ${this.maxHealth.toFixed(1)}`),this.entity&&this.entity.world&&this.entity.world.messageBus.publish("health.upgraded",{entity:this.entity,oldMax:t,newMax:this.maxHealth}),{maxHealth:this.maxHealth,healthBoost:this.maxHealth-t}}upgradeShield(e=1.5){console.log("===== SHIELD UPGRADE INITIATED ====="),console.log(`Current shield values - Max: ${this.maxShield}, Current: ${this.shield}`);const t=this.maxShield,i=this.shield;return this.maxShield=Math.ceil(this.maxShield*e),this.shield=this.maxShield,console.log(`Upgraded shield from ${t.toFixed(1)} to ${this.maxShield.toFixed(1)}`),console.log(`Current shield value changed from ${i.toFixed(1)} to ${this.shield.toFixed(1)}`),console.log("===== SHIELD UPGRADE COMPLETED ====="),this.entity&&this.entity.world&&this.entity.world.messageBus.publish("shield.upgraded",{entity:this.entity,oldMax:t,newMax:this.maxShield}),{maxShield:this.maxShield,shieldBoost:this.maxShield-t}}}class w extends o{constructor(e=new s,t=new m,i=new s(1,1,1)){super(),this.position=e.clone(),this.rotation=t.clone(),this.scale=i.clone(),this.quaternion=new y().setFromEuler(this.rotation),this.matrix=new d,this.needsUpdate=!0}setPosition(e,t,i){return this.position.set(e,t,i),this.needsUpdate=!0,this}setRotation(e,t,i){return this.rotation.set(e,t,i),this.quaternion.setFromEuler(this.rotation),this.needsUpdate=!0,this}setQuaternion(e){return this.quaternion.copy(e),this.rotation.setFromQuaternion(this.quaternion),this.needsUpdate=!0,this}setScale(e,t,i){return this.scale.set(e,t,i),this.needsUpdate=!0,this}lookAt(e){const t=new d;return t.lookAt(this.position,e,new s(0,1,0)),this.quaternion.setFromRotationMatrix(t),this.rotation.setFromQuaternion(this.quaternion),this.needsUpdate=!0,this}updateMatrix(){return this.needsUpdate&&(this.matrix.compose(this.position,this.quaternion,this.scale),this.needsUpdate=!1),this.matrix}getWorldPosition(){return this.position.clone()}getForwardVector(){const e=new s(0,0,-1);return e.applyQuaternion(this.quaternion),e}getRightVector(){const e=new s(1,0,0);return e.applyQuaternion(this.quaternion),e}getUpVector(){const e=new s(0,1,0);return e.applyQuaternion(this.quaternion),e}}class H extends o{constructor(e=1){super(),this.velocity=new s,this.angularVelocity=new s,this.mass=e,this.drag=.01,this.angularDrag=.01,this.useGravity=!1,this.isKinematic=!1,this.freezeRotation=!1,this.forces=new s,this.torque=new s,this.collisionRadius=1,this.isTrigger=!1}resetForces(){this.forces.set(0,0,0),this.torque.set(0,0,0)}applyForce(e,t=null){if(!this.isKinematic&&(this.forces.add(e),t)){const i=this.entity.getComponent("TransformComponent");if(i){const a=t.clone().sub(i.position).cross(e);this.applyTorque(a)}}}applyImpulse(e){if(this.isKinematic)return;const t=e.clone().divideScalar(this.mass);this.velocity.add(t)}applyTorque(e){this.isKinematic||this.freezeRotation||this.torque.add(e)}setVelocity(e){this.velocity.copy(e)}setAngularVelocity(e){this.freezeRotation||this.angularVelocity.copy(e)}}export{f as H,H as R,w as T};
//# sourceMappingURL=components-oXlWjsfY.js.map
