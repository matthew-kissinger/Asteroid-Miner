{"version":3,"file":"core-BKht4hCZ.js","sources":["../../js/core/events.js","../../js/core/messageBus.js"],"sourcesContent":["// events.js - typed events enum + optional dev validation\r\n\r\nexport const EVENT = Object.freeze({\r\n  GAME_OVER: 'game.over',\r\n  PLAYER_CREATED: 'player.created',\r\n  TRANSFORM_UPDATED: 'transform.updated',\r\n  VFX_EXPLOSION: 'vfx.explosion',\r\n  MINING_START: 'player.mining.start',\r\n  MINING_STOP: 'player.mining.stop',\r\n  ENEMY_DESTROYED: 'enemy.destroyed',\r\n  WEAPON_FIRED: 'weapon.fired',\r\n});\r\n\r\nconst SCHEMA = {\r\n  [EVENT.GAME_OVER]: { reason: 'string' },\r\n  [EVENT.PLAYER_CREATED]: { entity: 'object' },\r\n  [EVENT.TRANSFORM_UPDATED]: { entity: 'object' },\r\n  [EVENT.VFX_EXPLOSION]: { position: 'object', color: 'number', size: 'number', duration: 'number' },\r\n  [EVENT.MINING_START]: { sourceEntity: 'object', targetEntity: 'object' },\r\n  [EVENT.MINING_STOP]: { sourceEntity: 'object' },\r\n  [EVENT.ENEMY_DESTROYED]: { entityId: 'string' },\r\n  [EVENT.WEAPON_FIRED]: { entity: 'object' },\r\n};\r\n\r\nexport function validateEventPayload(type, data) {\r\n  if (!window || !window.DEBUG_MODE) return true;\r\n  const shape = SCHEMA[type];\r\n  if (!shape) return true;\r\n  if (typeof data !== 'object' || data == null) return warn(type, 'payload is not object');\r\n  for (const [key, t] of Object.entries(shape)) {\r\n    const v = data[key];\r\n    if (t === 'object') {\r\n      if (typeof v !== 'object' || v == null) return warn(type, `field ${key} must be object`);\r\n    } else if (typeof v !== t) {\r\n      return warn(type, `field ${key} must be ${t}`);\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction warn(type, msg) {\r\n  console.warn(`[EVENT VALIDATION] ${type}: ${msg}`);\r\n  return false;\r\n}\r\n\r\n\r\n","/**\r\n * MessageBus - Event system for decoupled communication between systems\r\n * \r\n * The MessageBus enables systems to communicate without direct references\r\n * by publishing and subscribing to specific message types.\r\n */\r\n\r\nimport { validateEventPayload } from './events.js';\r\n\r\nexport class MessageBus {\r\n    constructor() {\r\n        this.listeners = new Map();\r\n        this.queuedMessages = [];\r\n        this.dispatching = false;\r\n        \r\n        // High-frequency message types to minimize logging\r\n        this.highFrequencyTypes = new Set([\r\n            'transform.updated',\r\n            'physics.update',\r\n            'render.update'\r\n        ]);\r\n        \r\n        // Store this instance in a global registry for emergency access\r\n        if (!window.messageRegistry) {\r\n            window.messageRegistry = new Set();\r\n        }\r\n        window.messageRegistry.add(this);\r\n        \r\n        // Always ensure that mainMessageBus is set - critically important for game over events\r\n        if (!window.mainMessageBus) {\r\n            window.mainMessageBus = this;\r\n            console.log(\"MessageBus: Set this instance as window.mainMessageBus\");\r\n        } else if (window.mainMessageBus !== this) {\r\n            // If this is not the main message bus, make sure game.over events are \r\n            // forwarded to the main message bus for centralized handling\r\n            console.log(\"MessageBus: This instance will forward game.over events to window.mainMessageBus\");\r\n        }\r\n        \r\n        console.log(\"MessageBus: New instance created and added to registry\");\r\n    }\r\n    \r\n    /**\r\n     * Register a listener for a message type\r\n     * @param {string} messageType The message type to listen for\r\n     * @param {Function} callback Function to call when message is published\r\n     * @param {Object} context Context to use when calling the callback\r\n     * @returns {Function} Unsubscribe function\r\n     */\r\n    subscribe(messageType, callback, context = null) {\r\n        if (!this.listeners.has(messageType)) {\r\n            this.listeners.set(messageType, []);\r\n        }\r\n        \r\n        this.listeners.get(messageType).push({\r\n            callback,\r\n            context\r\n        });\r\n        \r\n        // Return unsubscribe function for convenience\r\n        return () => this.unsubscribe(messageType, callback, context);\r\n    }\r\n    \r\n    /**\r\n     * Remove a listener\r\n     * @param {string} messageType The message type to unsubscribe from\r\n     * @param {Function} callback The callback to remove\r\n     * @param {Object} context The context used when subscribing\r\n     */\r\n    unsubscribe(messageType, callback, context = null) {\r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        const listeners = this.listeners.get(messageType);\r\n        const index = listeners.findIndex(listener => \r\n            listener.callback === callback && listener.context === context);\r\n            \r\n        if (index !== -1) {\r\n            listeners.splice(index, 1);\r\n        }\r\n        \r\n        if (listeners.length === 0) {\r\n            this.listeners.delete(messageType);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Fast publish for high-frequency events with minimal overhead\r\n     * @param {string} messageType The message type to publish\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    fastPublish(messageType, data = {}) {\r\n        // Typed event validation in dev\r\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        const listeners = this.listeners.get(messageType);\r\n        const messageObj = {\r\n            type: messageType,\r\n            data: data,\r\n            timestamp: Date.now()\r\n        };\r\n        \r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const listener = listeners[i];\r\n            listener.callback.call(listener.context, messageObj);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Send a message immediately\r\n     * @param {string} messageType The message type to publish\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    publish(messageType, data = {}) {\r\n        // Typed event validation in dev\r\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\r\n        // Use fast path for high-frequency messages\r\n        if (this.highFrequencyTypes.has(messageType)) {\r\n            return this.fastPublish(messageType, data);\r\n        }\r\n        \r\n        // Debug logging for critical messages\r\n        const criticalMessages = ['entity.created', 'entity.destroyed', 'component.added', 'component.removed', 'game.over'];\r\n        if (criticalMessages.includes(messageType)) {\r\n            console.log(`MessageBus: Publishing ${messageType}`, data);\r\n        }\r\n        \r\n        // Enhanced handling for game.over events to ensure they are properly processed\r\n        if (messageType === 'game.over') {\r\n            // Always forward game.over events to the main message bus if this isn't it\r\n            if (window.mainMessageBus && window.mainMessageBus !== this) {\r\n                console.log(`MessageBus: Forwarding game.over event to window.mainMessageBus`);\r\n                window.mainMessageBus.publish(messageType, data);\r\n                return; // Let the main message bus handle it\r\n            }\r\n            \r\n            // Only proceed if we have listeners or we are the main message bus\r\n            if (!this.listeners.has(messageType)) {\r\n                console.error(`MessageBus: No listeners found for '${messageType}' event!`);\r\n                console.log(`MessageBus: Registered event types:`, Array.from(this.listeners.keys()));\r\n                \r\n                // Log where subscribers should be\r\n                console.trace(\"MessageBus: This is where the game.over event was published from\");\r\n                \r\n                // Verify main game instance\r\n                if (window.game) {\r\n                    console.log(\"MessageBus: window.game exists:\", window.game);\r\n                    console.log(\"MessageBus: window.game.messageBus exists:\", window.game.messageBus);\r\n                    \r\n                    // Try to directly call gameOver as a last resort\r\n                    console.log(\"MessageBus: Directly calling window.game.gameOver as an emergency measure\");\r\n                    window.game.gameOver(data.reason || \"Unknown reason\");\r\n                } else {\r\n                    console.error(\"MessageBus: window.game does not exist - critical issue\");\r\n                }\r\n                \r\n                return;\r\n            } else {\r\n                const listeners = this.listeners.get(messageType);\r\n                console.log(`MessageBus: Found ${listeners.length} listeners for '${messageType}' event`);\r\n            }\r\n        }\r\n        \r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        // If we're already dispatching, queue this message\r\n        if (this.dispatching) {\r\n            console.log(`MessageBus: Already dispatching, queueing ${messageType} message`);\r\n            this.queuedMessages.push({ type: messageType, data });\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            // Set flag to prevent nested dispatch issues\r\n            this.dispatching = true;\r\n            \r\n            const listeners = this.listeners.get(messageType);\r\n            listeners.forEach((listener, index) => {\r\n                try {\r\n                    if (messageType === 'game.over') {\r\n                        console.log(`MessageBus: Calling listener #${index + 1} for game.over event`);\r\n                    }\r\n                    \r\n                    listener.callback.call(listener.context, {\r\n                        type: messageType,\r\n                        data: data,\r\n                        timestamp: Date.now()\r\n                    });\r\n                    \r\n                    if (messageType === 'game.over') {\r\n                        console.log(`MessageBus: Listener #${index + 1} for game.over event completed successfully`);\r\n                    }\r\n                } catch (error) {\r\n                    console.error(`Error in message listener #${index + 1} (${messageType}):`, error);\r\n                    console.error(\"Error stack:\", error.stack);\r\n                }\r\n            });\r\n        } finally {\r\n            // Always clear the dispatching flag, even if an error occurs\r\n            this.dispatching = false;\r\n            \r\n            // Process any queued messages\r\n            if (this.queuedMessages.length > 0) {\r\n                const queuedMessages = [...this.queuedMessages];\r\n                this.queuedMessages = [];\r\n                \r\n                queuedMessages.forEach(message => {\r\n                    this.publish(message.type, message.data);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Queue a message for next update\r\n     * @param {string} messageType The message type to queue\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    queue(messageType, data = {}) {\r\n        this.queuedMessages.push({\r\n            type: messageType,\r\n            data: data\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Universal handler for game over events - used by multiple components\r\n     * @param {string} reason Reason for game over\r\n     * @param {string} source Source of the game over event\r\n     */\r\n    static triggerGameOver(reason, source) {\r\n        console.log(\"MessageBus.triggerGameOver called:\", reason, \"from\", source);\r\n        \r\n        // Try to find a message bus to use - prioritization order for reliability\r\n        let messageBusToUse = null;\r\n        \r\n        // Use window.mainMessageBus if available (highest priority)\r\n        if (window.mainMessageBus) {\r\n            console.log(\"MessageBus: Using window.mainMessageBus for game over\");\r\n            messageBusToUse = window.mainMessageBus;\r\n        }\r\n        // Use window.game.messageBus if available and mainMessageBus not found\r\n        else if (window.game && window.game.messageBus) {\r\n            console.log(\"MessageBus: Using window.game.messageBus for game over\");\r\n            messageBusToUse = window.game.messageBus;\r\n        } \r\n        \r\n        // Check if we found a message bus to use\r\n        if (messageBusToUse) {\r\n            console.log(\"MessageBus: Publishing game.over event\");\r\n            \r\n            // Log the listeners to verify game.over handler is registered\r\n            if (messageBusToUse.listeners.has('game.over')) {\r\n                const listeners = messageBusToUse.listeners.get('game.over');\r\n                console.log(`MessageBus: Found ${listeners.length} game.over listeners`);\r\n            } else {\r\n                console.warn(\"MessageBus: No game.over listeners found before publishing\");\r\n            }\r\n            \r\n            // Publish the event\r\n            messageBusToUse.publish('game.over', {\r\n                reason: reason,\r\n                source: source\r\n            });\r\n        } else {\r\n            console.error(\"MessageBus: No message bus instance found for game over!\");\r\n        }\r\n    }\r\n}"],"names":["EVENT","SCHEMA","validateEventPayload","type","data","shape","warn","key","t","v","msg","MessageBus","messageType","callback","context","listeners","index","listener","messageObj","error","queuedMessages","message","reason","source","messageBusToUse"],"mappings":"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"}