{"version":3,"file":"core-BKht4hCZ.js","sources":["../../js/core/events.js","../../js/core/messageBus.js"],"sourcesContent":["// events.js - typed events enum + optional dev validation\n\nexport const EVENT = Object.freeze({\n  GAME_OVER: 'game.over',\n  PLAYER_CREATED: 'player.created',\n  TRANSFORM_UPDATED: 'transform.updated',\n  VFX_EXPLOSION: 'vfx.explosion',\n  MINING_START: 'player.mining.start',\n  MINING_STOP: 'player.mining.stop',\n  ENEMY_DESTROYED: 'enemy.destroyed',\n  WEAPON_FIRED: 'weapon.fired',\n});\n\nconst SCHEMA = {\n  [EVENT.GAME_OVER]: { reason: 'string' },\n  [EVENT.PLAYER_CREATED]: { entity: 'object' },\n  [EVENT.TRANSFORM_UPDATED]: { entity: 'object' },\n  [EVENT.VFX_EXPLOSION]: { position: 'object', color: 'number', size: 'number', duration: 'number' },\n  [EVENT.MINING_START]: { sourceEntity: 'object', targetEntity: 'object' },\n  [EVENT.MINING_STOP]: { sourceEntity: 'object' },\n  [EVENT.ENEMY_DESTROYED]: { entityId: 'string' },\n  [EVENT.WEAPON_FIRED]: { entity: 'object' },\n};\n\nexport function validateEventPayload(type, data) {\n  if (!window || !window.DEBUG_MODE) return true;\n  const shape = SCHEMA[type];\n  if (!shape) return true;\n  if (typeof data !== 'object' || data == null) return warn(type, 'payload is not object');\n  for (const [key, t] of Object.entries(shape)) {\n    const v = data[key];\n    if (t === 'object') {\n      if (typeof v !== 'object' || v == null) return warn(type, `field ${key} must be object`);\n    } else if (typeof v !== t) {\n      return warn(type, `field ${key} must be ${t}`);\n    }\n  }\n  return true;\n}\n\nfunction warn(type, msg) {\n  console.warn(`[EVENT VALIDATION] ${type}: ${msg}`);\n  return false;\n}\n\n\n","/**\n * MessageBus - Event system for decoupled communication between systems\n * \n * The MessageBus enables systems to communicate without direct references\n * by publishing and subscribing to specific message types.\n */\n\nimport { validateEventPayload } from './events.js';\n\nexport class MessageBus {\n    constructor() {\n        this.listeners = new Map();\n        this.queuedMessages = [];\n        this.dispatching = false;\n        \n        // High-frequency message types to minimize logging\n        this.highFrequencyTypes = new Set([\n            'transform.updated',\n            'physics.update',\n            'render.update'\n        ]);\n        \n        // Store this instance in a global registry for emergency access\n        if (!window.messageRegistry) {\n            window.messageRegistry = new Set();\n        }\n        window.messageRegistry.add(this);\n        \n        // Always ensure that mainMessageBus is set - critically important for game over events\n        if (!window.mainMessageBus) {\n            window.mainMessageBus = this;\n            console.log(\"MessageBus: Set this instance as window.mainMessageBus\");\n        } else if (window.mainMessageBus !== this) {\n            // If this is not the main message bus, make sure game.over events are \n            // forwarded to the main message bus for centralized handling\n            console.log(\"MessageBus: This instance will forward game.over events to window.mainMessageBus\");\n        }\n        \n        console.log(\"MessageBus: New instance created and added to registry\");\n    }\n    \n    /**\n     * Register a listener for a message type\n     * @param {string} messageType The message type to listen for\n     * @param {Function} callback Function to call when message is published\n     * @param {Object} context Context to use when calling the callback\n     * @returns {Function} Unsubscribe function\n     */\n    subscribe(messageType, callback, context = null) {\n        if (!this.listeners.has(messageType)) {\n            this.listeners.set(messageType, []);\n        }\n        \n        this.listeners.get(messageType).push({\n            callback,\n            context\n        });\n        \n        // Return unsubscribe function for convenience\n        return () => this.unsubscribe(messageType, callback, context);\n    }\n    \n    /**\n     * Remove a listener\n     * @param {string} messageType The message type to unsubscribe from\n     * @param {Function} callback The callback to remove\n     * @param {Object} context The context used when subscribing\n     */\n    unsubscribe(messageType, callback, context = null) {\n        if (!this.listeners.has(messageType)) return;\n        \n        const listeners = this.listeners.get(messageType);\n        const index = listeners.findIndex(listener => \n            listener.callback === callback && listener.context === context);\n            \n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n        \n        if (listeners.length === 0) {\n            this.listeners.delete(messageType);\n        }\n    }\n    \n    /**\n     * Fast publish for high-frequency events with minimal overhead\n     * @param {string} messageType The message type to publish\n     * @param {Object} data Data to include with the message\n     */\n    fastPublish(messageType, data = {}) {\n        // Typed event validation in dev\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\n        if (!this.listeners.has(messageType)) return;\n        \n        const listeners = this.listeners.get(messageType);\n        const messageObj = {\n            type: messageType,\n            data: data,\n            timestamp: Date.now()\n        };\n        \n        for (let i = 0; i < listeners.length; i++) {\n            const listener = listeners[i];\n            listener.callback.call(listener.context, messageObj);\n        }\n    }\n    \n    /**\n     * Send a message immediately\n     * @param {string} messageType The message type to publish\n     * @param {Object} data Data to include with the message\n     */\n    publish(messageType, data = {}) {\n        // Typed event validation in dev\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\n        // Use fast path for high-frequency messages\n        if (this.highFrequencyTypes.has(messageType)) {\n            return this.fastPublish(messageType, data);\n        }\n        \n        // Debug logging for critical messages\n        const criticalMessages = ['entity.created', 'entity.destroyed', 'component.added', 'component.removed', 'game.over'];\n        if (criticalMessages.includes(messageType)) {\n            console.log(`MessageBus: Publishing ${messageType}`, data);\n        }\n        \n        // Enhanced handling for game.over events to ensure they are properly processed\n        if (messageType === 'game.over') {\n            // Always forward game.over events to the main message bus if this isn't it\n            if (window.mainMessageBus && window.mainMessageBus !== this) {\n                console.log(`MessageBus: Forwarding game.over event to window.mainMessageBus`);\n                window.mainMessageBus.publish(messageType, data);\n                return; // Let the main message bus handle it\n            }\n            \n            // Only proceed if we have listeners or we are the main message bus\n            if (!this.listeners.has(messageType)) {\n                console.error(`MessageBus: No listeners found for '${messageType}' event!`);\n                console.log(`MessageBus: Registered event types:`, Array.from(this.listeners.keys()));\n                \n                // Log where subscribers should be\n                console.trace(\"MessageBus: This is where the game.over event was published from\");\n                \n                // Verify main game instance\n                if (window.game) {\n                    console.log(\"MessageBus: window.game exists:\", window.game);\n                    console.log(\"MessageBus: window.game.messageBus exists:\", window.game.messageBus);\n                    \n                    // Try to directly call gameOver as a last resort\n                    console.log(\"MessageBus: Directly calling window.game.gameOver as an emergency measure\");\n                    window.game.gameOver(data.reason || \"Unknown reason\");\n                } else {\n                    console.error(\"MessageBus: window.game does not exist - critical issue\");\n                }\n                \n                return;\n            } else {\n                const listeners = this.listeners.get(messageType);\n                console.log(`MessageBus: Found ${listeners.length} listeners for '${messageType}' event`);\n            }\n        }\n        \n        if (!this.listeners.has(messageType)) return;\n        \n        // If we're already dispatching, queue this message\n        if (this.dispatching) {\n            console.log(`MessageBus: Already dispatching, queueing ${messageType} message`);\n            this.queuedMessages.push({ type: messageType, data });\n            return;\n        }\n        \n        try {\n            // Set flag to prevent nested dispatch issues\n            this.dispatching = true;\n            \n            const listeners = this.listeners.get(messageType);\n            listeners.forEach((listener, index) => {\n                try {\n                    if (messageType === 'game.over') {\n                        console.log(`MessageBus: Calling listener #${index + 1} for game.over event`);\n                    }\n                    \n                    listener.callback.call(listener.context, {\n                        type: messageType,\n                        data: data,\n                        timestamp: Date.now()\n                    });\n                    \n                    if (messageType === 'game.over') {\n                        console.log(`MessageBus: Listener #${index + 1} for game.over event completed successfully`);\n                    }\n                } catch (error) {\n                    console.error(`Error in message listener #${index + 1} (${messageType}):`, error);\n                    console.error(\"Error stack:\", error.stack);\n                }\n            });\n        } finally {\n            // Always clear the dispatching flag, even if an error occurs\n            this.dispatching = false;\n            \n            // Process any queued messages\n            if (this.queuedMessages.length > 0) {\n                const queuedMessages = [...this.queuedMessages];\n                this.queuedMessages = [];\n                \n                queuedMessages.forEach(message => {\n                    this.publish(message.type, message.data);\n                });\n            }\n        }\n    }\n    \n    /**\n     * Queue a message for next update\n     * @param {string} messageType The message type to queue\n     * @param {Object} data Data to include with the message\n     */\n    queue(messageType, data = {}) {\n        this.queuedMessages.push({\n            type: messageType,\n            data: data\n        });\n    }\n    \n    /**\n     * Universal handler for game over events - used by multiple components\n     * @param {string} reason Reason for game over\n     * @param {string} source Source of the game over event\n     */\n    static triggerGameOver(reason, source) {\n        console.log(\"MessageBus.triggerGameOver called:\", reason, \"from\", source);\n        \n        // Try to find a message bus to use - prioritization order for reliability\n        let messageBusToUse = null;\n        \n        // Use window.mainMessageBus if available (highest priority)\n        if (window.mainMessageBus) {\n            console.log(\"MessageBus: Using window.mainMessageBus for game over\");\n            messageBusToUse = window.mainMessageBus;\n        }\n        // Use window.game.messageBus if available and mainMessageBus not found\n        else if (window.game && window.game.messageBus) {\n            console.log(\"MessageBus: Using window.game.messageBus for game over\");\n            messageBusToUse = window.game.messageBus;\n        } \n        \n        // Check if we found a message bus to use\n        if (messageBusToUse) {\n            console.log(\"MessageBus: Publishing game.over event\");\n            \n            // Log the listeners to verify game.over handler is registered\n            if (messageBusToUse.listeners.has('game.over')) {\n                const listeners = messageBusToUse.listeners.get('game.over');\n                console.log(`MessageBus: Found ${listeners.length} game.over listeners`);\n            } else {\n                console.warn(\"MessageBus: No game.over listeners found before publishing\");\n            }\n            \n            // Publish the event\n            messageBusToUse.publish('game.over', {\n                reason: reason,\n                source: source\n            });\n        } else {\n            console.error(\"MessageBus: No message bus instance found for game over!\");\n        }\n    }\n}"],"names":["EVENT","SCHEMA","validateEventPayload","type","data","shape","warn","key","t","v","msg","MessageBus","messageType","callback","context","listeners","index","listener","messageObj","error","queuedMessages","message","reason","source","messageBusToUse"],"mappings":"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"}