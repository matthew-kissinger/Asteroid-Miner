{"version":3,"mappings":"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","names":["HealthComponent","Component","maxHealth","maxShield","message","data","oldShield","oldMaxShield","oldHealth","oldMaxHealth","amount","type","source","resistedAmount","shieldDamage","healthDamage","__vitePreload","module","MessageBus","err","startHealth","healedAmount","startShield","rechargedAmount","deltaTime","regenAmount","healthRegenAmount","multiplier","oldMax","TransformComponent","position","THREE.Vector3","rotation","THREE.Euler","scale","THREE.Quaternion","THREE.Matrix4","x","y","z","quaternion","target","tempMatrix","forward","right","up","RigidbodyComponent","mass","force","point","transformComponent","torque","impulse","velocityChange","velocity","angularVelocity"],"ignoreList":[],"sources":["../../js/components/combat/healthComponent.js","../../js/components/transform.js","../../js/components/physics/rigidbody.js"],"sourcesContent":["/**\n * HealthComponent - Handles health, shield, and damage for entities\n * \n * Manages health, shields, and damage application for both players and enemies\n */\n\nimport { Component } from '../../core/component.js';\n\nexport class HealthComponent extends Component {\n    constructor(maxHealth = 100, maxShield = 0) {\n        super();\n        \n        // Health properties\n        this.maxHealth = maxHealth;\n        this.health = maxHealth;\n        \n        // Shield properties\n        this.maxShield = maxShield;\n        this.shield = maxShield;\n        this.shieldRegenRate = 5; // Shield points per second\n        this.shieldRegenDelay = 3; // Seconds after damage before regeneration starts\n        this.timeSinceLastDamage = this.shieldRegenDelay; // Start regenerating immediately\n        \n        // Resistance properties (damage reduction percentage)\n        this.damageResistance = 0; // 0-1 range, 0.5 = 50% damage reduction\n        \n        // Status\n        this.isDestroyed = false;\n        this.isInvulnerable = false;\n        \n        console.log(`Created health component with ${maxHealth} max health and ${maxShield} max shield`);\n    }\n    \n    // Add an onAttached method to subscribe to health sync events\n    onAttached() {\n        // Only subscribe for player entities\n        if (this.entity && this.entity.hasTag && this.entity.hasTag('player')) {\n            console.log(\"HealthComponent attached to player entity - subscribing to sync events\");\n            \n            // Subscribe to health sync events on the message bus\n            if (this.entity.world && this.entity.world.messageBus) {\n                this.entity.world.messageBus.subscribe('player.syncHealth', this.handleSyncHealth.bind(this));\n                this.entity.world.messageBus.subscribe('player.undocked', this.handleSyncHealth.bind(this));\n                console.log(\"Subscribed to player.syncHealth and player.undocked events\");\n            } else if (window.mainMessageBus) {\n                window.mainMessageBus.subscribe('player.syncHealth', this.handleSyncHealth.bind(this));\n                window.mainMessageBus.subscribe('player.undocked', this.handleSyncHealth.bind(this));\n                console.log(\"Subscribed to player.syncHealth and player.undocked events via mainMessageBus\");\n            }\n        }\n    }\n    \n    // Handle the sync health event\n    handleSyncHealth(message) {\n        // Only apply if this component is attached to a player entity\n        if (!this.entity || !this.entity.hasTag || !this.entity.hasTag('player')) {\n            return;\n        }\n        \n        console.log(\"HealthComponent received syncHealth event:\", message);\n        \n        // CRITICAL FIX: The message from MessageBus has a nested data property\n        // Extract the actual sync data from the message\n        const data = message.data || message;\n        \n        console.log(\"Extracted sync data:\", data);\n        \n        // Update shield values if provided\n        if (data.shield !== undefined) {\n            const oldShield = this.shield;\n            \n            // SHIELD SYNC: Add additional logging to debug shield sync issues\n            console.log(`SHIELD SYNC: HealthComponent shield was ${oldShield}, spaceship shield is ${data.shield}`);\n            \n            // Set shield value from spaceship\n            this.shield = data.shield;\n            \n            console.log(`Updated shield: ${oldShield} → ${this.shield}`);\n        } else {\n            console.warn(\"Shield value not provided in sync data\");\n        }\n        \n        if (data.maxShield !== undefined) {\n            const oldMaxShield = this.maxShield;\n            this.maxShield = data.maxShield;\n            console.log(`Updated maxShield: ${oldMaxShield} → ${this.maxShield}`);\n        } else {\n            console.warn(\"MaxShield value not provided in sync data\");\n        }\n        \n        // Update health values if provided\n        if (data.hull !== undefined) {\n            const oldHealth = this.health;\n            this.health = data.hull;\n            console.log(`Updated health: ${oldHealth} → ${this.health}`);\n        } else {\n            console.warn(\"Hull value not provided in sync data\");\n        }\n        \n        if (data.maxHull !== undefined) {\n            const oldMaxHealth = this.maxHealth;\n            this.maxHealth = data.maxHull;\n            console.log(`Updated maxHealth: ${oldMaxHealth} → ${this.maxHealth}`);\n        } else {\n            console.warn(\"MaxHull value not provided in sync data\");\n        }\n        \n        console.log(`HealthComponent synced: Health ${this.health}/${this.maxHealth}, Shield ${this.shield}/${this.maxShield}`);\n    }\n    \n    /**\n     * Apply damage to this entity\n     * @param {number} amount Amount of damage to apply\n     * @param {string} type Type of damage (e.g., 'projectile', 'collision', 'emp')\n     * @param {object} source Source entity of the damage\n     * @returns {object} Damage result with actual damage dealt\n     */\n    applyDamage(amount, type = 'projectile', source = null) {\n        // Debug logging\n        console.log(`HealthComponent: Applying ${amount} damage of type ${type} to entity ${this.entity ? this.entity.id : 'unknown'}`);\n        console.log(`Current health: ${this.health}/${this.maxHealth}, Shield: ${this.shield}/${this.maxShield}`);\n        \n        // Check if entity can be damaged\n        if (this.isDestroyed || this.isInvulnerable) {\n            console.log(\"Entity is destroyed or invulnerable, damage not applied\");\n            return { damageApplied: 0, shieldDamage: 0, healthDamage: 0, destroyed: false };\n        }\n        \n        // Apply damage resistance\n        const resistedAmount = amount * (1 - this.damageResistance);\n        \n        // Track how much damage was applied to shields vs health\n        let shieldDamage = 0;\n        let healthDamage = 0;\n        \n        // Reset shield regeneration timer\n        this.timeSinceLastDamage = 0;\n        \n        // Apply damage to shield first if available\n        if (this.shield > 0) {\n            if (resistedAmount <= this.shield) {\n                // Shield absorbs all damage\n                this.shield -= resistedAmount;\n                shieldDamage = resistedAmount;\n            } else {\n                // Damage breaks through shield\n                shieldDamage = this.shield;\n                healthDamage = resistedAmount - this.shield;\n                this.shield = 0;\n                this.health -= healthDamage;\n            }\n        } else {\n            // No shield, apply damage directly to health\n            this.health -= resistedAmount;\n            healthDamage = resistedAmount;\n        }\n        \n        // Ensure health doesn't go below 0\n        if (this.health < 0) {\n            this.health = 0;\n        }\n        \n        // Check if entity is destroyed\n        if (this.health <= 0 && !this.isDestroyed) {\n            this.isDestroyed = true;\n            \n            // Notify entity destruction\n            if (this.entity && this.entity.world) {\n                this.entity.world.messageBus.publish('entity.destroyed', {\n                    entity: this.entity,\n                    source: source,\n                    damageType: type\n                });\n                \n                // Additional check for player entity - publish game over event\n                if (this.entity.hasTag && this.entity.hasTag('player')) {\n                    console.log(\"PLAYER HEALTH COMPONENT DESTROYED - TRIGGERING GAME OVER\");\n                    \n                    console.log(\"HealthComponent: Initiating game over sequence\");\n                    \n                    // Use direct world message bus\n                    if (this.entity && this.entity.world && this.entity.world.messageBus) {\n                        console.log(\"HealthComponent: Publishing game.over via world.messageBus\");\n                        this.entity.world.messageBus.publish('game.over', {\n                            reason: \"You were pwned by a space alien!\",\n                            source: \"health\"\n                        });\n                    } else {\n                        // Import MessageBus to use the static method if needed\n                        import('../../core/messageBus.js').then(module => {\n                            const MessageBus = module.MessageBus;\n                            console.log(\"HealthComponent: Using MessageBus.triggerGameOver\");\n                            \n                            // Use the static method for handling\n                            MessageBus.triggerGameOver(\"You were pwned by a space alien!\", \"health\");\n                        }).catch(err => {\n                            console.error(\"Error importing MessageBus:\", err);\n                        });\n                    }\n                }\n            }\n        }\n        \n        // Notify about damage\n        if (this.entity && this.entity.world) {\n            this.entity.world.messageBus.publish('entity.damaged', {\n                entity: this.entity,\n                source: source,\n                damageType: type,\n                amount: resistedAmount,\n                shieldDamage: shieldDamage,\n                healthDamage: healthDamage\n            });\n        }\n        \n        // More debug logging \n        console.log(`After damage: Health: ${this.health}/${this.maxHealth}, Shield: ${this.shield}/${this.maxShield}`);\n        console.log(`Entity destroyed: ${this.isDestroyed}`);\n        \n        return {\n            damageApplied: resistedAmount,\n            shieldDamage: shieldDamage,\n            healthDamage: healthDamage,\n            destroyed: this.isDestroyed\n        };\n    }\n    \n    /**\n     * Heal the entity\n     * @param {number} amount Amount to heal\n     * @returns {number} Actual amount healed\n     */\n    heal(amount) {\n        if (this.isDestroyed) return 0;\n        \n        const startHealth = this.health;\n        this.health = Math.min(this.health + amount, this.maxHealth);\n        \n        const healedAmount = this.health - startHealth;\n        \n        if (healedAmount > 0 && this.entity && this.entity.world) {\n            this.entity.world.messageBus.publish('entity.healed', {\n                entity: this.entity,\n                amount: healedAmount\n            });\n        }\n        \n        return healedAmount;\n    }\n    \n    /**\n     * Recharge the shield\n     * @param {number} amount Amount to recharge\n     * @returns {number} Actual amount recharged\n     */\n    rechargeShield(amount) {\n        if (this.isDestroyed) return 0;\n        \n        const startShield = this.shield;\n        this.shield = Math.min(this.shield + amount, this.maxShield);\n        \n        const rechargedAmount = this.shield - startShield;\n        \n        if (rechargedAmount > 0 && this.entity && this.entity.world) {\n            this.entity.world.messageBus.publish('entity.shieldRecharged', {\n                entity: this.entity,\n                amount: rechargedAmount\n            });\n        }\n        \n        return rechargedAmount;\n    }\n    \n    /**\n     * Update shield and health regeneration\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        if (this.isDestroyed) return;\n        \n        // Update timer since last damage\n        this.timeSinceLastDamage += deltaTime;\n        \n        // Regenerate shields if enough time has passed since last damage\n        if (this.timeSinceLastDamage >= this.shieldRegenDelay && this.shield < this.maxShield) {\n            const regenAmount = this.shieldRegenRate * deltaTime;\n            this.rechargeShield(regenAmount);\n        }\n        \n        // Regenerate hull health slowly (only for player)\n        if (this.entity && this.entity.hasTag('player') && this.health < this.maxHealth) {\n            // Regenerate 5% of max health per second\n            const healthRegenRate = this.maxHealth * 0.05;\n            const healthRegenAmount = healthRegenRate * deltaTime;\n            this.heal(healthRegenAmount);\n        }\n    }\n    \n    /**\n     * Get health as a percentage (0-100)\n     * @returns {number} Health percentage\n     */\n    getHealthPercentage() {\n        return (this.health / this.maxHealth) * 100;\n    }\n    \n    /**\n     * Get shield as a percentage (0-100)\n     * @returns {number} Shield percentage\n     */\n    getShieldPercentage() {\n        return this.maxShield > 0 ? (this.shield / this.maxShield) * 100 : 0;\n    }\n    \n    /**\n     * Upgrade health capacity and fully heal\n     * @param {number} multiplier Multiplier for health increase\n     * @returns {object} New health stats\n     */\n    upgradeHealth(multiplier = 1.25) {\n        const oldMax = this.maxHealth;\n        this.maxHealth *= multiplier;\n        this.health = this.maxHealth; // Full heal on upgrade\n        \n        console.log(`Upgraded health from ${oldMax.toFixed(1)} to ${this.maxHealth.toFixed(1)}`);\n        \n        // Notify upgrade\n        if (this.entity && this.entity.world) {\n            this.entity.world.messageBus.publish('health.upgraded', {\n                entity: this.entity,\n                oldMax: oldMax,\n                newMax: this.maxHealth\n            });\n        }\n        \n        return {\n            maxHealth: this.maxHealth,\n            healthBoost: this.maxHealth - oldMax\n        };\n    }\n    \n    /**\n     * Upgrade shield capacity\n     * @param {number} multiplier Multiplier for shield increase\n     * @returns {object} New shield stats\n     */\n    upgradeShield(multiplier = 1.5) {\n        console.log(`===== SHIELD UPGRADE INITIATED =====`);\n        console.log(`Current shield values - Max: ${this.maxShield}, Current: ${this.shield}`);\n        \n        const oldMax = this.maxShield;\n        const oldShield = this.shield;\n        \n        // Increase max shield\n        this.maxShield = Math.ceil(this.maxShield * multiplier);\n        \n        // Full recharge on upgrade - this is the original behavior\n        this.shield = this.maxShield;\n        \n        console.log(`Upgraded shield from ${oldMax.toFixed(1)} to ${this.maxShield.toFixed(1)}`);\n        console.log(`Current shield value changed from ${oldShield.toFixed(1)} to ${this.shield.toFixed(1)}`);\n        console.log(`===== SHIELD UPGRADE COMPLETED =====`);\n        \n        // Notify upgrade\n        if (this.entity && this.entity.world) {\n            this.entity.world.messageBus.publish('shield.upgraded', {\n                entity: this.entity,\n                oldMax: oldMax,\n                newMax: this.maxShield\n            });\n        }\n        \n        return {\n            maxShield: this.maxShield,\n            shieldBoost: this.maxShield - oldMax\n        };\n    }\n}","/**\n * TransformComponent - Position, rotation, scale component\n * \n * Handles spatial transformation of entities in the 3D world.\n */\n\nimport { Component } from '../core/component.js';\nimport * as THREE from 'three';\n\nexport class TransformComponent extends Component {\n    constructor(position = new THREE.Vector3(), rotation = new THREE.Euler(), scale = new THREE.Vector3(1, 1, 1)) {\n        super();\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new THREE.Quaternion().setFromEuler(this.rotation);\n        this.matrix = new THREE.Matrix4();\n        this.needsUpdate = true;\n    }\n    \n    /**\n     * Set the position\n     * @param {number} x X coordinate\n     * @param {number} y Y coordinate\n     * @param {number} z Z coordinate\n     * @returns {TransformComponent} This component for chaining\n     */\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.needsUpdate = true;\n        return this;\n    }\n    \n    /**\n     * Set the rotation in Euler angles\n     * @param {number} x X rotation in radians\n     * @param {number} y Y rotation in radians\n     * @param {number} z Z rotation in radians\n     * @returns {TransformComponent} This component for chaining\n     */\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.quaternion.setFromEuler(this.rotation);\n        this.needsUpdate = true;\n        return this;\n    }\n    \n    /**\n     * Set the rotation from a quaternion\n     * @param {THREE.Quaternion} quaternion The quaternion\n     * @returns {TransformComponent} This component for chaining\n     */\n    setQuaternion(quaternion) {\n        this.quaternion.copy(quaternion);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.needsUpdate = true;\n        return this;\n    }\n    \n    /**\n     * Set the scale\n     * @param {number} x X scale\n     * @param {number} y Y scale\n     * @param {number} z Z scale\n     * @returns {TransformComponent} This component for chaining\n     */\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.needsUpdate = true;\n        return this;\n    }\n    \n    /**\n     * Look at a point\n     * @param {THREE.Vector3} target The point to look at\n     * @returns {TransformComponent} This component for chaining\n     */\n    lookAt(target) {\n        // Create a temporary matrix to derive the rotation\n        const tempMatrix = new THREE.Matrix4();\n        tempMatrix.lookAt(this.position, target, new THREE.Vector3(0, 1, 0));\n        \n        // Extract the quaternion from the matrix\n        this.quaternion.setFromRotationMatrix(tempMatrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        \n        this.needsUpdate = true;\n        return this;\n    }\n    \n    /**\n     * Update the matrix from position, quaternion, and scale\n     * @returns {THREE.Matrix4} The updated matrix\n     */\n    updateMatrix() {\n        if (this.needsUpdate) {\n            this.matrix.compose(this.position, this.quaternion, this.scale);\n            this.needsUpdate = false;\n        }\n        return this.matrix;\n    }\n    \n    /**\n     * Get world position\n     * @returns {THREE.Vector3} A new vector representing the world position\n     */\n    getWorldPosition() {\n        return this.position.clone();\n    }\n    \n    /**\n     * Get forward direction vector\n     * @returns {THREE.Vector3} A normalized vector pointing forward\n     */\n    getForwardVector() {\n        const forward = new THREE.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    \n    /**\n     * Get right direction vector\n     * @returns {THREE.Vector3} A normalized vector pointing right\n     */\n    getRightVector() {\n        const right = new THREE.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    \n    /**\n     * Get up direction vector\n     * @returns {THREE.Vector3} A normalized vector pointing up\n     */\n    getUpVector() {\n        const up = new THREE.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n}","/**\n * RigidbodyComponent - Physics properties for entities\n * \n * Handles velocity, forces, and other physics-related properties.\n */\n\nimport * as THREE from 'three';\nimport { Component } from '../../core/component.js';\n\nexport class RigidbodyComponent extends Component {\n    constructor(mass = 1.0) {\n        super();\n        \n        // Basic physics properties\n        this.velocity = new THREE.Vector3();\n        this.angularVelocity = new THREE.Vector3();\n        this.mass = mass;\n        this.drag = 0.01;\n        this.angularDrag = 0.01;\n        \n        // Movement constraints\n        this.useGravity = false;\n        this.isKinematic = false;\n        this.freezeRotation = false;\n        \n        // Force properties\n        this.forces = new THREE.Vector3();\n        this.torque = new THREE.Vector3();\n        \n        // Collision properties\n        this.collisionRadius = 1.0;\n        this.isTrigger = false;\n    }\n    \n    /**\n     * Reset forces applied this frame\n     */\n    resetForces() {\n        this.forces.set(0, 0, 0);\n        this.torque.set(0, 0, 0);\n    }\n    \n    /**\n     * Apply a force to the rigidbody\n     * @param {THREE.Vector3} force Force vector to apply\n     * @param {THREE.Vector3} point Point where force is applied (for torque)\n     */\n    applyForce(force, point = null) {\n        if (this.isKinematic) return;\n        \n        // Add to force accumulator\n        this.forces.add(force);\n        \n        // Calculate torque if point is specified\n        if (point) {\n            const transformComponent = this.entity.getComponent('TransformComponent');\n            if (transformComponent) {\n                const relativePoint = point.clone().sub(transformComponent.position);\n                const torque = relativePoint.cross(force);\n                this.applyTorque(torque);\n            }\n        }\n    }\n    \n    /**\n     * Apply an impulse (immediate velocity change)\n     * @param {THREE.Vector3} impulse Impulse vector\n     */\n    applyImpulse(impulse) {\n        if (this.isKinematic) return;\n        \n        // Calculate velocity change based on mass\n        const velocityChange = impulse.clone().divideScalar(this.mass);\n        this.velocity.add(velocityChange);\n    }\n    \n    /**\n     * Apply torque (rotational force)\n     * @param {THREE.Vector3} torque Torque vector\n     */\n    applyTorque(torque) {\n        if (this.isKinematic || this.freezeRotation) return;\n        \n        this.torque.add(torque);\n    }\n    \n    /**\n     * Set velocity directly\n     * @param {THREE.Vector3} velocity New velocity vector\n     */\n    setVelocity(velocity) {\n        this.velocity.copy(velocity);\n    }\n    \n    /**\n     * Set angular velocity directly\n     * @param {THREE.Vector3} angularVelocity New angular velocity vector\n     */\n    setAngularVelocity(angularVelocity) {\n        if (this.freezeRotation) return;\n        \n        this.angularVelocity.copy(angularVelocity);\n    }\n}"],"file":"assets/components-oXlWjsfY.js"}