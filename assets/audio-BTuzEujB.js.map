{"version":3,"file":"audio-BTuzEujB.js","sources":["../../js/modules/audio/core/context.ts","../../js/modules/audio/core/loader.ts","../../js/modules/audio/music/playlist.ts","../../js/modules/audio/music/player.ts","../../js/modules/audio/effects/soundPlayer.ts","../../js/modules/audio/mobile/enabler.ts","../../js/modules/audio/audio.ts"],"sourcesContent":["// context.ts - Web Audio API context management and compatibility\n\nexport interface TrackableNode {\n    _inactive?: boolean;\n    disposed?: boolean;\n}\n\nexport class AudioContextManager {\n    private audioContext: AudioContext | null = null;\n    private activeNodes: Set<TrackableNode> = new Set();\n    private gcInterval: number | ReturnType<typeof setInterval> | null = null;\n    private masterEQ: { connect: (node: any) => any } | null = null;\n    \n    constructor() {\n        this.initializeContext();\n        this.setupGarbageCollection();\n    }\n    \n    // Initialize Web Audio API context with compatibility\n    initializeContext(): void {\n        try {\n            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;\n            if (AudioContextClass) {\n                this.audioContext = new AudioContextClass();\n                console.log(\"Web Audio API context created successfully\");\n            } else {\n                console.error(\"Web Audio API not supported in this browser\");\n            }\n        } catch (error) {\n            console.error(\"Failed to create Web Audio API context:\", error);\n        }\n    }\n    \n    // Resume audio context on user interaction\n    resumeAudioContext(): Promise<void> {\n        if (this.audioContext && this.audioContext.state === 'suspended') {\n            return this.audioContext.resume().then(() => {\n                console.log(\"AudioContext resumed successfully\");\n            }).catch(error => {\n                console.error(\"Failed to resume AudioContext:\", error);\n            });\n        }\n        return Promise.resolve();\n    }\n    \n    // Get the audio context instance\n    getContext(): AudioContext | null {\n        return this.audioContext;\n    }\n    \n    // Check if context is available and ready\n    isReady(): boolean {\n        return this.audioContext !== null && this.audioContext.state !== 'closed';\n    }\n    \n    // Set up regular garbage collection for unused audio nodes\n    setupGarbageCollection(): void {\n        // Clean up inactive nodes every 30 seconds\n        this.gcInterval = setInterval(() => this.cleanupInactiveNodes(), 30000);\n        console.log(\"Audio garbage collection scheduled\");\n    }\n    \n    // Clean up inactive audio nodes to prevent memory leaks\n    cleanupInactiveNodes(): void {\n        let count = 0;\n        this.activeNodes.forEach(node => {\n            // Check if node is inactive\n            if (node._inactive || (node.disposed === true)) {\n                this.activeNodes.delete(node);\n                count++;\n            }\n        });\n        \n        if (count > 0) {\n            console.log(`Audio context: cleaned up ${count} inactive audio objects`);\n        }\n    }\n    \n    // Track an audio node for garbage collection\n    trackNode<T extends TrackableNode>(node: T): T {\n        if (node) {\n            this.activeNodes.add(node);\n        }\n        return node;\n    }\n    \n    // Initialize a minimal Tone.js compatibility layer for the intro sequence\n    initializeToneCompatibility(): { connect: (node: any) => any } {\n        // Create a dummy masterEQ object that the intro sequence can connect to\n        // This allows the intro sequence code to remain unchanged\n        this.masterEQ = {\n            // Dummy connect method that returns the input\n            connect: function(node: any) {\n                return node;\n            }\n        };\n        \n        console.log(\"Audio compatibility layer initialized for intro sequence\");\n        return this.masterEQ;\n    }\n    \n    // Clean up context and resources\n    cleanup(): Promise<void> {\n        console.log(\"Cleaning up AudioContext resources...\");\n        \n        // Clear intervals\n        if (this.gcInterval) {\n            clearInterval(this.gcInterval as number);\n            this.gcInterval = null;\n        }\n        \n        // Close audio context\n        if (this.audioContext) {\n            return this.audioContext.close().then(() => {\n                console.log(\"AudioContext closed successfully\");\n                this.audioContext = null;\n            }).catch(error => {\n                console.error(\"Error closing AudioContext:\", error);\n            });\n        }\n        \n        return Promise.resolve();\n    }\n}\n","// loader.ts - Audio file loading, decoding, and caching\nimport { getAbsolutePath } from '../../../utils/pathUtils.js';\nimport { AudioContextManager } from './context.js';\n\nexport interface SoundMap {\n    [key: string]: AudioBuffer | null;\n}\n\nexport class AudioLoader {\n    private audioContextManager: AudioContextManager;\n    private sounds: SoundMap = {}; // Stores decoded AudioBuffers\n    \n    constructor(audioContextManager: AudioContextManager) {\n        this.audioContextManager = audioContextManager;\n    }\n    \n    // Helper method to handle paths correctly for both local and GitHub Pages deployment\n    getPath(relativePath: string): string {\n        return getAbsolutePath(relativePath);\n    }\n    \n    // Load and decode a sound file using Web Audio API\n    async loadAndDecodeSound(name: string, url: string): Promise<AudioBuffer> {\n        try {\n            console.log(`Loading and decoding sound: ${name} from ${url}`);\n            \n            const audioContext = this.audioContextManager.getContext();\n            if (!audioContext) {\n                throw new Error(\"AudioContext not available\");\n            }\n            \n            // Fetch the audio file\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch sound ${name}: ${response.status} ${response.statusText}`);\n            }\n            \n            // Get the audio data as an ArrayBuffer\n            const audioData = await response.arrayBuffer();\n            \n            // Decode the audio data\n            const audioBuffer = await audioContext.decodeAudioData(audioData);\n            \n            // Store the decoded buffer\n            this.sounds[name] = audioBuffer;\n            \n            console.log(`Sound ${name} loaded and decoded successfully`);\n            return audioBuffer;\n        } catch (error) {\n            console.error(`Error loading and decoding sound ${name}:`, error);\n            \n            // Create a dummy buffer for this sound to prevent errors\n            this.sounds[name] = null;\n            throw error;\n        }\n    }\n    \n    // Pre-decode only essential UI sounds for quick startup\n    async preDecodeEssentialSounds(): Promise<void> {\n        try {\n            console.log(\"Pre-decoding essential UI sounds...\");\n            \n            // List of essential sounds needed for UI interaction\n            const essentialSounds = [\n                { name: 'boink', path: 'sounds/effects/boink.wav' },\n                { name: 'phaserUp', path: 'sounds/effects/phaserUp.wav' },\n                { name: 'phaserDown', path: 'sounds/effects/phaserDown.wav' },\n            ];\n            \n            // Create a promise for each sound to load\n            const loadPromises = essentialSounds.map(sound => \n                this.loadAndDecodeSound(sound.name, this.getPath(sound.path))\n            );\n            \n            // Wait for all essential sounds to be loaded and decoded\n            await Promise.all(loadPromises);\n            \n            console.log(\"Essential UI sounds pre-decoded successfully\");\n            \n        } catch (error) {\n            console.error(\"Error pre-decoding essential sounds:\", error);\n            this.createDummySounds();\n        }\n    }\n    \n    // Load remaining gameplay sounds in the background\n    async loadGameplaySounds(): Promise<void> {\n        try {\n            console.log(\"Loading gameplay sounds in background...\");\n            \n            // List of gameplay sounds to load\n            const gameplaySounds = [\n                { name: 'thrust', path: 'sounds/effects/thrust.wav' },\n                { name: 'laser', path: 'sounds/effects/laser.wav' },\n                { name: 'mining-laser', path: 'sounds/effects/mining-laser.wav' },\n                { name: 'explosion', path: 'sounds/effects/explosion.wav' },\n            ];\n            \n            // Load sounds sequentially to avoid overwhelming the audio decoder\n            for (const sound of gameplaySounds) {\n                try {\n                    await this.loadAndDecodeSound(sound.name, this.getPath(sound.path));\n                } catch (err) {\n                    console.warn(`Could not load gameplay sound ${sound.name}:`, err);\n                }\n            }\n            \n            // Explicitly set up projectile sound using the laser sound\n            // This is needed for weapon firing\n            if (this.sounds.laser && !this.sounds.projectile) {\n                console.log(\"Setting up projectile sound using laser sound buffer\");\n                this.sounds.projectile = this.sounds.laser;\n            }\n            \n            console.log(\"All gameplay sounds loaded successfully\");\n        } catch (error) {\n            console.error(\"Error loading gameplay sounds:\", error);\n        }\n    }\n    \n    // Create dummy sounds if loading fails\n    createDummySounds(): void {\n        console.warn(\"Creating dummy silent AudioBuffers as fallback\");\n        \n        const soundEffects = ['laser', 'thrust', 'explosion', 'boink', 'phaserUp', 'phaserDown', 'mining-laser', 'projectile'];\n        const audioContext = this.audioContextManager.getContext();\n        \n        for (const name of soundEffects) {\n            // Create a silent buffer (0.1 seconds of silence)\n            if (audioContext) {\n                try {\n                    const buffer = audioContext.createBuffer(\n                        2, // stereo\n                        audioContext.sampleRate * 0.1, // 0.1 seconds\n                        audioContext.sampleRate\n                    );\n                    this.sounds[name] = buffer;\n                } catch (error) {\n                    console.error(`Failed to create dummy buffer for ${name}:`, error);\n                    this.sounds[name] = null;\n                }\n            } else {\n                this.sounds[name] = null;\n            }\n        }\n    }\n    \n    // Helper method to check if a file exists\n    async checkFileExists(path: string): Promise<{ path: string; exists: boolean }> {\n        console.log(`Checking if file/directory exists: ${path}`);\n        try {\n            // Try to fetch the resource\n            const response = await fetch(path, { \n                method: 'HEAD',\n                cache: 'no-cache' // Avoid caching issues\n            });\n            \n            console.log(`Fetch response for ${path}: status=${response.status}, ok=${response.ok}`);\n            \n            return { \n                path, \n                exists: response.ok \n            };\n        } catch (err) {\n            console.error(`Error checking if file exists (${path}):`, err);\n            return { path, exists: false };\n        }\n    }\n    \n    // Check if the required sound directories exist and notify user if they don't\n    async checkSoundDirectories(): Promise<boolean> {\n        // Check for sounds directory\n        const soundsDirExists = await this.checkFileExists(this.getPath('sounds'));\n        if (!soundsDirExists.exists) {\n            console.warn(\"Sounds directory not found, but will attempt to load files directly anyway.\");\n        }\n        \n        // Check for soundtrack directory\n        const soundtrackDirExists = await this.checkFileExists(this.getPath('sounds/soundtrack'));\n        if (!soundtrackDirExists.exists) {\n            console.warn(\"Soundtrack directory not found, but will attempt to load files directly anyway.\");\n        }\n        \n        // Check for sound effects directory\n        const effectsDirExists = await this.checkFileExists(this.getPath('sounds/effects'));\n        if (!effectsDirExists.exists) {\n            console.warn(\"Sound effects directory not found. Some sounds may not play correctly.\");\n        }\n        \n        // Always return true to continue loading process\n        return true;\n    }\n    \n    // Get a loaded sound buffer\n    getSound(name: string): AudioBuffer | null {\n        return this.sounds[name];\n    }\n    \n    // Get all loaded sounds\n    getAllSounds(): SoundMap {\n        return this.sounds;\n    }\n}\n","// playlist.ts - Music queue management and shuffling\nimport { getAbsolutePath } from '../../../utils/pathUtils.js';\n\nexport class MusicPlaylist {\n    private music: HTMLAudioElement[] = []; // Store all background music tracks\n    private musicVolume: number = 0.21; // Reduced by 30% from 0.3\n    \n    constructor() {}\n    \n    // Helper method to handle paths correctly for both local and GitHub Pages deployment\n    getPath(relativePath: string): string {\n        return getAbsolutePath(relativePath);\n    }\n    \n    // Fisher-Yates shuffle algorithm for arrays\n    shuffleArray<T>(array: T[]): T[] {\n        let currentIndex = array.length, randomIndex;\n        \n        // While there remain elements to shuffle\n        while (currentIndex > 0) {\n            // Pick a remaining element\n            randomIndex = Math.floor(Math.random() * currentIndex);\n            currentIndex--;\n            \n            // Swap it with the current element\n            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n        }\n        \n        return array;\n    }\n    \n    // Helper method to check if a file exists\n    async checkFileExists(path: string): Promise<{ path: string; exists: boolean }> {\n        console.log(`Checking if file/directory exists: ${path}`);\n        try {\n            // Try to fetch the resource\n            const response = await fetch(path, { \n                method: 'HEAD',\n                cache: 'no-cache' // Avoid caching issues\n            });\n            \n            console.log(`Fetch response for ${path}: status=${response.status}, ok=${response.ok}`);\n            \n            return { \n                path, \n                exists: response.ok \n            };\n        } catch (err) {\n            console.error(`Error checking if file exists (${path}):`, err);\n            return { path, exists: false };\n        }\n    }\n    \n    // Load all music files from the soundtrack folder\n    async loadBackgroundMusic(): Promise<void> {\n        try {\n            console.log(\"Loading soundtrack files...\");\n            \n            // Directly use the exact soundtrack files from the user's folder\n            const soundtrackFiles = [\n                this.getPath('sounds/soundtrack/The Sound of Lightyears.wav'),\n                this.getPath('sounds/soundtrack/Aurora Drifts.wav'),\n                this.getPath('sounds/soundtrack/Tidal Lock.wav'),\n                this.getPath('sounds/soundtrack/Solar Drift.wav'),\n                this.getPath('sounds/soundtrack/Orbital Resonance.wav'),\n                this.getPath('sounds/soundtrack/Starlight Trails.wav'),\n                this.getPath('sounds/soundtrack/Orbit Bloom.wav')\n            ];\n            \n            console.log(`Loading ${soundtrackFiles.length} soundtrack files...`);\n            \n            // Load the music files\n            await this.loadMusicFiles(soundtrackFiles);\n            \n        } catch (error) {\n            console.error(\"Error loading background music:\", error);\n            \n            // Create a dummy audio element if loading fails\n            console.warn(\"Falling back to a dummy silent track\");\n            this.createDummyTrack();\n        }\n    }\n    \n    // Helper method to load music files\n    async loadMusicFiles(files: string[]): Promise<void> {\n        // Note: Currently keeping music as HTML5 Audio for compatibility\n        // Could be updated to Web Audio API in the future\n        console.log(`Found ${files.length} music files:`, files);\n        \n        // Create a copy of the files array and shuffle it to randomize the order\n        const shuffledFiles = [...files];\n        this.shuffleArray(shuffledFiles);\n        \n        console.log(`Randomized playlist order:`, shuffledFiles.map(file => file.split('/').pop()));\n        \n        // Check if any files exist before trying to load them\n        let anyFilesExist = false;\n        for (const file of shuffledFiles) {\n            const fileExists = await this.checkFileExists(file);\n            if (fileExists.exists) {\n                anyFilesExist = true;\n                break;\n            }\n        }\n        \n        if (!anyFilesExist) {\n            console.warn(\"None of the music files could be found. Using fallback audio.\");\n            this.createDummyTrack();\n            return;\n        }\n        \n        // Load each music track in the randomized order\n        for (const file of shuffledFiles) {\n            try {\n                console.log(`Attempting to load audio file: ${file}`);\n                const audio = new Audio(file);\n                audio.loop = false; // We'll handle looping manually for playlist functionality\n                audio.volume = this.musicVolume;\n                \n                // Add error handler\n                audio.addEventListener('error', (e) => {\n                    console.error(`Error loading music file ${file}:`, e);\n                });\n                \n                // Add a load event to confirm successful loading\n                audio.addEventListener('canplaythrough', () => {\n                    console.log(`Successfully loaded music file: ${file}`);\n                });\n                \n                this.music.push(audio);\n                console.log(`Added music track to playlist: ${file}`);\n            } catch (err) {\n                console.error(`Failed to load music file ${file}:`, err);\n            }\n        }\n        \n        console.log(`Loaded ${this.music.length} music tracks in randomized order`);\n        \n        // If we haven't found any music, create a dummy audio element\n        // so that the music system doesn't break\n        if (this.music.length === 0) {\n            console.warn(\"No music files could be loaded, creating a dummy track\");\n            this.createDummyTrack();\n        }\n    }\n    \n    // Create dummy track if loading fails\n    createDummyTrack(): void {\n        const dummyAudio = new Audio();\n        dummyAudio.loop = true;\n        this.music.push(dummyAudio);\n    }\n    \n    // Play the next music track in the playlist\n    playNextTrack(): HTMLAudioElement | null {\n        if (this.music.length === 0) return null;\n        \n        // Move current track to the end of the playlist\n        const currentTrack = this.music.shift();\n        if (currentTrack) {\n            this.music.push(currentTrack);\n        }\n        \n        // Return the next track\n        return this.getCurrentTrack();\n    }\n    \n    // Get the current track (first in queue)\n    getCurrentTrack(): HTMLAudioElement | null {\n        return this.music.length > 0 ? this.music[0] : null;\n    }\n    \n    // Get all tracks\n    getTracks(): HTMLAudioElement[] {\n        return this.music;\n    }\n    \n    // Set volume for all tracks\n    setVolume(volume: number): void {\n        this.musicVolume = volume;\n        for (const track of this.music) {\n            track.volume = volume;\n        }\n    }\n    \n    // Get current volume\n    getVolume(): number {\n        return this.musicVolume;\n    }\n    \n    // Check if playlist has tracks\n    hasTracks(): boolean {\n        return this.music.length > 0;\n    }\n}\n","// player.ts - Music playback control and volume management\nimport { MusicPlaylist } from './playlist.js';\n\ninterface ExtendedAudioElement extends HTMLAudioElement {\n    hasEndedListener?: boolean;\n}\n\nexport class MusicPlayer {\n    public playlist: MusicPlaylist;\n    private currentMusic: ExtendedAudioElement | null = null;\n    private muted: boolean = false;\n    \n    constructor(playlist: MusicPlaylist) {\n        this.playlist = playlist;\n    }\n    \n    // Start playing background music\n    playBackgroundMusic(userHasInteracted: boolean): void {\n        if (!this.playlist.hasTracks() || this.muted) return;\n        \n        // Only attempt to play if the user has interacted with the page\n        if (!userHasInteracted) {\n            console.log(\"Deferring music playback until user interaction\");\n            return;\n        }\n        \n        // Get the track at the front of the queue\n        const track = this.playlist.getCurrentTrack() as ExtendedAudioElement;\n        if (!track) return;\n        \n        console.log(`Starting to play track: ${track.src.split('/').pop()}`);\n        \n        // Set up ended event listener for this track if not already set\n        if (!track.hasEndedListener) {\n            track.addEventListener('ended', () => this.playNextTrack(userHasInteracted));\n            track.hasEndedListener = true;\n        }\n        \n        // Reset the track to the beginning\n        track.currentTime = 0;\n        \n        // Attempt to play the track\n        const playPromise = track.play();\n        \n        // Handle play promise (modern browsers return a promise from play())\n        if (playPromise !== undefined) {\n            playPromise\n                .then(() => {\n                    console.log(\"Started playing background music\");\n                    this.currentMusic = track;\n                })\n                .catch(err => {\n                    if (err.name === 'NotAllowedError') {\n                        console.log(\"Autoplay prevented by browser. Music will play after user interaction.\");\n                    } else {\n                        console.error(\"Error playing background music:\", err);\n                    }\n                });\n        } else {\n            this.currentMusic = track;\n        }\n    }\n    \n    // Play the next track in the playlist\n    playNextTrack(userHasInteracted: boolean): void {\n        const nextTrack = this.playlist.playNextTrack();\n        if (nextTrack && userHasInteracted) {\n            this.playBackgroundMusic(userHasInteracted);\n        }\n    }\n    \n    // Toggle mute for music\n    toggleMute(): boolean {\n        this.muted = !this.muted;\n        \n        // Adjust music volume\n        const tracks = this.playlist.getTracks();\n        for (const track of tracks) {\n            track.volume = this.muted ? 0 : this.playlist.getVolume();\n        }\n        \n        console.log(`Music ${this.muted ? 'muted' : 'unmuted'}`);\n        return this.muted;\n    }\n    \n    // Set music volume\n    setVolume(volume: number): void {\n        this.playlist.setVolume(this.muted ? 0 : volume);\n    }\n    \n    // Get current music volume\n    getVolume(): number {\n        return this.playlist.getVolume();\n    }\n    \n    // Check if music is muted\n    isMuted(): boolean {\n        return this.muted;\n    }\n    \n    // Pause all music\n    pauseAll(): void {\n        const tracks = this.playlist.getTracks();\n        for (const track of tracks) {\n            track.pause();\n        }\n        this.currentMusic = null;\n    }\n    \n    // Get current playing track\n    getCurrentTrack(): ExtendedAudioElement | null {\n        return this.currentMusic;\n    }\n}\n","// soundPlayer.ts - Sound effects playback with 3D audio and volume control\nimport { AudioContextManager, TrackableNode } from '../core/context.js';\nimport { AudioLoader } from '../core/loader.js';\n\ninterface ActiveSoundNodes {\n    source: AudioBufferSourceNode & TrackableNode;\n    gain: GainNode & TrackableNode;\n}\n\nexport class SoundPlayer {\n    private audioContextManager: AudioContextManager;\n    private audioLoader: AudioLoader;\n    private sfxVolume: number = 0.5; // Default sound effects volume\n    private muted: boolean = false;\n    \n    private lastWeaponSoundPlayTime: number = 0;\n    private weaponSoundCooldown: number = 70; // milliseconds\n    \n    \n    // Track active continuous sounds\n    public activeSounds: {\n        [key: string]: ActiveSoundNodes | null;\n    } = {\n        laser: null,\n        thrust: null,\n        \"mining-laser\": null\n    };\n    \n    constructor(audioContextManager: AudioContextManager, audioLoader: AudioLoader) {\n        this.audioContextManager = audioContextManager;\n        this.audioLoader = audioLoader;\n    }\n    \n    // Play a sound effect using Web Audio API\n    playSound(name: string, userHasInteracted: boolean): void {\n        console.log(`Attempting to play sound: ${name}`);\n        \n        if (this.muted) {\n            console.log(`Sound ${name} not played: audio is muted`);\n            return;\n        }\n        \n        if (!userHasInteracted) {\n            console.log(`Sound ${name} not played: waiting for user interaction`);\n            return;\n        }\n        \n        const audioContext = this.audioContextManager.getContext();\n        if (!audioContext) {\n            console.warn(\"AudioContext not available for playing sound\");\n            return;\n        }\n        \n        // Make sure AudioContext is running\n        if (audioContext.state === 'suspended') {\n            this.audioContextManager.resumeAudioContext();\n        }\n        \n        // Handle the case where the name is 'weapon' or similar, map to projectile sound\n        if (name === 'weapon' || name === 'fire' || name === 'shoot') {\n            console.log(`Mapping ${name} sound to projectile sound`);\n            name = 'projectile';\n            // Use 'laser' sound for projectile if projectile sound is not available\n            const sounds = this.audioLoader.getAllSounds();\n            if (!sounds.projectile && sounds.laser) {\n                console.log(\"Using laser sound for projectile\");\n                sounds.projectile = sounds.laser;\n            }\n        }\n        \n        const soundBuffer = this.audioLoader.getSound(name);\n        if (!soundBuffer) {\n            console.warn(`Sound \"${name}\" not found in loaded sounds`);\n            return;\n        }\n        \n        try {\n            // Handle looped sounds vs one-shot sounds\n            if (name === 'laser' || name === 'thrust' || name === 'mining-laser') {\n                // For continuous sounds, create and track the sound source node\n                if (!this.activeSounds[name]) {\n                    // Create source node for looping sound\n                    const sourceNode = audioContext.createBufferSource() as AudioBufferSourceNode & TrackableNode;\n                    sourceNode.buffer = soundBuffer;\n                    sourceNode.loop = true;\n                    \n                    // Create gain node for volume control\n                    const gainNode = audioContext.createGain() as GainNode & TrackableNode;\n                    gainNode.gain.value = this.sfxVolume * (name === 'thrust' ? 1.5 : 1.0);\n                    \n                    // Connect nodes: source -> gain -> destination\n                    sourceNode.connect(gainNode);\n                    gainNode.connect(audioContext.destination);\n                    \n                    // Start playing\n                    sourceNode.start(0);\n                    \n                    // Store references to these nodes for later control\n                    this.activeSounds[name] = {\n                        source: sourceNode,\n                        gain: gainNode\n                    };\n                    \n                    // Track nodes for garbage collection\n                    this.audioContextManager.trackNode(sourceNode);\n                    this.audioContextManager.trackNode(gainNode);\n                }\n            } else {\n                // For one-shot sounds\n                // Create source node\n                const sourceNode = audioContext.createBufferSource() as AudioBufferSourceNode & TrackableNode;\n                sourceNode.buffer = soundBuffer;\n                \n                // Create gain node for volume control\n                const gainNode = audioContext.createGain() as GainNode & TrackableNode;\n                // Increase volume slightly for projectile sounds to make them more noticeable\n                const volumeMultiplier = name === 'projectile' ? 0.7 : 0.5;\n                gainNode.gain.value = this.sfxVolume * volumeMultiplier;\n                \n                // Connect nodes: source -> gain -> destination\n                sourceNode.connect(gainNode);\n                gainNode.connect(audioContext.destination);\n                \n                // Start playing (one-shot)\n                sourceNode.start(0);\n                \n                // Set ended callback for cleanup\n                sourceNode.onended = () => {\n                    sourceNode._inactive = true;\n                    gainNode._inactive = true;\n                };\n                \n                // Track nodes for garbage collection\n                this.audioContextManager.trackNode(sourceNode);\n                this.audioContextManager.trackNode(gainNode);\n                \n                // Log successful playback\n                console.log(`Started playback of one-shot sound: ${name}`);\n            }\n        } catch (err) {\n            console.error(`Error playing sound ${name}:`, err);\n        }\n    }\n    \n    // Stop a continuous sound effect\n    stopSound(name: string): void {\n        if (!this.activeSounds[name]) return;\n        \n        try {\n            if (name === 'laser' || name === 'thrust' || name === 'mining-laser') {\n                // For looping sounds\n                const nodes = this.activeSounds[name];\n                if (nodes) {\n                    // Stop the source node\n                    if (nodes.source) {\n                        try {\n                            nodes.source.stop();\n                        } catch (e) {\n                            // Ignore errors if already stopped\n                        }\n                        nodes.source._inactive = true;\n                    }\n                    \n                    // Mark gain node as inactive\n                    if (nodes.gain) {\n                        nodes.gain._inactive = true;\n                    }\n                    \n                    // Clear reference\n                    this.activeSounds[name] = null;\n                }\n            }\n        } catch (err) {\n            console.error(`Error stopping sound ${name}:`, err);\n        }\n    }\n    \n    // Set the volume for thrust sound based on thrust level\n    setThrustVolume(thrustLevel: number): void {\n        const thrustSound = this.activeSounds.thrust;\n        if (!thrustSound || !thrustSound.gain) return;\n        \n        // Scale the volume based on thrust level\n        const volume = Math.min(1.0, Math.max(0.1, thrustLevel)) * this.sfxVolume * 1.5;\n        \n        // Apply volume to gain node\n        try {\n            thrustSound.gain.gain.value = volume;\n        } catch (err) {\n            console.error(\"Error setting thrust volume:\", err);\n        }\n    }\n    \n    // Play weapon firing sound - dedicated method for weapon sounds\n    playWeaponSound(userHasInteracted: boolean): void {\n        console.log(\"Playing weapon firing sound\");\n        \n        // Check usual conditions\n        if (this.muted || !userHasInteracted) {\n            return;\n        }\n        \n        const audioContext = this.audioContextManager.getContext();\n        if (!audioContext) {\n            console.warn(\"AudioContext not available for weapon sound\");\n            return;\n        }\n        \n        // Make sure AudioContext is running\n        if (audioContext.state === 'suspended') {\n            this.audioContextManager.resumeAudioContext();\n        }\n        \n        // Make sure we have a projectile sound (use laser as fallback)\n        const sounds = this.audioLoader.getAllSounds();\n        if (!sounds.projectile && sounds.laser) {\n            console.log(\"Using laser sound for projectile in playWeaponSound\");\n            sounds.projectile = sounds.laser;\n        }\n        \n        if (!sounds.projectile) {\n            console.warn(\"Projectile sound not found\");\n            return;\n        }\n        \n        // Check for cooldown\n        const now = performance.now();\n        if (now - this.lastWeaponSoundPlayTime < this.weaponSoundCooldown) {\n            return;\n        }\n        this.lastWeaponSoundPlayTime = now;\n        \n        try {\n            // Create source node\n            const sourceNode = audioContext.createBufferSource() as AudioBufferSourceNode & TrackableNode;\n            sourceNode.buffer = sounds.projectile;\n\n            // Apply pitch variation (+/- 5% or 50 cents)\n            const pitchVariation = (Math.random() * 100) - 50; // -50 to +50 cents\n            sourceNode.detune.value = pitchVariation;\n            \n            // Create gain node with higher volume for weapon sound\n            const gainNode = audioContext.createGain() as GainNode & TrackableNode;\n            gainNode.gain.value = this.sfxVolume * 0.8; // Higher volume for weapon sounds\n            \n            // Connect nodes: source -> gain -> destination\n            sourceNode.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            // Start playing\n            sourceNode.start(0);\n            \n            // Set ended callback for cleanup\n            sourceNode.onended = () => {\n                sourceNode._inactive = true;\n                gainNode._inactive = true;\n            };\n            \n            // Track nodes for garbage collection\n            this.audioContextManager.trackNode(sourceNode);\n            this.audioContextManager.trackNode(gainNode);\n            \n            console.log(\"Weapon sound started playing\");\n        } catch (err) {\n            console.error(\"Error playing weapon sound:\", err);\n        }\n    }\n    \n    // Toggle mute for sound effects\n    toggleMute(): boolean {\n        this.muted = !this.muted;\n        \n        // Stop any active sound effects when muting\n        if (this.muted) {\n            this.stopSound('laser');\n            this.stopSound('thrust');\n            this.stopSound('mining-laser');\n        }\n        \n        console.log(`Sound effects ${this.muted ? 'muted' : 'unmuted'}`);\n        return this.muted;\n    }\n    \n    // Set sound effects volume\n    setVolume(volume: number): void {\n        this.sfxVolume = volume;\n    }\n    \n    // Get sound effects volume\n    getVolume(): number {\n        return this.sfxVolume;\n    }\n    \n    // Check if sound effects are muted\n    isMuted(): boolean {\n        return this.muted;\n    }\n    \n    // Stop all active sounds\n    stopAllSounds(): void {\n        this.stopSound('laser');\n        this.stopSound('thrust');\n        this.stopSound('mining-laser');\n    }\n}\n","// enabler.ts - Mobile audio unlock handling and user interaction detection\nimport { AudioContextManager } from '../core/context.js';\nimport { MusicPlayer } from '../music/player.js';\n\nexport class MobileAudioEnabler {\n    private audioContextManager: AudioContextManager;\n    private musicPlayer: MusicPlayer;\n    private userHasInteracted: boolean = false;\n    \n    constructor(audioContextManager: AudioContextManager, musicPlayer: MusicPlayer) {\n        this.audioContextManager = audioContextManager;\n        this.musicPlayer = musicPlayer;\n        \n        this.setupUserInteractionListener();\n    }\n    \n    // Check if user has interacted\n    hasUserInteracted(): boolean {\n        return this.userHasInteracted;\n    }\n    \n    // Show a notification to the user when a directory is missing\n    showDirectoryMissingNotification(directory: string): void {\n        console.warn(`Directory not found: ${directory}`);\n        \n        // Create a notification element\n        const notification = document.createElement('div');\n        notification.style.position = 'fixed';\n        notification.style.top = '20px';\n        notification.style.left = '50%';\n        notification.style.transform = 'translateX(-50%)';\n        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n        notification.style.color = '#ff4400';\n        notification.style.padding = '10px 15px';\n        notification.style.borderRadius = '5px';\n        notification.style.zIndex = '9999';\n        notification.style.fontSize = '14px';\n        notification.style.maxWidth = '80%';\n        notification.style.textAlign = 'center';\n        \n        // Add message\n        notification.innerHTML = `\n            <div style=\"margin-bottom: 5px;\">\n                <strong>Note:</strong> ${directory} directory not found.\n            </div>\n            <div style=\"font-size: 12px; color: #aaa;\">\n                Game will continue with limited audio. This is normal when running on GitHub Pages.\n            </div>\n        `;\n        \n        // Add close button\n        const closeButton = document.createElement('div');\n        closeButton.style.position = 'absolute';\n        closeButton.style.top = '5px';\n        closeButton.style.right = '10px';\n        closeButton.style.cursor = 'pointer';\n        closeButton.style.color = '#aaa';\n        closeButton.textContent = 'âœ•';\n        closeButton.addEventListener('click', () => notification.remove());\n        notification.appendChild(closeButton);\n        \n        // Add to document\n        document.body.appendChild(notification);\n        \n        // Auto-remove after 5 seconds\n        setTimeout(() => {\n            if (document.body.contains(notification)) {\n                notification.style.opacity = '0';\n                notification.style.transition = 'opacity 0.5s ease';\n                setTimeout(() => {\n                    if (document.body.contains(notification)) {\n                        notification.remove();\n                    }\n                }, 500);\n            }\n        }, 5000);\n    }\n    \n    // Set up a listener to detect the first user interaction\n    setupUserInteractionListener(): void {\n        const handleInteraction = () => {\n            if (!this.userHasInteracted) {\n                this.userHasInteracted = true;\n                console.log(\"User interaction detected, enabling audio playback\");\n                \n                // Resume AudioContext if it's suspended\n                this.audioContextManager.resumeAudioContext();\n                \n                // Start playing background music once the user interacts\n                this.musicPlayer.playBackgroundMusic(true);\n                \n                // Clean up the event listeners\n                document.removeEventListener('click', handleInteraction);\n                document.removeEventListener('keydown', handleInteraction);\n                document.removeEventListener('touchstart', handleInteraction);\n            }\n        };\n        \n        // Add event listeners for user interactions\n        document.addEventListener('click', handleInteraction);\n        document.addEventListener('keydown', handleInteraction);\n        document.addEventListener('touchstart', handleInteraction);\n        \n        // Additional handling specifically for mobile devices\n        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {\n            console.log(\"Mobile device detected - adding additional audio handlers\");\n            \n            // Force audio context resumption on specific UI interactions for mobile\n            const forceAudioResume = () => {\n                this.userHasInteracted = true;\n                \n                // Resume AudioContext if it's suspended\n                this.audioContextManager.resumeAudioContext();\n                \n                // Ensure background music is playing\n                const playlist = this.musicPlayer.playlist;\n                if (playlist.hasTracks() && !this.musicPlayer.isMuted()) {\n                    const currentTrack = playlist.getCurrentTrack();\n                    if (currentTrack && currentTrack.paused) {\n                        console.log(\"Mobile: Forcing background music playback\");\n                        this.musicPlayer.playBackgroundMusic(true);\n                    }\n                }\n            };\n            \n            // Add these handlers to common UI interaction points\n            document.addEventListener('touchend', forceAudioResume, {passive: true});\n            \n            // Attach to specific game buttons when they're created\n            const attachToButtons = () => {\n                // Check for UI elements every 500ms for 5 seconds after page load\n                let attempts = 0;\n                const interval = setInterval(() => {\n                    attempts++;\n                    \n                    // Find and attach to important action buttons\n                    const actionButtons = document.querySelectorAll('button');\n                    if (actionButtons.length > 0) {\n                        console.log(`Mobile: Found ${actionButtons.length} buttons to attach audio handlers`);\n                        actionButtons.forEach(button => {\n                            const btn = button as HTMLButtonElement & { hasAudioHandler?: boolean };\n                            if (!btn.hasAudioHandler) {\n                                btn.addEventListener('touchend', forceAudioResume, {passive: true});\n                                btn.hasAudioHandler = true;\n                            }\n                        });\n                    }\n                    \n                    // Stop checking after 10 attempts (5 seconds)\n                    if (attempts >= 10) {\n                        clearInterval(interval);\n                    }\n                }, 500);\n            };\n            \n            // Run initially and also after document is fully loaded\n            attachToButtons();\n            if (document.readyState === 'complete') {\n                attachToButtons();\n            } else {\n                window.addEventListener('load', attachToButtons);\n            }\n        }\n    }\n    \n    // Clean up event listeners\n    cleanup(): void {\n        // Note: The actual cleanup of event listeners is handled in the main handler\n        // This method is here for consistency with other modules\n        this.userHasInteracted = false;\n        console.log(\"Mobile audio enabler cleanup complete\");\n    }\n}\n","// audio.ts - Main AudioManager facade that delegates to specialized modules\nimport { AudioContextManager } from './core/context.js';\nimport { AudioLoader, SoundMap } from './core/loader.js';\nimport { MusicPlaylist } from './music/playlist.js';\nimport { MusicPlayer } from './music/player.js';\nimport { SoundPlayer } from './effects/soundPlayer.js';\nimport { MobileAudioEnabler } from './mobile/enabler.js';\n\nexport class AudioManager {\n    private audioContextManager: AudioContextManager;\n    private audioLoader: AudioLoader;\n    private musicPlaylist: MusicPlaylist;\n    private musicPlayer: MusicPlayer;\n    private soundPlayer: SoundPlayer;\n    private mobileEnabler: MobileAudioEnabler;\n    \n    // Exposed properties for compatibility\n    public sounds: SoundMap;\n    public soundSources: Record<string, any> = {}; // Legacy compatibility\n    public backgroundMusic: any[] = []; // Legacy compatibility\n    public currentMusicIndex: number = 0; // Legacy compatibility\n    public currentMusic: any = null; // Legacy compatibility\n    public music: HTMLAudioElement[];\n    public activeNodes: Set<any>;\n    public activeSounds: Record<string, any>;\n    \n    // Compatibility layer for intro sequence\n    private masterEQ: any;\n    \n    constructor() {\n        // Initialize core components\n        this.audioContextManager = new AudioContextManager();\n        this.audioLoader = new AudioLoader(this.audioContextManager);\n        this.musicPlaylist = new MusicPlaylist();\n        this.musicPlayer = new MusicPlayer(this.musicPlaylist);\n        this.soundPlayer = new SoundPlayer(this.audioContextManager, this.audioLoader);\n        this.mobileEnabler = new MobileAudioEnabler(this.audioContextManager, this.musicPlayer);\n        \n        // Exposed properties for compatibility\n        this.sounds = this.audioLoader.getAllSounds();\n        this.music = this.musicPlaylist.getTracks();\n        this.activeNodes = (this.audioContextManager as any).activeNodes;\n        this.activeSounds = this.soundPlayer.activeSounds;\n        \n        // Set up compatibility layer for intro sequence\n        this.masterEQ = this.audioContextManager.initializeToneCompatibility();\n        \n        console.log(\"Initializing audio manager with Web Audio API...\");\n    }\n    \n    // Getter/setter for volume properties\n    get isMuted(): boolean {\n        return this.soundPlayer.isMuted() || this.musicPlayer.isMuted();\n    }\n    \n    set isMuted(value: boolean) {\n        // Legacy setter - use toggleMute() instead\n        if (value !== this.isMuted) {\n            this.toggleMute();\n        }\n    }\n    \n    get muted(): boolean {\n        return this.isMuted;\n    }\n    \n    set muted(value: boolean) {\n        this.isMuted = value;\n    }\n    \n    get musicVolume(): number {\n        return this.musicPlayer.getVolume();\n    }\n    \n    set musicVolume(value: number) {\n        this.musicPlayer.setVolume(value);\n    }\n    \n    get sfxVolume(): number {\n        return this.soundPlayer.getVolume();\n    }\n    \n    set sfxVolume(value: number) {\n        this.soundPlayer.setVolume(value);\n    }\n    \n    get userHasInteracted(): boolean {\n        return this.mobileEnabler.hasUserInteracted();\n    }\n    \n    get audioContext(): AudioContext | null {\n        return this.audioContextManager.getContext();\n    }\n    \n    // Initialize audio - load all sounds and music\n    async initialize(): Promise<boolean> {\n        try {\n            console.log(\"Loading audio files...\");\n            \n            // Ensure audio context is resumed on first user interaction\n            const context = this.audioContext;\n            if (context && context.state === 'suspended') {\n                this.audioContextManager.resumeAudioContext();\n            }\n            \n            // Check if the sound directories exist for music\n            await this.audioLoader.checkSoundDirectories();\n            \n            // Load only the essential UI sounds first for faster startup\n            await this.audioLoader.preDecodeEssentialSounds();\n            \n            // Load music in the background (non-blocking)\n            this.musicPlaylist.loadBackgroundMusic().catch(error => {\n                console.error(\"Error loading background music:\", error);\n            });\n            \n            console.log(\"Essential audio initialization complete\");\n            \n            // Music will play automatically once the user interacts with the page\n            // If the user has already interacted, we can play immediately\n            if (this.userHasInteracted) {\n                this.musicPlayer.playBackgroundMusic(true);\n            } else {\n                console.log(\"Music playback waiting for user interaction.\");\n            }\n            \n            // Schedule loading of remaining gameplay sounds in the background \n            // after a short delay to let the UI fully initialize\n            setTimeout(() => {\n                this.audioLoader.loadGameplaySounds();\n            }, 1000);\n            \n            return true;\n        } catch (error) {\n            console.error(\"Error initializing audio:\", error);\n            return false;\n        }\n    }\n    \n    // Legacy method for compatibility\n    async preDecodeAllSoundEffects(): Promise<void> {\n        console.log(\"Using optimized sound loading path instead of preDecodeAllSoundEffects\");\n        await this.audioLoader.preDecodeEssentialSounds();\n        await this.audioLoader.loadGameplaySounds();\n    }\n    \n    // Resume audio context on user interaction\n    resumeAudioContext(): Promise<void> {\n        return this.audioContextManager.resumeAudioContext();\n    }\n    \n    // Start playing background music\n    playBackgroundMusic(): void {\n        this.musicPlayer.playBackgroundMusic(this.userHasInteracted);\n    }\n    \n    // Play the next music track in the playlist\n    playNextTrack(): void {\n        this.musicPlayer.playNextTrack(this.userHasInteracted);\n    }\n    \n    // Play a sound effect\n    playSound(name: string): void {\n        this.soundPlayer.playSound(name, this.userHasInteracted);\n    }\n    \n    // Stop a continuous sound effect\n    stopSound(name: string): void {\n        this.soundPlayer.stopSound(name);\n    }\n    \n    // Set the volume for thrust sound based on thrust level\n    setThrustVolume(thrustLevel: number): void {\n        this.soundPlayer.setThrustVolume(thrustLevel);\n    }\n    \n    // Play weapon firing sound\n    playWeaponSound(): void {\n        this.soundPlayer.playWeaponSound(this.userHasInteracted);\n    }\n    \n    // Toggle mute for all audio\n    toggleMute(): boolean {\n        const soundMuted = this.soundPlayer.toggleMute();\n        const musicMuted = this.musicPlayer.toggleMute();\n        \n        const overallMuted = soundMuted || musicMuted;\n        console.log(`Audio ${overallMuted ? 'muted' : 'unmuted'}`);\n        return overallMuted;\n    }\n    \n    // Track an audio node for garbage collection (legacy compatibility)\n    trackNode(node: any): any {\n        return this.audioContextManager.trackNode(node);\n    }\n    \n    // Clean up inactive audio nodes (legacy compatibility)\n    cleanupInactiveNodes(): void {\n        this.audioContextManager.cleanupInactiveNodes();\n    }\n    \n    // Setup garbage collection (legacy compatibility)\n    setupGarbageCollection(): void {\n        // Already handled in audioContextManager constructor\n        console.log(\"Garbage collection already set up in context manager\");\n    }\n    \n    // Setup user interaction listener (legacy compatibility)\n    setupUserInteractionListener(): void {\n        // Already handled in mobileEnabler constructor\n        console.log(\"User interaction listener already set up in mobile enabler\");\n    }\n    \n    // Initialize tone compatibility (legacy compatibility)\n    initializeToneCompatibility(): any {\n        return this.masterEQ;\n    }\n    \n    // Clean up resources when destroying the audio manager\n    cleanup(): void {\n        console.log(\"Cleaning up AudioManager resources...\");\n        \n        // Stop all active sounds\n        this.soundPlayer.stopAllSounds();\n        \n        // Pause all music\n        this.musicPlayer.pauseAll();\n        \n        // Clean up mobile enabler\n        this.mobileEnabler.cleanup();\n        \n        // Clean up audio context\n        this.audioContextManager.cleanup();\n        \n        console.log(\"AudioManager cleanup complete\");\n    }\n}\n"],"names":["AudioContextManager","__publicField","AudioContextClass","error","count","node","AudioLoader","audioContextManager","relativePath","getAbsolutePath","name","url","audioContext","response","audioData","audioBuffer","loadPromises","sound","gameplaySounds","err","soundEffects","buffer","path","MusicPlaylist","array","currentIndex","randomIndex","soundtrackFiles","files","shuffledFiles","file","anyFilesExist","audio","e","dummyAudio","currentTrack","volume","track","MusicPlayer","playlist","userHasInteracted","playPromise","tracks","SoundPlayer","audioLoader","sounds","soundBuffer","sourceNode","gainNode","volumeMultiplier","nodes","thrustLevel","thrustSound","now","pitchVariation","MobileAudioEnabler","musicPlayer","directory","notification","closeButton","handleInteraction","forceAudioResume","attachToButtons","attempts","interval","actionButtons","button","btn","AudioManager","value","context","soundMuted","musicMuted","overallMuted"],"mappings":"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"}