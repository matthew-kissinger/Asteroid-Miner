{"version":3,"file":"InstancedRenderer-CFyXucD5.js","sources":["../../js/systems/rendering/InstancedRenderer.js"],"sourcesContent":["// InstancedRenderer.js - ECS-driven instanced rendering per cell × archetype\r\n\r\nimport * as THREE from 'three';\r\nimport { System } from '../../core/system.js';\r\n\r\nexport class InstancedRenderer extends System {\r\n  constructor(world, scene) {\r\n    super(world);\r\n    this.requiredComponents = ['TransformComponent'];\r\n    this.priority = 95; // run before standard RenderSystem (which is 100)\r\n    this.scene = scene;\r\n    this.cellSize = world && world.spatial ? world.spatial.cellSize : 400;\r\n\r\n    // cellKey|archetype -> { mesh, count, max, freeIds, dummy }\r\n    this.cellMeshes = new Map();\r\n    // entityId -> { key, index }\r\n    this.entityToInstance = new Map();\r\n  }\r\n\r\n  initialize() {\r\n    // Nothing on init; will allocate lazily\r\n  }\r\n\r\n  getArchetype(entity) {\r\n    if (entity.hasTag && entity.hasTag('enemy')) return 'enemy_drone';\r\n    return null; // others not yet handled\r\n  }\r\n\r\n  getCellKeyFromPosition(pos) {\r\n    const ix = Math.floor(pos.x / this.cellSize) | 0;\r\n    const iy = Math.floor(pos.y / this.cellSize) | 0;\r\n    const iz = Math.floor(pos.z / this.cellSize) | 0;\r\n    return `${ix}|${iy}|${iz}`;\r\n  }\r\n\r\n  ensureCellMesh(cellKey, archetype, sampleMesh) {\r\n    const key = `${cellKey}|${archetype}`;\r\n    let rec = this.cellMeshes.get(key);\r\n    if (rec) return rec;\r\n    // Derive geometry/material from sample mesh or simple placeholder\r\n    let geom, mat;\r\n    if (sampleMesh && sampleMesh.geometry && sampleMesh.material) {\r\n      geom = sampleMesh.geometry;\r\n      mat = sampleMesh.material;\r\n    } else {\r\n      geom = new THREE.SphereGeometry(2, 8, 8);\r\n      mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });\r\n    }\r\n    const max = 2048; // capacity per cell × archetype\r\n    const inst = new THREE.InstancedMesh(geom, mat, max);\r\n    inst.count = 0;\r\n    inst.frustumCulled = true;\r\n    this.scene.add(inst);\r\n    rec = { mesh: inst, count: 0, max, freeIds: [], dummy: new THREE.Object3D() };\r\n    this.cellMeshes.set(key, rec);\r\n    return rec;\r\n  }\r\n\r\n  allocateInstance(rec) {\r\n    if (rec.freeIds.length > 0) return rec.freeIds.pop();\r\n    if (rec.count >= rec.max) return -1;\r\n    const id = rec.count;\r\n    rec.count++;\r\n    rec.mesh.count = rec.count;\r\n    return id;\r\n  }\r\n\r\n  releaseInstance(rec, index) {\r\n    if (index < 0) return;\r\n    rec.freeIds.push(index);\r\n  }\r\n\r\n  update(deltaTime) {\r\n    const world = this.world;\r\n    if (!world || !world.entityManager) return;\r\n    const entities = world.getEntitiesWithComponents(['TransformComponent', 'MeshComponent']);\r\n\r\n    // Per-frame: hide original meshes for handled archetypes\r\n    for (const entity of entities) {\r\n      const archetype = this.getArchetype(entity);\r\n      if (!archetype) continue;\r\n      const meshComp = entity.getComponent('MeshComponent');\r\n      if (meshComp && meshComp.mesh) meshComp.mesh.visible = false;\r\n      const t = entity.getComponent('TransformComponent');\r\n      const cellKey = this.getCellKeyFromPosition(t.position);\r\n      const key = `${cellKey}|${archetype}`;\r\n      let mapEntry = this.entityToInstance.get(entity.id);\r\n      let rec = this.cellMeshes.get(key);\r\n\r\n      // If entity moved cell or not allocated, (re)allocate\r\n      if (!mapEntry || mapEntry.key !== key) {\r\n        // free previous\r\n        if (mapEntry) {\r\n          const prev = this.cellMeshes.get(mapEntry.key);\r\n          if (prev) this.releaseInstance(prev, mapEntry.index);\r\n        }\r\n        // ensure mesh\r\n        rec = this.ensureCellMesh(cellKey, archetype, meshComp ? meshComp.mesh : null);\r\n        const idx = this.allocateInstance(rec);\r\n        if (idx === -1) continue; // capacity reached\r\n        mapEntry = { key, index: idx };\r\n        this.entityToInstance.set(entity.id, mapEntry);\r\n      }\r\n\r\n      if (!rec) rec = this.cellMeshes.get(key);\r\n      if (!rec) continue;\r\n\r\n      // Update instance matrix\r\n      rec.dummy.position.copy(t.position);\r\n      rec.dummy.quaternion.copy(t.quaternion);\r\n      rec.dummy.scale.set(1, 1, 1);\r\n      rec.dummy.updateMatrix();\r\n      rec.mesh.setMatrixAt(mapEntry.index, rec.dummy.matrix);\r\n      rec.mesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    // TODO: CPU frustum cull by toggling entire cell meshes via bounding boxes\r\n    // and picking instanceId → entityId mapping if needed in future gates.\r\n  }\r\n}\r\n\r\n\r\n"],"names":["InstancedRenderer","System","world","scene","entity","pos","ix","iy","iz","cellKey","archetype","sampleMesh","key","rec","geom","mat","THREE.SphereGeometry","THREE.MeshBasicMaterial","max","inst","THREE.InstancedMesh","THREE.Object3D","id","index","deltaTime","entities","meshComp","t","mapEntry","prev","idx"],"mappings":"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"}