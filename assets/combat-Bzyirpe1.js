import{S as Ce,W as $e}from"./core-AGMxUAyq.js";import{F as Z}from"./game-modules-DrL_oOTa.js";import{ab as Be,ac as oe,ad as ve,ae as ze,af as H,ag as Pe,ah as L,V as de,a as C,ai as _,h as V,aj as He,k as Re,D as Ue,m as j,b as E,I as Ke,Q as q,ak as Ve,l as Y,T as qe,al as We,r as U,am as Xe,an as De,ao as Ye,ap as Qe,aq as Ze,ar as ae,as as Ie,at as re,au as Je,av as et,u as Le,aw as J,a5 as le,K as me,v as W,c as R,ax as tt,B as $,ay as st,M as P,a8 as nt,a6 as X,az as it,s as pe,G as ee,P as ot,aA as at,O as rt,aB as lt,aC as ct,aD as ht,aE as dt,aF as Fe,aG as mt,a9 as ge,aH as ye,aI as we,aJ as Te,aK as Ae,x as pt,aL as ut,a0 as ft,aM as gt,R as _e,q as K,t as ue,A as N,L as yt,n as te,d as wt,F as Tt}from"./three-DEtojxaq.js";import{T as fe,H as Oe,R as At}from"./components-oXlWjsfY.js";import{R as Et,C as Mt,V as St}from"./physics-rendering-Bkwvzh1H.js";function Ee(p,e){if(e===Be)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),p;if(e===oe||e===ve){let t=p.getIndex();if(t===null){const o=[],l=p.getAttribute("position");if(l!==void 0){for(let r=0;r<l.count;r++)o.push(r);p.setIndex(o),t=p.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),p}const n=t.count-2,i=[];if(e===oe)for(let o=1;o<=n;o++)i.push(t.getX(0)),i.push(t.getX(o)),i.push(t.getX(o+1));else for(let o=0;o<n;o++)o%2===0?(i.push(t.getX(o)),i.push(t.getX(o+1)),i.push(t.getX(o+2))):(i.push(t.getX(o+2)),i.push(t.getX(o+1)),i.push(t.getX(o)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=p.clone();return s.setIndex(i),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),p}class xt extends ze{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Rt(t)}),this.register(function(t){return new Dt(t)}),this.register(function(t){return new kt(t)}),this.register(function(t){return new $t(t)}),this.register(function(t){return new Bt(t)}),this.register(function(t){return new Lt(t)}),this.register(function(t){return new Ft(t)}),this.register(function(t){return new _t(t)}),this.register(function(t){return new Ot(t)}),this.register(function(t){return new Pt(t)}),this.register(function(t){return new Nt(t)}),this.register(function(t){return new It(t)}),this.register(function(t){return new Gt(t)}),this.register(function(t){return new jt(t)}),this.register(function(t){return new Ct(t)}),this.register(function(t){return new zt(t)}),this.register(function(t){return new Ht(t)})}load(e,t,n,i){const s=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const a=H.extractUrlBase(e);o=H.resolveURL(a,this.path)}else o=H.extractUrlBase(e);this.manager.itemStart(e);const l=function(a){i?i(a):console.error(a),s.manager.itemError(e),s.manager.itemEnd(e)},r=new Pe(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(a){try{s.parse(a,o,function(c){t(c),s.manager.itemEnd(e)},l)}catch(c){l(c)}},n,l)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){let s;const o={},l={},r=new TextDecoder;if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(r.decode(new Uint8Array(e,0,4))===Ne){try{o[S.KHR_BINARY_GLTF]=new Ut(e)}catch(h){i&&i(h);return}s=JSON.parse(o[S.KHR_BINARY_GLTF].content)}else s=JSON.parse(r.decode(e));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const a=new ns(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});a.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](a);h.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),l[h.name]=h,o[h.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const h=s.extensionsUsed[c],d=s.extensionsRequired||[];switch(h){case S.KHR_MATERIALS_UNLIT:o[h]=new vt;break;case S.KHR_DRACO_MESH_COMPRESSION:o[h]=new Kt(s,this.dracoLoader);break;case S.KHR_TEXTURE_TRANSFORM:o[h]=new Vt;break;case S.KHR_MESH_QUANTIZATION:o[h]=new qt;break;default:d.indexOf(h)>=0&&l[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}a.setExtensions(o),a.setPlugins(l),a.parse(n,i)}parseAsync(e,t){const n=this;return new Promise(function(i,s){n.parse(e,t,i,s)})}}function bt(){let p={};return{get:function(e){return p[e]},add:function(e,t){p[e]=t},remove:function(e){delete p[e]},removeAll:function(){p={}}}}const S={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Ct{constructor(e){this.parser=e,this.name=S.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const s=t[n];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const s=t.json,r=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let a;const c=new C(16777215);r.color!==void 0&&c.setRGB(r.color[0],r.color[1],r.color[2],_);const h=r.range!==void 0?r.range:0;switch(r.type){case"directional":a=new Ue(c),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new Re(c),a.distance=h;break;case"spot":a=new He(c),a.distance=h,r.spot=r.spot||{},r.spot.innerConeAngle=r.spot.innerConeAngle!==void 0?r.spot.innerConeAngle:0,r.spot.outerConeAngle=r.spot.outerConeAngle!==void 0?r.spot.outerConeAngle:Math.PI/4,a.angle=r.spot.outerConeAngle,a.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return a.position.set(0,0,0),F(a,r),r.intensity!==void 0&&(a.intensity=r.intensity),a.name=t.createUniqueName(r.name||"light_"+e),i=Promise.resolve(a),t.cache.add(n,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,s=n.json.nodes[e],l=(s.extensions&&s.extensions[this.name]||{}).light;return l===void 0?null:this._loadLight(l).then(function(r){return n._getNodeRef(t.cache,l,r)})}}class vt{constructor(){this.name=S.KHR_MATERIALS_UNLIT}getMaterialType(){return R}extendParams(e,t,n){const i=[];e.color=new C(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],_),e.opacity=o[3]}s.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",s.baseColorTexture,V))}return Promise.all(i)}}class Pt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}}class Rt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(n.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(n.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const l=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new de(l,l)}return Promise.all(s)}}class Dt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return t.dispersion=s.dispersion!==void 0?s.dispersion:0,Promise.resolve()}}class It{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(n.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(n.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}class Lt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new C(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=i.extensions[this.name];if(o.sheenColorFactor!==void 0){const l=o.sheenColorFactor;t.sheenColor.setRGB(l[0],l[1],l[2],_)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(n.assignTexture(t,"sheenColorMap",o.sheenColorTexture,V)),o.sheenRoughnessTexture!==void 0&&s.push(n.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class Ft{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(n.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class _t{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(n.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const l=o.attenuationColor||[1,1,1];return t.attenuationColor=new C().setRGB(l[0],l[1],l[2],_),Promise.all(s)}}class Ot{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class Nt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(n.assignTexture(t,"specularIntensityMap",o.specularTexture));const l=o.specularColorFactor||[1,1,1];return t.specularColor=new C().setRGB(l[0],l[1],l[2],_),o.specularColorTexture!==void 0&&s.push(n.assignTexture(t,"specularColorMap",o.specularColorTexture,V)),Promise.all(s)}}class jt{constructor(e){this.parser=e,this.name=S.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return t.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&s.push(n.assignTexture(t,"bumpMap",o.bumpTexture)),Promise.all(s)}}class Gt{constructor(e){this.parser=e,this.name=S.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:L}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(n.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}class kt{constructor(e){this.parser=e,this.name=S.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}}class $t{constructor(e){this.parser=e,this.name=S.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],l=i.images[o.source];let r=n.textureLoader;if(l.uri){const a=n.options.manager.getHandler(l.uri);a!==null&&(r=a)}return this.detectSupport().then(function(a){if(a)return n.loadTextureImage(e,o.source,r);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Bt{constructor(e){this.parser=e,this.name=S.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],l=i.images[o.source];let r=n.textureLoader;if(l.uri){const a=n.options.manager.getHandler(l.uri);a!==null&&(r=a)}return this.detectSupport().then(function(a){if(a)return n.loadTextureImage(e,o.source,r);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class zt{constructor(e){this.name=S.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(l){const r=i.byteOffset||0,a=i.byteLength||0,c=i.count,h=i.byteStride,d=new Uint8Array(l,r,a);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(c,h,d,i.mode,i.filter).then(function(m){return m.buffer}):o.ready.then(function(){const m=new ArrayBuffer(c*h);return o.decodeGltfBuffer(new Uint8Array(m),c,h,d,i.mode,i.filter),m})})}else return null}}class Ht{constructor(e){this.name=S.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=t.meshes[n.mesh];for(const a of i.primitives)if(a.mode!==D.TRIANGLES&&a.mode!==D.TRIANGLE_STRIP&&a.mode!==D.TRIANGLE_FAN&&a.mode!==void 0)return null;const o=n.extensions[this.name].attributes,l=[],r={};for(const a in o)l.push(this.parser.getDependency("accessor",o[a]).then(c=>(r[a]=c,r[a])));return l.length<1?null:(l.push(this.parser.createNodeMesh(e)),Promise.all(l).then(a=>{const c=a.pop(),h=c.isGroup?c.children:[c],d=a[0].count,m=[];for(const f of h){const y=new j,u=new E,w=new q,g=new E(1,1,1),A=new Ke(f.geometry,f.material,d);for(let T=0;T<d;T++)r.TRANSLATION&&u.fromBufferAttribute(r.TRANSLATION,T),r.ROTATION&&w.fromBufferAttribute(r.ROTATION,T),r.SCALE&&g.fromBufferAttribute(r.SCALE,T),A.setMatrixAt(T,y.compose(u,w,g));for(const T in r)if(T==="_COLOR_0"){const M=r[T];A.instanceColor=new Ve(M.array,M.itemSize,M.normalized)}else T!=="TRANSLATION"&&T!=="ROTATION"&&T!=="SCALE"&&f.geometry.setAttribute(T,r[T]);Y.prototype.copy.call(A,f),this.parser.assignFinalMaterial(A),m.push(A)}return c.isGroup?(c.clear(),c.add(...m),c):m[0]}))}}const Ne="glTF",z=12,Me={JSON:1313821514,BIN:5130562};class Ut{constructor(e){this.name=S.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,z),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ne)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-z,s=new DataView(e,z);let o=0;for(;o<i;){const l=s.getUint32(o,!0);o+=4;const r=s.getUint32(o,!0);if(o+=4,r===Me.JSON){const a=new Uint8Array(e,z+o,l);this.content=n.decode(a)}else if(r===Me.BIN){const a=z+o;this.body=e.slice(a,a+l)}o+=l}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Kt{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=S.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,l={},r={},a={};for(const c in o){const h=ce[c]||c.toLowerCase();l[h]=o[c]}for(const c in e.attributes){const h=ce[c]||c.toLowerCase();if(o[c]!==void 0){const d=n.accessors[e.attributes[c]],m=B[d.componentType];a[h]=m.name,r[h]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(c){return new Promise(function(h,d){i.decodeDracoFile(c,function(m){for(const f in m.attributes){const y=m.attributes[f],u=r[f];u!==void 0&&(y.normalized=u)}h(m)},l,a,_,d)})})}}class Vt{constructor(){this.name=S.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class qt{constructor(){this.name=S.KHR_MESH_QUANTIZATION}}class je extends ut{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let o=0;o!==i;o++)t[o]=n[s+o];return t}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,l=this.valueSize,r=l*2,a=l*3,c=i-t,h=(n-t)/c,d=h*h,m=d*h,f=e*a,y=f-a,u=-2*m+3*d,w=m-d,g=1-u,A=w-d+h;for(let T=0;T!==l;T++){const M=o[y+T+l],x=o[y+T+r]*c,v=o[f+T+l],b=o[f+T]*c;s[T]=g*M+A*x+u*v+w*b}return s}}const Wt=new q;class Xt extends je{interpolate_(e,t,n,i){const s=super.interpolate_(e,t,n,i);return Wt.fromArray(s).normalize().toArray(s),s}}const D={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},B={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Se={9728:Ie,9729:ae,9984:Ze,9985:Qe,9986:Ye,9987:De},xe={33071:et,33648:Je,10497:re},se={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ce={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},O={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Yt={CUBICSPLINE:void 0,LINEAR:Fe,STEP:dt},ne={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Qt(p){return p.DefaultMaterial===void 0&&(p.DefaultMaterial=new me({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:pt})),p.DefaultMaterial}function G(p,e,t){for(const n in t.extensions)p[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function F(p,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(p.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Zt(p,e,t){let n=!1,i=!1,s=!1;for(let a=0,c=e.length;a<c;a++){const h=e[a];if(h.POSITION!==void 0&&(n=!0),h.NORMAL!==void 0&&(i=!0),h.COLOR_0!==void 0&&(s=!0),n&&i&&s)break}if(!n&&!i&&!s)return Promise.resolve(p);const o=[],l=[],r=[];for(let a=0,c=e.length;a<c;a++){const h=e[a];if(n){const d=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):p.attributes.position;o.push(d)}if(i){const d=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):p.attributes.normal;l.push(d)}if(s){const d=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):p.attributes.color;r.push(d)}}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(r)]).then(function(a){const c=a[0],h=a[1],d=a[2];return n&&(p.morphAttributes.position=c),i&&(p.morphAttributes.normal=h),s&&(p.morphAttributes.color=d),p.morphTargetsRelative=!0,p})}function Jt(p,e){if(p.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)p.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(p.morphTargetInfluences.length===t.length){p.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)p.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function es(p){let e;const t=p.extensions&&p.extensions[S.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+ie(t.attributes):e=p.indices+":"+ie(p.attributes)+":"+p.mode,p.targets!==void 0)for(let n=0,i=p.targets.length;n<i;n++)e+=":"+ie(p.targets[n]);return e}function ie(p){let e="";const t=Object.keys(p).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+p[t[n]]+";";return e}function he(p){switch(p){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function ts(p){return p.search(/\.jpe?g($|\?)/i)>0||p.search(/^data\:image\/jpeg/)===0?"image/jpeg":p.search(/\.webp($|\?)/i)>0||p.search(/^data\:image\/webp/)===0?"image/webp":p.search(/\.ktx2($|\?)/i)>0||p.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const ss=new j;class ns{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new bt,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=-1,s=!1,o=-1;if(typeof navigator<"u"){const l=navigator.userAgent;n=/^((?!chrome|android).)*safari/i.test(l)===!0;const r=l.match(/Version\/(\d+)/);i=n&&r?parseInt(r[1],10):-1,s=l.indexOf("Firefox")>-1,o=s?l.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||n&&i<17||s&&o<98?this.textureLoader=new qe(this.options.manager):this.textureLoader=new We(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Pe(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(o){const l={scene:o[0][i.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:i.asset,parser:n,userData:{}};return G(s,l,i),F(l,i),Promise.all(n._invokeAll(function(r){return r.afterRoot&&r.afterRoot(l)})).then(function(){for(const r of l.scenes)r.updateMatrixWorld();e(l)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,s=t.length;i<s;i++){const o=t[i].joints;for(let l=0,r=o.length;l<r;l++)e[o[l]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const o=e[i];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(n[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone(),s=(o,l)=>{const r=this.associations.get(o);r!=null&&this.associations.set(l,r);for(const[a,c]of o.children.entries())s(c,l.children[a])};return s(n,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const s=e(t[i]);s&&n.push(s)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(s,o){return n.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[S.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,o){n.load(H.resolveURL(t.uri,i.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,s=t.byteOffset||0;return n.slice(s,s+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const o=se[i.type],l=B[i.componentType],r=i.normalized===!0,a=new l(i.count*o);return Promise.resolve(new U(a,o,r))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(o){const l=o[0],r=se[i.type],a=B[i.componentType],c=a.BYTES_PER_ELEMENT,h=c*r,d=i.byteOffset||0,m=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,f=i.normalized===!0;let y,u;if(m&&m!==h){const w=Math.floor(d/m),g="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+w+":"+i.count;let A=t.cache.get(g);A||(y=new a(l,w*m,i.count*m/c),A=new Xe(y,m/c),t.cache.add(g,A)),u=new mt(A,r,d%m/c,f)}else l===null?y=new a(i.count*r):y=new a(l,d,i.count*r),u=new U(y,r,f);if(i.sparse!==void 0){const w=se.SCALAR,g=B[i.sparse.indices.componentType],A=i.sparse.indices.byteOffset||0,T=i.sparse.values.byteOffset||0,M=new g(o[1],A,i.sparse.count*w),x=new a(o[2],T,i.sparse.count*r);l!==null&&(u=new U(u.array.slice(),u.itemSize,u.normalized)),u.normalized=!1;for(let v=0,b=M.length;v<b;v++){const I=M[v];if(u.setX(I,x[v*r]),r>=2&&u.setY(I,x[v*r+1]),r>=3&&u.setZ(I,x[v*r+2]),r>=4&&u.setW(I,x[v*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}u.normalized=f}return u})}loadTexture(e){const t=this.json,n=this.options,s=t.textures[e].source,o=t.images[s];let l=this.textureLoader;if(o.uri){const r=n.manager.getHandler(o.uri);r!==null&&(l=r)}return this.loadTextureImage(e,s,l)}loadTextureImage(e,t,n){const i=this,s=this.json,o=s.textures[e],l=s.images[t],r=(l.uri||l.bufferView)+":"+o.sampler;if(this.textureCache[r])return this.textureCache[r];const a=this.loadImageSource(t,n).then(function(c){c.flipY=!1,c.name=o.name||l.name||"",c.name===""&&typeof l.uri=="string"&&l.uri.startsWith("data:image/")===!1&&(c.name=l.uri);const d=(s.samplers||{})[o.sampler]||{};return c.magFilter=Se[d.magFilter]||ae,c.minFilter=Se[d.minFilter]||De,c.wrapS=xe[d.wrapS]||re,c.wrapT=xe[d.wrapT]||re,c.generateMipmaps=!c.isCompressedTexture&&c.minFilter!==Ie&&c.minFilter!==ae,i.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[r]=a,a}loadImageSource(e,t){const n=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const o=i.images[e],l=self.URL||self.webkitURL;let r=o.uri||"",a=!1;if(o.bufferView!==void 0)r=n.getDependency("bufferView",o.bufferView).then(function(h){a=!0;const d=new Blob([h],{type:o.mimeType});return r=l.createObjectURL(d),r});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(r).then(function(h){return new Promise(function(d,m){let f=d;t.isImageBitmapLoader===!0&&(f=function(y){const u=new ge(y);u.needsUpdate=!0,d(u)}),t.load(H.resolveURL(h,s.path),f,void 0,m)})}).then(function(h){return a===!0&&l.revokeObjectURL(r),F(h,o),h.userData.mimeType=o.mimeType||ts(o.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",r),h});return this.sourceCache[e]=c,c}assignTexture(e,t,n,i){const s=this;return this.getDependency("texture",n.index).then(function(o){if(!o)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(o=o.clone(),o.channel=n.texCoord),s.extensions[S.KHR_TEXTURE_TRANSFORM]){const l=n.extensions!==void 0?n.extensions[S.KHR_TEXTURE_TRANSFORM]:void 0;if(l){const r=s.associations.get(o);o=s.extensions[S.KHR_TEXTURE_TRANSFORM].extendTexture(o,l),s.associations.set(o,r)}}return i!==void 0&&(o.colorSpace=i),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const i=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const l="PointsMaterial:"+n.uuid;let r=this.cache.get(l);r||(r=new Le,J.prototype.copy.call(r,n),r.color.copy(n.color),r.map=n.map,r.sizeAttenuation=!1,this.cache.add(l,r)),n=r}else if(e.isLine){const l="LineBasicMaterial:"+n.uuid;let r=this.cache.get(l);r||(r=new le,J.prototype.copy.call(r,n),r.color.copy(n.color),r.map=n.map,this.cache.add(l,r)),n=r}if(i||s||o){let l="ClonedMaterial:"+n.uuid+":";i&&(l+="derivative-tangents:"),s&&(l+="vertex-colors:"),o&&(l+="flat-shading:");let r=this.cache.get(l);r||(r=n.clone(),s&&(r.vertexColors=!0),o&&(r.flatShading=!0),i&&(r.normalScale&&(r.normalScale.y*=-1),r.clearcoatNormalScale&&(r.clearcoatNormalScale.y*=-1)),this.cache.add(l,r),this.associations.set(r,this.associations.get(n))),n=r}e.material=n}getMaterialType(){return me}loadMaterial(e){const t=this,n=this.json,i=this.extensions,s=n.materials[e];let o;const l={},r=s.extensions||{},a=[];if(r[S.KHR_MATERIALS_UNLIT]){const h=i[S.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),a.push(h.extendParams(l,s,t))}else{const h=s.pbrMetallicRoughness||{};if(l.color=new C(1,1,1),l.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;l.color.setRGB(d[0],d[1],d[2],_),l.opacity=d[3]}h.baseColorTexture!==void 0&&a.push(t.assignTexture(l,"map",h.baseColorTexture,V)),l.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,l.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(a.push(t.assignTexture(l,"metalnessMap",h.metallicRoughnessTexture)),a.push(t.assignTexture(l,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),a.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,l)})))}s.doubleSided===!0&&(l.side=W);const c=s.alphaMode||ne.OPAQUE;if(c===ne.BLEND?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,c===ne.MASK&&(l.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==R&&(a.push(t.assignTexture(l,"normalMap",s.normalTexture)),l.normalScale=new de(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;l.normalScale.set(h,h)}if(s.occlusionTexture!==void 0&&o!==R&&(a.push(t.assignTexture(l,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(l.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==R){const h=s.emissiveFactor;l.emissive=new C().setRGB(h[0],h[1],h[2],_)}return s.emissiveTexture!==void 0&&o!==R&&a.push(t.assignTexture(l,"emissiveMap",s.emissiveTexture,V)),Promise.all(a).then(function(){const h=new o(l);return s.name&&(h.name=s.name),F(h,s),t.associations.set(h,{materials:e}),s.extensions&&G(i,h,s),h})}createUniqueName(e){const t=tt.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function s(l){return n[S.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l,t).then(function(r){return be(r,l,t)})}const o=[];for(let l=0,r=e.length;l<r;l++){const a=e[l],c=es(a),h=i[c];if(h)o.push(h.promise);else{let d;a.extensions&&a.extensions[S.KHR_DRACO_MESH_COMPRESSION]?d=s(a):d=be(new $,a,t),i[c]={primitive:a,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,n=this.json,i=this.extensions,s=n.meshes[e],o=s.primitives,l=[];for(let r=0,a=o.length;r<a;r++){const c=o[r].material===void 0?Qt(this.cache):this.getDependency("material",o[r].material);l.push(c)}return l.push(t.loadGeometries(o)),Promise.all(l).then(function(r){const a=r.slice(0,r.length-1),c=r[r.length-1],h=[];for(let m=0,f=c.length;m<f;m++){const y=c[m],u=o[m];let w;const g=a[m];if(u.mode===D.TRIANGLES||u.mode===D.TRIANGLE_STRIP||u.mode===D.TRIANGLE_FAN||u.mode===void 0)w=s.isSkinnedMesh===!0?new st(y,g):new P(y,g),w.isSkinnedMesh===!0&&w.normalizeSkinWeights(),u.mode===D.TRIANGLE_STRIP?w.geometry=Ee(w.geometry,ve):u.mode===D.TRIANGLE_FAN&&(w.geometry=Ee(w.geometry,oe));else if(u.mode===D.LINES)w=new nt(y,g);else if(u.mode===D.LINE_STRIP)w=new X(y,g);else if(u.mode===D.LINE_LOOP)w=new it(y,g);else if(u.mode===D.POINTS)w=new pe(y,g);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+u.mode);Object.keys(w.geometry.morphAttributes).length>0&&Jt(w,s),w.name=t.createUniqueName(s.name||"mesh_"+e),F(w,s),u.extensions&&G(i,w,u),t.assignFinalMaterial(w),h.push(w)}for(let m=0,f=h.length;m<f;m++)t.associations.set(h[m],{meshes:e,primitives:m});if(h.length===1)return s.extensions&&G(i,h[0],s),h[0];const d=new ee;s.extensions&&G(i,d,s),t.associations.set(d,{meshes:e});for(let m=0,f=h.length;m<f;m++)d.add(h[m]);return d})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new ot(at.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new rt(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),F(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let i=0,s=t.joints.length;i<s;i++)n.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const s=i.pop(),o=i,l=[],r=[];for(let a=0,c=o.length;a<c;a++){const h=o[a];if(h){l.push(h);const d=new j;s!==null&&d.fromArray(s.array,a*16),r.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[a])}return new lt(l,r)})}loadAnimation(e){const t=this.json,n=this,i=t.animations[e],s=i.name?i.name:"animation_"+e,o=[],l=[],r=[],a=[],c=[];for(let h=0,d=i.channels.length;h<d;h++){const m=i.channels[h],f=i.samplers[m.sampler],y=m.target,u=y.node,w=i.parameters!==void 0?i.parameters[f.input]:f.input,g=i.parameters!==void 0?i.parameters[f.output]:f.output;y.node!==void 0&&(o.push(this.getDependency("node",u)),l.push(this.getDependency("accessor",w)),r.push(this.getDependency("accessor",g)),a.push(f),c.push(y))}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(r),Promise.all(a),Promise.all(c)]).then(function(h){const d=h[0],m=h[1],f=h[2],y=h[3],u=h[4],w=[];for(let g=0,A=d.length;g<A;g++){const T=d[g],M=m[g],x=f[g],v=y[g],b=u[g];if(T===void 0)continue;T.updateMatrix&&T.updateMatrix();const I=n._createAnimationTracks(T,M,x,v,b);if(I)for(let Q=0;Q<I.length;Q++)w.push(I[Q])}return new ct(s,void 0,w)})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(s){const o=n._getNodeRef(n.meshCache,i.mesh,s);return i.weights!==void 0&&o.traverse(function(l){if(l.isMesh)for(let r=0,a=i.weights.length;r<a;r++)l.morphTargetInfluences[r]=i.weights[r]}),o})}loadNode(e){const t=this.json,n=this,i=t.nodes[e],s=n._loadNodeShallow(e),o=[],l=i.children||[];for(let a=0,c=l.length;a<c;a++)o.push(n.getDependency("node",l[a]));const r=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([s,Promise.all(o),r]).then(function(a){const c=a[0],h=a[1],d=a[2];d!==null&&c.traverse(function(m){m.isSkinnedMesh&&m.bind(d,ss)});for(let m=0,f=h.length;m<f;m++)c.add(h[m]);return c})}_loadNodeShallow(e){const t=this.json,n=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],o=s.name?i.createUniqueName(s.name):"",l=[],r=i._invokeOne(function(a){return a.createNodeMesh&&a.createNodeMesh(e)});return r&&l.push(r),s.camera!==void 0&&l.push(i.getDependency("camera",s.camera).then(function(a){return i._getNodeRef(i.cameraCache,s.camera,a)})),i._invokeAll(function(a){return a.createNodeAttachment&&a.createNodeAttachment(e)}).forEach(function(a){l.push(a)}),this.nodeCache[e]=Promise.all(l).then(function(a){let c;if(s.isBone===!0?c=new ht:a.length>1?c=new ee:a.length===1?c=a[0]:c=new Y,c!==a[0])for(let h=0,d=a.length;h<d;h++)c.add(a[h]);if(s.name&&(c.userData.name=s.name,c.name=o),F(c,s),s.extensions&&G(n,c,s),s.matrix!==void 0){const h=new j;h.fromArray(s.matrix),c.applyMatrix4(h)}else s.translation!==void 0&&c.position.fromArray(s.translation),s.rotation!==void 0&&c.quaternion.fromArray(s.rotation),s.scale!==void 0&&c.scale.fromArray(s.scale);return i.associations.has(c)||i.associations.set(c,{}),i.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],i=this,s=new ee;n.name&&(s.name=i.createUniqueName(n.name)),F(s,n),n.extensions&&G(t,s,n);const o=n.nodes||[],l=[];for(let r=0,a=o.length;r<a;r++)l.push(i.getDependency("node",o[r]));return Promise.all(l).then(function(r){for(let c=0,h=r.length;c<h;c++)s.add(r[c]);const a=c=>{const h=new Map;for(const[d,m]of i.associations)(d instanceof J||d instanceof ge)&&h.set(d,m);return c.traverse(d=>{const m=i.associations.get(d);m!=null&&h.set(d,m)}),h};return i.associations=a(s),s})}_createAnimationTracks(e,t,n,i,s){const o=[],l=e.name?e.name:e.uuid,r=[];O[s.path]===O.weights?e.traverse(function(d){d.morphTargetInfluences&&r.push(d.name?d.name:d.uuid)}):r.push(l);let a;switch(O[s.path]){case O.weights:a=we;break;case O.rotation:a=Te;break;case O.translation:case O.scale:a=ye;break;default:switch(n.itemSize){case 1:a=we;break;case 2:case 3:default:a=ye;break}break}const c=i.interpolation!==void 0?Yt[i.interpolation]:Fe,h=this._getArrayFromAccessor(n);for(let d=0,m=r.length;d<m;d++){const f=new a(r[d]+"."+O[s.path],t.array,h,c);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),o.push(f)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=he(t.constructor),i=new Float32Array(t.length);for(let s=0,o=t.length;s<o;s++)i[s]=t[s]*n;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const i=this instanceof Te?Xt:je;return new i(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function is(p,e,t){const n=e.attributes,i=new ft;if(n.POSITION!==void 0){const l=t.json.accessors[n.POSITION],r=l.min,a=l.max;if(r!==void 0&&a!==void 0){if(i.set(new E(r[0],r[1],r[2]),new E(a[0],a[1],a[2])),l.normalized){const c=he(B[l.componentType]);i.min.multiplyScalar(c),i.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const l=new E,r=new E;for(let a=0,c=s.length;a<c;a++){const h=s[a];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],m=d.min,f=d.max;if(m!==void 0&&f!==void 0){if(r.setX(Math.max(Math.abs(m[0]),Math.abs(f[0]))),r.setY(Math.max(Math.abs(m[1]),Math.abs(f[1]))),r.setZ(Math.max(Math.abs(m[2]),Math.abs(f[2]))),d.normalized){const y=he(B[d.componentType]);r.multiplyScalar(y)}l.max(r)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(l)}p.boundingBox=i;const o=new gt;i.getCenter(o.center),o.radius=i.min.distanceTo(i.max)/2,p.boundingSphere=o}function be(p,e,t){const n=e.attributes,i=[];function s(o,l){return t.getDependency("accessor",o).then(function(r){p.setAttribute(l,r)})}for(const o in n){const l=ce[o]||o.toLowerCase();l in p.attributes||i.push(s(n[o],l))}if(e.indices!==void 0&&!p.index){const o=t.getDependency("accessor",e.indices).then(function(l){p.setIndex(l)});i.push(o)}return Ae.workingColorSpace!==_&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ae.workingColorSpace}" not supported.`),F(p,e),is(p,e,t),Promise.all(i).then(function(){return e.targets!==void 0?Zt(p,e.targets,t):p})}class Ge{constructor(){this.entity=null,this.enabled=!0}onAttached(){}onDetached(){}onEnabled(){}onDisabled(){}enable(){return this.enabled||(this.enabled=!0,this.onEnabled()),this}disable(){return this.enabled&&(this.enabled=!1,this.onDisabled()),this}}class os extends Ce{constructor(e){super(e),this.requiredComponents=["TransformComponent","RigidbodyComponent"],this.priority=50,this.projectiles=new Set,this.damageDealt=0,this.damageReceived=0,this.cachedProjectiles=new Z(100),this.cachedEnemies=new Z(50),this.cachedPlayers=new Z(5),this.hitPosition=new E,this.effectPosition=new E,this.setupEventListeners()}setupEventListeners(){this.world.messageBus.subscribe("weapon.fired",this.handleProjectileCreated.bind(this)),this.world.messageBus.subscribe("turret.fire",this.handleProjectileCreated.bind(this)),this.world.messageBus.subscribe("missile.fired",this.handleProjectileCreated.bind(this)),this.world.messageBus.subscribe("entity.damaged",this.handleEntityDamaged.bind(this))}update(e){const t=this.world.entityManager.getEntities();this.checkProjectileCollisions(t),this.cleanupInvalidProjectiles()}cleanupInvalidProjectiles(){const e=new Set,t=this.world.entityManager.getEntitiesByTag("projectile"),n=this.world.entityManager.getEntitiesByTag("enemyProjectile");[...t,...n].forEach(i=>{i&&i.id&&e.add(i.id)});for(const i of this.projectiles)e.has(i)||(console.log(`Removing invalid projectile ${i} from tracking`),this.projectiles.delete(i))}checkProjectileCollisions(e){const t=this.world.entityManager.getEntitiesByTag("projectile"),n=this.world.entityManager.getEntitiesByTag("enemyProjectile");this.cachedProjectiles.clear(),this.cachedEnemies.clear(),this.cachedPlayers.clear();for(let i=0;i<e.length;i++){const s=e[i];s.hasTag("enemy")||s.hasComponent("EnemyAIComponent")?this.cachedEnemies.push(s):s.hasTag("player")&&this.cachedPlayers.push(s)}for(let i=0;i<t.length;i++)this.cachedProjectiles.push(t[i]);for(let i=0;i<n.length;i++)this.cachedProjectiles.push(n[i]);this.cachedProjectiles.length>0&&console.log(`CombatSystem: Checking ${this.cachedProjectiles.length} projectiles for collisions`);for(let i=0;i<this.cachedProjectiles.length;i++){const s=this.cachedProjectiles.get(i);try{this.projectiles.has(s.id)||this.projectiles.add(s.id);const o=s.getComponent("TransformComponent"),l=s.getComponent("RigidbodyComponent");if(!o||!l){console.log(`Projectile ${s.id} missing transform or rigidbody component`);continue}const r=s._isPlayerProjectile||s.hasTag("projectile")||s.hasTag("playerProjectile"),a=s._isEnemyProjectile||s.hasTag("enemyProjectile");if(l.velocity.lengthSq()<.1)continue;const c=r?this.cachedEnemies:a?this.cachedPlayers:e,h=new _e,d=o.position.clone(),m=l.velocity.clone().normalize(),f=m.clone().multiplyScalar(-10),y=d.clone().add(f);h.set(y,m),h.near=0,h.far=50,console.log(`Raycaster for projectile ${s.id} - Origin: (${y.x.toFixed(1)}, ${y.y.toFixed(1)}, ${y.z.toFixed(1)}), Direction: (${m.x.toFixed(2)}, ${m.y.toFixed(2)}, ${m.z.toFixed(2)})`);let u=!1;for(let w=0;w<c.length;w++){const g=c.get?c.get(w):c[w];if(g.destroyed||g.id===s.id)continue;const A=g.getComponent("MeshComponent");if(!A||!A.mesh){console.log(`Target ${g.id} has no mesh component or mesh`);continue}if(console.log(`Testing collision with target ${g.id}, mesh visible: ${A.mesh.visible}, mesh children: ${A.mesh.children?A.mesh.children.length:0}`),!A.mesh.visible){console.log(`Mesh for ${g.id} is not visible, skipping`);continue}const T=h.intersectObject(A.mesh,!0);if(T.length>0){const M=T[0];console.log(`MESH HIT! Projectile ${s.id} hit ${g.id} at distance ${M.distance.toFixed(2)}`),console.log(`Hit point: (${M.point.x.toFixed(1)}, ${M.point.y.toFixed(1)}, ${M.point.z.toFixed(1)})`),M.object&&console.log(`Hit specific mesh: ${M.object.name||"unnamed"}`),this.hitPosition.copy(M.point),this.handleProjectileCollision(s,g);try{this.world.destroyEntity(s.id),this.projectiles.delete(s.id),u=!0}catch(x){console.error("Failed to destroy projectile after hit:",x)}break}else{const M=g.getComponent("TransformComponent");if(M){const x=d.distanceTo(M.position);console.log(`No intersection with ${g.id} at distance ${x.toFixed(1)}`)}}}if(u)continue}catch(o){console.error(`Error processing projectile ${s.id}:`,o)}}}handleProjectileCollision(e,t){var o,l;let n=10;const i=(o=e.userData)==null?void 0:o.source;e.userData&&e.userData.damage?n=e.userData.damage:e.sourceComponent&&(n=e.sourceComponent.damage);const s=t.getComponent("HealthComponent");if(s){const r=((l=e.userData)==null?void 0:l.attackType)||"projectile",a=s.applyDamage(n,r,i);this.createHitEffect(e,t,a),t.hasTag("player")?this.damageReceived+=a.damageApplied:t.hasTag("enemy")&&(this.damageDealt+=a.damageApplied);const c=e.getComponent("TransformComponent");c?this.hitPosition.copy(c.position):this.hitPosition.set(0,0,0),this.world.messageBus.publish("combat.hit",{projectile:e,target:t,damage:a.damageApplied,shieldDamage:a.shieldDamage,healthDamage:a.healthDamage,destroyed:a.destroyed,position:this.hitPosition})}}createHitEffect(e,t,n){const i=e.getComponent("TransformComponent");if(!i)return;let s=16733440,o=1;n.shieldDamage>0&&(s=3381759,o=1.5),n.healthDamage>20&&(s=16711680,o=2),this.effectPosition.copy(i.position);let l;const r=window.objectPool&&window.objectPool.pools&&window.objectPool.pools.hitEffect;r?l=window.objectPool.get("hitEffect",s,o):l=this.createNewHitEffect(s,o),l&&l.mesh&&(l.mesh.position.copy(this.effectPosition),l.mesh.parent||this.world.scene.add(l.mesh),this.animateHitEffect(l,l.mesh,r))}createNewHitEffect(e,t){let n;window.game&&window.game.hitEffectGeometry?n=window.game.hitEffectGeometry:this.hitEffectGeometry?n=this.hitEffectGeometry:(this.hitEffectGeometry=new K(1,8,8),n=this.hitEffectGeometry);const i=new R({color:e,transparent:!0,opacity:.8}),s=new P(n,i);return s.scale.set(t,t,t),{mesh:s,material:i}}animateHitEffect(e,t,n=!0){let i=1,s=.8;const o=()=>{i+=.1,s-=.05,t&&t.scale&&(t.scale.set(i,i,i),e.material&&(e.material.opacity=s),s>0?requestAnimationFrame(o):(t.parent&&t.parent.remove(t),n&&window.objectPool&&window.objectPool.pools.hitEffect?window.objectPool.release("hitEffect",e):n||e.material&&e.material.dispose()))};o()}handleProjectileCreated(e){e.entity&&e.entity.id&&this.projectiles.add(e.entity.id)}handleEntityDamaged(e){e.target&&(e.target.hasTag("player")?this.damageReceived+=e.damage||0:e.target.hasTag("enemy")&&(this.damageDealt+=e.damage||0))}onDisabled(){this.world.messageBus.unsubscribe("weapon.fired",this.handleProjectileCreated),this.world.messageBus.unsubscribe("turret.fire",this.handleProjectileCreated),this.world.messageBus.unsubscribe("missile.fired",this.handleProjectileCreated),this.world.messageBus.unsubscribe("entity.damaged",this.handleEntityDamaged)}}class as extends Ge{constructor(e={}){super(),this.faction=e.faction||"spectrals",this.type=e.type||"drone",this.detectionRange=e.detectionRange||2500,this.damage=e.damage||25,this.speed=e.speed||1e3,this.playerFound=!1,this.spiralAmplitude=e.spiralAmplitude||150,this.spiralFrequency=e.spiralFrequency||2,this.spiralPhase=Math.random()*Math.PI*2,this.timeAlive=0,this.lastDirection=new E(0,0,1),this.isDroneLike=e.isDroneLike||!1,this.separationInfluence=e.separationInfluence||.3,this.separationForce=new E,console.log(`Created ${this.faction} ${this.type} enemy AI with detection range ${this.detectionRange}`)}setSeparationForce(e){this.separationForce.copy(e)}update(e){if(!this.entity||!this.entity.world)return;this.timeAlive+=e;let t=null;try{this.entity.world.playerEntity&&(t=this.entity.world.playerEntity)}catch{}if(!t&&window.game&&window.game.combat&&window.game.combat.playerEntity&&(t=window.game.combat.playerEntity),!t)try{const r=this.entity.world.getEntitiesByTag("player");r&&r.length>0&&(t=r[0])}catch{}if(!t&&this.entity.world.entityManager&&this.entity.world.entityManager.entitiesByTag)try{const r=this.entity.world.entityManager.entitiesByTag.get("player");r&&(r.size>0||r.length>0)&&(t=Array.from(r)[0])}catch{}if(!t&&this.entity.world.entityManager&&this.entity.world.entityManager.entities)try{const r=Array.from(this.entity.world.entityManager.entities.values());for(const a of r)if(a.hasTag&&a.hasTag("player")||a.name==="player"||a.id&&a.id.includes("player")){t=a;break}}catch{}if(!t&&window.game&&window.game.spaceship&&window.game.spaceship.mesh&&(console.log("No player entity found, but found spaceship - will use position directly"),t={getComponent:r=>r==="TransformComponent"?{position:window.game.spaceship.mesh.position,rotation:window.game.spaceship.mesh.rotation,quaternion:window.game.spaceship.mesh.quaternion}:null}),!t){Math.random()<.01&&console.error("No player entity found by any method! Enemy cannot move.");return}const n=this.entity.getComponent("TransformComponent");if(!n)return;const i=this.entity.getComponent("HealthComponent");if(i&&i.isDestroyed)return;let s=t.getComponent?t.getComponent("TransformComponent"):null;if(!s)if(t.position)s=t;else{console.warn("Player found but missing transform component!");return}this.playerFound||(console.log(`ENEMY FOUND PLAYER TARGET! Player position: ${s.position.x.toFixed(1)}, ${s.position.y.toFixed(1)}, ${s.position.z.toFixed(1)}`),this.playerFound=!0);const o=n.position.distanceTo(s.position),l=new E().subVectors(s.position,n.position).normalize();if(this.lastDirection.copy(l),this.faction==="spectrals"&&this.type==="drone"?this.isDroneLike?this.applyDroneLikeMovement(n,s,l,o,e):this.applySpectralDroneMovement(n,s,l,o,e):(n.position.add(l.multiplyScalar(this.speed*e)),n.lookAt(s.position)),o<75){console.log("ENEMY KAMIKAZE ATTACK!");const r=t.getComponent("HealthComponent");if(r){if(r.applyDamage(this.damage,"collision",this.entity),console.log(`Enemy collided with player! Applied ${this.damage} damage to player entity health component`),window.game&&window.game.spaceship){const a=window.game.spaceship;if(a.shield>0)if(a.shield>=this.damage)a.shield-=this.damage;else{const c=this.damage-a.shield;a.shield=0,a.hull-=c}else a.hull-=this.damage;console.log(`Applied ${this.damage} damage directly to spaceship: Hull=${a.hull}, Shield=${a.shield}`),a.hull<=0&&!a.isDestroyed&&(a.hull=0,a.isDestroyed=!0,window.game&&window.game.gameOver&&window.game.gameOver("Your ship was destroyed by a kamikaze attack!"))}if(this.entity.world&&this.entity.world.messageBus&&(this.entity.world.messageBus.publish("vfx.explosion",{position:n.position.clone(),scale:1.5,duration:2}),this.entity.world.messageBus.publish("vfx.damageFlash",{intensity:.3})),window.game&&window.game.audio&&window.game.audio.playSound("boink"),this.entity&&this.entity.world){const a=this.entity.id,c=this.entity.world;c.messageBus.publish("entity.aboutToBeDestroyed",{entity:this.entity,reason:"kamikaze"}),c.destroyEntity(a),console.log(`Enemy entity ${a} self-destructed after kamikaze attack`)}}}}applyDroneLikeMovement(e,t,n,i,s){const o=new E(0,1,0),l=new E().crossVectors(n,o).normalize();l.lengthSq()<.1&&l.set(1,0,0);const r=new E().crossVectors(l,n).normalize();let a=this.speed,c=new E;if(i>1e3){a=this.speed*1.2;const w=Math.sin(this.timeAlive*1.5)*30;c.copy(n).multiplyScalar(a).add(l.clone().multiplyScalar(w))}else if(i>400){const g=this.speed*.4,T=this.entity.id.split("").reduce((b,I)=>b+I.charCodeAt(0),0)%2===0?1:-1,M=l.clone().multiplyScalar(T*g),x=n.clone().multiplyScalar(this.speed*.6);c.copy(x).add(M);const v=Math.sin(this.timeAlive*2)*15;c.add(r.clone().multiplyScalar(v))}else{const w=this.timeAlive*3,g=Math.sin(w)*Math.cos(w*1.3)*80,A=Math.cos(w*.7)*Math.sin(w*1.1)*60,T=.5+.5*(.5+.5*Math.sin(w*.5));c.copy(n).multiplyScalar(this.speed*T).add(l.clone().multiplyScalar(g)).add(r.clone().multiplyScalar(A))}if(this.separationForce&&this.separationForce.lengthSq()>0){const w=this.separationForce.clone().normalize(),g=this.separationForce.length(),A=this.separationInfluence*(.5+.5*Math.min(1,g/100));c.lerp(w.multiplyScalar(this.speed),A)}e.position.add(c.multiplyScalar(s));const h=new E().copy(e.position).add(c.clone().normalize().multiplyScalar(100));e.lookAt(h);const d=new E;d.copy(c).projectOnVector(l);const f=d.length()*(d.dot(l)>0?-1:1)/this.speed*.4,y=e.getForwardVector(),u=new q().setFromAxisAngle(y,f);e.quaternion.multiply(u),e.rotation.setFromQuaternion(e.quaternion)}applySpectralDroneMovement(e,t,n,i,s){const o=new E(0,1,0),l=new E().crossVectors(n,o).normalize();l.lengthSq()<.1&&l.set(1,0,0);const r=new E().crossVectors(l,n).normalize(),a=this.timeAlive*this.spiralFrequency;let c=this.spiralAmplitude;i<500&&(c=this.spiralAmplitude*(i/500));const h=Math.sin(a)*c,d=Math.cos(a)*c,m=new E().copy(n).multiplyScalar(this.speed).add(l.multiplyScalar(h)).add(r.multiplyScalar(d));if(this.separationForce&&this.separationForce.lengthSq()>0){const x=this.separationForce.clone().normalize(),v=this.separationForce.length(),b=this.separationInfluence*(.5+.5*Math.min(1,v/100));m.lerp(x.multiplyScalar(this.speed),b)}e.position.add(m.multiplyScalar(s));const y=a+this.spiralFrequency*.2,u=Math.sin(y)*c,w=Math.cos(y)*c,g=new E().copy(e.position).add(n.multiplyScalar(100)).add(l.multiplyScalar(u)).add(r.multiplyScalar(w));e.lookAt(g);const A=Math.atan2(h,this.speed)*.5,T=e.getForwardVector(),M=new q().setFromAxisAngle(T,A);e.quaternion.multiply(M),e.rotation.setFromQuaternion(e.quaternion)}}class ke extends Ge{constructor(e,t){if(super(),e&&e.isMesh||e&&e.isGroup)this.mesh=e;else if(e&&t)this.mesh=new P(e,t),e&&typeof e.computeBoundingSphere=="function"&&!e.boundingSphere&&e.computeBoundingSphere();else{console.warn("MeshComponent created with invalid geometry, using invisible default cube");const n=new ue(10,10,10);n.computeBoundingSphere();const i=new R({color:16711680,transparent:!0,opacity:0,visible:!1});this.mesh=new P(n,i),this.mesh.visible=!1}this.visible=!0,this.castShadow=!1,this.receiveShadow=!1}onAttached(){const e=this.entity.getComponent("TransformComponent");e&&(this.mesh.position.copy(e.position),this.mesh.quaternion.copy(e.quaternion),this.mesh.scale.copy(e.scale))}onDetached(){this.mesh.parent&&this.mesh.parent.remove(this.mesh),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.material&&(Array.isArray(this.mesh.material)?this.mesh.material.forEach(e=>{e.map&&e.map.dispose(),e.lightMap&&e.lightMap.dispose(),e.bumpMap&&e.bumpMap.dispose(),e.normalMap&&e.normalMap.dispose(),e.specularMap&&e.specularMap.dispose(),e.envMap&&e.envMap.dispose(),e.dispose()}):(this.mesh.material.map&&this.mesh.material.map.dispose(),this.mesh.material.lightMap&&this.mesh.material.lightMap.dispose(),this.mesh.material.bumpMap&&this.mesh.material.bumpMap.dispose(),this.mesh.material.normalMap&&this.mesh.material.normalMap.dispose(),this.mesh.material.specularMap&&this.mesh.material.specularMap.dispose(),this.mesh.material.envMap&&this.mesh.material.envMap.dispose(),this.mesh.material.dispose()))}setVisible(e){this.visible=e,this.mesh.visible=e}setCastShadow(e){this.castShadow=e,this.mesh.castShadow=e}setReceiveShadow(e){this.receiveShadow=e,this.mesh.receiveShadow=e}setMaterial(e){this.mesh.material=e}setGeometry(e){this.mesh.geometry=e}addToScene(e){e.add(this.mesh)}updateFromTransform(){const e=this.entity.getComponent("TransformComponent");e&&(this.mesh.position.copy(e.position),this.mesh.quaternion.copy(e.quaternion),this.mesh.scale.copy(e.scale))}}class rs{constructor(e,t=20){this.world=e,this.maxPoolSize=t,this.enemyPool=[],this.preallocateEnemyPool()}preallocateEnemyPool(){for(let e=0;e<10;e++){const t=this.createEnemyEntity();this.enemyPool.push(t)}console.log(`Pre-allocated enemy pool with ${this.enemyPool.length} spectral drones`)}createEnemyEntity(){const e=this.world.createEntity("enemy_spectral");return e.addTag("pooled"),e.addComponent(new fe),e.addComponent(new ke),e}getEnemyFromPool(){if(this.enemyPool.length>0){const t=this.enemyPool.pop();this.enemies&&this.enemies.has(t.id)&&(console.warn(`CRITICAL ERROR: Entity ${t.id} is in both the pool and active enemies!`),this.enemies.delete(t.id),console.log(`Fixed inconsistency: Removed entity ${t.id} from active enemies`));for(let i=0;i<this.enemyPool.length;i++)this.enemyPool[i].id===t.id&&(console.warn(`CRITICAL ERROR: Duplicate of entity ${t.id} found in enemy pool!`),this.enemyPool.splice(i,1),console.log(`Fixed inconsistency: Removed duplicate entity ${t.id} from enemy pool`),i--);console.log(`Getting entity ${t.id} from pool. Current tags: [${t.tags?[...t.tags]:"undefined"}]`),t.clearTags&&typeof t.clearTags=="function"?(t.clearTags(),console.log(`Cleared all tags from entity ${t.id}`)):(console.warn(`Entity ${t.id} missing clearTags method`),t.hasTag&&t.removeTag&&(t.hasTag("pooled")&&t.removeTag("pooled"),t.hasTag("enemy")&&t.removeTag("enemy"),t.hasTag("spectrals")&&t.removeTag("spectrals"))),t._syncTagCache&&typeof t._syncTagCache=="function"?(t._syncTagCache(),console.log(`Reset tag cache for entity ${t.id}`)):(t._isEnemy!==void 0&&(t._isEnemy=!1),t._isPooled!==void 0&&(t._isPooled=!1));const n=t.getComponent("EnemyAIComponent");return n&&(n.playerFound=!1,n.timeAlive=0,n.spiralPhase=Math.random()*Math.PI*2,n.enabled=!0),console.log(`Entity ${t.id} prepared for reuse. Current tags: [${t.tags?[...t.tags]:"undefined"}]`),t}const e=this.createEnemyEntity();return console.log(`Created new entity ${e.id} because pool was empty`),e}returnEnemyToPool(e,t){if(!e){console.warn("Attempt to return null/undefined entity to pool");return}const n=e.id;if(console.log(`Returning entity ${n} to pool. Has tags: [${e.tags?[...e.tags]:"undefined"}]`),t&&t.has(n)&&(t.delete(n),console.log(`Removed entity ${n} from enemies tracking`)),e.clearTags&&typeof e.clearTags=="function"?(e.clearTags(),console.log(`Cleared all tags from entity ${n}`)):(console.warn(`No clearTags method on entity ${n}, using manual tag removal`),e.hasTag&&e.removeTag&&(e.hasTag("enemy")&&e.removeTag("enemy"),e.hasTag("spectrals")&&e.removeTag("spectrals"),e.hasTag("drone")&&e.removeTag("drone"),e.hasTag("frozen")&&e.removeTag("frozen"))),this.enemyPool.length<this.maxPoolSize){const i=e.getComponent("TrailComponent");if(i)try{typeof i.onDetached=="function"&&i.onDetached(),window.game&&window.game.trailSystem&&window.game.trailSystem.unregisterTrail&&window.game.trailSystem.unregisterTrail(n),i.trailMesh&&i.trailMesh.parent&&i.trailMesh.parent.remove(i.trailMesh),i.trailMesh&&(i.trailMesh.geometry&&i.trailMesh.geometry.dispose(),i.trailMesh.material&&i.trailMesh.material.dispose()),e.removeComponent("TrailComponent"),console.log(`Removed and cleaned up TrailComponent from entity ${n}`)}catch(c){console.error(`Error cleaning up trail for entity ${n}:`,c)}const s=e.getComponent("TransformComponent");s&&(s.position.set(0,0,0),s.rotation.set(0,0,0),s.scale.set(1,1,1));const o=e.getComponent("HealthComponent");o&&(o.health=0,o.isDestroyed=!0);const l=e.getComponent("EnemyAIComponent");l&&(l.enabled=!1,l.playerFound=!1,l.timeAlive=0,l.spiralPhase=Math.random()*Math.PI*2);const r=e.getComponent("MeshComponent");if(r&&r.mesh)try{r.mesh.parent&&r.mesh.parent.remove(r.mesh),r.mesh.visible=!1}catch(c){console.error(`Error cleaning up mesh for entity ${n}:`,c)}const a=e.getComponent("RigidbodyComponent");a&&(a.isFrozen=!0,a.velocity&&a.velocity.set(0,0,0)),e.addTag("pooled"),console.log(`Entity ${n} marked as pooled`),console.log(`Final entity ${n} state - Tags: [${e.tags?[...e.tags]:"none"}]`),this.enemyPool.push(e),console.log(`Entity ${n} returned to pool. Pool size now ${this.enemyPool.length}`)}else console.log(`Pool is full (${this.maxPoolSize}), destroying entity ${n} instead of pooling`),this.world&&this.world.destroyEntity?(this.world.destroyEntity(n),console.log(`Entity ${n} fully destroyed`)):console.error(`Failed to destroy entity ${n} - world or destroyEntity method not available`)}runPoolDiagnostics(e){console.log("=== RUNNING ENEMY POOL DIAGNOSTICS ==="),console.log(`Active enemies: ${e.size}, Pool size: ${this.enemyPool.length}`);let t=0;const n=new Set,i=[];for(let a=0;a<this.enemyPool.length;a++){const c=this.enemyPool[a];if(!c||!c.id){console.warn(`Invalid entity at index ${a} in enemy pool - removing`),i.push(a),t++;continue}n.has(c.id)?(console.warn(`Duplicate entity ${c.id} found in enemy pool at index ${a} - removing`),i.push(a),t++):n.add(c.id)}for(let a=i.length-1;a>=0;a--)this.enemyPool.splice(i[a],1);const s=[];for(let a=0;a<this.enemyPool.length;a++){const c=this.enemyPool[a];e.has(c.id)&&(console.error(`CRITICAL ERROR: Entity ${c.id} is both active and in the pool!`),s.push(a),t++)}for(let a=s.length-1;a>=0;a--){const c=s[a],h=this.enemyPool[c].id;this.enemyPool.splice(c,1),console.log(`Fixed critical inconsistency: Removed entity ${h} from pool since it's active`)}let o=0,l=0,r=0;if(this.world&&this.world.entityManager&&this.world.entityManager.entitiesByTag){const a=this.world.entityManager.entitiesByTag.get("enemy")||[];o=a.length,l=(this.world.entityManager.entitiesByTag.get("pooled")||[]).length;for(const h of a)h.hasTag("pooled")&&(console.warn(`INCONSISTENT ENTITY ${h.id}: Has both 'enemy' and 'pooled' tags`),r++,this.enemyPool.some(m=>m.id===h.id)?(h.removeTag("enemy"),console.log(`Fixed entity ${h.id} by removing 'enemy' tag since it's in the pool`)):(h.removeTag("pooled"),console.log(`Fixed entity ${h.id} by removing 'pooled' tag since it's not in the pool`)),t++);for(const h of e){const d=this.world.getEntity(h);d&&d.hasTag("pooled")&&(console.warn(`INCONSISTENT TRACKING: Entity ${h} is in active enemies but has 'pooled' tag`),this.enemyPool.some(f=>f.id===h)?(e.delete(h),console.log(`Fixed by removing entity ${h} from active enemies set since it's in the pool`)):(d.removeTag("pooled"),console.log(`Fixed entity ${h} by removing 'pooled' tag since it's not in the pool`)),r++,t++)}for(let h=0;h<this.enemyPool.length;h++){const d=this.enemyPool[h];if(!d)continue;let m=!1;d.hasTag("pooled")||(console.warn(`INCONSISTENT POOL: Entity ${d.id} in enemy pool but missing 'pooled' tag`),d.addTag("pooled"),console.log(`Fixed by adding 'pooled' tag to entity ${d.id}`),m=!0,t++),d.hasTag("enemy")&&(console.warn(`INCONSISTENT POOL: Entity ${d.id} in enemy pool but has 'enemy' tag`),d.removeTag("enemy"),console.log(`Fixed by removing 'enemy' tag from entity ${d.id}`),m=!0,t++),m&&r++}}console.log(`Diagnostic results: ${o} entities with 'enemy' tag, ${l} entities with 'pooled' tag`),console.log(`Fixed ${t} inconsistencies across ${r} entities`),console.log("=== DIAGNOSTICS COMPLETE ===")}}class ls{constructor(e){this.world=e,this.spawnPoints=[],this.spawnTimer=0,this.spawnInterval=3,this.lastSpawnTime=Date.now(),this.modelCache={},this.baseEnemyConfig={health:20,damage:15,speed:700,spiralAmplitude:150,spiralFrequency:2},this.enemyConfig={...this.baseEnemyConfig},this.loadModels(),this.generateSpawnPoints()}loadModels(){new xt().load("assets/enemy.glb",t=>{console.log("Enemy model loaded successfully"),this.modelCache.enemyDrone=t.scene,this.modelCache.enemyDrone.traverse(n=>{n.isMesh&&n.material&&(n.material.emissive=new C(35071),n.material.emissiveIntensity=2)})},t=>{console.log("Loading enemy model: "+t.loaded/t.total*100+"% loaded")},t=>{console.error("Error loading enemy model",t)})}generateSpawnPoints(){this.spawnPoints=[];const e=this.world.entityManager.getEntitiesByTag("player");if(e.length===0){for(let a=0;a<10;a++){const c=a/10*Math.PI*2,h=Math.cos(c)*3e3,d=(Math.random()-.5)*1e3,m=Math.sin(c)*3e3;this.spawnPoints.push(new E(h,d,m))}console.log(`Generated ${this.spawnPoints.length} default spawn points around origin`);return}const n=e[0].getComponent("TransformComponent");if(!n){console.warn("Player entity has no transform component, using default spawn points");return}const i=n.position.clone(),s=2500,o=12;for(let l=0;l<o;l++){const r=Math.acos(2*Math.random()-1),a=Math.random()*Math.PI*2,c=i.x+s*Math.sin(r)*Math.cos(a),h=i.y+s*Math.sin(r)*Math.sin(a),d=i.z+s*Math.cos(r);this.spawnPoints.push(new E(c,h,d))}console.log(`Generated ${this.spawnPoints.length} spawn points around player at position ${i.x.toFixed(0)}, ${i.y.toFixed(0)}, ${i.z.toFixed(0)}`)}getRandomSpawnPoint(){if(this.spawnPoints.length===0&&this.generateSpawnPoints(),this.spawnPoints.length>0){const e=Math.floor(Math.random()*this.spawnPoints.length);return this.spawnPoints[e].clone()}else{console.warn("No spawn points available, using fallback position");const e=Math.random()*Math.PI*2,t=2e3;return new E(Math.cos(e)*t,(Math.random()-.5)*500,Math.sin(e)*t)}}update(e,t,n,i){this.spawnTimer+=e;let s=this.spawnInterval;if(this.updateDifficultyParameters(),this.spawnTimer>=s&&t.size<n){const o=this.getRandomSpawnPoint();if(!o)return console.error("Failed to get spawn point! Generating new spawn points."),this.generateSpawnPoints(),!1;if(i(o))return this.spawnTimer=0,this.lastSpawnTime=Date.now(),!0}return!1}updateDifficultyParameters(){if(window.game&&window.game.difficultyManager&&window.game.difficultyManager.params){const e=window.game.difficultyManager.params;e.enemyHealth!==void 0&&(this.enemyConfig.health=e.enemyHealth),e.enemyDamage!==void 0&&(this.enemyConfig.damage=e.enemyDamage),e.enemySpeed!==void 0&&(this.enemyConfig.speed=e.enemySpeed),e.spawnInterval!==void 0&&(this.spawnInterval=e.spawnInterval),Math.random()<.005&&console.log(`Current enemy parameters: Health=${this.enemyConfig.health}, Damage=${this.enemyConfig.damage}, Speed=${this.enemyConfig.speed}, SpawnInterval=${this.spawnInterval}`)}}spawnSpectralDrone(e,t,n,i){if(console.log("Setting up spectral drone config..."),n.size>=i)return console.warn(`SPAWN BLOCKED: Already at maximum enemies (${n.size}/${i})`),null;this.updateDifficultyParameters();const s=t.getEnemyFromPool();if(!s)return console.error("Failed to get entity from pool or create new one"),null;if(n.has(s.id))return console.error(`Entity ${s.id} is already in the active enemies list!`),null;s.tags&&s.tags.size>0&&(console.warn(`Entity ${s.id} from pool still has tags: [${[...s.tags]}]. Clearing all tags.`),s.clearTags&&typeof s.clearTags=="function"?s.clearTags():(s.tags.clear(),s._isEnemy=!1,s._isPooled=!1,s._isPlayer=!1,s._isProjectile=!1)),s.addTag("enemy"),s.addTag("spectrals");const o=this.enemyConfig.spiralAmplitude*(.8+Math.random()*.4),l=this.enemyConfig.spiralFrequency*(.9+Math.random()*.2),r=this.enemyConfig.speed*(.7+Math.random()*.6),h=80*(.8+Math.random()*.8),d={x:(Math.random()-.5)*.2,y:(Math.random()-.5)*.2,z:(Math.random()-.5)*.2},m=Math.floor(Math.random()*4);s.visualVariant=m;const f=s.getComponent("TransformComponent");if(f)f.position.copy(e),f.scale.set(h,h,h),f.rotation.x+=d.x,f.rotation.y+=d.y,f.rotation.z+=d.z,f.needsUpdate=!0;else{const T=new fe(e);T.scale.set(h,h,h),T.rotation.x+=d.x,T.rotation.y+=d.y,T.rotation.z+=d.z,s.addComponent(T)}let y=s.getComponent("HealthComponent");y?(y.maxHealth=this.enemyConfig.health,y.health=this.enemyConfig.health,y.isDestroyed=!1):(y=new Oe(this.enemyConfig.health,0),s.addComponent(y));let u=s.getComponent("EnemyAIComponent");if(u)u.faction="spectrals",u.type="drone",u.damage=this.enemyConfig.damage,u.speed=r,u.spiralAmplitude=o,u.spiralFrequency=l,u.isDroneLike=!0,u.enabled=!0;else{const T={faction:"spectrals",type:"drone",health:this.enemyConfig.health,damage:this.enemyConfig.damage,speed:r,spiralAmplitude:o,spiralFrequency:l,isDroneLike:!0};u=new as(T),s.addComponent(u)}this.currentEntity=s;const w=this.createSpectralDroneMesh();this.currentEntity=null;let g=s.getComponent("MeshComponent");g||(g=new ke,s.addComponent(g)),g.mesh&&(g.mesh.parent&&g.mesh.parent.remove(g.mesh),g.mesh.geometry&&g.mesh.geometry.dispose(),g.mesh.material&&(Array.isArray(g.mesh.material)?g.mesh.material.forEach(T=>T.dispose()):g.mesh.material.dispose())),w.isGLTF?g.mesh=w.model:g.mesh=new P(w.geometry,w.material),g.onAddedToScene=function(T){this.mesh&&!this.mesh.parent&&T&&(console.log("Adding enemy drone mesh to scene"),T.add(this.mesh))},this.world&&this.world.scene&&g.mesh&&(g.mesh.visible=!0,this.world.scene.add(g.mesh),g.mesh.position.copy(f.position),g.mesh.quaternion.copy(f.quaternion),g.mesh.scale.copy(f.scale),console.log("Added enemy drone mesh to scene immediately"));let A=s.getComponent("RigidbodyComponent");return A?(A.isFrozen=!1,A.velocity.set(0,0,0),A.collisionRadius=50):(A=new At(1),A.useGravity=!1,A.drag=.1,A.shape="sphere",A.collisionRadius=50,s.addComponent(A)),s.getComponent("TrailComponent"),n.delete(s.id),n.add(s.id),this.lastSpawnTime=Date.now(),s.hasTag("enemy")||(console.warn(`CRITICAL ERROR: Entity ${s.id} missing 'enemy' tag after setup!`),s.addTag("enemy")),window.game&&window.game.combat&&window.game.combat.registerEnemy&&window.game.combat.registerEnemy(s.id),console.log(`Spawned enemy drone at position: x=${e.x.toFixed(0)}, y=${e.y.toFixed(0)}, z=${e.z.toFixed(0)}`),console.log(`Properties: Speed=${u.speed}, Amplitude=${u.spiralAmplitude}, Frequency=${u.spiralFrequency}`),console.log(`Current enemy count after spawn: ${n.size}/${i}`),s}addSpectralTrail(e,t){const n=new TrailComponent({maxPoints:50,pointDistance:5,width:15,color:52479,fadeTime:1.5,transparent:!0,alphaTest:.01,blending:N,pulse:!0,pulseSpeed:2.5,tapering:!0,glow:!0,thrusterMode:!0});t&&t.position&&(n.lastPosition=t.position.clone(),n.points&&(n.points=[t.position.clone()]),typeof n.initializeTrail=="function"&&n.initializeTrail(t.position)),e.addComponent(n);let i=!1;if(window.game&&window.game.trailSystem&&(window.game.trailSystem.registerTrail(e.id,n),i=!0),!i&&this.world&&this.world.systemManager){const s=this.world.systemManager.getSystem("TrailSystem");s&&(s.registerTrail(e.id,n),i=!0)}return i||console.log("No trail system found - initializing trail component directly"),console.log(`Added thruster trail component to entity ${e.id} at position (${t.position.x.toFixed(0)}, ${t.position.y.toFixed(0)}, ${t.position.z.toFixed(0)})`),n}createSpectralDroneMesh(){if(console.log("Creating spectral drone from GLB model..."),!this.modelCache.enemyDrone){console.warn("Enemy model not loaded yet - using temporary placeholder");const a=new ue(1,1,1),c=new R({color:65535,wireframe:!0});return{geometry:a,material:c,isPlaceholder:!0}}const e=this.modelCache.enemyDrone.clone();let t=0;this.currentEntity&&this.currentEntity.visualVariant!==void 0&&(t=this.currentEntity.visualVariant);const n=[{main:52479,emissive:new C(35071)},{main:8939263,emissive:new C(6697983)},{main:65484,emissive:new C(48025)},{main:16724838,emissive:new C(13373764)},{main:16755200,emissive:new C(13404160)},{main:6750003,emissive:new C(4508689)},{main:16751103,emissive:new C(13395660)},{main:16777011,emissive:new C(13421585)},{main:3368703,emissive:new C(1131724)},{main:16724787,emissive:new C(13373713)}],i=Math.floor(Math.random()*n.length),s=n[i];let o=1,l=1,r=!1;switch(t){case 0:o=1+Math.random()*.5;break;case 1:o=.5+Math.sin(Date.now()*.01)*.3,s.emissive.multiplyScalar(.7),l=.85;break;case 2:o=2+Math.sin(Date.now()*.003)*.5,s.emissive.multiplyScalar(1.2),r=!0;break;case 3:o=1.5;const a=Date.now()*.001,c=.8+Math.sin(a)*.2;s.emissive.r*=c,s.emissive.g*=1+(1-c),s.emissive.b*=1+Math.cos(a)*.2;break}if(e.traverse(a=>{a.isMesh&&a.material&&(a.material=a.material.clone(),a.material.color=new C(s.main),a.material.emissive=s.emissive,a.material.emissiveIntensity=o,l<1&&(a.material.transparent=!0,a.material.opacity=l),r&&(a.material.shininess!==void 0&&(a.material.shininess=100),a.material.envMap!==void 0&&(a.material.envMapIntensity=.8)))}),t===2)try{const a=new yt(1.2,1.5,16),c=new R({color:s.main,transparent:!0,opacity:.6,side:W,blending:N}),h=new P(a,c);h.rotation.x=Math.PI/2,e.add(h),h.userData.update=function(d){h.rotation.z+=d*.5;const m=1+.2*Math.sin(Date.now()*.002);h.scale.set(m,m,m)}}catch(a){console.error("Failed to create elite halo effect:",a)}else if(t===3)try{const a=new K(1.1,16,12),c=new R({color:11197951,transparent:!0,opacity:.3,side:W,blending:N,wireframe:!1}),h=new P(a,c);e.add(h),h.userData.update=function(d){const m=1+.05*Math.sin(Date.now()*.003);h.scale.set(m,m,m),h.material.opacity=.2+.1*Math.sin(Date.now()*.002)}}catch(a){console.error("Failed to create shield effect:",a)}return console.log(`Enemy drone model created with color #${s.main.toString(16)} and variant ${t}`),{model:e,isGLTF:!0}}}class cs{constructor(e){this.world=e}validateEnemyReferences(e){const t=e.size,n=new Set;for(const s of e){const o=this.world.getEntity(s);if(o&&o.hasTag&&o.hasTag("enemy")&&!o.hasTag("pooled"))n.add(s);else if(!o)console.warn(`Removing invalid enemy reference: ${s} - Entity does not exist`);else if(!o.hasTag)console.warn(`Removing invalid enemy reference: ${s} - Entity missing hasTag method`);else if(o.hasTag("enemy"))o.hasTag("pooled")&&(console.warn(`Removing invalid enemy reference: ${s} - Entity is pooled but still has 'enemy' tag`),o.hasTag("enemy")&&(console.log(`Fixing inconsistent tag state: entity ${s} is pooled but still has 'enemy' tag`),o.removeTag("enemy")));else{if(o.tags&&o.tags.has&&o.tags.has("enemy")&&(console.warn(`Entity ${s} has inconsistent tag state: hasTag('enemy')=false but tag exists in Set`),o._syncTagCache&&typeof o._syncTagCache=="function"&&(o._syncTagCache(),console.log(`Fixed tag cache for entity ${s}`),o.hasTag("enemy")))){console.log(`Entity ${s} now properly recognizes 'enemy' tag, keeping in tracking`),n.add(s);continue}console.warn(`Removing invalid enemy reference: ${s} - Entity missing 'enemy' tag. Tags: [${Array.from(o.tags)}]`)}}e.clear();for(const s of n)e.add(s);let i=0;try{if(this.world&&this.world.entityManager){let s=[];if(this.world.entityManager.entitiesByTag&&this.world.entityManager.entitiesByTag.get){s=this.world.entityManager.entitiesByTag.get("enemy")||[],i=s.length;for(const o of s)o&&(o._syncTagCache&&typeof o._syncTagCache=="function"&&o._syncTagCache(),o.hasTag("pooled")?(e.has(o.id)&&(console.log(`Removing pooled enemy from tracking: ${o.id}`),e.delete(o.id)),o.hasTag("enemy")&&(console.log(`Fixing inconsistent tag state: pooled entity ${o.id} still has 'enemy' tag`),o.removeTag("enemy"))):e.has(o.id)||(console.log(`Found untracked enemy: ${o.id}, adding to tracking. Tags: [${[...o.tags]}]`),e.add(o.id)));this.validateEntityManagerTagMaps(e)}}}catch(s){console.error("Error during entity scan:",s)}t!==e.size&&console.log(`Enemy tracking corrected: ${t} -> ${e.size} enemies tracked. Scanned ${i} entities.`)}validateEntityManagerTagMaps(e){if(!(!this.world||!this.world.entityManager||!this.world.entityManager.entitiesByTag))try{const t=this.world.entityManager.entitiesByTag;if(t.has("enemy")){const n=t.get("enemy"),i=[];for(let s=0;s<n.length;s++){const o=n[s];if(!o){i.push(s);continue}(!o.tags||!o.tags.has("enemy"))&&(console.warn(`Entity ${o.id} is in 'enemy' tag map but doesn't have the tag in its Set`),o.addTag?(o.addTag("enemy"),console.log(`Added missing 'enemy' tag to entity ${o.id}`)):i.push(s)),o.hasTag&&o.hasTag("pooled")&&o.hasTag("enemy")&&(console.warn(`Entity ${o.id} has both 'pooled' and 'enemy' tags - removing 'enemy' tag`),o.removeTag("enemy"),i.push(s))}for(let s=i.length-1;s>=0;s--){const o=i[s];n.splice(o,1)}i.length>0&&console.log(`Fixed ${i.length} inconsistencies in EntityManager 'enemy' tag map`)}}catch(t){console.error("Error validating EntityManager tag maps:",t)}}freezeAllEnemies(e){const t=Array.from(e).filter(n=>{const i=this.world.getEntity(n);return i&&!i.hasTag("pooled")});console.log(`Freezing all ${t.length} active enemies...`);for(const n of t){const i=this.world.getEntity(n);if(!i){console.warn(`Enemy ${n} not found when freezing - may have been destroyed`);continue}const s=i.getComponent("RigidbodyComponent");s&&(s.velocity.set(0,0,0),s.angularVelocity&&s.angularVelocity.set(0,0,0),s.isFrozen=!0);const o=i.getComponent("EnemyAIComponent");o&&(o.originalEnabledState===void 0&&(o.originalEnabledState=o.enabled),o.enabled=!1),i.addTag("frozen")}console.log("All enemies frozen successfully")}unfreezeAllEnemies(e){const t=Array.from(e).filter(n=>{const i=this.world.getEntity(n);return i&&!i.hasTag("pooled")});console.log(`Unfreezing all ${t.length} active enemies...`);for(const n of t){const i=this.world.getEntity(n);if(!i){console.warn(`Enemy ${n} not found when unfreezing - may have been destroyed`);continue}const s=i.getComponent("RigidbodyComponent");s&&(s.isFrozen=!1);const o=i.getComponent("EnemyAIComponent");o&&(o.enabled=o.originalEnabledState!==void 0?o.originalEnabledState:!0),i.hasTag&&i.hasTag("frozen")&&i.removeTag("frozen")}console.log("All enemies unfrozen successfully")}enforceEnemyLimit(e,t,n){const i=[...e],s=e.size-t;if(!(s<=0)){console.log(`Enforcing enemy limit by removing ${s} excess enemies`);for(let o=0;o<s&&o<i.length;o++){const l=i[o],r=this.world.getEntity(l);if(r){console.log(`Force destroying excess enemy ${l}`),e.delete(l);const a=r.getComponent("HealthComponent");if(a&&(a.health=0,a.isDestroyed=!0),this.world&&this.world.messageBus){const c=r.getComponent("TransformComponent");c&&this.world.messageBus.publish("vfx.explosion",{position:c.position.clone(),scale:1,duration:1})}n(r)}else e.delete(l)}this.validateEnemyReferences(e)}}clearAllEnemies(e){console.log(`Clearing all enemies. Current count: ${e.size}`),e.clear(),console.log(`After clearing, enemy count: ${e.size}`)}processEntityUpdate(e,t){const n=e.getComponent("EnemyAIComponent");if(!n)return;const i=e.getComponent("TransformComponent");if(!i)return;const s=e.getComponent("MeshComponent");if(s&&s.mesh&&(s.mesh.visible=!0,!s.mesh.parent&&this.world.scene&&(console.log("Adding enemy mesh to scene"),this.world.scene.add(s.mesh),s.onAddedToScene&&s.onAddedToScene(this.world.scene)),s.mesh.position.copy(i.position),s.mesh.quaternion.copy(i.quaternion),s.mesh.scale.copy(i.scale),(e.visualVariant===2||e.visualVariant===3)&&(s.mesh.traverse(l=>{l.userData&&typeof l.userData.update=="function"&&l.userData.update(t)}),e.visualVariant===2&&e.eliteParticleTime===void 0?e.eliteParticleTime=0:e.visualVariant===2&&(e.eliteParticleTime+=t,e.eliteParticleTime>1.5&&(e.eliteParticleTime=0,this.world&&this.world.messageBus&&this.world.messageBus.publish("vfx.pulse",{position:i.position.clone(),color:11206655,scale:.7,duration:.8})))),e.visualVariant===1&&s.mesh.material))if(Array.isArray(s.mesh.material))for(const l of s.mesh.material)l.emissiveIntensity=.5+Math.sin(Date.now()*.01)*.3;else s.mesh.material.emissiveIntensity!==void 0&&(s.mesh.material.emissiveIntensity=.5+Math.sin(Date.now()*.01)*.3);n.update(t);const o=e.getComponent("HealthComponent");o&&o.update(t)}}class hs extends Ce{constructor(e){super(e),this.requiredComponents=["EnemyAIComponent","TransformComponent"],this.priority=40,this.enemies=new Set,this.maxEnemies=10,this.spawnTimer=0,this.spawnInterval=3,this.lastSpawnTime=Date.now(),this.initialSpawnDelay=60,this.initialSpawnTimer=0,this.initialSpawnComplete=!1,this.poolManager=new rs(e),this.spawner=new ls(e),this.lifecycle=new cs(e),this.playerIsDocked=!1,this.enemiesDestroyed=0,this.lastSpawnCheckTime=Date.now(),this.spawnCheckInterval=1e4,this.SEPARATION_FORCE_MAGNITUDE=150,this.separationThresholdMultiplier=2.5,this.spatialGrid={cellSize:200,cells:new Map},this.setupEventListeners(),this.lifecycle.clearAllEnemies(this.enemies),this.lifecycle.validateEnemyReferences(this.enemies),this.startSpawnMonitoring(),console.log("Enemy system initialized with faster spawn rate and object pooling")}setupEventListeners(){this.world.messageBus.subscribe("entity.destroyed",this.handleEntityDestroyed.bind(this)),this.world.messageBus.subscribe("player.docked",this.handlePlayerDocked.bind(this)),this.world.messageBus.subscribe("player.undocked",this.handlePlayerUndocked.bind(this)),console.log("Enemy system: Event listeners set up for player docking/undocking")}handlePlayerDocked(e){console.log("Enemy system detected player docked - freezing enemies"),this.playerIsDocked=!0,this.lifecycle.freezeAllEnemies(this.enemies),console.log(`Froze ${this.enemies.size} enemies due to player docking`)}handlePlayerUndocked(e){console.log("Enemy system detected player undocked - resuming enemy activities"),this.playerIsDocked=!1,this.lifecycle.unfreezeAllEnemies(this.enemies),console.log(`Unfroze ${this.enemies.size} enemies due to player undocking`)}update(e){if(window.game&&window.game.spaceship&&window.game.spaceship.isDocked!==void 0&&this.playerIsDocked!==window.game.spaceship.isDocked&&(console.log(`Enemy system syncing docked state from global: ${window.game.spaceship.isDocked}`),this.playerIsDocked=window.game.spaceship.isDocked,this.playerIsDocked?this.lifecycle.freezeAllEnemies(this.enemies):this.lifecycle.unfreezeAllEnemies(this.enemies)),!this.playerIsDocked){if(super.update(e),this._lastDiagnosticTime||(this._lastDiagnosticTime=0),this._lastDiagnosticTime+=e,this._lastDiagnosticTime>=3&&(this.poolManager.runPoolDiagnostics(this.enemies),this._lastDiagnosticTime=0),this.lifecycle.validateEnemyReferences(this.enemies),this.updateDifficultyScaling(),this.enemies.size>this.maxEnemies&&(console.warn(`ENFORCING ENEMY LIMIT: Current count ${this.enemies.size} exceeds limit of ${this.maxEnemies}`),this.lifecycle.enforceEnemyLimit(this.enemies,this.maxEnemies,t=>this.poolManager.returnEnemyToPool(t,this.enemies))),!this.initialSpawnComplete){if(this.initialSpawnTimer+=e,Math.floor(this.initialSpawnTimer)%10===0&&Math.floor(this.initialSpawnTimer)>0){const t=Math.ceil(this.initialSpawnDelay-this.initialSpawnTimer);console.log(`Initial spawn delay: ${t} seconds remaining`)}if(this.initialSpawnTimer>=this.initialSpawnDelay)this.initialSpawnComplete=!0,console.log("Initial spawn delay complete. Spectral drones beginning to spawn."),window.mainMessageBus&&window.mainMessageBus.publish("ui.notification",{message:"WARNING: Spectral drones have been spotted in the sector!",duration:5e3}),window.game&&window.game.ui&&window.game.ui.showNotification&&window.game.ui.showNotification("WARNING: Spectral drones have been spotted in the sector!",5e3);else return}(this.spawnTimer>this.spawnInterval*.9||this.enemies.size===0)&&console.log(`Spawn status: ${this.enemies.size}/${this.maxEnemies} enemies, timer: ${this.spawnTimer.toFixed(1)}/${this.spawnInterval} seconds`),this.spawner.update(e,this.enemies,this.maxEnemies,t=>this.spawnSpectralDrone(t)),this.enemies.size===0&&this.spawnTimer>this.spawnInterval*2&&(console.warn("FAILSAFE: No enemies detected for extended period. Resetting spawn system."),this.enemies.clear(),this.spawner.generateSpawnPoints(),this.spawnTimer=this.spawnInterval)}}updateDifficultyScaling(){if(window.game&&window.game.isHordeActive){this.applyHordeModeScaling();return}if(window.game&&window.game.difficultyManager&&window.game.difficultyManager.params){const e=window.game.difficultyManager.params;e.maxEnemies!==void 0&&this.maxEnemies!==e.maxEnemies&&(console.log(`Updating max enemies from ${this.maxEnemies} to ${e.maxEnemies}`),this.maxEnemies=e.maxEnemies),e.spawnInterval!==void 0&&this.spawnInterval!==e.spawnInterval&&(console.log(`Updating spawn interval from ${this.spawnInterval} to ${e.spawnInterval}`),this.spawnInterval=e.spawnInterval)}}applyHordeModeScaling(){if(!window.game||window.game.hordeSurvivalTime===void 0)return;const e=window.game.hordeSurvivalTime/1e3;Math.floor(e)%10===0&&Math.floor(e)!==this.lastLoggedHordeTime&&(this.lastLoggedHordeTime=Math.floor(e),console.log(`HORDE MODE: Scaling at ${e.toFixed(1)}s survival time`));const t=e/60,n=50;let i;t<5?i=n+t*10:i=(n+50)*Math.pow(1.2,t-5),this.maxEnemies=Math.min(Math.floor(i),300);const s=.2,o=1;if(this.spawnInterval=Math.max(o*Math.pow(.95,t*2),s),this.spawner){const c=1+t*.5,h=1+t*.3,d=1+t*.2;this.spawner.enemyConfig.health=Math.floor(20*c),this.spawner.enemyConfig.damage=Math.floor(15*h),this.spawner.enemyConfig.speed=700*d,Math.floor(e)%30===0&&Math.floor(e)!==this.lastFullLoggedHordeTime&&(this.lastFullLoggedHordeTime=Math.floor(e),console.log(`HORDE MODE SCALING at ${Math.floor(e)}s:`),console.log(`  Max Enemies: ${this.maxEnemies}`),console.log(`  Spawn Interval: ${this.spawnInterval.toFixed(2)}s`),console.log(`  Enemy Health: ${this.spawner.enemyConfig.health}`),console.log(`  Enemy Damage: ${this.spawner.enemyConfig.damage}`),console.log(`  Enemy Speed: ${this.spawner.enemyConfig.speed.toFixed(1)}`))}}processEntity(e,t){this.lifecycle.processEntityUpdate(e,t),this.applySeparationBehavior(e,t)}applySeparationBehavior(e,t){const n=e.getComponent("TransformComponent"),i=e.getComponent("RigidbodyComponent"),s=e.getComponent("EnemyAIComponent");if(!n||!i||!s||i.isFrozen)return;const o=this.calculateSeparationForce(e,n,i);o.lengthSq()>.01?(s.setSeparationForce(o),i.applyForce(o)):s.setSeparationForce(new E)}calculateSeparationForce(e,t,n){const i=new E,s=n.collisionRadius*this.separationThresholdMultiplier,o=this.findNearbyEnemies(e,t.position,s);for(const l of o){if(l===e.id)continue;const r=this.world.getEntity(l);if(!r)continue;const a=r.getComponent("TransformComponent");if(!a)continue;const c=t.position.clone().sub(a.position),h=c.length();if(h>=s||h===0)continue;let d=(s-h)/s;c.normalize(),i.add(c.multiplyScalar(d*this.SEPARATION_FORCE_MAGNITUDE))}return i}findNearbyEnemies(e,t,n){const i=new Set;for(const s of this.enemies){if(s===e.id)continue;const o=this.world.getEntity(s);if(!o||o.hasTag("pooled"))continue;const l=o.getComponent("TransformComponent");if(!l)continue;t.distanceTo(l.position)<n&&i.add(s)}return i}handleEntityDestroyed(e){const t=e.entity;if(!t){console.warn("Entity destroyed event received but no entity in message!");return}const n=t.id,i=this.enemies.has(n);if(t.hasTag&&t.hasTag("enemy")||i){console.log(`Enemy destroyed: ${n}`),i&&(this.enemies.delete(n),console.log(`Removed entity ${n} from enemies tracking`));const s=t.getComponent("TrailComponent");if(s)try{typeof s.onDetached=="function"&&s.onDetached(),window.game&&window.game.trailSystem&&window.game.trailSystem.unregisterTrail&&window.game.trailSystem.unregisterTrail(n),s.trailMesh&&s.trailMesh.parent&&s.trailMesh.parent.remove(s.trailMesh),s.trailMesh&&(s.trailMesh.geometry&&s.trailMesh.geometry.dispose(),s.trailMesh.material&&s.trailMesh.material.dispose()),t.removeComponent("TrailComponent"),console.log(`Cleaned up trail component for destroyed enemy ${n}`)}catch(r){console.error(`Error cleaning up trail for entity ${n}:`,r)}const o=t.getComponent("MeshComponent");if(o&&o.mesh)try{o.mesh.parent&&o.mesh.parent.remove(o.mesh)}catch(r){console.error(`Error cleaning up mesh for entity ${n}:`,r)}this.enemiesDestroyed++,console.log(`Enemy ${n} destroyed. Enemies remaining: ${this.enemies.size}/${this.maxEnemies}`),t.hasTag&&t.hasTag("enemy")&&(console.log(`Explicitly removing 'enemy' tag from destroyed entity ${n}`),t.removeTag("enemy"));let l=!1;for(let r=0;r<this.poolManager.enemyPool.length;r++)if(this.poolManager.enemyPool[r]&&this.poolManager.enemyPool[r].id===n){console.warn(`CRITICAL ERROR: Destroyed entity ${n} is already in the pool!`),this.poolManager.enemyPool.splice(r,1),console.log(`Removed entity ${n} from pool to prevent double-pooling`),l=!0;break}l||(this.poolManager.returnEnemyToPool(t,this.enemies),console.log(`Returned enemy ${n} to pool`)),this.enemiesDestroyed%5===0&&(console.log("Regenerating spawn points after multiple enemy destructions"),this.spawner.generateSpawnPoints()),this.enemies.size===0&&(console.log("All enemies destroyed - accelerating next spawn"),this.spawnTimer=Math.max(this.spawnTimer,this.spawnInterval*.8)),this.lifecycle.validateEnemyReferences(this.enemies)}}onDisabled(){this.spawnMonitorInterval&&(clearInterval(this.spawnMonitorInterval),this.spawnMonitorInterval=null,console.log("Spawn monitoring stopped")),this.enemies.clear(),console.log("Enemy system disabled")}startSpawnMonitoring(){this.spawnMonitorInterval=setInterval(()=>{this.checkSpawnSystemHealth()},1e4),console.log("Spawn system monitoring started")}checkSpawnSystemHealth(){const t=(Date.now()-this.lastSpawnTime)/1e3;console.log(`Spawn system health check: ${this.enemies.size}/${this.maxEnemies} enemies, ${t.toFixed(1)}s since last spawn`),t>this.spawnInterval*3&&this.enemies.size<this.maxEnemies&&(console.warn("Spawn system appears stuck! Performing recovery..."),this.enemies.clear(),this.spawner.generateSpawnPoints(),this.spawnTimer=this.spawnInterval,this.lifecycle.validateEnemyReferences(this.enemies),console.log("Spawn system recovery completed"))}spawnSpectralDrone(e){return this.spawner.spawnSpectralDrone(e,this.poolManager,this.enemies,this.maxEnemies)}freezeAllEnemies(){this.lifecycle.freezeAllEnemies(this.enemies)}unfreezeAllEnemies(){this.lifecycle.unfreezeAllEnemies(this.enemies)}}class k{constructor(e,t,n=20,i=10){this.createFn=e,this.resetFn=t,this.expandSize=i,this.pool=[],this.active=new Set,this.expand(n),console.log(`ObjectPool created with ${n} objects`)}get(){let e;return this.pool.length===0&&(console.log(`Pool empty, expanding by ${this.expandSize} objects`),this.expand(this.expandSize)),e=this.pool.pop(),this.active.add(e),e}release(e){this.active.has(e)&&(this.resetFn(e),this.active.delete(e),this.pool.push(e))}expand(e){for(let t=0;t<e;t++){const n=this.createFn();this.pool.push(n)}}availableCount(){return this.pool.length}activeCount(){return this.active.size}releaseAll(){const e=Array.from(this.active);for(const t of e)this.release(t)}dispose(e){if(e){for(const t of this.active)e(t);for(const t of this.pool)e(t)}this.active.clear(),this.pool=[]}}class ds{constructor(e,t){this.scene=e,this.sharedAssets=t,this.projectileGeometry=this.sharedAssets.projectileGeometry,this.projectileGlowGeometry=this.sharedAssets.projectileGlowGeometry,this.muzzleFlashGeometry=this.sharedAssets.muzzleFlashGeometry,this.trailParticleGeometries=this.sharedAssets.trailParticleGeometries,this.tracerGeometry=this.sharedAssets.tracerGeometry,this.projectileMaterial=this.sharedAssets.projectileMaterial,this.projectileGlowMaterial=this.sharedAssets.projectileGlowMaterial,this.trailParticleMaterial=this.sharedAssets.trailParticleMaterial,this.muzzleFlashMaterial=this.sharedAssets.muzzleFlashMaterial,this.tracerLineMaterial=this.sharedAssets.tracerLineMaterial,this.explosionParticleMaterial=this.sharedAssets.explosionParticleMaterial,this.populateWindowGameWithSharedAssets(),this.initializePools(),console.log("ProjectilePoolManager initialized using pre-warmed shared assets and pools")}populateWindowGameWithSharedAssets(){window.game||(window.game={}),window.game.projectileGeometry=this.projectileGeometry,window.game.projectileGlowGeometry=this.projectileGlowGeometry,window.game.muzzleFlashGeometry=this.muzzleFlashGeometry,window.game.trailParticleGeometries=this.trailParticleGeometries,window.game.tracerGeometry=this.tracerGeometry,window.game.projectileMaterial=this.projectileMaterial,window.game.projectileGlowMaterial=this.projectileGlowMaterial,window.game.trailParticleMaterial=this.trailParticleMaterial,window.game.muzzleFlashMaterial=this.muzzleFlashMaterial,window.game.tracerLineMaterial=this.tracerLineMaterial,window.game.explosionParticleMaterial=this.explosionParticleMaterial}initializePools(){this.projectilePool=new k(()=>{const e=new P(this.projectileGeometry,this.projectileMaterial.clone()),t=new P(this.projectileGlowGeometry,this.projectileGlowMaterial.clone());return e.add(t),e.userData={isProjectile:!0,active:!1,pooled:!0,glowMesh:t},e},e=>{e.position.set(0,0,0),e.rotation.set(0,0,0),e.scale.set(1,1,1),e.visible=!1,e.userData.active=!1,e.userData.creationTime=0,e.userData.entityId=null,e.userData.trail=null,e.userData.trailParticles=null},30,10),this.explosionPool=new k(()=>{const t=new $,n=new Float32Array(200*3);for(let o=0;o<200;o++){const l=o*3;n[l]=(Math.random()-.5)*100,n[l+1]=(Math.random()-.5)*100,n[l+2]=(Math.random()-.5)*100}t.setAttribute("position",new U(n,3));const i=this.explosionParticleMaterial.clone(),s=new pe(t,i);return s.userData={isExplosion:!0,active:!1,pooled:!0,startTime:0,duration:1e3,particleCount:200},s},e=>{e.position.set(0,0,0),e.visible=!1,e.material.opacity=1,e.userData.active=!1,e.userData.startTime=0;const t=e.geometry.attributes.position.array,n=e.userData.particleCount;for(let i=0;i<n;i++){const s=i*3;t[s]=(Math.random()-.5)*100,t[s+1]=(Math.random()-.5)*100,t[s+2]=(Math.random()-.5)*100}e.geometry.attributes.position.needsUpdate=!0},10,5),this.muzzleFlashPool=new k(()=>{const e=new P(this.muzzleFlashGeometry,this.muzzleFlashMaterial.clone());e.userData={isMuzzleFlash:!0,active:!1,pooled:!0,startTime:0,flashLight:null};const t=new Re(65535,200,10,2);return t.visible=!1,this.scene.add(t),e.userData.flashLight=t,e},e=>{e.position.set(0,0,0),e.rotation.set(0,0,0),e.scale.set(1,1,1),e.visible=!1,e.material.opacity=.7;const t=e.userData.flashLight;t&&(t.position.set(0,0,0),t.intensity=200,t.visible=!1),e.userData.active=!1,e.userData.startTime=0},20,5),this.trailContainerPool=new k(()=>{const e=new Y;return e.userData={isTrail:!0,active:!1,pooled:!0,particles:[]},e},e=>{e.position.set(0,0,0),e.rotation.set(0,0,0),e.visible=!1,e.userData.active=!1,e.userData.parentProjectile=null},30,10),this.trailParticlePool=new k(()=>{const e=new P(this.trailParticleGeometries[0],this.trailParticleMaterial.clone());return e.userData={isTrailParticle:!0,active:!1,pooled:!0,sizeIndex:0,initialOffset:new E},e},e=>{e.position.set(0,0,0),e.visible=!1,e.material.opacity=.9,e.userData.active=!1,e.userData.sizeIndex=0,e.userData.initialOffset.set(0,0,0),e.userData.initialOpacity=.9},600,100),this.tracerPool=new k(()=>{const e=new X(this.tracerGeometry.clone(),this.tracerLineMaterial.clone());return e.userData={isTracer:!0,active:!1,pooled:!0,startTime:0},e},e=>{e.position.set(0,0,0),e.visible=!1,e.material.opacity=.6,e.userData.active=!1,e.userData.startTime=0},20,5)}getProjectile(){const e=this.projectilePool.get();return e.visible=!0,e.userData.active=!0,e.userData.creationTime=performance.now(),e.parent||this.scene.add(e),e}getMuzzleFlash(){const e=this.muzzleFlashPool.get();e.visible=!0,e.userData.active=!0,e.userData.startTime=performance.now();const t=e.userData.flashLight;return t&&(t.visible=!0,t.intensity=200),e.parent||this.scene.add(e),e}getTrailContainer(){const e=this.trailContainerPool.get();return e.visible=!0,e.userData.active=!0,e}getTrailParticle(e=0){const t=this.trailParticlePool.get();return t.visible=!0,t.userData.active=!0,t.userData.sizeIndex=e,e>=0&&e<this.trailParticleGeometries.length&&(t.geometry=this.trailParticleGeometries[e]),t}getTracer(){const e=this.tracerPool.get();return e.visible=!0,e.userData.active=!0,e.userData.startTime=performance.now(),e.parent||this.scene.add(e),e}getExplosion(e,t=1e3){const n=this.explosionPool.get();return n.position.copy(e),n.visible=!0,n.userData.active=!0,n.userData.startTime=Date.now(),n.userData.duration=t,n.parent||this.scene.add(n),n}releaseProjectile(e){!e||!e.userData||!e.userData.isProjectile||(e.userData.trail&&(this.releaseTrail(e.userData.trail),e.remove(e.userData.trail),e.userData.trail=null,e.userData.trailParticles=null),e.parent&&e.parent.remove(e),this.projectilePool.release(e))}releaseMuzzleFlash(e){if(!e||!e.userData||!e.userData.isMuzzleFlash)return;const t=e.userData.flashLight;t&&(t.visible=!1),e.parent&&e.parent.remove(e),this.muzzleFlashPool.release(e)}releaseTrail(e){if(!(!e||!e.userData||!e.userData.isTrail)){if(e.userData.particles)for(const t of e.userData.particles)t&&(e.remove(t),this.releaseTrailParticle(t));e.userData.particles=[],this.trailContainerPool.release(e)}}releaseTrailParticle(e){!e||!e.userData||!e.userData.isTrailParticle||this.trailParticlePool.release(e)}releaseTracer(e){!e||!e.userData||!e.userData.isTracer||(e.parent&&e.parent.remove(e),this.tracerPool.release(e))}releaseExplosion(e){!e||!e.userData||!e.userData.isExplosion||(e.parent&&e.parent.remove(e),this.explosionPool.release(e))}update(e){this.updateMuzzleFlashes(e),this.updateTracers(e),this.updateExplosions(e)}updateMuzzleFlashes(e){for(const t of this.muzzleFlashPool.active){const s=(performance.now()-t.userData.startTime)/70;if(s>=1)this.releaseMuzzleFlash(t);else{const o=Math.min(s*2.5,1),l=300;if(t.userData.initialPosition&&t.userData.direction){const a=t.userData.initialPosition.clone().add(t.userData.direction.clone().multiplyScalar(l*o));t.position.copy(a),t.userData.flashLight&&t.userData.flashLight.position.copy(a)}t.material.opacity=.7*(1-s),t.userData.flashLight&&(t.userData.flashLight.intensity=200*(1-s*3));const r=1+s*1.5;t.scale.set(1,1,r)}}}updateTracers(e){for(const t of this.tracerPool.active){performance.now()-t.userData.startTime;const i=Math.max(0,t.material.opacity-1.5*.016);i<=0?this.releaseTracer(t):t.material.opacity=i}}updateExplosions(e){for(const t of this.explosionPool.active){const n=Date.now()-t.userData.startTime,i=t.userData.duration,s=n/i;if(s>=1)this.releaseExplosion(t);else{const o=t.geometry.attributes.position.array,l=t.userData.particleCount;for(let r=0;r<l;r++){const a=r*3,c=o[a]*(1+s*5),h=o[a+1]*(1+s*5),d=o[a+2]*(1+s*5);t.geometry.attributes.position.array[a]=c,t.geometry.attributes.position.array[a+1]=h,t.geometry.attributes.position.array[a+2]=d}t.geometry.attributes.position.needsUpdate=!0,t.material.opacity=1-s}}}dispose(){this.projectileGeometry.dispose(),this.projectileGlowGeometry.dispose(),this.muzzleFlashGeometry.dispose(),this.tracerGeometry.dispose(),this.trailParticleGeometries.forEach(e=>e.dispose()),this.projectileMaterial.dispose(),this.projectileGlowMaterial.dispose(),this.trailParticleMaterial.dispose(),this.muzzleFlashMaterial.dispose(),this.tracerLineMaterial.dispose(),this.projectilePool.dispose(e=>{e.parent&&e.parent.remove(e),e.userData.glowMesh&&e.userData.glowMesh.material&&e.userData.glowMesh.material.dispose(),e.material&&e.material.dispose()}),this.muzzleFlashPool.dispose(e=>{e.parent&&e.parent.remove(e),e.userData.flashLight&&e.userData.flashLight.parent&&e.userData.flashLight.parent.remove(e.userData.flashLight),e.material&&e.material.dispose()}),this.trailContainerPool.dispose(e=>{e.parent&&e.parent.remove(e)}),this.trailParticlePool.dispose(e=>{e.parent&&e.parent.remove(e),e.material&&e.material.dispose()}),this.tracerPool.dispose(e=>{e.parent&&e.parent.remove(e),e.material&&e.material.dispose()}),console.log("ProjectilePoolManager disposed all pools and shared assets")}}class ys{constructor(e,t){console.log("Initializing combat system"),this.scene=e,this.spaceship=t,this.projectiles=[],this.projectileLifetime=2e3,this.fireRate=3,this.projectileSpeed=3e4,this.lastFireTime=0,this.aimingSpread=.05,this.isFiring=!1,this.cooldown=1e3/this.fireRate,this.projectileDamage=20,this.initializeTemplateMaterials(),this.precreateGeometries(),this.poolManager=new ds(e,{projectileMaterial:this.projectileMaterial,projectileGlowMaterial:this.projectileGlowMaterial,trailParticleMaterial:this.trailParticleMaterial,muzzleFlashMaterial:this.muzzleFlashMaterial,tracerLineMaterial:this.tracerLineMaterial,explosionParticleMaterial:this.explosionParticleMaterial,projectileGeometry:window.game.projectileGeometry,projectileGlowGeometry:window.game.projectileGlowGeometry,muzzleFlashGeometry:window.game.muzzleFlashGeometry,trailParticleGeometries:window.game.trailParticleGeometries,tracerGeometry:window.game.tracerGeometry}),console.log("Initialized ProjectilePoolManager for object pooling with pre-warmed assets"),this.initializeECSWorld(),console.log("Combat systems initialized")}initializeTemplateMaterials(){console.log("Initializing template materials for combat effects"),this.projectileMaterial=new me({color:16711680,emissive:16711680,emissiveIntensity:10,metalness:.5,roughness:.5}),this.projectileGlowMaterial=new R({color:16711680,transparent:!0,opacity:.5,blending:N}),this.trailParticleMaterial=new R({color:16711680,transparent:!0,opacity:.9,blending:N}),this.muzzleFlashMaterial=new R({color:16711680,transparent:!0,opacity:.8,blending:N,side:W,depthWrite:!1,wireframe:!1}),this.tracerLineMaterial=new le({color:16711680,transparent:!0,opacity:.8,blending:N}),this.pointLightMaterial=new R({color:16711680,emissive:16711680,emissiveIntensity:1}),this.explosionParticleMaterial=new Le({color:16724736,size:15,transparent:!0,opacity:1,blending:N});const e=new ue(.1,.1,.1),t=new K(.1,8,8),n=new te(.1,.2,1,8,1),i=new Float32Array(30);for(let f=0;f<30;f++)i[f]=Math.random()-.5;const s=new $;s.setAttribute("position",new U(i,3));const o=new P(t,this.projectileMaterial),l=new P(t,this.projectileGlowMaterial),r=new P(t,this.trailParticleMaterial),a=new P(n,this.muzzleFlashMaterial),c=new X(new $().setFromPoints([new E(0,0,0),new E(0,0,1)]),this.tracerLineMaterial),h=new pe(s,this.explosionParticleMaterial),d=new Y;for(let f=0;f<5;f++){const y=new P(t,this.trailParticleMaterial.clone());y.position.z=-f*.2,d.add(y)}const m=new wt;m.add(o),m.add(l),m.add(r),m.add(a),m.add(c),m.add(d),m.add(h),this.scene.add(o),this.scene.add(l),this.scene.add(r),this.scene.add(a),this.scene.add(c),this.scene.add(d),this.scene.add(h),window.renderer?(console.log("Forcing shader compilation with renderer.compile()"),window.renderer.compile(m,this.scene.camera||{isCamera:!0,matrixWorldInverse:new j}),window.renderer.compile(this.scene,this.scene.camera||{isCamera:!0,matrixWorldInverse:new j})):window.game&&window.game.renderer&&window.game.renderer.renderer?(console.log("Forcing shader compilation with game.renderer.renderer.compile()"),window.game.renderer.renderer.compile(m,this.scene.camera||window.game.camera||{isCamera:!0,matrixWorldInverse:new j}),window.game.renderer.renderer.compile(this.scene,this.scene.camera||window.game.camera||{isCamera:!0,matrixWorldInverse:new j})):console.warn("No renderer available for shader pre-compilation"),setTimeout(()=>{this.scene.remove(o),this.scene.remove(l),this.scene.remove(r),this.scene.remove(a),this.scene.remove(c),this.scene.remove(d),this.scene.remove(h),e.dispose(),t.dispose(),n.dispose(),s.dispose(),d.children.forEach(f=>{f.geometry&&f.geometry.dispose(),f.material&&f.material.dispose()}),console.log("Template materials initialized and dummy objects removed")},500)}precreateGeometries(){console.log("Pre-creating geometries for combat effects"),window.game||(window.game={}),window.game.projectileGeometry=new te(.15,.15,10,8),window.game.projectileGlowGeometry=new K(.8,12,12),window.game.muzzleFlashGeometry=new te(.5,2,15,12,1,!0),window.game.muzzleFlashGeometry.rotateX(Math.PI/2),window.game.muzzleFlashGeometry.translate(0,0,15/2),window.game.trailParticleGeometries=[];const e=20;for(let n=0;n<e;n++){const s=.5*(1-n/e);window.game.trailParticleGeometries[n]=new K(s,8,8)}window.game.tracerGeometry=new $;const t=[0,0,0,0,0,1];window.game.tracerGeometry.setAttribute("position",new Tt(t,3)),window.game.projectileMaterial=this.projectileMaterial,window.game.projectileGlowMaterial=this.projectileGlowMaterial,window.game.trailParticleMaterial=this.trailParticleMaterial,window.game.muzzleFlashMaterial=this.muzzleFlashMaterial,window.game.tracerLineMaterial=this.tracerLineMaterial,window.game.explosionParticleMaterial=this.explosionParticleMaterial,console.log("Combat geometries pre-created successfully")}async initializeECSWorld(){try{console.log("[COMBAT] Starting ECS world initialization..."),this.world=new $e(window.mainMessageBus),console.log("[COMBAT] Created world with messageBus: ",this.world.messageBus===window.mainMessageBus?"Using shared messageBus":"Created new messageBus"),window.game&&(window.game.ecsWorld=this.world,console.log("[COMBAT] Made ECS world globally available via window.game.ecsWorld")),await this.createPlayerReferenceEntity(),await this.setupECSWorld(),console.log("[COMBAT] ECS world initialization complete")}catch(e){console.error("[COMBAT] Error initializing ECS world:",e)}}async setupECSWorld(){if(this.worldInitialized){console.log("[COMBAT] World already initialized, skipping setup");return}this.world.scene=this.scene,console.log("[COMBAT] Set scene reference in ECS world for enemy rendering:",this.scene?"Scene available":"No scene available"),console.log("[COMBAT] Registering combat systems with ECS world...");try{this.combatSystem=new os(this.world),this.world.registerSystem(this.combatSystem),this.enemySystem=new hs(this.world),this.world.registerSystem(this.enemySystem),window.game&&(window.game.ecsWorld=window.game.ecsWorld||{},window.game.ecsWorld.enemySystem=this.enemySystem,console.log("[COMBAT] Made enemy system globally available via window.game.ecsWorld.enemySystem")),this.trailSystem=await this.importAndRegisterSystem("../systems/rendering/trailSystem.js","TrailSystem"),this.world.registerSystem(this.trailSystem),this.deployableLaserSystem=await this.importAndRegisterSystem("../systems/weapons/deployableLaserSystem.js","DeployableLaserSystem"),this.world.registerSystem(this.deployableLaserSystem),this.deploymentSystem=await this.importAndRegisterSystem("../systems/deployables/deploymentSystem.js","DeploymentSystem"),this.world.registerSystem(this.deploymentSystem),window.game&&(window.game.trailSystem=this.trailSystem,console.log("[COMBAT] Registered trail system with window.game for global access"));const e=this.scene.camera;e||console.error("[COMBAT] No camera found on scene, enemies may not be visible"),console.log(`[COMBAT] Camera reference for RenderSystem: ${e?"Available":"Missing"}`),this.renderSystem=new Et(this.world,this.scene,e),this.world.registerSystem(this.renderSystem),console.log("[COMBAT] Registering CollisionSystem with the world..."),this.collisionSystem=new Mt(this.world),this.world.registerSystem(this.collisionSystem),console.log("[COMBAT] CollisionSystem registered"),console.log("[COMBAT] Registering VisualEffectsSystem with the world..."),this.visualEffectsSystem=new St(this.world),this.world.registerSystem(this.visualEffectsSystem),console.log("[COMBAT] VisualEffectsSystem registered"),this.scene&&(this.scene.ecsWorld=this.world,console.log("[COMBAT] Set ECS world reference in scene for cross-system access"));try{console.log("[COMBAT] Calling world.initialize()..."),this.world.initialize(),console.log("[COMBAT] World initialization completed successfully")}catch(t){console.error("[COMBAT] Error during world.initialize():",t),console.error("[COMBAT] Stack trace:",t.stack),console.log("[COMBAT] Continuing despite initialization error")}await this.createPlayerReferenceEntity(),this.enemySystem&&(this.enemySystem.lifecycle.validateEnemyReferences(this.enemySystem.enemies),this.enemySystem.enemies.size>this.enemySystem.maxEnemies&&(console.warn(`[COMBAT] Found ${this.enemySystem.enemies.size} enemies exceeding limit of ${this.enemySystem.maxEnemies} during setup`),this.enemySystem.enforceEnemyLimit()),this.enemySystem.spawner.generateSpawnPoints(),console.log(`[COMBAT] Configured enemy system: Max enemies ${this.enemySystem.maxEnemies}`)),this.worldInitialized=!0,console.log("[COMBAT] ECS combat systems registered and initialization process completed")}catch(e){console.error("[COMBAT] Error during world setup:",e),console.error("[COMBAT] Stack trace:",e.stack)}}async createPlayerReferenceEntity(){if(!this.world)return console.error("[COMBAT] Cannot create player entity - world not available"),null;if(!this.spaceship)return console.error("[COMBAT] Cannot create player entity - spaceship not available"),null;try{if(console.log("[COMBAT] Creating player reference entity..."),this.playerEntity){const t=this.world.getEntity(this.playerEntity.id);if(t){console.log(`[COMBAT] Player entity already exists with ID: ${this.playerEntity.id}`),t.hasTag("player")||(console.log("[COMBAT] Re-adding 'player' tag to existing entity"),t.addTag("player"));const n=t.getComponent("TransformComponent");return n&&this.spaceship.mesh&&(n.position.copy(this.spaceship.mesh.position),n.rotation.copy(this.spaceship.mesh.rotation),n.quaternion.copy(this.spaceship.mesh.quaternion),typeof n.setUpdated=="function"&&n.setUpdated()),window.game&&(window.game.combat=window.game.combat||{},window.game.combat.playerEntity=t),t}else console.log("[COMBAT] Previous player entity no longer exists, creating new one")}const e=this.world.createEntity("player_"+Date.now());e.addTag("player"),console.log(`[COMBAT] Added 'player' tag to entity ${e.id}`);try{const t=this.spaceship.mesh?this.spaceship.mesh.position.clone():new E,n=new fe(t);e.addComponent(n),console.log(`[COMBAT] Added TransformComponent to player entity with position: ${t.x.toFixed(1)}, ${t.y.toFixed(1)}, ${t.z.toFixed(1)}`)}catch(t){console.error("[COMBAT] Error adding TransformComponent to player entity:",t)}try{const t=new Oe(100,50);e.addComponent(t),console.log("[COMBAT] Added HealthComponent to player entity")}catch(t){console.error("[COMBAT] Error adding HealthComponent to player entity:",t)}return this.playerEntity=e,window.game&&(window.game.combat=window.game.combat||{},window.game.combat.playerEntity=e,console.log("[COMBAT] Made player entity globally accessible via window.game.combat.playerEntity")),this.world.playerEntity=e,console.log("[COMBAT] Made player entity available directly via world.playerEntity"),this.world&&this.world.messageBus&&(this.world.messageBus.publish("player.created",{entity:e}),console.log("[COMBAT] Published player.created event")),console.log("[COMBAT] Successfully created player reference entity with ID:",e.id),e}catch(e){return console.error("[COMBAT] Error creating player reference entity:",e),console.error("[COMBAT] Stack trace:",e.stack),null}}update(e){if(!this.scene||!this.spaceship)return;const t=window.game&&window.game.introSequenceActive;if(this.updatePlayerReference(),this.updateSpaceshipHealth(),this.updateProjectiles(e),this.poolManager&&this.poolManager.update(e),this.isFiring&&!this.spaceship.isDocked&&this.fireParticleCannon(),this.world&&!t)this.world.update(e);else if(this.world&&t&&this.world.systems)for(const n of this.world.systems)n.constructor.name!=="EnemySystem"&&n.constructor.name!=="EnemyAISystem"&&n.update(e)}updatePlayerReference(){if(!this.world||!this.spaceship||!this.playerEntity){if(this.world&&this.spaceship&&!this.playerEntity){console.log("No player entity found, creating one..."),this.createPlayerReferenceEntity();return}return}const e=this.world.getEntity(this.playerEntity.id);if(!e){console.warn("Player entity lost, recreating..."),this.createPlayerReferenceEntity();return}const t=e.getComponent("TransformComponent");t&&this.spaceship.mesh&&(t.position.copy(this.spaceship.mesh.position),t.rotation.copy(this.spaceship.mesh.rotation),t.quaternion.copy(this.spaceship.mesh.quaternion),typeof t.setUpdated=="function"&&t.setUpdated());const n=e.getComponent("HealthComponent");n&&this.spaceship.health!==void 0&&(this.spaceship.health>n.health&&(n.health=this.spaceship.health),this.spaceship.shield!==void 0&&this.spaceship.shield>n.shield&&(n.shield=this.spaceship.shield))}updateSpaceshipHealth(){if(!this.playerEntity||!this.spaceship)return;const e=this.playerEntity.getComponent("HealthComponent");e&&(e.health<this.spaceship.hull&&(console.log(`Damage detected in health component: ${e.health} (was ${this.spaceship.hull})`),this.spaceship.hull=e.health),e.shield<this.spaceship.shield&&(console.log(`Shield damage detected in health component: ${e.shield} (was ${this.spaceship.shield})`),this.spaceship.shield=e.shield),e.isDestroyed&&!this.spaceship.isDestroyed&&(console.log("Health component indicates player is destroyed - updating spaceship state"),this.spaceship.isDestroyed=!0,typeof this.spaceship.handleDestruction=="function"&&this.spaceship.handleDestruction()),e.health<=0&&!this.spaceship.isDestroyed&&(console.log("Player health is zero - marking spaceship as destroyed"),this.spaceship.isDestroyed=!0,typeof this.spaceship.handleDestruction=="function"&&this.spaceship.handleDestruction(),window.game&&(console.log("FORCING GAME OVER FROM COMBAT MODULE!"),window.game.gameOver("You were pwned by a space alien!"))))}updateProjectiles(e){for(let t=this.projectiles.length-1;t>=0;t--){const n=this.projectiles[t];if(n.position.add(n.velocity.clone().multiplyScalar(e)),n.userData&&n.userData.entityId&&this.world){const i=this.world.getEntity(n.userData.entityId);if(i)if(typeof i.update=="function")i.update(e);else{const s=i.getComponent("TransformComponent");s&&(s.position.copy(n.position),s.needsUpdate=!0);const o=i.getComponent("RigidbodyComponent");o&&o.velocity.copy(n.velocity)}}if(performance.now()-n.userData.creationTime>this.projectileLifetime){if(n.userData&&n.userData.entityId&&this.world)try{this.world.destroyEntity(n.userData.entityId),console.log(`Removed expired projectile entity ${n.userData.entityId}`)}catch(i){console.error("Error removing projectile entity:",i)}this.poolManager.releaseProjectile(n),this.projectiles.splice(t,1)}}}setFiring(e){this.isFiring=e,console.log(`Particle cannon firing state changed: ${e}`)}createExplosionEffect(e,t=1e3,n=!0){try{const i=this.poolManager.getExplosion(e,t);return window.game&&window.game.audio&&window.game.audio.playSound("boink"),console.log("Created explosion effect at:",e.x.toFixed(0),e.y.toFixed(0),e.z.toFixed(0)),i}catch(i){return console.error("Error creating explosion effect:",i),null}}registerEnemy(e){this._registeredEnemyIds||(this._registeredEnemyIds=new Set),this._registeredEnemyIds.add(e),console.log(`Combat module: Registered enemy ${e} for tracking (total: ${this._registeredEnemyIds.size})`)}unregisterEnemy(e){this._registeredEnemyIds&&this._registeredEnemyIds.has(e)&&(this._registeredEnemyIds.delete(e),console.log(`Combat module: Unregistered enemy ${e} (remaining: ${this._registeredEnemyIds.size})`))}fireParticleCannon(){if(!this.spaceship||!this.spaceship.mesh)return!1;const e=performance.now();if(e-this.lastFireTime<this.cooldown)return!1;console.log("*** COMBAT MODULE: Firing particle cannon ***"),this.lastFireTime=e;const t=this.spaceship.mesh.position.clone(),n=this.scene.camera;if(!n)return console.error("Camera not available for aiming"),!1;const i=new _e,s=new de(0,0);i.setFromCamera(s,n);const o=i.ray.direction.clone().normalize();console.log(`Projectile direction (using camera ray): ${o.x.toFixed(2)}, ${o.y.toFixed(2)}, ${o.z.toFixed(2)}`);const l=new E().crossVectors(o,new E(0,1,0)).normalize(),r=new E().copy(l).multiplyScalar(-1.5),a=new E().copy(l).multiplyScalar(1.5),c=new E().copy(o).multiplyScalar(15),h=new E().copy(o).multiplyScalar(4);new E().copy(t).add(r).add(h),new E().copy(t).add(a).add(h);const d=new E().copy(t).add(r).add(c);this.createProjectile(d,o);const m=new E().copy(t).add(a).add(c);if(this.createProjectile(m,o),window.game&&window.game.audio&&(console.log("Playing ASMR projectile sound for particle cannon"),window.game.audio.playSound("projectile")),console.log("DIRECT ENEMY CHECK: Searching for enemies to destroy"),this.world&&this.world.entityManager){let f=[];try{if(this.world.entityManager.entitiesByTag&&this.world.entityManager.entitiesByTag.get("enemy"))f=this.world.entityManager.entitiesByTag.get("enemy"),console.log(`Found ${f.length} enemies via tag map`);else{console.log("No enemy tag map, checking all entities");const y=Array.from(this.world.entityManager.entities.values());for(const u of y)(u.hasTag&&u.hasTag("enemy")||u.hasComponent&&u.hasComponent("EnemyAIComponent"))&&f.push(u);console.log(`Found ${f.length} enemies by checking all entities`)}}catch(y){console.error("Error finding enemies:",y)}for(const y of f)if(y)try{let u=null;const w=y.getComponent("TransformComponent");if(w)u=w.position;else{console.log("Enemy missing transform component");continue}const g=y.getComponent("MeshComponent");if(!g||!g.mesh){console.log(`Enemy ${y.id} has no mesh component or mesh`);continue}console.log(`Testing ray intersection with enemy ${y.id}:`),console.log(`- Position: (${u.x.toFixed(1)}, ${u.y.toFixed(1)}, ${u.z.toFixed(1)})`),console.log(`- Mesh visible: ${g.mesh.visible}`),console.log(`- Mesh children: ${g.mesh.children?g.mesh.children.length:0}`);const A=t.distanceTo(u);if(console.log(`- Distance to enemy: ${A.toFixed(1)}`),!g.mesh.visible){console.log(`Mesh for enemy ${y.id} is not visible, skipping`);continue}const T=i.intersectObject(g.mesh,!0);if(T.length>0){const M=T[0];console.log(`*** MESH HIT on enemy ${y.id}! ***`),console.log(`- Hit distance: ${M.distance.toFixed(2)}`),console.log(`- Hit point: (${M.point.x.toFixed(1)}, ${M.point.y.toFixed(1)}, ${M.point.z.toFixed(1)})`),M.object&&console.log(`- Hit specific object: ${M.object.name||"unnamed"}`),M.face&&console.log(`- Hit face normal: (${M.face.normal.x.toFixed(2)}, ${M.face.normal.y.toFixed(2)}, ${M.face.normal.z.toFixed(2)})`);const x=y.getComponent("HealthComponent");if(x){console.log("Applying damage to enemy");const v=x.applyDamage(this.projectileDamage,"particle",this.playerEntity);if(x.health<=0){if(console.log("Enemy health depleted, destroying entity"),x.isDestroyed=!0,w&&(this.createExplosionEffect(w.position.clone()),window.game&&window.game.audio&&window.game.audio.playSound("boink")),this.unregisterEnemy(y.id),window.game&&window.game.ecsWorld&&window.game.ecsWorld.enemySystem){console.log(`Notifying EnemySystem directly about enemy ${y.id} destruction`);try{const b=window.game.ecsWorld.enemySystem;typeof b.handleEntityDestroyed=="function"&&b.handleEntityDestroyed({entity:y,reason:"projectile"})}catch(b){console.error("Error syncing with EnemySystem:",b)}}try{if(window.game&&window.game.ecsWorld&&window.game.ecsWorld.enemySystem){const b=window.game.ecsWorld.enemySystem;typeof b.returnEnemyToPool=="function"&&(console.log(`Using EnemySystem.returnEnemyToPool for enemy ${y.id}`),b.returnEnemyToPool(y)),typeof b.validateEnemyReferences=="function"&&b.validateEnemyReferences()}else this.world.destroyEntity(y.id),console.log("Enemy destroyed via world.destroyEntity")}catch(b){console.error("Failed to destroy enemy:",b)}this.world&&this.world.messageBus&&this.world.messageBus.publish("enemy.destroyed",{entityId:y.id,source:"playerProjectile",position:u.clone()})}else console.log(`Enemy hit but survived with ${x.health}/${x.maxHealth} health remaining`)}}else if(console.log(`Ray missed enemy ${y.id} - no mesh intersection`),window.debugMode){const M=new X(new $().setFromPoints([i.ray.origin.clone(),i.ray.origin.clone().add(i.ray.direction.clone().multiplyScalar(1e3))]),new le({color:16711680}));this.scene.add(M),setTimeout(()=>this.scene.remove(M),1e3)}}catch(u){console.error("Error checking enemy collision:",u)}}else console.log("No world or entityManager available for enemy check");return!0}createProjectile(e,t){const n=this.poolManager.getProjectile();n.position.copy(e),n.visible=!0;const i=new E(0,1,0),s=new q;return s.setFromUnitVectors(i,t),n.quaternion.copy(s),n.velocity=t.clone().multiplyScalar(this.projectileSpeed),n.userData.isPlayerProjectile=!0,n.userData.sourceId="player",n.userData.damage=this.projectileDamage,this.addProjectileTrail(n,t),n.parent||this.scene.add(n),n.userData.creationTime=performance.now(),this.projectiles.push(n),n}setEnabled(e){e?this.world&&(this.enemySystem&&typeof this.enemySystem.setEnabled=="function"?this.enemySystem.setEnabled(!0):this.enemySystem&&(this.enemySystem.enabled=!0),this.combatSystem&&typeof this.combatSystem.setEnabled=="function"?this.combatSystem.setEnabled(!0):this.combatSystem&&(this.combatSystem.enabled=!0)):(this.clearAllProjectiles(),this.world&&(this.enemySystem&&typeof this.enemySystem.setEnabled=="function"?this.enemySystem.setEnabled(!1):this.enemySystem&&(this.enemySystem.enabled=!1),this.combatSystem&&typeof this.combatSystem.setEnabled=="function"?this.combatSystem.setEnabled(!1):this.combatSystem&&(this.combatSystem.enabled=!1))),console.log(`Combat systems ${e?"enabled":"disabled"}`)}addProjectileTrail(e,t){if(!this.poolManager){console.warn("PoolManager not available for projectile trail.");return}const o=this.poolManager.getTrailContainer();if(!o){console.warn("Failed to get trail container from pool.");return}e.add(o);const l=[];o.userData.particles=l,o.userData.isTrailActive=!0;for(let a=0;a<4;a++){const c=a/3,h=this.poolManager.getTrailParticle(a%window.game.trailParticleGeometries.length);if(!h){console.warn(`Failed to get trail particle ${a} from pool.`);continue}const d=t.clone().multiplyScalar(-c*4-2);h.position.copy(d),h.userData.creationTime=performance.now(),h.userData.initialOpacity=h.material.opacity,h.userData.initialScale=h.scale.x,o.add(h),l.push(h)}e.userData.trail=o;const r=()=>{if(!e.parent||!o.userData.isTrailActive){o.userData.isTrailActive=!1;return}for(let a=l.length-1;a>=0;a--){const c=l[a],h=performance.now()-c.userData.creationTime,d=Math.min(h/150,1);if(d>=1)this.poolManager.releaseTrailParticle(c),l.splice(a,1),c.parent&&c.parent.remove(c);else{c.material.opacity=c.userData.initialOpacity*(1-d);const m=c.userData.initialScale*(1-d);c.scale.set(m,m,m)}}if(l.length===0){o.userData.isTrailActive=!1;return}requestAnimationFrame(r)};r()}clearAllProjectiles(){for(const e of this.projectiles){if(e.userData&&e.userData.entityId&&this.world)try{this.world.destroyEntity(e.userData.entityId)}catch(t){console.error("Error removing projectile entity:",t)}this.poolManager.releaseProjectile(e)}this.projectiles=[],console.log("All projectiles cleared and returned to the pool")}createAimingTracer(e,t,n=3e3){const i=this.poolManager.getTracer(),s=e.clone().add(t.clone().multiplyScalar(n)),o=i.geometry.attributes.position.array;return o[0]=e.x,o[1]=e.y,o[2]=e.z,o[3]=s.x,o[4]=s.y,o[5]=s.z,i.geometry.attributes.position.needsUpdate=!0,i}createMuzzleFlash(e,t){const n=this.poolManager.getMuzzleFlash();n.position.copy(e);const i=e.clone().add(t.clone().normalize().multiplyScalar(10));n.lookAt(i),n.userData.initialPosition=e.clone(),n.userData.direction=t.clone();const s=n.userData.flashLight;return s&&(s.position.copy(e),s.intensity=200),n}dispose(){console.log("Disposing Combat module resources..."),this.clearAllProjectiles(),this.poolManager&&(this.poolManager.dispose(),this.poolManager=null),this.disposed=!0,console.log("Combat module resources disposed")}async importAndRegisterSystem(e,t){try{const n=await import(e);if(!n[t])return console.error(`[COMBAT] System class ${t} not found in module ${e}`),null;const i=n[t];let s;return t==="TrailSystem"||t==="VisualEffectsSystem"||t==="RenderSystem"?s=new i(this.world,this.scene):s=new i(this.world),s}catch(n){return console.error(`[COMBAT] Error importing system ${t} from ${e}:`,n),null}}}export{Ge as C,xt as G,ys as a};
//# sourceMappingURL=combat-Bzyirpe1.js.map
