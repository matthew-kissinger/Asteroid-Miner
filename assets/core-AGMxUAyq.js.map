{"version":3,"file":"core-AGMxUAyq.js","sources":["../../js/core/entity.js","../../js/core/entityManager.js","../../js/core/systemManager.js","../../js/core/messageBus.js","../../js/core/world.js","../../js/core/system.js"],"sourcesContent":["/**\n * Entity Class - Base entity class for ECS architecture\n * \n * The core building block of the Entity-Component-System pattern.\n * Each entity is essentially just an ID with a collection of components\n * that define its behavior and properties.\n */\n\nexport class Entity {\n    constructor(id, world) {\n        this.id = id;\n        this.world = world;\n        this.components = new Map();\n        this.tags = new Set();\n        \n        // Cache flags for commonly checked tags (initialize as undefined)\n        this._isEnemy = undefined;\n        this._isPlayer = undefined;\n        this._isProjectile = undefined;\n        this._isPooled = undefined;\n    }\n    \n    /**\n     * Add a component to this entity\n     * @param {Component} component The component to add\n     * @returns {Entity} This entity for chaining\n     */\n    addComponent(component) {\n        component.entity = this;\n        this.components.set(component.constructor.name, component);\n        \n        // Call onAttached\n        if (component.onAttached) {\n            component.onAttached();\n        }\n        \n        // Notify the world that a component was added\n        if (this.world && this.world.messageBus) {\n            this.world.messageBus.publish('component.added', {\n                entity: this,\n                componentType: component.constructor.name,\n                component: component\n            });\n        }\n        \n        return this;\n    }\n    \n    /**\n     * Remove a component from this entity\n     * @param {Function} componentType The component class to remove\n     * @returns {Entity} This entity for chaining\n     */\n    removeComponent(componentType) {\n        const component = this.getComponent(componentType);\n        if (component) {\n            if (component.onDetached) {\n                component.onDetached();\n            }\n            component.entity = null;\n            \n            // Get the component type name before deleting\n            const componentTypeName = componentType.name;\n            this.components.delete(componentTypeName);\n            \n            // Notify the world that a component was removed\n            if (this.world && this.world.messageBus) {\n                this.world.messageBus.publish('component.removed', {\n                    entity: this,\n                    componentType: componentTypeName,\n                    component: component\n                });\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Get a component of the specified type\n     * @param {Function|string} componentType The component class or name to get\n     * @returns {Component|null} The component or null if not found\n     */\n    getComponent(componentType) {\n        if (typeof componentType === 'string') {\n            return this.components.get(componentType);\n        }\n        return this.components.get(componentType.name);\n    }\n    \n    /**\n     * Check if this entity has a component of the specified type\n     * @param {Function|string} componentType The component class or name to check for\n     * @returns {boolean} True if the entity has the component\n     */\n    hasComponent(componentType) {\n        if (typeof componentType === 'string') {\n            return this.components.has(componentType);\n        }\n        return this.components.has(componentType.name);\n    }\n    \n    /**\n     * Sync internal tag cache with actual tags\n     * @private\n     */\n    _syncTagCache() {\n        // Reset all cached flags to match actual tag state\n        this._isEnemy = this.tags.has('enemy');\n        this._isPlayer = this.tags.has('player');\n        this._isProjectile = this.tags.has('projectile');\n        this._isPooled = this.tags.has('pooled');\n    }\n    \n    /**\n     * Add a tag to this entity\n     * @param {string} tag The tag to add\n     * @returns {Entity} This entity for chaining\n     */\n    addTag(tag) {\n        if (!this.tags.has(tag)) {\n            // Add tag to local Set\n            this.tags.add(tag);\n            \n            // Update cached flags immediately\n            if (tag === 'enemy') this._isEnemy = true;\n            else if (tag === 'player') this._isPlayer = true;\n            else if (tag === 'projectile') this._isProjectile = true;\n            else if (tag === 'pooled') this._isPooled = true;\n            \n            // Update the entity manager's tag index\n            if (this.world && this.world.entityManager) {\n                this.world.entityManager.onTagAdded(this, tag);\n                \n                // Verify tag was added to tag index map\n                if (!this.world.entityManager.entitiesByTag.has(tag) || \n                    !this.world.entityManager.entitiesByTag.get(tag).includes(this)) {\n                    console.error(`Failed to register entity ${this.id} with tag '${tag}' in entity manager!`);\n                    \n                    // Force add entity to tag map as fallback\n                    if (!this.world.entityManager.entitiesByTag.has(tag)) {\n                        this.world.entityManager.entitiesByTag.set(tag, []);\n                    }\n                    this.world.entityManager.entitiesByTag.get(tag).push(this);\n                    console.log(`Manually fixed tag registration for entity ${this.id} with tag '${tag}'`);\n                }\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Remove a tag from this entity\n     * @param {string} tag The tag to remove\n     * @returns {Entity} This entity for chaining\n     */\n    removeTag(tag) {\n        if (this.tags.has(tag)) {\n            // Remove tag from local Set\n            this.tags.delete(tag);\n            \n            // Update cached flags immediately\n            if (tag === 'enemy') this._isEnemy = false;\n            else if (tag === 'player') this._isPlayer = false;\n            else if (tag === 'projectile') this._isProjectile = false;\n            else if (tag === 'pooled') this._isPooled = false;\n            \n            // Update the entity manager's tag index\n            if (this.world && this.world.entityManager) {\n                this.world.entityManager.onTagRemoved(this, tag);\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Clear all tags from this entity\n     * @returns {Entity} This entity for chaining\n     */\n    clearTags() {\n        // Make a copy of the tags to iterate over\n        const allTags = [...this.tags];\n        \n        // Remove each tag properly\n        for (const tag of allTags) {\n            this.removeTag(tag);\n        }\n        \n        // Reset ALL tag caches to ensure consistency\n        this._isEnemy = false;\n        this._isPlayer = false;\n        this._isProjectile = false;\n        this._isPooled = false;\n        \n        // Verify the local Set is empty\n        this.tags.clear();\n        \n        return this;\n    }\n    \n    /**\n     * Check if this entity has the specified tag\n     * @param {string} tag The tag to check for\n     * @returns {boolean} True if the entity has the tag\n     */\n    hasTag(tag) {\n        // Use direct Set lookup instead of potentially stale cached values\n        const hasTag = this.tags.has(tag);\n        \n        // Check for inconsistency between cache and actual tags\n        // This helps detect and fix cache issues\n        let cacheInconsistent = false;\n        \n        if (tag === 'enemy' && this._isEnemy !== hasTag) {\n            console.warn(`Tag cache inconsistency for entity ${this.id}: _isEnemy=${this._isEnemy}, actual=Set{${Array.from(this.tags)}}`);\n            this._isEnemy = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        } \n        else if (tag === 'player' && this._isPlayer !== hasTag) {\n            console.warn(`Tag cache inconsistency for entity ${this.id}: _isPlayer=${this._isPlayer}, actual=Set{${Array.from(this.tags)}}`);\n            this._isPlayer = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        } \n        else if (tag === 'projectile' && this._isProjectile !== hasTag) {\n            console.warn(`Tag cache inconsistency for entity ${this.id}: _isProjectile=${this._isProjectile}, actual=Set{${Array.from(this.tags)}}`);\n            this._isProjectile = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        }\n        else if (tag === 'pooled' && this._isPooled !== hasTag) {\n            console.warn(`Tag cache inconsistency for entity ${this.id}: _isPooled=${this._isPooled}, actual=Set{${Array.from(this.tags)}}`);\n            this._isPooled = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        }\n        \n        // If we detected an inconsistency, sync the entire cache\n        if (cacheInconsistent) {\n            this._syncTagCache();\n        }\n        \n        return hasTag;\n    }\n}","/**\n * EntityManager - Manages entity creation, tracking and destruction\n * \n * Handles entity lifecycle and provides methods to query entities\n * based on components or tags.\n */\n\nimport { Entity } from './entity.js';\n\nexport class EntityManager {\n    constructor(world) {\n        this.world = world;\n        this.entities = new Map();\n        // Use WeakMap for entity tracking to allow garbage collection\n        this.entitiesByComponent = new Map();\n        this.entitiesByTag = new Map();\n        this.lastEntityId = 0;\n        \n        // Entity recycle pool for faster instantiation\n        this.recycledEntities = [];\n        this.maxRecycledEntities = 100;\n    }\n    \n    /**\n     * Create a new entity\n     * @param {string} name Optional name for the entity\n     * @returns {Entity} The created entity\n     */\n    createEntity(name = '') {\n        // Try to reuse a recycled entity first\n        let entity;\n        \n        if (this.recycledEntities.length > 0) {\n            entity = this.recycledEntities.pop();\n            entity.components.clear();\n            entity.tags.clear();\n            entity._isEnemy = undefined;\n            entity._isPlayer = undefined;\n            entity._isProjectile = undefined;\n        } else {\n            const id = this._generateEntityId();\n            entity = new Entity(id, this.world);\n        }\n        \n        // Add to entities map first\n        this.entities.set(entity.id.toString(), entity);\n        \n        // Add name as tag using the fixed addTag method which will register with entityManager\n        if (name) {\n            entity.addTag(name);\n        }\n        \n        // Notify systems that an entity was created\n        this.world.messageBus.publish('entity.created', { entity });\n        \n        return entity;\n    }\n    \n    /**\n     * Destroy an entity and remove all its components\n     * @param {Entity|string} entityOrId The entity or entity ID to destroy\n     */\n    destroyEntity(entityOrId) {\n        const id = typeof entityOrId === 'string' ? entityOrId : entityOrId.id;\n        const entity = this.entities.get(id.toString());\n        \n        if (!entity) return;\n        \n        // Notify systems that this entity will be destroyed\n        this.world.messageBus.publish('entity.destroyed', { entity });\n        \n        // Remove from tag maps\n        entity.tags.forEach(tag => {\n            if (this.entitiesByTag.has(tag)) {\n                const entities = this.entitiesByTag.get(tag);\n                const index = entities.indexOf(entity);\n                if (index !== -1) {\n                    entities.splice(index, 1);\n                }\n                \n                if (entities.length === 0) {\n                    this.entitiesByTag.delete(tag);\n                }\n            }\n        });\n        \n        // Remove all components\n        for (const [componentType, component] of entity.components.entries()) {\n            entity.removeComponent(component.constructor);\n        }\n        \n        // Remove from entities map\n        this.entities.delete(id.toString());\n        \n        // Add to recycled entities pool if not full\n        if (this.recycledEntities.length < this.maxRecycledEntities) {\n            this.recycledEntities.push(entity);\n        }\n    }\n    \n    /**\n     * Get an entity by ID\n     * @param {string} id The entity ID\n     * @returns {Entity|undefined} The entity or undefined if not found\n     */\n    getEntity(id) {\n        return this.entities.get(id.toString());\n    }\n    \n    /**\n     * Get all entities with the specified tag\n     * @param {string} tag The tag to filter by\n     * @returns {Entity[]} Array of entities with the tag\n     */\n    getEntitiesByTag(tag) {\n        return this.entitiesByTag.get(tag) || [];\n    }\n    \n    /**\n     * Get all entities that have all the specified components\n     * @param {Function[]} componentTypes Array of component types\n     * @returns {Entity[]} Array of entities with all components\n     */\n    getEntitiesWithComponents(componentTypes) {\n        if (!componentTypes || componentTypes.length === 0) {\n            return Array.from(this.entities.values());\n        }\n        \n        return Array.from(this.entities.values()).filter(entity => {\n            return componentTypes.every(type => entity.hasComponent(type));\n        });\n    }\n    \n    /**\n     * Get all entities in the manager\n     * @returns {Entity[]} Array of all entities\n     */\n    getEntities() {\n        return Array.from(this.entities.values());\n    }\n    \n    /**\n     * Update entity tag index when a tag is added\n     * @param {Entity} entity The entity\n     * @param {string} tag The tag\n     */\n    onTagAdded(entity, tag) {\n        if (!this.entitiesByTag.has(tag)) {\n            this.entitiesByTag.set(tag, []);\n        }\n        \n        this.entitiesByTag.get(tag).push(entity);\n    }\n    \n    /**\n     * Update entity tag index when a tag is removed\n     * @param {Entity} entity The entity\n     * @param {string} tag The tag\n     */\n    onTagRemoved(entity, tag) {\n        if (this.entitiesByTag.has(tag)) {\n            const entities = this.entitiesByTag.get(tag);\n            const index = entities.indexOf(entity);\n            \n            if (index !== -1) {\n                entities.splice(index, 1);\n            }\n            \n            if (entities.length === 0) {\n                this.entitiesByTag.delete(tag);\n            }\n        }\n    }\n    \n    /**\n     * Generate a unique entity ID\n     * @returns {string} A unique entity ID\n     * @private\n     */\n    _generateEntityId() {\n        return (++this.lastEntityId).toString();\n    }\n}","/**\n * SystemManager - Manages the registration and execution of systems\n * \n * Handles system priority, updates, and lifecycle.\n */\n\nexport class SystemManager {\n    constructor(world) {\n        this.world = world;\n        this.systems = [];\n        this.systemsByType = new Map();\n    }\n    \n    /**\n     * Register a system with the manager\n     * @param {System} system The system to register\n     * @returns {System} The registered system\n     */\n    registerSystem(system) {\n        if (this.systemsByType.has(system.constructor.name)) {\n            console.warn(`System of type ${system.constructor.name} already registered`);\n            return system;\n        }\n        \n        this.systems.push(system);\n        this.systemsByType.set(system.constructor.name, system);\n        \n        // Sort systems by priority (lower = earlier)\n        this.systems.sort((a, b) => a.priority - b.priority);\n        \n        return system;\n    }\n    \n    /**\n     * Get a system by type\n     * @param {Function} systemType The system class type\n     * @returns {System|undefined} The system instance or undefined if not found\n     */\n    getSystem(systemType) {\n        return this.systemsByType.get(systemType.name);\n    }\n    \n    /**\n     * Update all enabled systems\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        for (const system of this.systems) {\n            if (system.enabled) {\n                system.update(deltaTime);\n            }\n        }\n    }\n    \n    /**\n     * Initialize all systems\n     * Called once before the first update\n     */\n    initialize() {\n        for (const system of this.systems) {\n            if (typeof system.initialize === 'function') {\n                system.initialize();\n            }\n        }\n    }\n    \n    /**\n     * Enable a system by type\n     * @param {Function} systemType The system class type\n     */\n    enableSystem(systemType) {\n        const system = this.getSystem(systemType);\n        if (system) {\n            system.enable();\n        }\n    }\n    \n    /**\n     * Disable a system by type\n     * @param {Function} systemType The system class type\n     */\n    disableSystem(systemType) {\n        const system = this.getSystem(systemType);\n        if (system) {\n            system.disable();\n        }\n    }\n}","/**\n * MessageBus - Event system for decoupled communication between systems\n * \n * The MessageBus enables systems to communicate without direct references\n * by publishing and subscribing to specific message types.\n */\n\nexport class MessageBus {\n    constructor() {\n        this.listeners = new Map();\n        this.queuedMessages = [];\n        this.dispatching = false;\n        \n        // High-frequency message types to minimize logging\n        this.highFrequencyTypes = new Set([\n            'transform.updated',\n            'physics.update',\n            'render.update'\n        ]);\n        \n        // Store this instance in a global registry for emergency access\n        if (!window.messageRegistry) {\n            window.messageRegistry = new Set();\n        }\n        window.messageRegistry.add(this);\n        \n        // Always ensure that mainMessageBus is set - critically important for game over events\n        if (!window.mainMessageBus) {\n            window.mainMessageBus = this;\n            console.log(\"MessageBus: Set this instance as window.mainMessageBus\");\n        } else if (window.mainMessageBus !== this) {\n            // If this is not the main message bus, make sure game.over events are \n            // forwarded to the main message bus for centralized handling\n            console.log(\"MessageBus: This instance will forward game.over events to window.mainMessageBus\");\n        }\n        \n        console.log(\"MessageBus: New instance created and added to registry\");\n    }\n    \n    /**\n     * Register a listener for a message type\n     * @param {string} messageType The message type to listen for\n     * @param {Function} callback Function to call when message is published\n     * @param {Object} context Context to use when calling the callback\n     * @returns {Function} Unsubscribe function\n     */\n    subscribe(messageType, callback, context = null) {\n        if (!this.listeners.has(messageType)) {\n            this.listeners.set(messageType, []);\n        }\n        \n        this.listeners.get(messageType).push({\n            callback,\n            context\n        });\n        \n        // Return unsubscribe function for convenience\n        return () => this.unsubscribe(messageType, callback, context);\n    }\n    \n    /**\n     * Remove a listener\n     * @param {string} messageType The message type to unsubscribe from\n     * @param {Function} callback The callback to remove\n     * @param {Object} context The context used when subscribing\n     */\n    unsubscribe(messageType, callback, context = null) {\n        if (!this.listeners.has(messageType)) return;\n        \n        const listeners = this.listeners.get(messageType);\n        const index = listeners.findIndex(listener => \n            listener.callback === callback && listener.context === context);\n            \n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n        \n        if (listeners.length === 0) {\n            this.listeners.delete(messageType);\n        }\n    }\n    \n    /**\n     * Fast publish for high-frequency events with minimal overhead\n     * @param {string} messageType The message type to publish\n     * @param {Object} data Data to include with the message\n     */\n    fastPublish(messageType, data = {}) {\n        if (!this.listeners.has(messageType)) return;\n        \n        const listeners = this.listeners.get(messageType);\n        const messageObj = {\n            type: messageType,\n            data: data,\n            timestamp: Date.now()\n        };\n        \n        for (let i = 0; i < listeners.length; i++) {\n            const listener = listeners[i];\n            listener.callback.call(listener.context, messageObj);\n        }\n    }\n    \n    /**\n     * Send a message immediately\n     * @param {string} messageType The message type to publish\n     * @param {Object} data Data to include with the message\n     */\n    publish(messageType, data = {}) {\n        // Use fast path for high-frequency messages\n        if (this.highFrequencyTypes.has(messageType)) {\n            return this.fastPublish(messageType, data);\n        }\n        \n        // Debug logging for critical messages\n        const criticalMessages = ['entity.created', 'entity.destroyed', 'component.added', 'component.removed', 'game.over'];\n        if (criticalMessages.includes(messageType)) {\n            console.log(`MessageBus: Publishing ${messageType}`, data);\n        }\n        \n        // Enhanced handling for game.over events to ensure they are properly processed\n        if (messageType === 'game.over') {\n            // Always forward game.over events to the main message bus if this isn't it\n            if (window.mainMessageBus && window.mainMessageBus !== this) {\n                console.log(`MessageBus: Forwarding game.over event to window.mainMessageBus`);\n                window.mainMessageBus.publish(messageType, data);\n                return; // Let the main message bus handle it\n            }\n            \n            // Only proceed if we have listeners or we are the main message bus\n            if (!this.listeners.has(messageType)) {\n                console.error(`MessageBus: No listeners found for '${messageType}' event!`);\n                console.log(`MessageBus: Registered event types:`, Array.from(this.listeners.keys()));\n                \n                // Log where subscribers should be\n                console.trace(\"MessageBus: This is where the game.over event was published from\");\n                \n                // Verify main game instance\n                if (window.game) {\n                    console.log(\"MessageBus: window.game exists:\", window.game);\n                    console.log(\"MessageBus: window.game.messageBus exists:\", window.game.messageBus);\n                    \n                    // Try to directly call gameOver as a last resort\n                    console.log(\"MessageBus: Directly calling window.game.gameOver as an emergency measure\");\n                    window.game.gameOver(data.reason || \"Unknown reason\");\n                } else {\n                    console.error(\"MessageBus: window.game does not exist - critical issue\");\n                }\n                \n                return;\n            } else {\n                const listeners = this.listeners.get(messageType);\n                console.log(`MessageBus: Found ${listeners.length} listeners for '${messageType}' event`);\n            }\n        }\n        \n        if (!this.listeners.has(messageType)) return;\n        \n        // If we're already dispatching, queue this message\n        if (this.dispatching) {\n            console.log(`MessageBus: Already dispatching, queueing ${messageType} message`);\n            this.queuedMessages.push({ type: messageType, data });\n            return;\n        }\n        \n        try {\n            // Set flag to prevent nested dispatch issues\n            this.dispatching = true;\n            \n            const listeners = this.listeners.get(messageType);\n            listeners.forEach((listener, index) => {\n                try {\n                    if (messageType === 'game.over') {\n                        console.log(`MessageBus: Calling listener #${index + 1} for game.over event`);\n                    }\n                    \n                    listener.callback.call(listener.context, {\n                        type: messageType,\n                        data: data,\n                        timestamp: Date.now()\n                    });\n                    \n                    if (messageType === 'game.over') {\n                        console.log(`MessageBus: Listener #${index + 1} for game.over event completed successfully`);\n                    }\n                } catch (error) {\n                    console.error(`Error in message listener #${index + 1} (${messageType}):`, error);\n                    console.error(\"Error stack:\", error.stack);\n                }\n            });\n        } finally {\n            // Always clear the dispatching flag, even if an error occurs\n            this.dispatching = false;\n            \n            // Process any queued messages\n            if (this.queuedMessages.length > 0) {\n                const queuedMessages = [...this.queuedMessages];\n                this.queuedMessages = [];\n                \n                queuedMessages.forEach(message => {\n                    this.publish(message.type, message.data);\n                });\n            }\n        }\n    }\n    \n    /**\n     * Queue a message for next update\n     * @param {string} messageType The message type to queue\n     * @param {Object} data Data to include with the message\n     */\n    queue(messageType, data = {}) {\n        this.queuedMessages.push({\n            type: messageType,\n            data: data\n        });\n    }\n    \n    /**\n     * Universal handler for game over events - used by multiple components\n     * @param {string} reason Reason for game over\n     * @param {string} source Source of the game over event\n     */\n    static triggerGameOver(reason, source) {\n        console.log(\"MessageBus.triggerGameOver called:\", reason, \"from\", source);\n        \n        // Try to find a message bus to use - prioritization order for reliability\n        let messageBusToUse = null;\n        \n        // Use window.mainMessageBus if available (highest priority)\n        if (window.mainMessageBus) {\n            console.log(\"MessageBus: Using window.mainMessageBus for game over\");\n            messageBusToUse = window.mainMessageBus;\n        }\n        // Use window.game.messageBus if available and mainMessageBus not found\n        else if (window.game && window.game.messageBus) {\n            console.log(\"MessageBus: Using window.game.messageBus for game over\");\n            messageBusToUse = window.game.messageBus;\n        } \n        \n        // Check if we found a message bus to use\n        if (messageBusToUse) {\n            console.log(\"MessageBus: Publishing game.over event\");\n            \n            // Log the listeners to verify game.over handler is registered\n            if (messageBusToUse.listeners.has('game.over')) {\n                const listeners = messageBusToUse.listeners.get('game.over');\n                console.log(`MessageBus: Found ${listeners.length} game.over listeners`);\n            } else {\n                console.warn(\"MessageBus: No game.over listeners found before publishing\");\n            }\n            \n            // Publish the event\n            messageBusToUse.publish('game.over', {\n                reason: reason,\n                source: source\n            });\n        } else {\n            console.error(\"MessageBus: No message bus instance found for game over!\");\n        }\n    }\n}","/**\n * World - Main container class for the ECS architecture\n * \n * The World manages the entire ECS setup, including entities,\n * components, systems, and messaging.\n */\n\nimport { EntityManager } from './entityManager.js';\nimport { SystemManager } from './systemManager.js';\nimport { MessageBus } from './messageBus.js';\n\nexport class World {\n    constructor(messageBus = null) {\n        // Use provided message bus or create a new one\n        // This allows sharing the message bus between World and Game\n        this.messageBus = messageBus || new MessageBus();\n        \n        // If we created a new message bus, make it accessible globally\n        if (!messageBus && !window.mainMessageBus) {\n            window.mainMessageBus = this.messageBus;\n            console.log(\"World: Set this.messageBus as window.mainMessageBus\");\n        }\n        \n        // Create managers\n        this.entityManager = new EntityManager(this);\n        this.systemManager = new SystemManager(this);\n        \n        // Time tracking\n        this.deltaTime = 0;\n        this.time = 0;\n        this.lastUpdateTime = 0;\n    }\n    \n    /**\n     * Initialize the world and all systems\n     */\n    initialize() {\n        this.lastUpdateTime = performance.now();\n        this.systemManager.initialize();\n        this.messageBus.publish('world.initialized', {});\n    }\n    \n    /**\n     * Update all systems\n     */\n    update() {\n        // Calculate delta time\n        const now = performance.now();\n        this.deltaTime = Math.min((now - this.lastUpdateTime) / 1000, 0.1); // Cap at 100ms\n        this.lastUpdateTime = now;\n        this.time += this.deltaTime;\n        \n        // Publish pre-update message\n        this.messageBus.publish('world.preUpdate', { deltaTime: this.deltaTime, time: this.time });\n        \n        // Update all systems\n        this.systemManager.update(this.deltaTime);\n        \n        // Publish post-update message\n        this.messageBus.publish('world.postUpdate', { deltaTime: this.deltaTime, time: this.time });\n        \n        // For debugging - log active entities in dev console\n        if (window.DEBUG_MODE && this.time % 5 < this.deltaTime) {\n            // Get all entities from entity manager using values from the map\n            const entities = Array.from(this.entityManager.entities.values());\n            console.log(`World update - ${entities.length} entities active`);\n            const entitiesWithMesh = this.getEntitiesWithComponents(['MeshComponent']);\n            console.log(`Entities with mesh: ${entitiesWithMesh.length}`);\n        }\n    }\n    \n    /**\n     * Create a new entity\n     * @param {string} name Optional name for the entity\n     * @returns {Entity} The created entity\n     */\n    createEntity(name = '') {\n        return this.entityManager.createEntity(name);\n    }\n    \n    /**\n     * Destroy an entity\n     * @param {Entity|string} entityOrId The entity or entity ID to destroy\n     */\n    destroyEntity(entityOrId) {\n        this.entityManager.destroyEntity(entityOrId);\n    }\n    \n    /**\n     * Register a system\n     * @param {System} system The system to register\n     * @returns {System} The registered system\n     */\n    registerSystem(system) {\n        return this.systemManager.registerSystem(system);\n    }\n    \n    /**\n     * Get entities with specific components\n     * @param {Function[]} componentTypes Array of component types\n     * @returns {Entity[]} Array of entities with all components\n     */\n    getEntitiesWithComponents(componentTypes) {\n        return this.entityManager.getEntitiesWithComponents(componentTypes);\n    }\n    \n    /**\n     * Get entities with a specific tag\n     * @param {string} tag The tag to filter by\n     * @returns {Entity[]} Array of entities with the tag\n     */\n    getEntitiesByTag(tag) {\n        return this.entityManager.getEntitiesByTag(tag);\n    }\n    \n    /**\n     * Get a specific entity by ID\n     * @param {string} id The entity ID\n     * @returns {Entity|undefined} The entity or undefined if not found\n     */\n    getEntity(id) {\n        return this.entityManager.getEntity(id);\n    }\n    \n    /**\n     * Get a system by type\n     * @param {Function} systemType The system class type\n     * @returns {System|undefined} The system instance or undefined if not found\n     */\n    getSystem(systemType) {\n        return this.systemManager.getSystem(systemType);\n    }\n}","/**\n * System Base Class - Base class for all ECS systems\n * \n * Systems operate on entities that have specific components.\n * They contain the logic that processes entity data.\n */\n\nexport class System {\n    constructor(world) {\n        this.world = world;\n        this.enabled = true;\n        this.requiredComponents = []; // Component types required for processing\n        this.priority = 0; // Execution order (lower = earlier)\n    }\n    \n    /**\n     * Check if entity has all required components for this system\n     * @param {Entity} entity The entity to check\n     * @returns {boolean} True if entity can be processed by this system\n     */\n    checkEntity(entity) {\n        return this.requiredComponents.every(componentType => \n            entity.hasComponent(componentType));\n    }\n    \n    /**\n     * Get all entities that match this system's requirements\n     * @returns {Entity[]} Array of compatible entities\n     */\n    getEntities() {\n        return this.world.getEntitiesWithComponents(this.requiredComponents);\n    }\n    \n    /**\n     * Update method called each frame\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime) {\n        if (!this.enabled) return;\n        \n        const entities = this.getEntities();\n        entities.forEach(entity => {\n            this.processEntity(entity, deltaTime);\n        });\n    }\n    \n    /**\n     * Process a single entity\n     * @param {Entity} entity The entity to process\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    processEntity(entity, deltaTime) {\n        // Override in derived systems\n    }\n    \n    /**\n     * Initialize the system\n     * Called once when the system is first registered\n     */\n    initialize() {\n        // Base implementation does nothing\n        // Override in derived systems for initialization logic\n    }\n    \n    /**\n     * Enable this system\n     */\n    enable() {\n        this.enabled = true;\n    }\n    \n    /**\n     * Disable this system\n     */\n    disable() {\n        this.enabled = false;\n    }\n}"],"names":["Entity","id","world","component","componentType","componentTypeName","tag","allTags","hasTag","cacheInconsistent","EntityManager","name","entity","entityOrId","entities","index","componentTypes","type","SystemManager","system","a","b","systemType","deltaTime","MessageBus","messageType","callback","context","listeners","listener","data","messageObj","i","error","queuedMessages","message","reason","source","messageBusToUse","World","messageBus","now","entitiesWithMesh","System"],"mappings":"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"}