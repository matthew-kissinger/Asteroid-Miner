{"version":3,"file":"InstancedRenderer-6YWyCoVq.js","sources":["../../js/systems/rendering/InstancedRenderer.js"],"sourcesContent":["// InstancedRenderer.js - ECS-driven instanced rendering per cell × archetype\r\n\r\nimport * as THREE from 'three';\r\nimport { System } from '../../core/system.js';\r\n\r\nexport class InstancedRenderer extends System {\r\n  constructor(world, scene) {\r\n    super(world);\r\n    this.requiredComponents = ['TransformComponent'];\r\n    this.priority = 95; // run before standard RenderSystem (which is 100)\r\n    this.scene = scene;\r\n    this.cellSize = world && world.spatial ? world.spatial.cellSize : 400;\r\n\r\n    // cellKey|archetype -> { mesh, count, max, freeIds, dummy }\r\n    this.cellMeshes = new Map();\r\n    // entityId -> { key, index }\r\n    this.entityToInstance = new Map();\r\n  }\r\n\r\n  initialize() {\r\n    // Nothing on init; will allocate lazily\r\n  }\r\n\r\n  getArchetype(entity) {\r\n    if (entity.hasTag && entity.hasTag('enemy')) return 'enemy_drone';\r\n    return null; // others not yet handled\r\n  }\r\n\r\n  getCellKeyFromPosition(pos) {\r\n    const ix = Math.floor(pos.x / this.cellSize) | 0;\r\n    const iy = Math.floor(pos.y / this.cellSize) | 0;\r\n    const iz = Math.floor(pos.z / this.cellSize) | 0;\r\n    return `${ix}|${iy}|${iz}`;\r\n  }\r\n\r\n  ensureCellMesh(cellKey, archetype, sampleMesh) {\r\n    const key = `${cellKey}|${archetype}`;\r\n    let rec = this.cellMeshes.get(key);\r\n    if (rec) return rec;\r\n    // Derive geometry/material from sample mesh or simple placeholder\r\n    let geom, mat;\r\n    if (sampleMesh && sampleMesh.geometry && sampleMesh.material) {\r\n      geom = sampleMesh.geometry;\r\n      mat = sampleMesh.material;\r\n    } else {\r\n      geom = new THREE.SphereGeometry(2, 8, 8);\r\n      mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });\r\n    }\r\n    const max = 2048; // capacity per cell × archetype\r\n    const inst = new THREE.InstancedMesh(geom, mat, max);\r\n    inst.count = 0;\r\n    inst.frustumCulled = true;\r\n    this.scene.add(inst);\r\n    rec = { mesh: inst, count: 0, max, freeIds: [], dummy: new THREE.Object3D() };\r\n    this.cellMeshes.set(key, rec);\r\n    return rec;\r\n  }\r\n\r\n  allocateInstance(rec) {\r\n    if (rec.freeIds.length > 0) return rec.freeIds.pop();\r\n    if (rec.count >= rec.max) return -1;\r\n    const id = rec.count;\r\n    rec.count++;\r\n    rec.mesh.count = rec.count;\r\n    return id;\r\n  }\r\n\r\n  releaseInstance(rec, index) {\r\n    if (index < 0) return;\r\n    rec.freeIds.push(index);\r\n  }\r\n\r\n  update(deltaTime) {\r\n    const world = this.world;\r\n    if (!world || !world.entityManager) return;\r\n    const entities = world.getEntitiesWithComponents(['TransformComponent', 'MeshComponent']);\r\n\r\n    // Per-frame: hide original meshes for handled archetypes\r\n    for (const entity of entities) {\r\n      const archetype = this.getArchetype(entity);\r\n      if (!archetype) continue;\r\n      const meshComp = entity.getComponent('MeshComponent');\r\n      if (meshComp && meshComp.mesh) meshComp.mesh.visible = false;\r\n      const t = entity.getComponent('TransformComponent');\r\n      const cellKey = this.getCellKeyFromPosition(t.position);\r\n      const key = `${cellKey}|${archetype}`;\r\n      let mapEntry = this.entityToInstance.get(entity.id);\r\n      let rec = this.cellMeshes.get(key);\r\n\r\n      // If entity moved cell or not allocated, (re)allocate\r\n      if (!mapEntry || mapEntry.key !== key) {\r\n        // free previous\r\n        if (mapEntry) {\r\n          const prev = this.cellMeshes.get(mapEntry.key);\r\n          if (prev) this.releaseInstance(prev, mapEntry.index);\r\n        }\r\n        // ensure mesh\r\n        rec = this.ensureCellMesh(cellKey, archetype, meshComp ? meshComp.mesh : null);\r\n        const idx = this.allocateInstance(rec);\r\n        if (idx === -1) continue; // capacity reached\r\n        mapEntry = { key, index: idx };\r\n        this.entityToInstance.set(entity.id, mapEntry);\r\n      }\r\n\r\n      if (!rec) rec = this.cellMeshes.get(key);\r\n      if (!rec) continue;\r\n\r\n      // Update instance matrix\r\n      rec.dummy.position.copy(t.position);\r\n      rec.dummy.quaternion.copy(t.quaternion);\r\n      rec.dummy.scale.set(1, 1, 1);\r\n      rec.dummy.updateMatrix();\r\n      rec.mesh.setMatrixAt(mapEntry.index, rec.dummy.matrix);\r\n      rec.mesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    // TODO: CPU frustum cull by toggling entire cell meshes via bounding boxes\r\n    // and picking instanceId → entityId mapping if needed in future gates.\r\n  }\r\n}\r\n\r\n\r\n"],"names":["THREE.SphereGeometry","THREE.MeshBasicMaterial","THREE.InstancedMesh","THREE.Object3D"],"mappings":"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"}