{"version":3,"mappings":"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","names":["Entity","id","world","__publicField","component","componentType","componentTypeName","typeName","tag","allTags","hasTag","cacheInconsistent","EntityManager","name","entity","entityOrId","entities","index","_","componentTypes","type","SystemManager","system","systemType","a","b","deltaTime","t0","t1","SpatialHash","cellSize","ix","iy","iz","v","min","max","ix0","iy0","iz0","ix1","iy1","iz1","keys","entityId","position","radius","k","set","center","result","EntityIndex","view","World","messageBus","MessageBus","now","DEBUG_MODE","WorldSetup","scene","spaceship","OptimizedProjectileStore","__vitePreload","e","error","existingEntity","transform","playerEntity","TransformComponent","THREE.Vector3","THREE.Euler","THREE.Quaternion","HealthComponent","health","shield","SystemRegistrar","systemName","enabled","path","className","EventManager","sub1","data","sub2","points","damage","shieldDamage","sub","ExplosionEffects","duration","_isVisible","poolManager","addToScene","explosion","geometry","THREE.SphereGeometry","material","THREE.MeshBasicMaterial","THREE.AdditiveBlending","emissiveMaterial","THREE.Mesh","startTime","animate","progress","expansionScale","startPos","endPos","isHit","fadeTime","distance","beamGroup","THREE.Group","coreGeometry","THREE.CylinderGeometry","coreMaterial","coreMesh","innerGlowGeometry","innerGlowMaterial","innerGlowMesh","outerGlowGeometry","outerGlowMaterial","outerGlowMesh","midpoint","direction","quaternion","_deltaTime","removeFromScene","currentTime","tracersToRemove","i","userData","elapsed","fadeProgress","dissolveDistance","newStartOffset","newStartPos","newLength","newMidpoint","opacityFactor","MaterialManager","THREE.MeshStandardMaterial","THREE.DoubleSide","THREE.LineBasicMaterial","THREE.PointsMaterial","dummyGeometry","THREE.BoxGeometry","sphereGeometry","cylinderGeometry","pointsPositions","pointsGeometry","THREE.BufferGeometry","THREE.BufferAttribute","dummyProjectile","dummyGlow","dummyTrail","dummyFlash","dummyTracer","THREE.Line","dummyExplosion","THREE.Points","dummyTrailContainer","THREE.Object3D","trailParticle","tempScene","THREE.Scene","THREE.Matrix4","child","renderer","object","GeometryManager","game","numPoints","size","THREE.Float32BufferAttribute","materialManager","geom","ProjectileEffects","muzzleFlash","lookAtPosition","flashLight","projectile","trailContainer","trailParticles","ratio","trailGeometries","_a","geometryIndex","particle","offset","animateTrail","currentScale","startPosition","tracer","endPosition","positions","EffectsManager","isVisible","AISpawnerManager","enemySystem","enemyId","CombatLogic","effectsManager","eventManager","aiSpawnerManager","THREE.Raycaster","_playerEntity","lastFireTime","cooldown","hitObjects","obj","intersects","hitEntityId","hit","Combat","systems","introActive","isFiring"],"ignoreList":[],"sources":["../../js/core/entity.ts","../../js/core/entityManager.ts","../../js/core/systemManager.ts","../../js/core/spatial/SpatialHash.ts","../../js/core/EntityIndex.ts","../../js/core/world.ts","../../js/modules/combat/worldSetup.ts","../../js/modules/combat/registerSystems.ts","../../js/modules/combat/events.ts","../../js/modules/combat/effects/explosionEffects.ts","../../js/modules/combat/effects/materialManager.ts","../../js/modules/combat/effects/geometryManager.ts","../../js/modules/combat/effects/projectileEffects.ts","../../js/modules/combat/effects.ts","../../js/modules/combat/aiAndSpawners.ts","../../js/modules/combat/combatLogic.ts","../../js/modules/combat.ts"],"sourcesContent":["import type { World } from './world.js';\nimport { Component } from './component.js';\n\n/**\n * Entity Class - Base entity class for ECS architecture\n * \n * The core building block of the Entity-Component-System pattern.\n * Each entity is essentially just an ID with a collection of components\n * that define its behavior and properties.\n */\nexport class Entity {\n    public id: string;\n    public world: World;\n    public components: Map<string, Component>;\n    public tags: Set<string>;\n    \n    // Cache flags for commonly checked tags\n    private _isEnemy: boolean | undefined = undefined;\n    private _isPlayer: boolean | undefined = undefined;\n    private _isProjectile: boolean | undefined = undefined;\n    private _isPooled: boolean | undefined = undefined;\n\n    // Optional properties used by some systems\n    public collisionRadius?: number;\n\n    constructor(id: string, world: World) {\n        this.id = id;\n        this.world = world;\n        this.components = new Map();\n        this.tags = new Set();\n        \n        // Cache flags for commonly checked tags (initialize as undefined)\n        this._isEnemy = undefined;\n        this._isPlayer = undefined;\n        this._isProjectile = undefined;\n        this._isPooled = undefined;\n    }\n    \n    /**\n     * Add a component to this entity\n     * @param {Component} component The component to add\n     * @returns {Entity} This entity for chaining\n     */\n    addComponent(component: Component): this {\n        component.entity = this;\n        const componentType = component.type || component.constructor.name;\n        this.components.set(componentType, component);\n\n        // Call onAttached\n        if (component.onAttached) {\n            component.onAttached();\n        }\n\n        // Notify the world that a component was added\n        if (this.world && this.world.messageBus) {\n            this.world.messageBus.publish('component.added', {\n                entity: this,\n                componentType: componentType,\n                component: component\n            });\n        }\n\n        return this;\n    }\n    \n    /**\n     * Remove a component from this entity\n     * @param {any} componentType The component class or name to remove\n     * @returns {Entity} This entity for chaining\n     */\n    removeComponent(componentType: any): this {\n        const component = this.getComponent(componentType);\n        if (component) {\n            if (component.onDetached) {\n                component.onDetached();\n            }\n            component.entity = null;\n\n            // Get the component type name - handle both string and class inputs\n            let componentTypeName: string;\n            if (typeof componentType === 'string') {\n                componentTypeName = componentType;\n            } else if (componentType.type) {\n                componentTypeName = componentType.type;\n            } else {\n                componentTypeName = componentType.name;\n            }\n            this.components.delete(componentTypeName);\n\n            // Notify the world that a component was removed\n            if (this.world && this.world.messageBus) {\n                this.world.messageBus.publish('component.removed', {\n                    entity: this,\n                    componentType: componentTypeName,\n                    component: component\n                });\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Get a component of the specified type\n     * @param {any} componentType The component class or name to get\n     * @returns {any} The component or null if not found\n     */\n    getComponent<T extends Component>(componentType: any): T | null {\n        if (typeof componentType === 'string') {\n            return (this.components.get(componentType) as T) || null;\n        }\n        const typeName = componentType.type || componentType.name;\n        return (this.components.get(typeName) as T) || null;\n    }\n    \n    /**\n     * Check if this entity has a component of the specified type\n     * @param {any} componentType The component class or name to check for\n     * @returns {boolean} True if the entity has the component\n     */\n    hasComponent(componentType: any): boolean {\n        if (typeof componentType === 'string') {\n            return this.components.has(componentType);\n        }\n        const typeName = componentType.type || componentType.name;\n        return this.components.has(typeName);\n    }\n    \n    /**\n     * Sync internal tag cache with actual tags\n     * @private\n     */\n    private _syncTagCache(): void {\n        // Reset all cached flags to match actual tag state\n        this._isEnemy = this.tags.has('enemy');\n        this._isPlayer = this.tags.has('player');\n        this._isProjectile = this.tags.has('projectile');\n        this._isPooled = this.tags.has('pooled');\n    }\n    \n    /**\n     * Add a tag to this entity\n     * @param {string} tag The tag to add\n     * @returns {Entity} This entity for chaining\n     */\n    addTag(tag: string): this {\n        if (!this.tags.has(tag)) {\n            // Add tag to local Set\n            this.tags.add(tag);\n            \n            // Update cached flags immediately\n            if (tag === 'enemy') this._isEnemy = true;\n            else if (tag === 'player') this._isPlayer = true;\n            else if (tag === 'projectile') this._isProjectile = true;\n            else if (tag === 'pooled') this._isPooled = true;\n            \n            // Update the entity manager's tag index\n            if (this.world && this.world.entityManager) {\n                this.world.entityManager.onTagAdded(this, tag);\n                \n                // Verify tag was added to tag index map\n                if (!this.world.entityManager.entitiesByTag.has(tag) || \n                    !this.world.entityManager.entitiesByTag.get(tag)!.includes(this)) {\n                    // Force add entity to tag map as fallback\n                    if (!this.world.entityManager.entitiesByTag.has(tag)) {\n                        this.world.entityManager.entitiesByTag.set(tag, []);\n                    }\n                    this.world.entityManager.entitiesByTag.get(tag)!.push(this);\n                }\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Remove a tag from this entity\n     * @param {string} tag The tag to remove\n     * @returns {Entity} This entity for chaining\n     */\n    removeTag(tag: string): this {\n        if (this.tags.has(tag)) {\n            // Remove tag from local Set\n            this.tags.delete(tag);\n            \n            // Update cached flags immediately\n            if (tag === 'enemy') this._isEnemy = false;\n            else if (tag === 'player') this._isPlayer = false;\n            else if (tag === 'projectile') this._isProjectile = false;\n            else if (tag === 'pooled') this._isPooled = false;\n            \n            // Update the entity manager's tag index\n            if (this.world && this.world.entityManager) {\n                this.world.entityManager.onTagRemoved(this, tag);\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Clear all tags from this entity\n     * @returns {Entity} This entity for chaining\n     */\n    clearTags(): this {\n        // Make a copy of the tags to iterate over\n        const allTags = [...this.tags];\n        \n        // Remove each tag properly\n        for (const tag of allTags) {\n            this.removeTag(tag);\n        }\n        \n        // Reset ALL tag caches to ensure consistency\n        this._isEnemy = false;\n        this._isPlayer = false;\n        this._isProjectile = false;\n        this._isPooled = false;\n        \n        // Verify the local Set is empty\n        this.tags.clear();\n        \n        return this;\n    }\n    \n    /**\n     * Check if this entity has the specified tag\n     * @param {string} tag The tag to check for\n     * @returns {boolean} True if the entity has the tag\n     */\n    hasTag(tag: string): boolean {\n        // Use direct Set lookup instead of potentially stale cached values\n        const hasTag = this.tags.has(tag);\n        \n        // Check for inconsistency between cache and actual tags\n        // This helps detect and fix cache issues\n        let cacheInconsistent = false;\n        \n        if (tag === 'enemy' && this._isEnemy !== hasTag) {\n            this._isEnemy = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        } \n        else if (tag === 'player' && this._isPlayer !== hasTag) {\n            this._isPlayer = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        } \n        else if (tag === 'projectile' && this._isProjectile !== hasTag) {\n            this._isProjectile = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        }\n        else if (tag === 'pooled' && this._isPooled !== hasTag) {\n            this._isPooled = hasTag; // Fix the cache\n            cacheInconsistent = true;\n        }\n        \n        // If we detected an inconsistency, sync the entire cache\n        if (cacheInconsistent) {\n            this._syncTagCache();\n        }\n        \n        return hasTag;\n    }\n}\n","/**\n * EntityManager - Manages entity creation, tracking and destruction\n * \n * Handles entity lifecycle and provides methods to query entities\n * based on components or tags.\n */\n\nimport { Entity } from './entity.js';\nimport type { World } from './world.js';\n\nexport class EntityManager {\n    public world: World;\n    public entities: Map<string, Entity>;\n    public entitiesByComponent: Map<string, any>;\n    public entitiesByTag: Map<string, Entity[]>;\n    private lastEntityId: number;\n    private recycledEntities: Entity[];\n    private maxRecycledEntities: number;\n\n    constructor(world: World) {\n        this.world = world;\n        this.entities = new Map();\n        // Use WeakMap for entity tracking to allow garbage collection\n        this.entitiesByComponent = new Map();\n        this.entitiesByTag = new Map();\n        this.lastEntityId = 0;\n        \n        // Entity recycle pool for faster instantiation\n        this.recycledEntities = [];\n        this.maxRecycledEntities = 100;\n    }\n    \n    /**\n     * Create a new entity\n     * @param {string} name Optional name for the entity\n     * @returns {Entity} The created entity\n     */\n    createEntity(name: string = ''): Entity {\n        // Try to reuse a recycled entity first\n        let entity: Entity;\n        \n        if (this.recycledEntities.length > 0) {\n            entity = this.recycledEntities.pop()!;\n            entity.components.clear();\n            entity.tags.clear();\n            // @ts-ignore - access private properties for reset\n            entity._isEnemy = undefined;\n            // @ts-ignore\n            entity._isPlayer = undefined;\n            // @ts-ignore\n            entity._isProjectile = undefined;\n        } else {\n            const id = this._generateEntityId();\n            entity = new Entity(id, this.world);\n        }\n        \n        // Add to entities map first\n        this.entities.set(entity.id.toString(), entity);\n        \n        // Add name as tag using the fixed addTag method which will register with entityManager\n        if (name) {\n            entity.addTag(name);\n        }\n        \n        // Notify systems that an entity was created\n        this.world.messageBus.publish('entity.created', { entity });\n        \n        return entity;\n    }\n    \n    /**\n     * Destroy an entity and remove all its components\n     * @param {Entity|string} entityOrId The entity or entity ID to destroy\n     */\n    destroyEntity(entityOrId: Entity | string): void {\n        const id = typeof entityOrId === 'string' ? entityOrId : entityOrId.id;\n        const entity = this.entities.get(id.toString());\n        \n        if (!entity) return;\n        \n        // Notify systems that this entity will be destroyed\n        this.world.messageBus.publish('entity.destroyed', { entity });\n        \n        // Remove from tag maps\n        entity.tags.forEach(tag => {\n            if (this.entitiesByTag.has(tag)) {\n                const entities = this.entitiesByTag.get(tag)!;\n                const index = entities.indexOf(entity);\n                if (index !== -1) {\n                    entities.splice(index, 1);\n                }\n                \n                if (entities.length === 0) {\n                    this.entitiesByTag.delete(tag);\n                }\n            }\n        });\n        \n        // Remove all components\n        for (const [_, component] of entity.components.entries()) {\n            entity.removeComponent(component.constructor);\n        }\n        \n        // Remove from entities map\n        this.entities.delete(id.toString());\n        \n        // Add to recycled entities pool if not full\n        if (this.recycledEntities.length < this.maxRecycledEntities) {\n            this.recycledEntities.push(entity);\n        }\n    }\n    \n    /**\n     * Get an entity by ID\n     * @param {string} id The entity ID\n     * @returns {Entity|undefined} The entity or undefined if not found\n     */\n    getEntity(id: string): Entity | undefined {\n        return this.entities.get(id.toString());\n    }\n    \n    /**\n     * Get all entities with the specified tag\n     * @param {string} tag The tag to filter by\n     * @returns {Entity[]} Array of entities with the tag\n     */\n    getEntitiesByTag(tag: string): Entity[] {\n        return this.entitiesByTag.get(tag) || [];\n    }\n    \n    /**\n     * Get all entities that have all the specified components\n     * @param {any[]} componentTypes Array of component types\n     * @returns {Entity[]} Array of entities with all components\n     */\n    getEntitiesWithComponents(componentTypes: any[]): Entity[] {\n        if (!componentTypes || componentTypes.length === 0) {\n            return Array.from(this.entities.values());\n        }\n        \n        return Array.from(this.entities.values()).filter(entity => {\n            return componentTypes.every(type => entity.hasComponent(type));\n        });\n    }\n    \n    /**\n     * Get all entities in the manager\n     * @returns {Entity[]} Array of all entities\n     */\n    getEntities(): Entity[] {\n        return Array.from(this.entities.values());\n    }\n    \n    /**\n     * Update entity tag index when a tag is added\n     * @param {Entity} entity The entity\n     * @param {string} tag The tag\n     */\n    onTagAdded(entity: Entity, tag: string): void {\n        if (!this.entitiesByTag.has(tag)) {\n            this.entitiesByTag.set(tag, []);\n        }\n        \n        this.entitiesByTag.get(tag)!.push(entity);\n    }\n    \n    /**\n     * Update entity tag index when a tag is removed\n     * @param {Entity} entity The entity\n     * @param {string} tag The tag\n     */\n    onTagRemoved(entity: Entity, tag: string): void {\n        if (this.entitiesByTag.has(tag)) {\n            const entities = this.entitiesByTag.get(tag)!;\n            const index = entities.indexOf(entity);\n            \n            if (index !== -1) {\n                entities.splice(index, 1);\n            }\n            \n            if (entities.length === 0) {\n                this.entitiesByTag.delete(tag);\n            }\n        }\n    }\n    \n    /**\n     * Generate a unique entity ID\n     * @returns {string} A unique entity ID\n     * @private\n     */\n    private _generateEntityId(): string {\n        return (++this.lastEntityId).toString();\n    }\n}\n","/**\n * SystemManager - Manages the registration and execution of systems\n * \n * Handles system priority, updates, and lifecycle.\n */\n\nimport type { World } from './world.js';\nimport type { System } from './system.js';\n\nexport class SystemManager {\n    public world: World;\n    public systems: System[];\n    public systemsByType: Map<string, System>;\n    private _tick: number;\n\n    constructor(world: World) {\n        this.world = world;\n        this.systems = [];\n        this.systemsByType = new Map();\n        // perf timings bucket\n        if (!(window as any).__perf) (window as any).__perf = { systems: {} };\n        this._tick = 0;\n    }\n    \n    /**\n     * Register a system with the manager\n     * @param {System} system The system to register\n     * @returns {System} The registered system\n     */\n    registerSystem(system: System): System {\n        const systemType = (system as any).type || system.constructor.name;\n        if (this.systemsByType.has(systemType)) {\n            console.warn(`System of type ${systemType} already registered`);\n            return system;\n        }\n\n        this.systems.push(system);\n        this.systemsByType.set(systemType, system);\n\n        // Sort systems by priority (lower = earlier)\n        this.systems.sort((a, b) => a.priority - b.priority);\n\n        return system;\n    }\n    \n    /**\n     * Get a system by type\n     * @param {any} systemType The system class type\n     * @returns {System|undefined} The system instance or undefined if not found\n     */\n    getSystem(systemType: any): System | undefined {\n        const typeName = systemType.type || systemType.name;\n        return this.systemsByType.get(typeName);\n    }\n    \n    /**\n     * Update all enabled systems\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime: number): void {\n        this._tick = (this._tick + 1) >>> 0;\n        for (const system of this.systems) {\n            if (!system.enabled) continue;\n            // Stagger heavy systems every 2 ticks (example heuristic)\n            const name = (system as any).type || system.constructor.name;\n            const isHeavy = name === 'EnemySystem' || name === 'CollisionSystem' || name === 'TargetingSystem';\n            if (isHeavy && (this._tick & 1) === 1) {\n                continue;\n            }\n            const t0 = performance.now();\n            system.update(deltaTime);\n            const t1 = performance.now();\n            if ((window as any).__perf) {\n                if (!(window as any).__perf.systems) (window as any).__perf.systems = {};\n                (window as any).__perf.systems[name] = Number(t1 - t0);\n            }\n        }\n    }\n    \n    /**\n     * Initialize all systems\n     * Called once before the first update\n     */\n    initialize(): void {\n        for (const system of this.systems) {\n            if (typeof system.initialize === 'function') {\n                system.initialize();\n            }\n        }\n    }\n    \n    /**\n     * Enable a system by type\n     * @param {any} systemType The system class type\n     */\n    enableSystem(systemType: any): void {\n        const system = this.getSystem(systemType);\n        if (system) {\n            system.enable();\n        }\n    }\n    \n    /**\n     * Disable a system by type\n     * @param {any} systemType The system class type\n     */\n    disableSystem(systemType: any): void {\n        const system = this.getSystem(systemType);\n        if (system) {\n            system.disable();\n        }\n    }\n}\n","// SpatialHash.ts - simple 3D spatial hash grid for proximity queries\n\ninterface Vector3Like {\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport class SpatialHash {\n    private cellSize: number;\n    private map: Map<string, Set<string | number>>; // key -> Set(entityId)\n    private entityToCells: Map<string | number, string[]>; // entityId -> array of keys\n\n    constructor(cellSize: number = 200) {\n        this.cellSize = cellSize;\n        this.map = new Map();\n        this.entityToCells = new Map();\n    }\n\n    private _key(ix: number, iy: number, iz: number): string {\n        return `${ix}|${iy}|${iz}`;\n    }\n\n    private _cellIndex(v: number): number {\n        return Math.floor(v / this.cellSize) | 0;\n    }\n\n    private _computeKeysForAABB(min: Vector3Like, max: Vector3Like): string[] {\n        const ix0 = this._cellIndex(min.x), iy0 = this._cellIndex(min.y), iz0 = this._cellIndex(min.z);\n        const ix1 = this._cellIndex(max.x), iy1 = this._cellIndex(max.y), iz1 = this._cellIndex(max.z);\n        const keys: string[] = [];\n        for (let ix = ix0; ix <= ix1; ix++)\n            for (let iy = iy0; iy <= iy1; iy++)\n                for (let iz = iz0; iz <= iz1; iz++)\n                    keys.push(this._key(ix, iy, iz));\n        return keys;\n    }\n\n    public insert(entityId: string | number, position: Vector3Like, radius: number = 1): void {\n        const min = { x: position.x - radius, y: position.y - radius, z: position.z - radius };\n        const max = { x: position.x + radius, y: position.y + radius, z: position.z + radius };\n        const keys = this._computeKeysForAABB(min, max);\n        this.entityToCells.set(entityId, keys);\n        for (const k of keys) {\n            let set = this.map.get(k);\n            if (!set) {\n                set = new Set();\n                this.map.set(k, set);\n            }\n            set.add(entityId);\n        }\n    }\n\n    public update(entityId: string | number, position: Vector3Like, radius: number = 1): void {\n        this.remove(entityId);\n        this.insert(entityId, position, radius);\n    }\n\n    public remove(entityId: string | number): void {\n        const keys = this.entityToCells.get(entityId);\n        if (!keys) return;\n        for (const k of keys) {\n            const set = this.map.get(k);\n            if (set) {\n                set.delete(entityId);\n                if (set.size === 0) this.map.delete(k);\n            }\n        }\n        this.entityToCells.delete(entityId);\n    }\n\n    public querySphere(center: Vector3Like, radius: number): (string | number)[] {\n        const min = { x: center.x - radius, y: center.y - radius, z: center.z - radius };\n        const max = { x: center.x + radius, y: center.y + radius, z: center.z + radius };\n        const keys = this._computeKeysForAABB(min, max);\n        const result = new Set<string | number>();\n        for (const k of keys) {\n            const set = this.map.get(k);\n            if (set) {\n                for (const id of set) result.add(id);\n            }\n        }\n        return Array.from(result);\n    }\n}\n","// EntityIndex.ts - track entity lookups and mesh/instance mapping\n\nexport interface EntityView {\n    meshRef?: any;\n    instanceKey?: string;\n    instanceId?: number;\n    [key: string]: any;\n}\n\nexport class EntityIndex {\n    private entityToView: Map<string | number, EntityView>;\n    private tagToEntities: Map<string, Set<string | number>>;\n\n    constructor() {\n        this.entityToView = new Map();\n        this.tagToEntities = new Map();\n    }\n\n    public setView(entityId: string | number, view: EntityView): void {\n        this.entityToView.set(entityId, view);\n    }\n\n    public getView(entityId: string | number): EntityView | undefined {\n        return this.entityToView.get(entityId);\n    }\n\n    public clearView(entityId: string | number): void {\n        this.entityToView.delete(entityId);\n    }\n\n    public addTag(entityId: string | number, tag: string): void {\n        let set = this.tagToEntities.get(tag);\n        if (!set) {\n            set = new Set();\n            this.tagToEntities.set(tag, set);\n        }\n        set.add(entityId);\n    }\n\n    public removeTag(entityId: string | number, tag: string): void {\n        const set = this.tagToEntities.get(tag);\n        if (set) {\n            set.delete(entityId);\n            if (set.size === 0) this.tagToEntities.delete(tag);\n        }\n    }\n\n    public getByTag(tag: string): (string | number)[] {\n        const set = this.tagToEntities.get(tag);\n        return set ? Array.from(set) : [];\n    }\n}\n","/**\n * World - Main container class for the ECS architecture\n * \n * The World manages the entire ECS setup, including entities,\n * components, systems, and messaging.\n */\n\nimport { EntityManager } from './entityManager.js';\nimport { SystemManager } from './systemManager.js';\nimport { MessageBus } from './messageBus.js';\nimport { SpatialHash } from './spatial/SpatialHash.js';\nimport { EntityIndex } from './EntityIndex.js';\nimport { DEBUG_MODE } from '../globals/debug.ts';\nimport type { Entity } from './entity.js';\nimport type { System } from './system.ts';\n\nexport class World {\n    public messageBus: MessageBus;\n    public entityManager: EntityManager;\n    public systemManager: SystemManager;\n    public spatial: SpatialHash;\n    public index: EntityIndex;\n    public deltaTime: number;\n    public time: number;\n    public lastUpdateTime: number;\n    \n    // Optional properties used by systems/game\n    public scene?: any;\n    public optimizedProjectiles?: any;\n    public playerEntity?: Entity;\n\n    constructor(messageBus: MessageBus | null = null) {\n        // Use provided message bus or create a new one\n        // This allows sharing the message bus between World and Game\n        this.messageBus = messageBus || new MessageBus();\n        \n        // If we created a new message bus, make it accessible globally\n        if (!messageBus && !(globalThis as any).mainMessageBus) {\n            (globalThis as any).mainMessageBus = this.messageBus;\n        }\n        \n        // Create managers\n        this.entityManager = new EntityManager(this);\n        this.systemManager = new SystemManager(this);\n        this.spatial = new SpatialHash(400); // cell size tuned later\n        this.index = new EntityIndex();\n        \n        // Time tracking\n        this.deltaTime = 0;\n        this.time = 0;\n        this.lastUpdateTime = 0;\n    }\n    \n    /**\n     * Initialize the world and all systems\n     */\n    initialize(): void {\n        this.lastUpdateTime = performance.now();\n        this.systemManager.initialize();\n        this.messageBus.publish('world.initialized', {});\n    }\n\n    /**\n     * Hook for systems to notify when entity moved\n     * @param {Entity} entity The entity that moved\n     */\n    onEntityTransformUpdated(entity: any): void {\n        const t = entity.getComponent && entity.getComponent('TransformComponent');\n        if (t) {\n            this.spatial.update(entity.id, t.position, entity.collisionRadius || 1);\n        }\n    }\n    \n    /**\n     * Update all systems\n     */\n    update(): void {\n        // Calculate delta time\n        const now = performance.now();\n        this.deltaTime = Math.min((now - this.lastUpdateTime) / 1000, 0.1); // Cap at 100ms\n        this.lastUpdateTime = now;\n        this.time += this.deltaTime;\n        \n        // Publish pre-update message\n        this.messageBus.publish('world.preUpdate', { deltaTime: this.deltaTime, time: this.time });\n        \n        // Update all systems\n        this.systemManager.update(this.deltaTime);\n        \n        // Publish post-update message\n        this.messageBus.publish('world.postUpdate', { deltaTime: this.deltaTime, time: this.time });\n        \n        // For debugging - log active entities in dev console\n        if (DEBUG_MODE.enabled && this.time % 5 < this.deltaTime) {\n            // Get all entities from entity manager using values from the map\n            // const entities = Array.from(this.entityManager.entities.values());\n            // const entitiesWithMesh = this.getEntitiesWithComponents(['MeshComponent']);\n        }\n    }\n    \n    /**\n     * Create a new entity\n     * @param {string} name Optional name for the entity\n     * @returns {Entity} The created entity\n     */\n    createEntity(name: string = ''): Entity {\n        return this.entityManager.createEntity(name);\n    }\n    \n    /**\n     * Destroy an entity\n     * @param {Entity|string} entityOrId The entity or entity ID to destroy\n     */\n    destroyEntity(entityOrId: Entity | string): void {\n        this.entityManager.destroyEntity(entityOrId);\n    }\n    \n    /**\n     * Register a system\n     * @param {System} system The system to register\n     * @returns {System} The registered system\n     */\n    registerSystem(system: System): System {\n        return this.systemManager.registerSystem(system);\n    }\n    \n    /**\n     * Get entities with specific components\n     * @param {any[]} componentTypes Array of component types\n     * @returns {Entity[]} Array of entities with all components\n     */\n    getEntitiesWithComponents(componentTypes: any[]): Entity[] {\n        return this.entityManager.getEntitiesWithComponents(componentTypes);\n    }\n    \n    /**\n     * Get entities with a specific tag\n     * @param {string} tag The tag to filter by\n     * @returns {Entity[]} Array of entities with the tag\n     */\n    getEntitiesByTag(tag: string): Entity[] {\n        return this.entityManager.getEntitiesByTag(tag);\n    }\n    \n    /**\n     * Get a specific entity by ID\n     * @param {string} id The entity ID\n     * @returns {Entity|undefined} The entity or undefined if not found\n     */\n    getEntity(id: string): Entity | undefined {\n        return this.entityManager.getEntity(id);\n    }\n    \n    /**\n     * Get a system by type\n     * @param {any} systemType The system class type\n     * @returns {System|undefined} The system instance or undefined if not found\n     */\n    getSystem(systemType: any): System | undefined {\n        return this.systemManager.getSystem(systemType);\n    }\n}\n","/**\n * World Setup Module - Handles ECS World construction and scene setup\n * \n * This module contains all the logic for creating and initializing the ECS world,\n * including the player reference entity and basic world configuration.\n */\n\nimport { World } from '../../core/world.ts';\nimport * as THREE from 'three';\n\nexport class WorldSetup {\n    world: any = null;\n    playerEntity: any = null;\n    worldInitialized: boolean = false;\n\n    constructor() {\n    }\n\n    /**\n     * Initialize the ECS world asynchronously\n     * This is called from the constructor and runs in the background\n     */\n    async initializeECSWorld(scene: THREE.Scene, spaceship: any): Promise<any> {\n        try {\n            console.log(\"[COMBAT] Starting ECS world initialization...\");\n            \n            // Create a new World instance immediately to allow references\n            this.world = new World((window as any).mainMessageBus);\n            console.log(\"[COMBAT] Created world with messageBus: \", \n                        this.world.messageBus === (window as any).mainMessageBus ? \"Using shared messageBus\" : \"Created new messageBus\");\n            \n            // Make world globally available immediately\n            if ((window as any).game) {\n                (window as any).game.ecsWorld = this.world;\n                console.log(\"[COMBAT] Made ECS world globally available via window.game.ecsWorld\");\n            }\n            \n            // Store scene reference in world for systems that need it\n            this.world.scene = scene;\n            \n            // Log scene reference for debugging\n            console.log(`[COMBAT] Set scene reference in ECS world for enemy rendering:`, \n                       scene ? \"Scene available\" : \"No scene available\");\n            \n            // Create player entity immediately - don't wait for full setup\n            await this.createPlayerReferenceEntity(spaceship);\n            \n            // Create optimized projectile store\n            if (!this.world.optimizedProjectiles) {\n                try {\n                    const { OptimizedProjectileStore } = await import('../../core/optimized/OptimizedProjectileStore.ts');\n                    this.world.optimizedProjectiles = new OptimizedProjectileStore(4096);\n                    console.log('[COMBAT] OptimizedProjectileStore created');\n                } catch (e) {\n                    console.warn('[COMBAT] OptimizedProjectileStore unavailable:', e);\n                }\n            }\n            \n            console.log(\"[COMBAT] ECS world initialization complete\");\n            return this.world;\n        } catch (error) {\n            console.error(\"[COMBAT] Error initializing ECS world:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Create a player reference entity in the ECS world\n     * This allows enemies and other systems to interact with the player\n     */\n    async createPlayerReferenceEntity(spaceship: any): Promise<any> {\n        if (!this.world) {\n            console.error(\"[COMBAT] Cannot create player entity - world not available\");\n            return null;\n        }\n        \n        if (!spaceship) {\n            console.error(\"[COMBAT] Cannot create player entity - spaceship not available\");\n            return null;\n        }\n        \n        try {\n            console.log(\"[COMBAT] Creating player reference entity...\");\n            \n            // If player entity already exists, check if it's valid\n            if (this.playerEntity) {\n                const existingEntity = this.world.getEntity(this.playerEntity.id);\n                if (existingEntity) {\n                    console.log(`[COMBAT] Player entity already exists with ID: ${this.playerEntity.id}`);\n                    \n                    // Make sure it has the player tag (re-add if missing)\n                    if (!existingEntity.hasTag('player')) {\n                        console.log(\"[COMBAT] Re-adding 'player' tag to existing entity\");\n                        existingEntity.addTag('player');\n                    }\n                    \n                    // Update its position\n                    const transform = existingEntity.getComponent('TransformComponent');\n                    if (transform && spaceship.mesh) {\n                        transform.position.copy(spaceship.mesh.position);\n                        transform.rotation.copy(spaceship.mesh.rotation);\n                        transform.quaternion.copy(spaceship.mesh.quaternion);\n                        if (typeof transform.setUpdated === 'function') {\n                            transform.setUpdated();\n                        }\n                    }\n                    \n                    // Make it globally accessible\n                    if ((window as any).game) {\n                        (window as any).game.combat = (window as any).game.combat || {};\n                        (window as any).game.combat.playerEntity = existingEntity;\n                    }\n                    \n                    return existingEntity;\n                } else {\n                    console.log(\"[COMBAT] Previous player entity no longer exists, creating new one\");\n                }\n            }\n            \n            // Create player entity with a clear unique name\n            const playerEntity = this.world.createEntity('player_' + Date.now());\n            \n            // Add player tag and log it\n            playerEntity.addTag('player');\n            console.log(`[COMBAT] Added 'player' tag to entity ${playerEntity.id}`);\n            \n            // Legacy components removed; use minimal local shims.\n            const TransformComponent = class FallbackTransform {\n                position: THREE.Vector3;\n                rotation: THREE.Euler;\n                quaternion: THREE.Quaternion;\n                constructor(position?: THREE.Vector3) {\n                    this.position = position || new THREE.Vector3();\n                    this.rotation = new THREE.Euler();\n                    this.quaternion = new THREE.Quaternion();\n                }\n            };\n\n            const HealthComponent = class FallbackHealth {\n                health: number;\n                shield: number;\n                maxHealth: number;\n                maxShield: number;\n                constructor(health?: number, shield?: number) {\n                    this.health = health || 100;\n                    this.shield = shield || 50;\n                    this.maxHealth = health || 100;\n                    this.maxShield = shield || 50;\n                }\n            };\n            \n            // Add transform component linked to spaceship position\n            try {\n                const position = spaceship.mesh ? spaceship.mesh.position.clone() : new THREE.Vector3();\n                const transform = new TransformComponent(position);\n                playerEntity.addComponent(transform);\n                console.log(`[COMBAT] Added TransformComponent to player entity with position: ${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)}`);\n            } catch (error) {\n                console.error(\"[COMBAT] Error adding TransformComponent to player entity:\", error);\n            }\n            \n            // Add health component\n            try {\n                const health = new HealthComponent(100, 50); // 100 health, 50 shield\n                playerEntity.addComponent(health);\n                console.log(\"[COMBAT] Added HealthComponent to player entity\");\n            } catch (error) {\n                console.error(\"[COMBAT] Error adding HealthComponent to player entity:\", error);\n            }\n            \n            // Store reference to player entity\n            this.playerEntity = playerEntity;\n            \n            // Make the player entity globally accessible for emergency access\n            if ((window as any).game) {\n                (window as any).game.combat = (window as any).game.combat || {};\n                (window as any).game.combat.playerEntity = playerEntity;\n                console.log(\"[COMBAT] Made player entity globally accessible via window.game.combat.playerEntity\");\n            }\n            \n            // Add direct player entity reference to the world\n            this.world.playerEntity = playerEntity;\n            console.log(\"[COMBAT] Made player entity available directly via world.playerEntity\");\n            \n            // Explicitly publish an event for player entity creation\n            if (this.world && this.world.messageBus) {\n                this.world.messageBus.publish('player.created', { entity: playerEntity });\n                console.log(\"[COMBAT] Published player.created event\");\n            }\n            \n            console.log(\"[COMBAT] Successfully created player reference entity with ID:\", playerEntity.id);\n            \n            // Return the entity for chaining\n            return playerEntity;\n        } catch (error) {\n            console.error(\"[COMBAT] Error creating player reference entity:\", error);\n            console.error(\"[COMBAT] Stack trace:\", (error as Error).stack);\n            return null;\n        }\n    }\n\n    /**\n     * Update the player reference entity with the current spaceship position\n     */\n    updatePlayerReference(spaceship: any): void {\n        // Skip if missing references\n        if (!this.world || !spaceship || !this.playerEntity) {\n            // If we don't have a player entity, try to create one now if world is ready\n            if (this.world && spaceship && !this.playerEntity) {\n                console.log(\"No player entity found, creating one...\");\n                this.createPlayerReferenceEntity(spaceship);\n                return;\n            }\n            return;\n        }\n        \n        // Get the player entity\n        const playerEntity = this.world.getEntity(this.playerEntity.id);\n        \n        // If entity was somehow lost, recreate it\n        if (!playerEntity) {\n            console.warn(\"Player entity lost, recreating...\");\n            this.createPlayerReferenceEntity(spaceship);\n            return;\n        }\n        \n        // Update transform component with current spaceship position\n        const transform = playerEntity.getComponent('TransformComponent');\n        if (transform && spaceship.mesh) {\n            // Update position\n            transform.position.copy(spaceship.mesh.position);\n            \n            // Update rotation\n            transform.rotation.copy(spaceship.mesh.rotation);\n            transform.quaternion.copy(spaceship.mesh.quaternion);\n            \n            // Mark transform as updated to trigger any listening systems\n            if (typeof transform.setUpdated === 'function') {\n                transform.setUpdated();\n            }\n        }\n        \n        // Update health component if spaceship has relevant health info\n        const health = playerEntity.getComponent('HealthComponent');\n        if (health && spaceship.health !== undefined) {\n            // Only update health if it would be higher - don't override damage\n            if (spaceship.health > health.health) {\n                health.health = spaceship.health;\n            }\n            \n            // Only update shield if it would be higher - don't override damage\n            if (spaceship.shield !== undefined && spaceship.shield > health.shield) {\n                health.shield = spaceship.shield;\n            }\n        }\n    }\n\n    /**\n     * Sync the spaceship hull/shield with the player entity's HealthComponent\n     */\n    updateSpaceshipHealth(spaceship: any): void {\n        if (!this.playerEntity || !spaceship) return;\n        \n        // Get health component\n        const health = this.playerEntity.getComponent('HealthComponent');\n        if (health) {\n            // IMPORTANT: Only update spaceship health if the health component shows MORE damage\n            // (less health) than the spaceship currently has - this means damage was applied to the component\n            if (health.health < spaceship.hull) {\n                console.log(`Damage detected in health component: ${health.health} (was ${spaceship.hull})`);\n                spaceship.hull = health.health;\n            }\n            \n            // Similarly for shield\n            if (health.shield < spaceship.shield) {\n                console.log(`Shield damage detected in health component: ${health.shield} (was ${spaceship.shield})`);\n                spaceship.shield = health.shield;\n            }\n            \n            // Check if health indicates the ship is destroyed\n            if (health.isDestroyed && !spaceship.isDestroyed) {\n                console.log(\"Health component indicates player is destroyed - updating spaceship state\");\n                spaceship.isDestroyed = true;\n                \n                // Call handle destruction for visual effects\n                if (typeof spaceship.handleDestruction === 'function') {\n                    spaceship.handleDestruction();\n                }\n            }\n            \n            // Check for low health and update spaceship directly\n            if (health.health <= 0 && !spaceship.isDestroyed) {\n                console.log(\"Player health is zero - marking spaceship as destroyed\");\n                spaceship.isDestroyed = true;\n                \n                // Call handle destruction for visual effects\n                if (typeof spaceship.handleDestruction === 'function') {\n                    spaceship.handleDestruction();\n                }\n                \n                // Force game over with a \"pwned by space alien\" message\n                if ((window as any).game) {\n                    console.log(\"FORCING GAME OVER FROM COMBAT MODULE!\");\n                    (window as any).game.gameOver(\"You were pwned by a space alien!\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Initialize the world\n     */\n    initializeWorld(): void {\n        try {\n            console.log(\"[COMBAT] Calling world.initialize()...\");\n            this.world.initialize();\n            console.log(\"[COMBAT] World initialization completed successfully\");\n        } catch (error) {\n            console.error(\"[COMBAT] Error during world.initialize():\", error);\n            console.error(\"[COMBAT] Stack trace:\", (error as Error).stack);\n            \n            // Continue execution - don't let this error stop us\n            console.log(\"[COMBAT] Continuing despite initialization error\");\n        }\n    }\n\n    /**\n     * Mark world as initialized\n     */\n    setWorldInitialized(): void {\n        this.worldInitialized = true;\n    }\n\n    /**\n     * Set reference to this world in the scene for cross-component access\n     */\n    setSceneReference(scene: THREE.Scene): void {\n        if (scene) {\n            (scene as any).ecsWorld = this.world;\n            console.log(\"[COMBAT] Set ECS world reference in scene for cross-system access\");\n        }\n    }\n\n    /**\n     * Get the world instance\n     */\n    getWorld(): any {\n        return this.world;\n    }\n\n    /**\n     * Get the player entity\n     */\n    getPlayerEntity(): any {\n        return this.playerEntity;\n    }\n\n    /**\n     * Check if world is initialized\n     */\n    isWorldInitialized(): boolean {\n        return this.worldInitialized;\n    }\n}\n","/**\n * System Registration Module - Handles deterministic system registration\n *\n * NOTE: Legacy ECS systems have been removed in favor of bitECS. This module is\n * retained as a no-op shim to preserve existing call sites.\n */\n\nimport * as THREE from 'three';\n\nexport class SystemRegistrar {\n    registeredSystems: Record<string, any> = {};\n\n    constructor() {\n    }\n\n    /**\n     * Register all combat systems with the ECS world in the correct order\n     * (legacy no-op shim).\n     */\n    async registerAllSystems(world: any, scene: THREE.Scene): Promise<any> {\n        void world;\n        void scene;\n\n        console.warn('[COMBAT] Legacy ECS systems removed; SystemRegistrar is a no-op.');\n        this.registeredSystems = {};\n        return this.registeredSystems;\n    }\n\n    /**\n     * Get a specific system by name\n     */\n    getSystem(systemName: string): any {\n        return this.registeredSystems[systemName];\n    }\n\n    /**\n     * Get all registered systems\n     */\n    getAllSystems(): Record<string, any> {\n        return this.registeredSystems;\n    }\n\n    /**\n     * Enable or disable all systems (legacy no-op shim).\n     */\n    setSystemsEnabled(enabled: boolean): void {\n        void enabled;\n        console.warn('[COMBAT] setSystemsEnabled called on legacy SystemRegistrar.');\n    }\n\n    /**\n     * Import and register a system dynamically (legacy no-op shim).\n     * @param path The path to the system module\n     * @param className The name of the system class\n     * @param world The ECS world\n     * @param scene The scene (optional)\n     * @returns null\n     */\n    async importAndRegisterSystem(\n        path: string,\n        className: string,\n        world: any,\n        scene: any = null\n    ): Promise<any> {\n        void path;\n        void className;\n        void world;\n        void scene;\n\n        console.warn('[COMBAT] importAndRegisterSystem called on legacy SystemRegistrar.');\n        return null;\n    }\n}\n","/**\n * Event Manager Module - Handles event subscriptions and MessageBus interactions\n * \n * This module contains all the logic for subscribing to game events and\n * translating them into ECS actions, as well as publishing combat events.\n */\n\nexport class EventManager {\n    subscriptions: any[] = [];\n    world: any = null;\n    playerEntity: any = null;\n\n    constructor() {\n    }\n\n    /**\n     * Set up all event handlers for the combat module\n     */\n    setupEventHandlers(world: any, playerEntity: any): void {\n        this.world = world;\n        this.playerEntity = playerEntity;\n        \n        // Skip if no message bus\n        if (!world || !world.messageBus) return;\n        \n        const messageBus = world.messageBus;\n        \n        // Listen for enemy destruction to reward player\n        const sub1 = messageBus.subscribe('enemy.destroyed', (data: any) => {\n            this.handleEnemyDestroyed(data);\n        });\n        this.subscriptions.push({ topic: 'enemy.destroyed', token: sub1 });\n        \n        // Listen for player damage events from the ECS world\n        const sub2 = messageBus.subscribe('entity.damage', (data: any) => {\n            this.handleEntityDamage(data);\n        });\n        this.subscriptions.push({ topic: 'entity.damage', token: sub2 });\n        \n        console.log(`[COMBAT] Event handlers setup for world ${world.id || 'default'}`);\n    }\n\n    /**\n     * Handle enemy destruction events\n     */\n    handleEnemyDestroyed(data: any): void {\n        // Reward player with score or resources\n        if ((window as any).game && (window as any).game.ui && (window as any).game.ui.updateScore) {\n            const points = data.points || 100;\n            (window as any).game.ui.updateScore(points);\n        }\n    }\n\n    /**\n     * Handle entity damage events\n     */\n    handleEntityDamage(data: any): void {\n        const { entityId, damage, shieldDamage } = data;\n        \n        // Check if this is the player entity\n        if (this.playerEntity && entityId === this.playerEntity.id) {\n            \n            // Publish to main game message bus for UI and other modules\n            if ((window as any).mainMessageBus) {\n                (window as any).mainMessageBus.publish('player.damaged', {\n                    damage,\n                    shieldDamage,\n                    source: data.source || 'unknown'\n                });\n            }\n        }\n    }\n\n    /**\n     * Clean up all event subscriptions\n     */\n    cleanup(): void {\n        if (!this.world || !this.world.messageBus) return;\n        \n        for (const sub of this.subscriptions) {\n            this.world.messageBus.unsubscribe(sub.topic, sub.token);\n        }\n        \n        this.subscriptions = [];\n    }\n}\n","/**\n * Explosion Effects Module\n * \n * Handles explosion visual effects including instant tracers and pooled explosions\n */\n\nimport * as THREE from 'three';\n\nexport class ExplosionEffects {\n    activeTracers: THREE.Group[] = [];\n\n    constructor() {\n    }\n\n    /**\n     * Create an explosion effect at the given position\n     * @param {THREE.Vector3} position Position for the explosion\n     * @param {number} duration Duration of the explosion in milliseconds\n     * @param {boolean} _isVisible Whether the explosion should be visible\n     * @param {Object} poolManager Pool manager for getting explosion objects\n     * @param {Function} addToScene Function to add objects to scene\n     */\n    createExplosionEffect(position: THREE.Vector3, duration: number = 1000, _isVisible: boolean = true, poolManager: any = null, addToScene: ((obj: THREE.Object3D) => void) | null = null) {\n        try {\n            let explosion: any = null;\n            \n            // Try to get explosion from poolManager\n            if (poolManager && poolManager.getExplosion) {\n                explosion = poolManager.getExplosion(position, duration);\n            }\n            \n            // If no explosion from pool, create a simple one\n            if (!explosion) {\n                // Create a simple explosion mesh\n                const geometry = new THREE.SphereGeometry(30, 16, 16);\n                const material = new THREE.MeshBasicMaterial({\n                    color: 0xff6600,\n                    transparent: true,\n                    opacity: 0.9,\n                    blending: THREE.AdditiveBlending\n                });\n                const emissiveMaterial = material as THREE.MeshBasicMaterial & {\n                    emissive?: THREE.ColorRepresentation;\n                    emissiveIntensity?: number;\n                };\n                emissiveMaterial.emissive = 0xff3300;\n                emissiveMaterial.emissiveIntensity = 2;\n                \n                explosion = new THREE.Mesh(geometry, material);\n                explosion.position.copy(position);\n                \n                // Add to scene if function provided\n                if (addToScene) {\n                    addToScene(explosion);\n                } else if ((window as any).game && (window as any).game.scene) {\n                    (window as any).game.scene.add(explosion);\n                }\n                \n                // Animate the explosion\n                const startTime = Date.now();\n                const animate = () => {\n                    const elapsed = Date.now() - startTime;\n                    const progress = elapsed / duration;\n                    \n                    if (progress >= 1 || !explosion.parent) {\n                        // Remove explosion\n                        if (explosion.parent) {\n                            explosion.parent.remove(explosion);\n                        }\n                        geometry.dispose();\n                        material.dispose();\n                        return;\n                    }\n                    \n                    // Expand and fade\n                    const expansionScale = 1 + progress * 3;\n                    explosion.scale.setScalar(expansionScale);\n                    material.opacity = 0.9 * (1 - progress);\n                    \n                    requestAnimationFrame(animate);\n                };\n                \n                animate();\n            }\n            \n            // Play explosion sound\n            if ((window as any).game && (window as any).game.audio) {\n                (window as any).game.audio.playSound('boink');\n            }\n\n            // Trigger strong gamepad rumble\n            if ((window as any).mainMessageBus) {\n                (window as any).mainMessageBus.publish('input.vibrate', { intensity: 0.8, duration: 200 });\n            }\n            \n            return explosion;\n        } catch (error) {\n            console.error(\"Error creating explosion effect:\", error);\n            return null;\n        }\n    }\n\n    /**\n     * Create an instant plasma beam with hot glow\n     * @param {THREE.Vector3} startPos Starting position of the beam\n     * @param {THREE.Vector3} endPos End position of the beam (hit point or max range)\n     * @param {boolean} isHit Whether this beam hit a target\n     * @param {number} fadeTime Time in seconds for the beam to fade\n     * @param {Function} addToScene Function to add objects to scene\n     */\n    createInstantTracer(startPos: THREE.Vector3, endPos: THREE.Vector3, isHit: boolean = false, fadeTime: number = 0.5, addToScene: ((obj: THREE.Object3D) => void) | null = null) {\n        const distance = startPos.distanceTo(endPos);\n        \n        // Create multiple cylinders for a layered plasma effect\n        const beamGroup = new THREE.Group();\n        \n        // Core beam - bright white/yellow hot plasma\n        const coreGeometry = new THREE.CylinderGeometry(1.5, 1.5, distance, 12);\n        const coreMaterial = new THREE.MeshBasicMaterial({\n            color: 0xffffaa, // Hot yellow-white\n            transparent: true,\n            opacity: 1.0,\n            blending: THREE.AdditiveBlending\n        });\n        const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);\n        \n        // Inner glow - orange-white plasma\n        const innerGlowGeometry = new THREE.CylinderGeometry(3, 3, distance, 8);\n        const innerGlowMaterial = new THREE.MeshBasicMaterial({\n            color: isHit ? 0xffaa00 : 0xff8800, // Orange for hits, red-orange for misses\n            transparent: true,\n            opacity: 0.6,\n            blending: THREE.AdditiveBlending\n        });\n        const innerGlowMesh = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);\n        \n        // Outer glow - cooler blue-cyan edge\n        const outerGlowGeometry = new THREE.CylinderGeometry(5, 5, distance, 6);\n        const outerGlowMaterial = new THREE.MeshBasicMaterial({\n            color: isHit ? 0x00ffff : 0x0088ff, // Cyan for hits, blue for misses\n            transparent: true,\n            opacity: 0.3,\n            blending: THREE.AdditiveBlending\n        });\n        const outerGlowMesh = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);\n        \n        // Add all layers to the group\n        beamGroup.add(coreMesh);\n        beamGroup.add(innerGlowMesh);\n        beamGroup.add(outerGlowMesh);\n        \n        // Position and orient the entire beam group\n        const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);\n        beamGroup.position.copy(midpoint);\n        \n        // Orient the cylinders along the beam direction\n        const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();\n        const quaternion = new THREE.Quaternion();\n        quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);\n        beamGroup.quaternion.copy(quaternion);\n        \n        if (addToScene) {\n            addToScene(beamGroup);\n        }\n        \n        // Store beam data for progressive fade animation\n        beamGroup.userData = {\n            startTime: performance.now(),\n            fadeTime: fadeTime * 1000,\n            beamLength: distance,\n            startPos: startPos.clone(),\n            endPos: endPos.clone(),\n            direction: direction.clone(),\n            coreMesh: coreMesh,\n            innerGlowMesh: innerGlowMesh,\n            outerGlowMesh: outerGlowMesh,\n            initialCoreOpacity: 1.0,\n            initialInnerOpacity: 0.6,\n            initialOuterOpacity: 0.3,\n            isDissolving: false\n        };\n        \n        // Add to active tracers list for update loop\n        this.activeTracers.push(beamGroup);\n        \n        return beamGroup;\n    }\n\n    /**\n     * Update active tracer beams - fade them out from start to end\n     * @param {number} _deltaTime Time since last update\n     * @param {Function} removeFromScene Function to remove objects from scene\n     */\n    updateTracers(_deltaTime: number, removeFromScene: ((obj: THREE.Object3D) => void) | null = null) {\n        if (!this.activeTracers || this.activeTracers.length === 0) return;\n        \n        const currentTime = performance.now();\n        const tracersToRemove: number[] = [];\n        \n        for (let i = this.activeTracers.length - 1; i >= 0; i--) {\n            const beamGroup = this.activeTracers[i];\n            const userData = beamGroup.userData;\n            \n            if (!userData) continue;\n            \n            const elapsed = currentTime - userData.startTime;\n            const fadeProgress = Math.min(elapsed / userData.fadeTime, 1.0);\n            \n            if (fadeProgress >= 1.0) {\n                // Remove entire beam group\n                if (removeFromScene) {\n                    removeFromScene(beamGroup);\n                }\n                tracersToRemove.push(i);\n            } else {\n                // Progressive dissolve from start to end\n                // The beam shortens from the start point toward the end point\n                const dissolveDistance = userData.beamLength * fadeProgress;\n                \n                // Calculate new start position (moves toward end as it dissolves)\n                const newStartOffset = userData.direction.clone().multiplyScalar(dissolveDistance);\n                const newStartPos = userData.startPos.clone().add(newStartOffset);\n                \n                // Calculate new beam length\n                const newLength = userData.beamLength * (1.0 - fadeProgress);\n                \n                if (newLength > 0.1) {\n                    // Update beam geometry to be shorter\n                    // We need to recreate the cylinders with new height\n                    userData.coreMesh.geometry.dispose();\n                    userData.innerGlowMesh.geometry.dispose();\n                    userData.outerGlowMesh.geometry.dispose();\n                    \n                    userData.coreMesh.geometry = new THREE.CylinderGeometry(1.5, 1.5, newLength, 12);\n                    userData.innerGlowMesh.geometry = new THREE.CylinderGeometry(3, 3, newLength, 8);\n                    userData.outerGlowMesh.geometry = new THREE.CylinderGeometry(5, 5, newLength, 6);\n                    \n                    // Update position to new midpoint\n                    const newMidpoint = new THREE.Vector3().addVectors(newStartPos, userData.endPos).multiplyScalar(0.5);\n                    beamGroup.position.copy(newMidpoint);\n                    \n                    // Also fade opacity slightly as it dissolves\n                    const opacityFactor = Math.pow(1.0 - fadeProgress, 0.3); // Slower opacity fade\n                    userData.coreMesh.material.opacity = userData.initialCoreOpacity * opacityFactor;\n                    userData.innerGlowMesh.material.opacity = userData.initialInnerOpacity * opacityFactor;\n                    userData.outerGlowMesh.material.opacity = userData.initialOuterOpacity * opacityFactor;\n                }\n            }\n        }\n        \n        // Remove completed tracers from the array\n        // Sort indices in descending order to avoid splicing issues\n        tracersToRemove.sort((a, b) => b - a);\n        for (const index of tracersToRemove) {\n            this.activeTracers.splice(index, 1);\n        }\n    }\n\n    /**\n     * Clean up explosion effects resources\n     */\n    dispose(): void {\n        this.activeTracers = [];\n    }\n}\n","/**\n * Material Manager Module\n * \n * Handles initialization and management of combat effect materials\n */\n\nimport * as THREE from 'three';\n\nexport class MaterialManager {\n    scene: THREE.Scene;\n    projectileMaterial: THREE.MeshStandardMaterial;\n    projectileGlowMaterial: THREE.MeshBasicMaterial;\n    trailParticleMaterial: THREE.MeshBasicMaterial;\n    muzzleFlashMaterial: THREE.MeshBasicMaterial;\n    tracerLineMaterial: THREE.LineBasicMaterial;\n    pointLightMaterial: THREE.MeshBasicMaterial;\n    explosionParticleMaterial: THREE.PointsMaterial;\n\n    constructor(scene: THREE.Scene) {\n        this.scene = scene;\n        // Initialize with dummy values to satisfy TS, then real values in initializeTemplateMaterials\n        this.projectileMaterial = {} as any;\n        this.projectileGlowMaterial = {} as any;\n        this.trailParticleMaterial = {} as any;\n        this.muzzleFlashMaterial = {} as any;\n        this.tracerLineMaterial = {} as any;\n        this.pointLightMaterial = {} as any;\n        this.explosionParticleMaterial = {} as any;\n\n        this.initializeTemplateMaterials();\n    }\n\n    /**\n     * Initialize template materials to prevent shader compilation stutter during first fire\n     */\n    initializeTemplateMaterials(): void {\n        console.log(\"Initializing template materials for combat effects\");\n        \n        // Template for projectile material (MeshStandardMaterial) - Red Laser Bolt\n        this.projectileMaterial = new THREE.MeshStandardMaterial({\n            color: 0xff0000,\n            emissive: 0xff0000,\n            emissiveIntensity: 10, // Vibrant laser\n            metalness: 0.5,\n            roughness: 0.5\n        });\n        \n        // Template for projectile glow material (MeshBasicMaterial) - Red Glow\n        this.projectileGlowMaterial = new THREE.MeshBasicMaterial({\n            color: 0xff0000,\n            transparent: true,\n            opacity: 0.5, // Softer glow\n            blending: THREE.AdditiveBlending\n        });\n        \n        // Template for trail particle material (MeshBasicMaterial) - Red (Though complex trail is removed)\n        this.trailParticleMaterial = new THREE.MeshBasicMaterial({\n            color: 0xff0000,\n            transparent: true,\n            opacity: 0.9,\n            blending: THREE.AdditiveBlending\n        });\n        \n        // Template for muzzle flash material (MeshBasicMaterial) - Red Muzzle Flash\n        this.muzzleFlashMaterial = new THREE.MeshBasicMaterial({\n            color: 0xff0000,\n            transparent: true,\n            opacity: 0.8, // Brighter flash\n            blending: THREE.AdditiveBlending,\n            side: THREE.DoubleSide,\n            depthWrite: false,\n            wireframe: false\n        });\n        \n        // Template for tracer line material (LineBasicMaterial) - Red Aiming Line\n        this.tracerLineMaterial = new THREE.LineBasicMaterial({\n            color: 0xff0000,\n            transparent: true,\n            opacity: 0.8, // More visible aiming line\n            blending: THREE.AdditiveBlending\n        });\n        \n        // Template material for light-halo meshes (basic unlit glow)\n        this.pointLightMaterial = new THREE.MeshBasicMaterial({\n            color: 0xff0000,\n            transparent: true,\n            opacity: 0.9,\n            blending: THREE.AdditiveBlending,\n            depthWrite: false\n        });\n        \n        // Template for explosion particles - Red/Orange Impact\n        this.explosionParticleMaterial = new THREE.PointsMaterial({\n            color: 0xff3300, // Red-orange for impact\n            size: 15, // Slightly larger impact particles\n            transparent: true,\n            opacity: 1,\n            blending: THREE.AdditiveBlending\n        });\n        \n        // Force material compilation by creating a small invisible mesh\n        this.precompileShaders();\n    }\n\n    /**\n     * Pre-compile shaders to prevent stutter during combat\n     */\n    precompileShaders(): void {\n        // Force material compilation by creating a small invisible mesh\n        // This ensures shaders are compiled immediately rather than at first fire\n        const dummyGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 8);\n        const cylinderGeometry = new THREE.CylinderGeometry(0.1, 0.2, 1, 8, 1);\n        const pointsPositions = new Float32Array(30); // 10 points x 3 coordinates\n        for (let i = 0; i < 30; i++) {\n            pointsPositions[i] = Math.random() - 0.5;\n        }\n        const pointsGeometry = new THREE.BufferGeometry();\n        pointsGeometry.setAttribute('position', new THREE.BufferAttribute(pointsPositions, 3));\n        \n        // Create dummy objects using all materials that will be used in projectiles\n        // IMPORTANT: Use the original material instances, not clones, for pre-compilation.\n        const dummyProjectile = new THREE.Mesh(sphereGeometry, this.projectileMaterial);\n        const dummyGlow = new THREE.Mesh(sphereGeometry, this.projectileGlowMaterial);\n        const dummyTrail = new THREE.Mesh(sphereGeometry, this.trailParticleMaterial);\n        const dummyFlash = new THREE.Mesh(cylinderGeometry, this.muzzleFlashMaterial);\n        const dummyTracer = new THREE.Line(\n            new THREE.BufferGeometry().setFromPoints([\n                new THREE.Vector3(0, 0, 0),\n                new THREE.Vector3(0, 0, 1)\n            ]),\n            this.tracerLineMaterial\n        );\n        const dummyExplosion = new THREE.Points(pointsGeometry, this.explosionParticleMaterial);\n        \n        // Create a dummy trail system with multiple particles\n        const dummyTrailContainer = new THREE.Object3D();\n        for (let i = 0; i < 5; i++) {\n            const trailParticle = new THREE.Mesh(sphereGeometry, this.trailParticleMaterial.clone());\n            trailParticle.position.z = -i * 0.2;\n            dummyTrailContainer.add(trailParticle);\n        }\n        \n        // Create a temporary scene for shader compilation\n        const tempScene = new THREE.Scene();\n        \n        // Add all dummy objects to the temporary scene\n        tempScene.add(dummyProjectile);\n        tempScene.add(dummyGlow);\n        tempScene.add(dummyTrail);\n        tempScene.add(dummyFlash);\n        tempScene.add(dummyTracer);\n        tempScene.add(dummyTrailContainer);\n        tempScene.add(dummyExplosion);\n        \n        // Add to main scene temporarily for visibility checking via renderer facade\n        const addToScene = this._getAddToSceneFunction();\n        const removeFromScene = this._getRemoveFromSceneFunction();\n        \n        addToScene(dummyProjectile);\n        addToScene(dummyGlow);\n        addToScene(dummyTrail);\n        addToScene(dummyFlash);\n        addToScene(dummyTracer);\n        addToScene(dummyTrailContainer);\n        addToScene(dummyExplosion);\n        \n        // Force shader compilation using renderer.compile if available\n        if ((window as any).renderer) {\n            console.log(\"Forcing shader compilation with renderer.compile()\");\n            (window as any).renderer.compile(tempScene, (this.scene as any).camera || { isCamera: true, matrixWorldInverse: new THREE.Matrix4() });\n            (window as any).renderer.compile(this.scene, (this.scene as any).camera || { isCamera: true, matrixWorldInverse: new THREE.Matrix4() });\n        } else if ((window as any).game && (window as any).game.renderer && (window as any).game.renderer.renderer) {\n            console.log(\"Forcing shader compilation with game.renderer.renderer.compile()\");\n            (window as any).game.renderer.renderer.compile(tempScene, (this.scene as any).camera || (window as any).game.camera || { isCamera: true, matrixWorldInverse: new THREE.Matrix4() });\n            (window as any).game.renderer.renderer.compile(this.scene, (this.scene as any).camera || (window as any).game.camera || { isCamera: true, matrixWorldInverse: new THREE.Matrix4() });\n        } else {\n            console.warn(\"No renderer available for shader pre-compilation\");\n        }\n        \n        // Keep dummy objects in scene longer to ensure compilation completes\n        setTimeout(() => {\n            // Remove from scene after shader compilation is complete via renderer facade\n            removeFromScene(dummyProjectile);\n            removeFromScene(dummyGlow);\n            removeFromScene(dummyTrail);\n            removeFromScene(dummyFlash);\n            removeFromScene(dummyTracer);\n            removeFromScene(dummyTrailContainer);\n            removeFromScene(dummyExplosion);\n            \n            // Clean up temporary objects\n            dummyGeometry.dispose();\n            sphereGeometry.dispose();\n            cylinderGeometry.dispose();\n            pointsGeometry.dispose();\n            \n            // Clean up trail particles\n            dummyTrailContainer.children.forEach(child => {\n                if ((child as any).geometry) (child as any).geometry.dispose();\n                if ((child as any).material) (child as any).material.dispose(); // Material here is a clone, original is on this.trailParticleMaterial\n            });\n            \n            console.log(\"Template materials initialized and dummy objects removed\");\n        }, 500); // Increased timeout to 500ms to ensure shader compilation completes\n    }\n\n    /**\n     * Get material by type\n     */\n    getMaterial(type: string): THREE.Material | null {\n        switch (type) {\n            case 'projectile': return this.projectileMaterial;\n            case 'projectileGlow': return this.projectileGlowMaterial;\n            case 'trailParticle': return this.trailParticleMaterial;\n            case 'muzzleFlash': return this.muzzleFlashMaterial;\n            case 'tracerLine': return this.tracerLineMaterial;\n            case 'pointLight': return this.pointLightMaterial;\n            case 'explosionParticle': return this.explosionParticleMaterial;\n            default: return null;\n        }\n    }\n\n    /**\n     * Helper to get add to scene function\n     */\n    _getAddToSceneFunction(): (object: THREE.Object3D) => void {\n        const renderer = (window as any).game && (window as any).game.renderer ? (window as any).game.renderer : null;\n        if (renderer && typeof renderer._withGuard === 'function') {\n            return (object: THREE.Object3D) => renderer._withGuard(() => renderer.add(object));\n        } else if (this.scene && typeof this.scene.add === 'function') {\n            return (object: THREE.Object3D) => this.scene.add(object);\n        }\n        return () => {};\n    }\n\n    /**\n     * Helper to get remove from scene function\n     */\n    _getRemoveFromSceneFunction(): (object: THREE.Object3D) => void {\n        const renderer = (window as any).game && (window as any).game.renderer ? (window as any).game.renderer : null;\n        if (renderer && typeof renderer._withGuard === 'function') {\n            return (object: THREE.Object3D) => renderer._withGuard(() => this.scene.remove(object));\n        } else if (this.scene && typeof this.scene.remove === 'function') {\n            return (object: THREE.Object3D) => this.scene.remove(object);\n        }\n        return () => {};\n    }\n\n    /**\n     * Clean up material resources\n     */\n    dispose(): void {\n        // Dispose materials\n        if (this.projectileMaterial) this.projectileMaterial.dispose();\n        if (this.projectileGlowMaterial) this.projectileGlowMaterial.dispose();\n        if (this.trailParticleMaterial) this.trailParticleMaterial.dispose();\n        if (this.muzzleFlashMaterial) this.muzzleFlashMaterial.dispose();\n        if (this.tracerLineMaterial) this.tracerLineMaterial.dispose();\n        if (this.pointLightMaterial) this.pointLightMaterial.dispose();\n        if (this.explosionParticleMaterial) this.explosionParticleMaterial.dispose();\n\n        console.log(\"Material resources disposed\");\n    }\n}\n","/**\n * Geometry Manager Module\n * \n * Handles pre-creation and management of geometries for combat effects\n */\n\nimport * as THREE from 'three';\n\nexport class GeometryManager {\n    constructor() {\n        this.precreateGeometries();\n    }\n\n    /**\n     * Pre-create geometries that will be reused across projectiles and effects\n     * This prevents geometry creation during combat which can cause stutters\n     */\n    precreateGeometries(): void {\n        console.log(\"Pre-creating geometries for combat effects\");\n        \n        // Create geometries and store them on window.game for global access\n        const game = (window as any).game || ((window as any).game = {});\n        \n        // Projectile geometries - Changed to a thin cylinder for laser bolt\n        game.projectileGeometry = new THREE.CylinderGeometry(0.15, 0.15, 10, 8); // Thin, 10 units long cylinder\n        game.projectileGlowGeometry = new THREE.SphereGeometry(0.8, 12, 12); // Glow radius around the bolt\n        \n        // Pre-create standard muzzle flash geometry\n        game.muzzleFlashGeometry = new THREE.CylinderGeometry(0.5, 2, 15, 12, 1, true);\n        game.muzzleFlashGeometry.rotateX(Math.PI / 2);\n        game.muzzleFlashGeometry.translate(0, 0, 15 / 2);\n        \n        // Pre-create trail particle geometries with different sizes\n        game.trailParticleGeometries = [];\n        const numPoints = 20; // Same as in addProjectileTrail\n        for (let i = 0; i < numPoints; i++) {\n            const ratio = i / numPoints;\n            const size = 0.5 * (1 - ratio); // These might be unused or repurposed for simple impact sparks\n            game.trailParticleGeometries[i] = new THREE.SphereGeometry(size, 8, 8);\n        }\n        \n        // Pre-create line geometry for tracers\n        game.tracerGeometry = new THREE.BufferGeometry();\n        const points = [0, 0, 0, 0, 0, 1]; // Will be updated at runtime\n        game.tracerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));\n        \n        console.log(\"Combat geometries pre-created successfully\");\n    }\n\n    /**\n     * Store references to template materials on window.game\n     * @param {any} materialManager - The material manager instance\n     */\n    storeMaterialReferences(materialManager: any): void {\n        // Store references to template materials (which should now be pre-warmed)\n        // These materials are created and warmed in MaterialManager\n        const game = (window as any).game || ((window as any).game = {});\n        game.projectileMaterial = materialManager.projectileMaterial;\n        game.projectileGlowMaterial = materialManager.projectileGlowMaterial;\n        game.trailParticleMaterial = materialManager.trailParticleMaterial; // Will be red\n        game.muzzleFlashMaterial = materialManager.muzzleFlashMaterial;\n        game.tracerLineMaterial = materialManager.tracerLineMaterial;\n        game.explosionParticleMaterial = materialManager.explosionParticleMaterial; // Added for consistency\n    }\n\n    /**\n     * Clean up geometry resources\n     */\n    dispose(): void {\n        const game = (window as any).game;\n        if (game) {\n            if (game.projectileGeometry) game.projectileGeometry.dispose();\n            if (game.projectileGlowGeometry) game.projectileGlowGeometry.dispose();\n            if (game.muzzleFlashGeometry) game.muzzleFlashGeometry.dispose();\n            if (game.trailParticleGeometries) {\n                game.trailParticleGeometries.forEach((geom: THREE.BufferGeometry) => geom.dispose());\n            }\n            if (game.tracerGeometry) game.tracerGeometry.dispose();\n        }\n        console.log(\"Geometry resources disposed\");\n    }\n}\n","/**\n * Projectile Effects Module\n * \n * Handles muzzle flashes, trails, and aiming tracers for projectiles\n */\n\nimport * as THREE from 'three';\n\nexport class ProjectileEffects {\n    constructor() {\n        // No state needed - all effects are pooled\n    }\n\n    /**\n     * Create a laser burst effect that travels forward with the projectile\n     * @param {THREE.Vector3} position Position for the effect\n     * @param {THREE.Vector3} direction Direction the effect should travel\n     * @param {Object} poolManager Pool manager for getting muzzle flash objects\n     */\n    createMuzzleFlash(position: THREE.Vector3, direction: THREE.Vector3, poolManager: any) {\n        if (!poolManager) {\n            console.warn(\"No pool manager available for muzzle flash\");\n            return null;\n        }\n\n        // Get a muzzle flash from the pool\n        const muzzleFlash = poolManager.getMuzzleFlash();\n        \n        // Position and orient the flash\n        muzzleFlash.position.copy(position);\n        // Orient the flash to point away from the ship, along the direction of fire\n        const lookAtPosition = position.clone().add(direction.clone().normalize().multiplyScalar(10)); // Look 10 units along direction\n        muzzleFlash.lookAt(lookAtPosition);\n        \n        // Store reference to initial position and direction for animation\n        muzzleFlash.userData.initialPosition = position.clone();\n        muzzleFlash.userData.direction = direction.clone();\n        \n        // Set up the flash light\n        const flashLight = muzzleFlash.userData.flashLight;\n        if (flashLight) {\n            flashLight.position.copy(position);\n            flashLight.intensity = 200;\n        }\n        \n        // The pool manager will automatically handle animation and cleanup via its update method\n        // which checks the progress and releases back to the pool when complete\n        \n        return muzzleFlash;\n    }\n\n    /**\n     * Add a dynamic particle trail to a projectile (Simplified for Lasers)\n     * @param {THREE.Mesh} projectile The projectile mesh\n     * @param {THREE.Vector3} direction Direction of travel\n     * @param {Object} poolManager Pool manager for getting trail components\n     */\n    addProjectileTrail(projectile: THREE.Mesh, direction: THREE.Vector3, poolManager: any): void {\n        // Parameters for a subtle, short trail\n        const numPoints = 4; // Number of particles in the trail\n        const trailLength = 4.0; // Total length of the trail (shorter than laser bolt length for subtlety)\n        const particleLifetime = 150; // milliseconds\n\n        if (!poolManager) {\n            console.warn(\"PoolManager not available for projectile trail.\");\n            return;\n        }\n\n        const trailContainer = poolManager.getTrailContainer();\n        if (!trailContainer) {\n            console.warn(\"Failed to get trail container from pool.\");\n            return;\n        }\n        projectile.add(trailContainer);\n\n        const trailParticles: THREE.Mesh[] = [];\n        trailContainer.userData.particles = trailParticles; // Store for release by PoolManager if needed\n        trailContainer.userData.isTrailActive = true; // Flag for animation loop\n\n        for (let i = 0; i < numPoints; i++) {\n            const ratio = i / (numPoints -1); // Distribute particles along the trail length\n            const trailGeometries = (window as any).game?.trailParticleGeometries as unknown[] | undefined;\n            const geometryIndex = trailGeometries && trailGeometries.length > 0 ? i % trailGeometries.length : 0;\n            const particle = poolManager.getTrailParticle(geometryIndex); // Cycle through available geometries\n            \n            if (!particle) {\n                console.warn(`Failed to get trail particle ${i} from pool.`);\n                continue;\n            }\n\n            const offset = direction.clone().multiplyScalar(-ratio * trailLength - 2.0); // Start trail slightly behind the projectile tip\n            particle.position.copy(offset);\n            \n            particle.userData.creationTime = performance.now();\n            particle.userData.initialOpacity = particle.material.opacity; // Should be from pre-warmed red material\n            particle.userData.initialScale = particle.scale.x; // Assuming uniform scale\n            \n            trailContainer.add(particle);\n            trailParticles.push(particle);\n        }\n        \n        projectile.userData.trail = trailContainer; // For cleanup by PoolManager\n\n        const animateTrail = () => {\n            if (!projectile.parent || !trailContainer.userData.isTrailActive) {\n                // Projectile removed or trail explicitly deactivated, stop animation and ensure cleanup\n                trailContainer.userData.isTrailActive = false;\n                // Particles will be cleaned up by releaseProjectile -> releaseTrail if not already done\n                return;\n            }\n\n            for (let i = trailParticles.length - 1; i >= 0; i--) {\n                const particle = trailParticles[i];\n                const elapsed = performance.now() - particle.userData.creationTime;\n                const progress = Math.min(elapsed / particleLifetime, 1.0);\n\n                if (progress >= 1.0) {\n                    poolManager.releaseTrailParticle(particle);\n                    trailParticles.splice(i, 1);\n                    if (particle.parent) particle.parent.remove(particle); // Ensure removal from container\n                } else {\n                    (particle.material as THREE.Material).opacity = particle.userData.initialOpacity * (1 - progress);\n                    const currentScale = particle.userData.initialScale * (1 - progress);\n                    particle.scale.set(currentScale, currentScale, currentScale);\n                }\n            }\n\n            if (trailParticles.length === 0) {\n                trailContainer.userData.isTrailActive = false; // All particles expired\n                // The container itself will be released when the projectile is released.\n                return;\n            }\n            \n            requestAnimationFrame(animateTrail);\n        };\n        \n        animateTrail();\n    }\n\n    /**\n     * New method to visualize projectile trajectory\n     * @param {THREE.Vector3} startPosition Starting position of the aiming line\n     * @param {THREE.Vector3} direction Direction the line should point\n     * @param {number} distance Distance of the aiming line\n     * @param {Object} poolManager Pool manager for getting tracer objects\n     */\n    createAimingTracer(startPosition: THREE.Vector3, direction: THREE.Vector3, distance: number = 3000, poolManager: any) {\n        if (!poolManager) {\n            console.warn(\"No pool manager available for aiming tracer\");\n            return null;\n        }\n\n        // Get a tracer from the pool\n        const tracer = poolManager.getTracer();\n        \n        // Calculate end position\n        const endPosition = startPosition.clone().add(direction.clone().multiplyScalar(distance));\n        \n        // Update the positions in the geometry\n        const positions = (tracer.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;\n        positions[0] = startPosition.x;\n        positions[1] = startPosition.y;\n        positions[2] = startPosition.z;\n        positions[3] = endPosition.x;\n        positions[4] = endPosition.y;\n        positions[5] = endPosition.z;\n        \n        // Mark the position attribute as needing update\n        tracer.geometry.attributes.position.needsUpdate = true;\n        \n        // The pool manager will automatically handle animation and cleanup\n        \n        return tracer;\n    }\n}\n","/**\n * Effects Module - Handles trail/instancing/vfx glue to rendering\n * \n * This module contains all visual effects logic including material initialization,\n * explosions, tracers, muzzle flashes, and particle effects.\n */\n\nimport * as THREE from 'three';\nimport { ExplosionEffects } from './effects/explosionEffects.js';\nimport { MaterialManager } from './effects/materialManager.js';\nimport { GeometryManager } from './effects/geometryManager.js';\nimport { ProjectileEffects } from './effects/projectileEffects.js';\n\nexport class EffectsManager {\n    scene: THREE.Scene;\n    materialManager: any;\n    geometryManager: any;\n    explosionEffects: any;\n    projectileEffects: any;\n\n    constructor(scene: THREE.Scene) {\n        this.scene = scene;\n        \n        // Initialize sub-managers\n        this.materialManager = new MaterialManager(scene);\n        this.geometryManager = new GeometryManager();\n        this.explosionEffects = new ExplosionEffects();\n        this.projectileEffects = new ProjectileEffects();\n        \n        // Store material references on window.game\n        this.geometryManager.storeMaterialReferences(this.materialManager);\n    }\n\n\n    /**\n     * Create an explosion effect at the given position\n     * @param {THREE.Vector3} position Position for the explosion\n     * @param {number} duration Duration of the explosion in milliseconds\n     * @param {boolean} isVisible Whether the explosion should be visible\n     */\n    createExplosionEffect(position: THREE.Vector3, duration: number = 1000, isVisible: boolean = true, poolManager: any = null) {\n        return this.explosionEffects.createExplosionEffect(position, duration, isVisible, poolManager, this._addToScene.bind(this));\n    }\n\n    /**\n     * Create an instant plasma beam with hot glow\n     * @param {THREE.Vector3} startPos Starting position of the beam\n     * @param {THREE.Vector3} endPos End position of the beam (hit point or max range)\n     * @param {boolean} isHit Whether this beam hit a target\n     * @param {number} fadeTime Time in seconds for the beam to fade\n     */\n    createInstantTracer(startPos: THREE.Vector3, endPos: THREE.Vector3, isHit: boolean = false, fadeTime: number = 0.5) {\n        return this.explosionEffects.createInstantTracer(startPos, endPos, isHit, fadeTime, this._addToScene.bind(this));\n    }\n\n    /**\n     * Update active tracer beams - fade them out from start to end\n     * @param {number} deltaTime Time since last update\n     */\n    updateTracers(deltaTime: number) {\n        this.explosionEffects.updateTracers(deltaTime, this._removeFromScene.bind(this));\n    }\n\n    /**\n     * Create a laser burst effect that travels forward with the projectile\n     * @param {THREE.Vector3} position Position for the effect\n     * @param {THREE.Vector3} direction Direction the effect should travel\n     */\n    createMuzzleFlash(position: THREE.Vector3, direction: THREE.Vector3, poolManager: any) {\n        return this.projectileEffects.createMuzzleFlash(position, direction, poolManager);\n    }\n\n    /**\n     * Add a dynamic particle trail to a projectile (Simplified for Lasers)\n     * @param {THREE.Mesh} projectile The projectile mesh\n     * @param {THREE.Vector3} direction Direction of travel\n     * @param {Object} poolManager Pool manager for getting trail components\n     */\n    addProjectileTrail(projectile: THREE.Mesh, direction: THREE.Vector3, poolManager: any) {\n        this.projectileEffects.addProjectileTrail(projectile, direction, poolManager);\n    }\n\n    /**\n     * New method to visualize projectile trajectory\n     */\n    createAimingTracer(startPosition: THREE.Vector3, direction: THREE.Vector3, distance: number = 3000, poolManager: any) {\n        return this.projectileEffects.createAimingTracer(startPosition, direction, distance, poolManager);\n    }\n\n    /**\n     * Get material by type\n     */\n    getMaterial(type: string) {\n        return this.materialManager.getMaterial(type);\n    }\n\n    // --- Renderer facade helpers to centralize scene mutations ---\n    _addToScene(object: THREE.Object3D) {\n        const renderer = (window as any).game && (window as any).game.renderer ? (window as any).game.renderer : null;\n        if (renderer && typeof renderer._withGuard === 'function') {\n            renderer._withGuard(() => renderer.add(object));\n        } else if (this.scene && typeof this.scene.add === 'function') {\n            // Fallback for safety; may warn in dev via guard wrapper\n            this.scene.add(object);\n        }\n    }\n\n    _removeFromScene(object: THREE.Object3D) {\n        const renderer = (window as any).game && (window as any).game.renderer ? (window as any).game.renderer : null;\n        if (renderer && typeof renderer._withGuard === 'function') {\n            renderer._withGuard(() => this.scene.remove(object));\n        } else if (this.scene && typeof this.scene.remove === 'function') {\n            // Fallback for safety\n            this.scene.remove(object);\n        }\n    }\n\n    /**\n     * Clean up all effects resources\n     */\n    dispose() {\n        // Dispose sub-managers\n        this.explosionEffects.dispose();\n        this.materialManager.dispose();\n        this.geometryManager.dispose();\n\n        console.log(\"Effects resources disposed\");\n    }\n}\n","/**\n * AI and Spawners Module - Handles enemy pool and spawner management\n * \n * This module contains all logic for configuring the enemy system,\n * registering/unregistering enemies, and handling spawner state.\n */\n\nexport class AISpawnerManager {\n    enemySystem: any = null;\n\n    constructor() {\n    }\n\n    /**\n     * Configure the enemy system with pool sizes and other settings\n     */\n    configureEnemySystem(enemySystem: any): void {\n        this.enemySystem = enemySystem;\n        \n        // Settings could be passed from a config module in the future\n        if (enemySystem && typeof enemySystem.configure === 'function') {\n            enemySystem.configure({\n                maxEnemies: 50,\n                spawnRate: 0.5, // enemies per second\n                poolEnabled: true\n            });\n            console.log(\"[COMBAT] Enemy system configured with maxEnemies: 50\");\n        }\n    }\n\n    /**\n     * Register an enemy entity for synchronization with EnemySystem\n     */\n    registerEnemy(enemyId: string): void {\n        if (!this.enemySystem) return;\n        \n        if (typeof this.enemySystem.registerEnemy === 'function') {\n            this.enemySystem.registerEnemy(enemyId);\n        }\n    }\n\n    /**\n     * Unregister an enemy entity\n     */\n    unregisterEnemy(enemyId: string): void {\n        if (!this.enemySystem) return;\n        \n        if (typeof this.enemySystem.unregisterEnemy === 'function') {\n            this.enemySystem.unregisterEnemy(enemyId);\n        }\n    }\n\n    /**\n     * Emergency cleanup for all spawners and enemies\n     */\n    emergencyCleanup(): void {\n        if (!this.enemySystem) return;\n        \n        if (typeof this.enemySystem.cleanupAll === 'function') {\n            this.enemySystem.cleanupAll();\n        }\n    }\n}\n","/**\n * Combat Logic Module - Handles particle cannon firing and raycasting\n * \n * This module contains the core combat logic for firing weapons,\n * performing raycasts, and applying damage to entities.\n */\n\nimport * as THREE from 'three';\n\nexport class CombatLogic {\n    effectsManager: any;\n    eventManager: any;\n    aiSpawnerManager: any;\n    raycaster: THREE.Raycaster;\n\n    constructor(effectsManager: any, eventManager: any, aiSpawnerManager: any) {\n        this.effectsManager = effectsManager;\n        this.eventManager = eventManager;\n        this.aiSpawnerManager = aiSpawnerManager;\n        \n        // Raycaster for weapon fire\n        this.raycaster = new THREE.Raycaster();\n    }\n\n    /**\n     * Fire the particle cannon with instant raycast damage\n     */\n    fireParticleCannon(scene: THREE.Scene, spaceship: any, world: any, _playerEntity: any, damage: number, lastFireTime: number, cooldown: number) {\n        const now = performance.now();\n        \n        // Rate limiting\n        if (now - lastFireTime < cooldown) {\n            return { newLastFireTime: lastFireTime, success: false };\n        }\n        \n        // Skip if no scene or spaceship\n        if (!scene || !spaceship || !spaceship.mesh) {\n            return { newLastFireTime: lastFireTime, success: false };\n        }\n        \n        // Get firing position and direction\n        const startPos = new THREE.Vector3();\n        spaceship.mesh.getWorldPosition(startPos);\n        \n        const direction = new THREE.Vector3(0, 0, -1);\n        direction.applyQuaternion(spaceship.mesh.quaternion);\n        \n        // Set raycaster\n        this.raycaster.set(startPos, direction);\n        this.raycaster.far = 2000; // Max range for particle cannon\n        \n        // Find all meshes to hit (enemies)\n        // Optimization: only check objects in a specific group or with a specific tag\n        const hitObjects: THREE.Object3D[] = [];\n        scene.traverse((obj) => {\n            if (obj instanceof THREE.Mesh && obj !== spaceship.mesh && obj.visible) {\n                // Heuristic: only hit enemies or asteroids\n                if (obj.name && (obj.name.includes('enemy') || obj.name.includes('asteroid'))) {\n                    hitObjects.push(obj);\n                } else if ((obj as any).userData && (obj as any).userData.entityId) {\n                    hitObjects.push(obj);\n                }\n            }\n        });\n        \n        const intersects = this.raycaster.intersectObjects(hitObjects);\n        \n        let endPos = startPos.clone().add(direction.clone().multiplyScalar(2000));\n        let hitEntityId = null;\n        \n        if (intersects.length > 0) {\n            const hit = intersects[0];\n            endPos = hit.point;\n            \n            // Try to find entity ID from userData\n            if (hit.object.userData && hit.object.userData.entityId) {\n                hitEntityId = hit.object.userData.entityId;\n                \n                // Apply damage via event if world exists\n                if (world && world.messageBus) {\n                    world.messageBus.publish('entity.damage', {\n                        entityId: hitEntityId,\n                        damage: damage,\n                        source: 'player',\n                        hitPoint: hit.point,\n                        hitNormal: hit.face ? hit.face.normal : null\n                    });\n                }\n            }\n            \n            // Create impact effect\n            if (this.effectsManager) {\n                this.effectsManager.createExplosionEffect(hit.point, 500, true);\n            }\n        }\n        \n        // Create visual tracer beam\n        if (this.effectsManager) {\n            this.effectsManager.createInstantTracer(startPos, endPos, hitEntityId !== null);\n            \n            // Create muzzle flash\n            this.effectsManager.createMuzzleFlash(startPos, direction);\n        }\n        \n        // Play sound\n        if ((window as any).game && (window as any).game.audio) {\n            (window as any).game.audio.playWeaponSound();\n        }\n\n        // Trigger camera recoil and gamepad rumble\n        if ((window as any).mainMessageBus) {\n            // Publish event for camera recoil (e.g., 'weapon.fire')\n            (window as any).mainMessageBus.publish('weapon.fire', {\n                type: 'projectile', // Weapon type for recoil scaling (projectile, laser, heavy)\n                direction: direction.clone(), // Pass the firing direction\n            });\n            (window as any).mainMessageBus.publish('input.vibrate', { intensity: 0.3, duration: 50 });\n        }\n        \n        return { newLastFireTime: now, success: true };\n    }\n}\n","/**\n * Combat module - Handles all combat-related functionality\n * \n * This module manages particle cannon firing and combat logic.\n * \n * REFACTORED: This module now uses submodules for better organization:\n * - worldSetup.js: ECS World construction and scene setup\n * - registerSystems.js: System registration in deterministic order\n * - events.js: Event subscriptions and MessageBus interactions\n * - effects.js: Visual effects, materials, and rendering helpers\n * - aiAndSpawners.js: Enemy pool/spawner management\n */\n\nimport { WorldSetup } from './combat/worldSetup.js';\nimport { SystemRegistrar } from './combat/registerSystems.js';\nimport { EventManager } from './combat/events.js';\nimport { EffectsManager } from './combat/effects.js';\nimport { AISpawnerManager } from './combat/aiAndSpawners.js';\nimport { CombatLogic } from './combat/combatLogic.js';\nimport * as THREE from 'three';\n\n// Define interfaces for submodules until they are converted\ninterface IWorldSetup {\n    initializeECSWorld(scene: THREE.Scene, spaceship: any): Promise<any>;\n    isWorldInitialized(): boolean;\n    getPlayerEntity(): any;\n    setSceneReference(scene: THREE.Scene): void;\n    initializeWorld(): void;\n    createPlayerReferenceEntity(spaceship: any): Promise<any>;\n    updatePlayerReference(spaceship: any): void;\n    updateSpaceshipHealth(spaceship: any): void;\n    setWorldInitialized(): void;\n    getWorld(): any;\n}\n\ninterface ISystemRegistrar {\n    registerAllSystems(world: any, scene: THREE.Scene): Promise<any>;\n    setSystemsEnabled(enabled: boolean): void;\n    importAndRegisterSystem(path: string, className: string, world: any, scene: THREE.Scene): Promise<any>;\n}\n\ninterface IEventManager {\n    setupEventHandlers(world: any, playerEntity: any): void;\n    cleanup(): void;\n}\n\ninterface IEffectsManager {\n    updateTracers(deltaTime: number): void;\n    createExplosionEffect(position: THREE.Vector3, duration: number, isVisible: boolean, arg3: null): any;\n    createAimingTracer(startPosition: THREE.Vector3, direction: THREE.Vector3, distance: number, arg3: null): any;\n    createMuzzleFlash(position: THREE.Vector3, direction: THREE.Vector3, arg3: null): any;\n    dispose(): void;\n}\n\ninterface IAISpawnerManager {\n    configureEnemySystem(enemySystem: any): void;\n    registerEnemy(enemyId: string): void;\n    unregisterEnemy(enemyId: string): void;\n    emergencyCleanup(): void;\n}\n\ninterface ICombatLogic {\n    fireParticleCannon(\n        scene: THREE.Scene,\n        spaceship: any,\n        world: any,\n        playerEntity: any,\n        particleCannonDamage: number,\n        lastFireTime: number,\n        cooldown: number\n    ): { newLastFireTime: number, success: boolean };\n}\n\nexport class Combat {\n    scene: THREE.Scene;\n    spaceship: any;\n    fireRate: number;\n    lastFireTime: number;\n    aimingSpread: number;\n    isFiring: boolean;\n    cooldown: number;\n    particleCannonDamage: number;\n    \n    worldSetup: IWorldSetup;\n    systemRegistrar: ISystemRegistrar;\n    eventManager: IEventManager;\n    effectsManager: IEffectsManager;\n    aiSpawnerManager: IAISpawnerManager;\n    combatLogic: ICombatLogic;\n    \n    world: any;\n    playerEntity: any;\n    enemySystem: any;\n    disposed: boolean = false;\n\n    constructor(scene: THREE.Scene, spaceship: any) {\n        this.scene = scene;\n        this.spaceship = spaceship;\n        \n        // Tuned these parameters for better gameplay\n        this.fireRate = 3; // shots per second\n        \n        // Track the last time we fired for rate limiting\n        this.lastFireTime = 0;\n        \n        // Reference size for spread calculation\n        this.aimingSpread = 0.05;\n        \n        // Weapon properties\n        this.isFiring = false;\n        this.cooldown = 1000 / this.fireRate; // milliseconds between shots\n        \n        // Combat properties\n        this.particleCannonDamage = 20; // Standard damage per particle cannon hit\n        \n        // Initialize submodules\n        this.worldSetup = new WorldSetup();\n        this.systemRegistrar = new SystemRegistrar();\n        this.eventManager = new EventManager();\n        this.effectsManager = new EffectsManager(scene);\n        this.aiSpawnerManager = new AISpawnerManager();\n        this.combatLogic = new CombatLogic(this.effectsManager, this.eventManager, this.aiSpawnerManager);\n        \n        // Pool manager removed - projectile system not in use\n        \n        // Initialize ECS world for advanced combat systems\n        this.initializeECSWorld();\n        \n    }\n    \n    // Material and geometry initialization moved to EffectsManager\n    \n    /**\n     * Initialize the ECS world asynchronously\n     * This is called from the constructor and runs in the background\n     */\n    async initializeECSWorld() {\n        try {\n            \n            // Use world setup module\n            this.world = await this.worldSetup.initializeECSWorld(this.scene, this.spaceship);\n            \n            // Continue with full world setup\n            await this.setupECSWorld();\n            \n        } catch (error) {\n            console.error(\"[COMBAT] Error initializing ECS world:\", error);\n        }\n    }\n    \n    /**\n     * Set up the ECS world and register combat systems\n     */\n    async setupECSWorld() {\n        // Skip if world was already set up\n        if (this.worldSetup.isWorldInitialized()) {\n            return;\n        }\n        \n        try {\n            // Register all systems using the system registrar\n            const systems = await this.systemRegistrar.registerAllSystems(this.world, this.scene);\n            \n            // Store system references for backwards compatibility\n            Object.assign(this, systems);\n            \n            // Set up event handlers\n            this.eventManager.setupEventHandlers(this.world, this.worldSetup.getPlayerEntity());\n            \n            // Set scene reference for cross-system access\n            this.worldSetup.setSceneReference(this.scene);\n            \n            // Initialize the world\n            this.worldSetup.initializeWorld();\n            \n            // Create/update player reference entity\n            this.playerEntity = await this.worldSetup.createPlayerReferenceEntity(this.spaceship);\n            \n            // Configure enemy system\n            if (this.enemySystem) {\n                this.aiSpawnerManager.configureEnemySystem(this.enemySystem);\n            }\n            \n            // Mark world as initialized\n            this.worldSetup.setWorldInitialized();\n            \n        } catch (error) {\n            console.error(\"[COMBAT] Error setting up ECS world:\", error);\n        }\n    }\n    \n    // Player entity creation moved to WorldSetup module\n    \n    /**\n     * Update combat systems and handle firing logic\n     * @param {number} deltaTime Time since last update in seconds\n     */\n    update(deltaTime: number) {\n        // Skip if disabled\n        if (!this.scene || !this.spaceship) return;\n        \n        // Skip enemy updates if intro sequence is active\n        const introActive = (window as any).game && (window as any).game.introSequenceActive;\n        \n        // Update the player reference entity position\n        this.updatePlayerReference();\n        \n        // Update the spaceship health from ECS\n        this.updateSpaceshipHealth();\n        \n        \n        // Update active tracer beams\n        this.effectsManager.updateTracers(deltaTime);\n        \n        // Pooled visual effects removed - using instant raycast only\n        \n        // Handle firing weapons\n        if (this.isFiring && !this.spaceship.isDocked) {\n            this.fireParticleCannon();\n        }\n        \n        // Update the ECS world with the current delta time\n        if (this.world && !introActive) {\n            this.world.update(deltaTime);\n        } else if (this.world && introActive) {\n            // During intro, only update non-enemy systems\n            if (this.world.systems) {\n                for (const system of this.world.systems) {\n                    // Skip enemy systems when intro is active\n                    const systemType = system.type || system.constructor.name;\n                    if (systemType !== 'EnemySystem' &&\n                        systemType !== 'EnemyAISystem') {\n                        system.update(deltaTime);\n                    }\n                }\n            }\n        } else if (!this.world) {\n            // World not initialized yet\n        }\n    }\n    \n    /**\n     * Update the player reference entity with the current spaceship position\n     */\n    updatePlayerReference() {\n        this.worldSetup.updatePlayerReference(this.spaceship);\n    }\n    \n    /**\n     * Sync the spaceship hull/shield with the player entity's HealthComponent\n     */\n    updateSpaceshipHealth() {\n        this.worldSetup.updateSpaceshipHealth(this.spaceship);\n    }\n    \n    \n    /**\n     * Set firing state for the particle cannon\n     * @param {boolean} isFiring Whether the cannon should be firing\n     */\n    setFiring(isFiring: boolean) {\n        this.isFiring = isFiring;\n    }\n    \n    /**\n     * Create an explosion effect at the given position\n     * @param {THREE.Vector3} position Position for the explosion\n     * @param {number} duration Duration of the explosion in milliseconds\n     * @param {boolean} isVisible Whether the explosion should be visible\n     */\n    createExplosionEffect(position: THREE.Vector3, duration: number = 1000, isVisible: boolean = true) {\n        return this.effectsManager.createExplosionEffect(position, duration, isVisible, null);\n    }\n    \n    // Tracer update logic moved to EffectsManager\n    \n    /**\n     * Register an enemy entity for synchronization with EnemySystem\n     * @param {string} enemyId ID of the enemy entity\n     */\n    registerEnemy(enemyId: string) {\n        this.aiSpawnerManager.registerEnemy(enemyId);\n    }\n    \n    /**\n     * Unregister an enemy entity\n     * @param {string} enemyId ID of the enemy entity\n     */\n    unregisterEnemy(enemyId: string) {\n        this.aiSpawnerManager.unregisterEnemy(enemyId);\n    }\n    \n    /**\n     * Fire the particle cannon with instant raycast damage\n     */\n    fireParticleCannon() {\n        const result = this.combatLogic.fireParticleCannon(\n            this.scene, \n            this.spaceship, \n            this.world, \n            this.playerEntity, \n            this.particleCannonDamage, \n            this.lastFireTime, \n            this.cooldown\n        );\n        \n        // Update last fire time\n        this.lastFireTime = result.newLastFireTime;\n        \n        return result.success;\n    }\n    \n    \n    /**\n     * Enable or disable all combat systems\n     * @param {boolean} enabled Whether combat systems should be enabled\n     */\n    setEnabled(enabled: boolean) {\n        \n        // Use system registrar to enable/disable systems\n        this.systemRegistrar.setSystemsEnabled(enabled);\n    }\n    \n    \n    // Aiming tracer creation moved to EffectsManager\n    createAimingTracer(startPosition: THREE.Vector3, direction: THREE.Vector3, distance: number = 3000) {\n        return this.effectsManager.createAimingTracer(startPosition, direction, distance, null);\n    }\n    \n    /**\n     * Create a laser burst effect that travels forward with the projectile\n     * @param {THREE.Vector3} position Position for the effect\n     * @param {THREE.Vector3} direction Direction the effect should travel\n     */\n    createMuzzleFlash(position: THREE.Vector3, direction: THREE.Vector3) {\n        return this.effectsManager.createMuzzleFlash(position, direction, null);\n    }\n    \n    /**\n     * Dispose Combat module resources\n     * Clean up all pools, geometries, and other resources\n     */\n    dispose() {\n\n        // Projectile system removed\n        \n        // Dispose submodules\n        if (this.effectsManager) {\n            this.effectsManager.dispose();\n        }\n        \n        if (this.eventManager) {\n            this.eventManager.cleanup();\n        }\n        \n        if (this.aiSpawnerManager) {\n            this.aiSpawnerManager.emergencyCleanup();\n        }\n        \n        // Mark as disposed\n        this.disposed = true;\n        \n    }\n\n    /**\n     * Import and register a system\n     * @param {string} path The path to the system module\n     * @param {string} className The name of the system class\n     * @returns {Object} The system instance\n     */\n    async importAndRegisterSystem(path: string, className: string) {\n        return this.systemRegistrar.importAndRegisterSystem(path, className, this.world, this.scene);\n    }\n}\n"],"file":"assets/combat-oJGfwFeG.js"}