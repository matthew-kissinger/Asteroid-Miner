{"version":3,"file":"core-CQR7b8gS.js","sources":["../../js/core/events.js","../../js/core/messageBus.js"],"sourcesContent":["// events.js - typed events enum + optional dev validation\r\n\r\nexport const EVENT = Object.freeze({\r\n  GAME_OVER: 'game.over',\r\n  PLAYER_CREATED: 'player.created',\r\n  TRANSFORM_UPDATED: 'transform.updated',\r\n  VFX_EXPLOSION: 'vfx.explosion',\r\n  MINING_START: 'player.mining.start',\r\n  MINING_STOP: 'player.mining.stop',\r\n  ENEMY_DESTROYED: 'enemy.destroyed',\r\n  WEAPON_FIRED: 'weapon.fired',\r\n});\r\n\r\nconst SCHEMA = {\r\n  [EVENT.GAME_OVER]: { reason: 'string' },\r\n  [EVENT.PLAYER_CREATED]: { entity: 'object' },\r\n  [EVENT.TRANSFORM_UPDATED]: { entity: 'object' },\r\n  [EVENT.VFX_EXPLOSION]: { position: 'object', color: 'number', size: 'number', duration: 'number' },\r\n  [EVENT.MINING_START]: { sourceEntity: 'object', targetEntity: 'object' },\r\n  [EVENT.MINING_STOP]: { sourceEntity: 'object' },\r\n  [EVENT.ENEMY_DESTROYED]: { entityId: 'string' },\r\n  [EVENT.WEAPON_FIRED]: { entity: 'object' },\r\n};\r\n\r\nexport function validateEventPayload(type, data) {\r\n  if (!window || !window.DEBUG_MODE) return true;\r\n  const shape = SCHEMA[type];\r\n  if (!shape) return true;\r\n  if (typeof data !== 'object' || data == null) return warn(type, 'payload is not object');\r\n  for (const [key, t] of Object.entries(shape)) {\r\n    const v = data[key];\r\n    if (t === 'object') {\r\n      if (typeof v !== 'object' || v == null) return warn(type, `field ${key} must be object`);\r\n    } else if (typeof v !== t) {\r\n      return warn(type, `field ${key} must be ${t}`);\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction warn(type, msg) {\r\n  console.warn(`[EVENT VALIDATION] ${type}: ${msg}`);\r\n  return false;\r\n}\r\n\r\n\r\n","/**\r\n * MessageBus - Event system for decoupled communication between systems\r\n * \r\n * The MessageBus enables systems to communicate without direct references\r\n * by publishing and subscribing to specific message types.\r\n */\r\n\r\nimport { validateEventPayload } from './events.js';\r\n\r\nexport class MessageBus {\r\n    constructor() {\r\n        this.listeners = new Map();\r\n        this.queuedMessages = [];\r\n        this.dispatching = false;\r\n        \r\n        // High-frequency message types to minimize logging\r\n        this.highFrequencyTypes = new Set([\r\n            'transform.updated',\r\n            'physics.update',\r\n            'render.update'\r\n        ]);\r\n        \r\n        // Store this instance in a global registry for emergency access\r\n        if (!window.messageRegistry) {\r\n            window.messageRegistry = new Set();\r\n        }\r\n        window.messageRegistry.add(this);\r\n        \r\n        // Always ensure that mainMessageBus is set - critically important for game over events\r\n        if (!window.mainMessageBus) {\r\n            window.mainMessageBus = this;\r\n        } else if (window.mainMessageBus !== this) {\r\n            // If this is not the main message bus, make sure game.over events are \r\n            // forwarded to the main message bus for centralized handling\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Register a listener for a message type\r\n     * @param {string} messageType The message type to listen for\r\n     * @param {Function} callback Function to call when message is published\r\n     * @param {Object} context Context to use when calling the callback\r\n     * @returns {Function} Unsubscribe function\r\n     */\r\n    subscribe(messageType, callback, context = null) {\r\n        if (!this.listeners.has(messageType)) {\r\n            this.listeners.set(messageType, []);\r\n        }\r\n        \r\n        this.listeners.get(messageType).push({\r\n            callback,\r\n            context\r\n        });\r\n        \r\n        // Return unsubscribe function for convenience\r\n        return () => this.unsubscribe(messageType, callback, context);\r\n    }\r\n    \r\n    /**\r\n     * Remove a listener\r\n     * @param {string} messageType The message type to unsubscribe from\r\n     * @param {Function} callback The callback to remove\r\n     * @param {Object} context The context used when subscribing\r\n     */\r\n    unsubscribe(messageType, callback, context = null) {\r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        const listeners = this.listeners.get(messageType);\r\n        const index = listeners.findIndex(listener => \r\n            listener.callback === callback && listener.context === context);\r\n            \r\n        if (index !== -1) {\r\n            listeners.splice(index, 1);\r\n        }\r\n        \r\n        if (listeners.length === 0) {\r\n            this.listeners.delete(messageType);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Fast publish for high-frequency events with minimal overhead\r\n     * @param {string} messageType The message type to publish\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    fastPublish(messageType, data = {}) {\r\n        // Typed event validation in dev\r\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        const listeners = this.listeners.get(messageType);\r\n        const messageObj = {\r\n            type: messageType,\r\n            data: data,\r\n            timestamp: Date.now()\r\n        };\r\n        \r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const listener = listeners[i];\r\n            listener.callback.call(listener.context, messageObj);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Send a message immediately\r\n     * @param {string} messageType The message type to publish\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    publish(messageType, data = {}) {\r\n        // Typed event validation in dev\r\n        try { validateEventPayload && validateEventPayload(messageType, data); } catch {}\r\n        // Use fast path for high-frequency messages\r\n        if (this.highFrequencyTypes.has(messageType)) {\r\n            return this.fastPublish(messageType, data);\r\n        }\r\n        \r\n        \r\n        // Enhanced handling for game.over events to ensure they are properly processed\r\n        if (messageType === 'game.over') {\r\n            // Always forward game.over events to the main message bus if this isn't it\r\n            if (window.mainMessageBus && window.mainMessageBus !== this) {\r\n                window.mainMessageBus.publish(messageType, data);\r\n                return; // Let the main message bus handle it\r\n            }\r\n            \r\n            // Only proceed if we have listeners or we are the main message bus\r\n            if (!this.listeners.has(messageType)) {\r\n                // Verify main game instance\r\n                if (window.game) {\r\n                    // Try to directly call gameOver as a last resort\r\n                    window.game.gameOver(data.reason || \"Unknown reason\");\r\n                } \r\n                \r\n                return;\r\n            }\r\n        }\r\n        \r\n        if (!this.listeners.has(messageType)) return;\r\n        \r\n        // If we're already dispatching, queue this message\r\n        if (this.dispatching) {\r\n            this.queuedMessages.push({ type: messageType, data });\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            // Set flag to prevent nested dispatch issues\r\n            this.dispatching = true;\r\n            \r\n            const listeners = this.listeners.get(messageType);\r\n            listeners.forEach((listener, index) => {\r\n                try {\r\n                    \r\n                    listener.callback.call(listener.context, {\r\n                        type: messageType,\r\n                        data: data,\r\n                        timestamp: Date.now()\r\n                    });\r\n                    \r\n                } catch (error) {\r\n                    \r\n                }\r\n            });\r\n        } finally {\r\n            // Always clear the dispatching flag, even if an error occurs\r\n            this.dispatching = false;\r\n            \r\n            // Process any queued messages\r\n            if (this.queuedMessages.length > 0) {\r\n                const queuedMessages = [...this.queuedMessages];\r\n                this.queuedMessages = [];\r\n                \r\n                queuedMessages.forEach(message => {\r\n                    this.publish(message.type, message.data);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Queue a message for next update\r\n     * @param {string} messageType The message type to queue\r\n     * @param {Object} data Data to include with the message\r\n     */\r\n    queue(messageType, data = {}) {\r\n        this.queuedMessages.push({\r\n            type: messageType,\r\n            data: data\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Universal handler for game over events - used by multiple components\r\n     * @param {string} reason Reason for game over\r\n     * @param {string} source Source of the game over event\r\n     */\r\n    static triggerGameOver(reason, source) {\r\n        \r\n        // Try to find a message bus to use - prioritization order for reliability\r\n        let messageBusToUse = null;\r\n        \r\n        // Use window.mainMessageBus if available (highest priority)\r\n        if (window.mainMessageBus) {\r\n            messageBusToUse = window.mainMessageBus;\r\n        }\r\n        // Use window.game.messageBus if available and mainMessageBus not found\r\n        else if (window.game && window.game.messageBus) {\r\n            messageBusToUse = window.game.messageBus;\r\n        } \r\n        \r\n        // Check if we found a message bus to use\r\n        if (messageBusToUse) {\r\n            // Publish the event\r\n            messageBusToUse.publish('game.over', {\r\n                reason: reason,\r\n                source: source\r\n            });\r\n        }\r\n    }\r\n}"],"names":[],"mappings":"AAEO,MAAM,QAAQ,OAAO,OAAO;AAAA,EACjC,WAAW;AAAA,EACX,gBAAgB;AAAA,EAChB,mBAAmB;AAAA,EACnB,eAAe;AAAA,EACf,cAAc;AAAA,EACd,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,cAAc;AAChB,CAAC;AAED,MAAM,SAAS;AAAA,EACb,CAAC,MAAM,SAAS,GAAG,EAAE,QAAQ,SAAU;AAAA,EACvC,CAAC,MAAM,cAAc,GAAG,EAAE,QAAQ,SAAU;AAAA,EAC5C,CAAC,MAAM,iBAAiB,GAAG,EAAE,QAAQ,SAAU;AAAA,EAC/C,CAAC,MAAM,aAAa,GAAG,EAAE,UAAU,UAAU,OAAO,UAAU,MAAM,UAAU,UAAU,SAAU;AAAA,EAClG,CAAC,MAAM,YAAY,GAAG,EAAE,cAAc,UAAU,cAAc,SAAU;AAAA,EACxE,CAAC,MAAM,WAAW,GAAG,EAAE,cAAc,SAAU;AAAA,EAC/C,CAAC,MAAM,eAAe,GAAG,EAAE,UAAU,SAAU;AAAA,EAC/C,CAAC,MAAM,YAAY,GAAG,EAAE,QAAQ,SAAU;AAC5C;AAEO,SAAS,qBAAqB,MAAM,MAAM;AAC/C,MAAI,CAAC,UAAU,CAAC,OAAO,WAAY,QAAO;AAC1C,QAAM,QAAQ,OAAO,IAAI;AACzB,MAAI,CAAC,MAAO,QAAO;AACnB,MAAI,OAAO,SAAS,YAAY,QAAQ,KAAM,QAAO,KAAK,MAAM,uBAAuB;AACvF,aAAW,CAAC,KAAK,CAAC,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC5C,UAAM,IAAI,KAAK,GAAG;AAClB,QAAI,MAAM,UAAU;AAClB,UAAI,OAAO,MAAM,YAAY,KAAK,KAAM,QAAO,KAAK,MAAM,SAAS,GAAG,iBAAiB;AAAA,IAC7F,WAAe,OAAO,MAAM,GAAG;AACzB,aAAO,KAAK,MAAM,SAAS,GAAG,YAAY,CAAC,EAAE;AAAA,IAC9C;AAAA,EACF;AACD,SAAO;AACT;AAEA,SAAS,KAAK,MAAM,KAAK;AACvB,UAAQ,KAAK,sBAAsB,IAAI,KAAK,GAAG,EAAE;AACjD,SAAO;AACT;AClCO,MAAM,WAAW;AAAA,EACpB,cAAc;AACV,SAAK,YAAY,oBAAI;AACrB,SAAK,iBAAiB;AACtB,SAAK,cAAc;AAGnB,SAAK,qBAAqB,oBAAI,IAAI;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,IACZ,CAAS;AAGD,QAAI,CAAC,OAAO,iBAAiB;AACzB,aAAO,kBAAkB,oBAAI;IAChC;AACD,WAAO,gBAAgB,IAAI,IAAI;AAG/B,QAAI,CAAC,OAAO,gBAAgB;AACxB,aAAO,iBAAiB;AAAA,IAI3B;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,UAAU,aAAa,UAAU,UAAU,MAAM;AAC7C,QAAI,CAAC,KAAK,UAAU,IAAI,WAAW,GAAG;AAClC,WAAK,UAAU,IAAI,aAAa,CAAE,CAAA;AAAA,IACrC;AAED,SAAK,UAAU,IAAI,WAAW,EAAE,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,IACZ,CAAS;AAGD,WAAO,MAAM,KAAK,YAAY,aAAa,UAAU,OAAO;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,YAAY,aAAa,UAAU,UAAU,MAAM;AAC/C,QAAI,CAAC,KAAK,UAAU,IAAI,WAAW,EAAG;AAEtC,UAAM,YAAY,KAAK,UAAU,IAAI,WAAW;AAChD,UAAM,QAAQ,UAAU,UAAU,cAC9B,SAAS,aAAa,YAAY,SAAS,YAAY,OAAO;AAElE,QAAI,UAAU,IAAI;AACd,gBAAU,OAAO,OAAO,CAAC;AAAA,IAC5B;AAED,QAAI,UAAU,WAAW,GAAG;AACxB,WAAK,UAAU,OAAO,WAAW;AAAA,IACpC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,YAAY,aAAa,OAAO,IAAI;AAEhC,QAAI;AAAE,8BAAwB,qBAAqB,aAAa,IAAI;AAAA,IAAI,QAAO;AAAA,IAAE;AACjF,QAAI,CAAC,KAAK,UAAU,IAAI,WAAW,EAAG;AAEtC,UAAM,YAAY,KAAK,UAAU,IAAI,WAAW;AAChD,UAAM,aAAa;AAAA,MACf,MAAM;AAAA,MACN;AAAA,MACA,WAAW,KAAK,IAAK;AAAA,IACjC;AAEQ,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,YAAM,WAAW,UAAU,CAAC;AAC5B,eAAS,SAAS,KAAK,SAAS,SAAS,UAAU;AAAA,IACtD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,QAAQ,aAAa,OAAO,IAAI;AAE5B,QAAI;AAAE,8BAAwB,qBAAqB,aAAa,IAAI;AAAA,IAAI,QAAO;AAAA,IAAE;AAEjF,QAAI,KAAK,mBAAmB,IAAI,WAAW,GAAG;AAC1C,aAAO,KAAK,YAAY,aAAa,IAAI;AAAA,IAC5C;AAID,QAAI,gBAAgB,aAAa;AAE7B,UAAI,OAAO,kBAAkB,OAAO,mBAAmB,MAAM;AACzD,eAAO,eAAe,QAAQ,aAAa,IAAI;AAC/C;AAAA,MACH;AAGD,UAAI,CAAC,KAAK,UAAU,IAAI,WAAW,GAAG;AAElC,YAAI,OAAO,MAAM;AAEb,iBAAO,KAAK,SAAS,KAAK,UAAU,gBAAgB;AAAA,QACvD;AAED;AAAA,MACH;AAAA,IACJ;AAED,QAAI,CAAC,KAAK,UAAU,IAAI,WAAW,EAAG;AAGtC,QAAI,KAAK,aAAa;AAClB,WAAK,eAAe,KAAK,EAAE,MAAM,aAAa,KAAI,CAAE;AACpD;AAAA,IACH;AAED,QAAI;AAEA,WAAK,cAAc;AAEnB,YAAM,YAAY,KAAK,UAAU,IAAI,WAAW;AAChD,gBAAU,QAAQ,CAAC,UAAU,UAAU;AACnC,YAAI;AAEA,mBAAS,SAAS,KAAK,SAAS,SAAS;AAAA,YACrC,MAAM;AAAA,YACN;AAAA,YACA,WAAW,KAAK,IAAK;AAAA,UAC7C,CAAqB;AAAA,QAEJ,SAAQ,OAAO;AAAA,QAEf;AAAA,MACjB,CAAa;AAAA,IACb,UAAkB;AAEN,WAAK,cAAc;AAGnB,UAAI,KAAK,eAAe,SAAS,GAAG;AAChC,cAAM,iBAAiB,CAAC,GAAG,KAAK,cAAc;AAC9C,aAAK,iBAAiB;AAEtB,uBAAe,QAAQ,aAAW;AAC9B,eAAK,QAAQ,QAAQ,MAAM,QAAQ,IAAI;AAAA,QAC3D,CAAiB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,MAAM,aAAa,OAAO,IAAI;AAC1B,SAAK,eAAe,KAAK;AAAA,MACrB,MAAM;AAAA,MACN;AAAA,IACZ,CAAS;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,OAAO,gBAAgB,QAAQ,QAAQ;AAGnC,QAAI,kBAAkB;AAGtB,QAAI,OAAO,gBAAgB;AACvB,wBAAkB,OAAO;AAAA,IAC5B,WAEQ,OAAO,QAAQ,OAAO,KAAK,YAAY;AAC5C,wBAAkB,OAAO,KAAK;AAAA,IACjC;AAGD,QAAI,iBAAiB;AAEjB,sBAAgB,QAAQ,aAAa;AAAA,QACjC;AAAA,QACA;AAAA,MAChB,CAAa;AAAA,IACJ;AAAA,EACJ;AACL;"}