class h{constructor(i=2048){this.capacity=i,this.count=0,this.pos=new Float32Array(i*3),this.vel=new Float32Array(i*3),this.alive=new Uint8Array(i),this.idToIndex=new Map,this.indexToProjectile=new Array(i)}_allocIndex(){return this.count>=this.capacity?-1:this.count++}register(i){const t=this._allocIndex();if(t===-1)return-1;this.idToIndex.set(i.uuid||i.id||t,t),this.indexToProjectile[t]=i,this.alive[t]=1;const s=i.position;this.pos[t*3+0]=s.x,this.pos[t*3+1]=s.y,this.pos[t*3+2]=s.z;const e=i.velocity||{x:0,y:0,z:0};return this.vel[t*3+0]=e.x,this.vel[t*3+1]=e.y,this.vel[t*3+2]=e.z,t}unregisterByIndex(i){i<0||i>=this.count||(this.alive[i]=0,this.indexToProjectile[i]=null)}unregister(i){const t=i.uuid||i.id;if(t==null)return;const s=this.idToIndex.get(t);s!=null&&(this.alive[s]=0,this.indexToProjectile[s]=null,this.idToIndex.delete(t))}update(i){const t=this.count;for(let s=0;s<t;s++){if(!this.alive[s])continue;const e=s*3;this.pos[e+0]+=this.vel[e+0]*i,this.pos[e+1]+=this.vel[e+1]*i,this.pos[e+2]+=this.vel[e+2]*i;const n=this.indexToProjectile[s];n&&n.position&&n.position.set(this.pos[e+0],this.pos[e+1],this.pos[e+2])}}}export{h as OptimizedProjectileStore};
//# sourceMappingURL=OptimizedProjectileStore-83fvI2Yz.js.map
