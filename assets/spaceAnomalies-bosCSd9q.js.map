{"version":3,"file":"spaceAnomalies-bosCSd9q.js","sources":["../../js/modules/environment/anomalies/vortex.ts","../../js/modules/environment/anomalies/crystalCluster.ts","../../js/modules/environment/anomalies/nebulaNexus.ts","../../js/modules/environment/anomalies/quantumFlux.ts","../../js/modules/environment/anomalies/darkMatter.ts","../../js/modules/environment/anomalies/anomalyRegistry.ts","../../js/modules/environment/spaceAnomalies.ts"],"sourcesContent":["// vortex.ts - Vortex anomaly with spiraling rings\n\nimport * as THREE from 'three';\n\ninterface RingData {\n    mesh: THREE.Mesh;\n    rotationSpeed: {\n        x: number;\n        y: number;\n        z: number;\n    };\n}\n\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ninterface VortexAnomalyData {\n    type: 'vortex';\n    mesh: THREE.Group;\n    position: THREE.Vector3;\n    rings: RingData[];\n    orb: EnergyOrbData;\n    collisionRadius: number;\n    orbCollected: boolean;\n    rotationSpeed: THREE.Vector3;\n}\n\nexport class VortexAnomaly {\n    private anomalyScale: number;\n\n    constructor(_scene: THREE.Scene, anomalyScale: number = 4, _orbScale: number = 4) {\n        this.anomalyScale = anomalyScale;\n    }\n\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: (rarity: string) => EnergyOrbData,\n        getRandomOrbRarityCallback: () => string,\n        addToSceneCallback: (object: THREE.Object3D) => void\n    ): VortexAnomalyData {\n        // Create a spiraling vortex structure with central orb\n        const anomalyGroup = new THREE.Group();\n        anomalyGroup.position.copy(position);\n\n        // Apply scale to make anomaly 4x bigger\n        anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);\n\n        // Create the structural elements - spiral rings\n        const ringCount: number = 6;\n        const rings: RingData[] = [];\n\n        // Create multiple rings with decreasing radius\n        for (let i = 0; i < ringCount; i++) {\n            const radius: number = 400 - (i * 50);\n            const geometry = new THREE.TorusGeometry(radius, 15, 16, 100); // Increased tube radius from 10 to 15\n\n            // Bright blue-cyan color scheme for better visibility\n            const hue: number = 0.5 + (i * 0.05); // Blue to cyan gradient\n            const color = new THREE.Color().setHSL(hue, 0.9, 0.6); // Increased saturation and lightness\n\n            const material = new THREE.MeshStandardMaterial({\n                color: color,\n                emissive: color.clone().multiplyScalar(0.5),\n                emissiveIntensity: 1.0,\n                metalness: 0.8,\n                roughness: 0.2,\n                transparent: true,\n                opacity: 0.95\n            });\n\n            const ring = new THREE.Mesh(geometry, material);\n\n            // Rotate each ring at different angles to create spiral effect\n            ring.rotation.x = Math.PI / 2 + (i * 0.2);\n            ring.rotation.y = i * 0.3;\n\n            anomalyGroup.add(ring);\n            rings.push({\n                mesh: ring,\n                rotationSpeed: {\n                    x: 0.005 + (i * 0.002),\n                    y: 0.003 + (i * 0.001),\n                    z: 0.001 + (i * 0.0005)\n                }\n            });\n        }\n\n        // Create energy orb in the center\n        const orbRarity: string = getRandomOrbRarityCallback();\n        const orb = createEnergyOrbCallback(orbRarity);\n        anomalyGroup.add(orb.mesh);\n\n        // Add to scene\n        addToSceneCallback(anomalyGroup);\n\n        // Return anomaly data\n        return {\n            type: 'vortex',\n            mesh: anomalyGroup,\n            position: position.clone(),\n            rings: rings,\n            orb: orb,\n            collisionRadius: 350, // Overall collision size\n            orbCollected: false,\n            rotationSpeed: new THREE.Vector3(0.001, 0.002, 0.0015)\n        };\n    }\n\n    update(anomaly: VortexAnomalyData, deltaTime: number): void {\n        // Rotate each ring\n        anomaly.rings.forEach((ring: RingData) => {\n            ring.mesh.rotation.x += ring.rotationSpeed.x * deltaTime;\n            ring.mesh.rotation.y += ring.rotationSpeed.y * deltaTime;\n            ring.mesh.rotation.z += ring.rotationSpeed.z * deltaTime;\n        });\n    }\n\n    cleanup(anomaly: VortexAnomalyData): void {\n        // Clean up rings\n        if (anomaly.rings) {\n            anomaly.rings.forEach((ring: RingData) => {\n                if (ring.mesh && ring.mesh.geometry) {\n                    ring.mesh.geometry.dispose();\n                }\n                if (ring.mesh && ring.mesh.material) {\n                    if (Array.isArray(ring.mesh.material)) {\n                        ring.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (ring.mesh.material as THREE.Material).dispose();\n                    }\n                }\n            });\n        }\n    }\n}\n","// crystalCluster.ts - Crystal cluster anomaly with floating crystals\n\nimport * as THREE from 'three';\n\ninterface CrystalData {\n    mesh: THREE.Mesh;\n    initialPosition: THREE.Vector3;\n    floatPhase: number;\n    floatSpeed: number;\n    floatAmplitude: number;\n    rotationSpeed: {\n        x: number;\n        y: number;\n        z: number;\n    };\n}\n\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ninterface CrystalClusterAnomalyData {\n    type: 'crystalCluster';\n    mesh: THREE.Group;\n    position: THREE.Vector3;\n    crystals: CrystalData[];\n    orb: EnergyOrbData;\n    collisionRadius: number;\n    orbCollected: boolean;\n    rotationSpeed: THREE.Vector3;\n}\n\nexport class CrystalClusterAnomaly {\n    private anomalyScale: number;\n\n    constructor(_scene: THREE.Scene, anomalyScale: number = 4, _orbScale: number = 4) {\n        this.anomalyScale = anomalyScale;\n    }\n\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: (rarity: string) => EnergyOrbData,\n        getRandomOrbRarityCallback: () => string,\n        addToSceneCallback: (object: THREE.Object3D) => void\n    ): CrystalClusterAnomalyData {\n        // Create a crystalline structure with floating crystals and central orb\n        const anomalyGroup = new THREE.Group();\n        anomalyGroup.position.copy(position);\n\n        // Apply scale to make anomaly 4x bigger\n        anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);\n\n        // Create main crystal structure using multiple crystal forms\n        const crystals: CrystalData[] = [];\n        const crystalCount: number = 20;\n\n        for (let i = 0; i < crystalCount; i++) {\n            // Random crystal size\n            const size: number = 50 + Math.random() * 100; // Increased from 30+80 to 50+100\n\n            // Create crystal geometry - mix of different polyhedra\n            let geometry: THREE.BufferGeometry;\n            const crystalType: number = Math.floor(Math.random() * 3);\n\n            if (crystalType === 0) {\n                // Octahedron - diamond-like crystal\n                geometry = new THREE.OctahedronGeometry(size, 0);\n            } else if (crystalType === 1) {\n                // Dodecahedron - more complex crystal\n                geometry = new THREE.DodecahedronGeometry(size, 0);\n            } else {\n                // Prism-like crystal using stretched tetrahedron\n                geometry = new THREE.TetrahedronGeometry(size, 0);\n\n                // Stretch it to make it more crystal-like\n                const positions = geometry.attributes.position;\n                for (let j = 0; j < positions.count; j++) {\n                    const vertex = new THREE.Vector3();\n                    vertex.fromBufferAttribute(positions, j);\n\n                    // Stretch along one axis\n                    vertex.y *= 2.5;\n\n                    positions.setXYZ(j, vertex.x, vertex.y, vertex.z);\n                }\n                geometry.computeVertexNormals();\n            }\n\n            // Create a semi-transparent crystalline material with bright teal colors\n            const hue: number = 0.45 + Math.random() * 0.1; // Teal/aqua/green color palette\n            const saturation: number = 0.9 + Math.random() * 0.1; // Increased saturation\n            const lightness: number = 0.6 + Math.random() * 0.2; // Increased lightness\n\n            const color = new THREE.Color().setHSL(hue, saturation, lightness);\n\n            const material = new THREE.MeshStandardMaterial({\n                color: color,\n                metalness: 0.9,\n                roughness: 0.1,\n                transparent: true,\n                opacity: 0.9,\n                emissive: color.clone(),\n                emissiveIntensity: 0.5\n            });\n\n            const crystal = new THREE.Mesh(geometry, material);\n\n            // Position crystal in a spherical arrangement\n            const radius: number = 200 + Math.random() * 100;\n            const theta: number = Math.random() * Math.PI * 2;\n            const phi: number = Math.random() * Math.PI;\n\n            crystal.position.set(\n                radius * Math.sin(phi) * Math.cos(theta),\n                radius * Math.sin(phi) * Math.sin(theta),\n                radius * Math.cos(phi)\n            );\n\n            // Random rotation\n            crystal.rotation.set(\n                Math.random() * Math.PI * 2,\n                Math.random() * Math.PI * 2,\n                Math.random() * Math.PI * 2\n            );\n\n            anomalyGroup.add(crystal);\n\n            // Store crystal data for animation\n            crystals.push({\n                mesh: crystal,\n                initialPosition: crystal.position.clone(),\n                floatPhase: Math.random() * Math.PI * 2,\n                floatSpeed: 0.3 + Math.random() * 0.3,\n                floatAmplitude: 5 + Math.random() * 10,\n                rotationSpeed: {\n                    x: (Math.random() - 0.5) * 0.01,\n                    y: (Math.random() - 0.5) * 0.01,\n                    z: (Math.random() - 0.5) * 0.01\n                }\n            });\n        }\n\n        // Create energy orb in the center\n        const orbRarity: string = getRandomOrbRarityCallback();\n        const orb = createEnergyOrbCallback(orbRarity);\n        anomalyGroup.add(orb.mesh);\n\n        // Add to scene\n        addToSceneCallback(anomalyGroup);\n\n        // Return anomaly data\n        return {\n            type: 'crystalCluster',\n            mesh: anomalyGroup,\n            position: position.clone(),\n            crystals: crystals,\n            orb: orb,\n            collisionRadius: 300, // Overall collision size\n            orbCollected: false,\n            rotationSpeed: new THREE.Vector3(0.0005, 0.001, 0.0005)\n        };\n    }\n\n    update(anomaly: CrystalClusterAnomalyData, deltaTime: number): void {\n        // Animate floating crystals\n        anomaly.crystals.forEach((crystal: CrystalData) => {\n            // Update float phase\n            crystal.floatPhase += deltaTime * crystal.floatSpeed;\n\n            // Create floating motion\n            const floatOffset: number = Math.sin(crystal.floatPhase) * crystal.floatAmplitude;\n            crystal.mesh.position.y = crystal.initialPosition.y + floatOffset;\n\n            // Rotate the crystal\n            crystal.mesh.rotation.x += crystal.rotationSpeed.x;\n            crystal.mesh.rotation.y += crystal.rotationSpeed.y;\n            crystal.mesh.rotation.z += crystal.rotationSpeed.z;\n        });\n    }\n\n    cleanup(anomaly: CrystalClusterAnomalyData): void {\n        // Clean up crystals\n        if (anomaly.crystals) {\n            anomaly.crystals.forEach((crystal: CrystalData) => {\n                if (crystal.mesh && crystal.mesh.geometry) {\n                    crystal.mesh.geometry.dispose();\n                }\n                if (crystal.mesh && crystal.mesh.material) {\n                    if (Array.isArray(crystal.mesh.material)) {\n                        crystal.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (crystal.mesh.material as THREE.Material).dispose();\n                    }\n                }\n            });\n        }\n    }\n}\n","// nebulaNexus.ts - Nebula nexus anomaly with crystalline rings and energy arcs\n\nimport * as THREE from 'three';\n\ninterface CrystalData {\n    mesh: THREE.Mesh;\n    initialPosition: THREE.Vector3;\n    pulsePhase: number;\n    pulseSpeed: number;\n}\n\ninterface RingData {\n    mesh: THREE.Mesh;\n    crystals: CrystalData[];\n    rotationSpeed: number;\n    rotationAxis: THREE.Vector3;\n}\n\ninterface CoreData {\n    mesh: THREE.Mesh;\n    pulsePhase: number;\n    pulseSpeed: number;\n}\n\ninterface ArcData {\n    mesh: THREE.Line;\n    curve: THREE.CubicBezierCurve3;\n    updatePhase: number;\n    updateSpeed: number;\n}\n\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ninterface NebulaNexusAnomalyData {\n    type: 'nebulaNexus';\n    mesh: THREE.Group;\n    position: THREE.Vector3;\n    rings: RingData[];\n    core: CoreData;\n    arcs: ArcData[];\n    orb: EnergyOrbData;\n    collisionRadius: number;\n    orbCollected: boolean;\n    rotationSpeed: THREE.Vector3;\n}\n\nexport class NebulaNexusAnomaly {\n    private anomalyScale: number;\n\n    constructor(_scene: THREE.Scene, anomalyScale: number = 4, _orbScale: number = 4) {\n        this.anomalyScale = anomalyScale;\n    }\n\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: (rarity: string) => EnergyOrbData,\n        getRandomOrbRarityCallback: () => string,\n        addToSceneCallback: (object: THREE.Object3D) => void\n    ): NebulaNexusAnomalyData {\n        // Create a crystalline ring structure with central orb\n        const anomalyGroup = new THREE.Group();\n        anomalyGroup.position.copy(position);\n\n        // Apply scale to make anomaly 4x bigger\n        anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);\n\n        // Create a series of rotating rings with crystal formations\n        const ringCount: number = 3;\n        const rings: RingData[] = [];\n\n        // Create multiple crystal-studded rings\n        for (let i = 0; i < ringCount; i++) {\n            // Create a ring\n            const ringRadius: number = 200 + i * 60;\n            const ringGeometry = new THREE.TorusGeometry(ringRadius, 8, 16, 50);\n\n            // Create a vibrant material for the ring\n            const ringHue: number = 0.6 + i * 0.1; // Blue to purple gradient\n            const ringColor = new THREE.Color().setHSL(ringHue, 1.0, 0.6);\n\n            const ringMaterial = new THREE.MeshStandardMaterial({\n                color: ringColor,\n                emissive: ringColor.clone().multiplyScalar(0.5),\n                emissiveIntensity: 1.0,\n                metalness: 0.9,\n                roughness: 0.1,\n                transparent: false,\n                opacity: 1.0\n            });\n\n            const ring = new THREE.Mesh(ringGeometry, ringMaterial);\n\n            // Position ring with different orientation\n            ring.rotation.x = Math.PI / 2 + (i * Math.PI / 3);\n            ring.rotation.y = i * Math.PI / 4;\n\n            anomalyGroup.add(ring);\n\n            // Add crystals along the ring\n            const crystalCount: number = 10 + i * 5;\n            const crystals: CrystalData[] = [];\n\n            for (let j = 0; j < crystalCount; j++) {\n                // Crystal position along the ring\n                const angle: number = (j / crystalCount) * Math.PI * 2;\n\n                // Create crystal geometry\n                const crystalSize: number = 15 + Math.random() * 10;\n                const crystalGeometry = new THREE.OctahedronGeometry(crystalSize, 0);\n\n                // Create crystal material with complementary color\n                const crystalHue: number = (ringHue + 0.5) % 1.0; // Complementary color\n                const crystalColor = new THREE.Color().setHSL(crystalHue, 1.0, 0.7);\n\n                const crystalMaterial = new THREE.MeshStandardMaterial({\n                    color: crystalColor,\n                    emissive: crystalColor.clone(),\n                    emissiveIntensity: 0.8,\n                    metalness: 0.9,\n                    roughness: 0.1,\n                    transparent: false,\n                    opacity: 1.0\n                });\n\n                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);\n\n                // Position crystal on the ring\n                crystal.position.x = ringRadius * Math.cos(angle);\n                crystal.position.y = 0;\n                crystal.position.z = ringRadius * Math.sin(angle);\n\n                // Random rotation\n                crystal.rotation.x = Math.random() * Math.PI;\n                crystal.rotation.y = Math.random() * Math.PI;\n                crystal.rotation.z = Math.random() * Math.PI;\n\n                ring.add(crystal);\n\n                crystals.push({\n                    mesh: crystal,\n                    initialPosition: crystal.position.clone(),\n                    pulsePhase: Math.random() * Math.PI * 2,\n                    pulseSpeed: 0.5 + Math.random() * 0.5\n                });\n            }\n\n            rings.push({\n                mesh: ring,\n                crystals: crystals,\n                rotationSpeed: 0.1 - (i * 0.03), // Outer rings rotate slower\n                rotationAxis: new THREE.Vector3(\n                    Math.random() - 0.5,\n                    Math.random() - 0.5,\n                    Math.random() - 0.5\n                ).normalize()\n            });\n        }\n\n        // Create an inner sphere with energy effect\n        const coreRadius: number = 80;\n        const coreGeometry = new THREE.SphereGeometry(coreRadius, 32, 32);\n        const coreColor = new THREE.Color().setHSL(0.15, 1.0, 0.6); // Gold color\n\n        const coreMaterial = new THREE.MeshStandardMaterial({\n            color: coreColor,\n            emissive: coreColor,\n            emissiveIntensity: 1.0,\n            metalness: 1.0,\n            roughness: 0.3,\n            transparent: true,\n            opacity: 0.9\n        });\n\n        const core = new THREE.Mesh(coreGeometry, coreMaterial);\n        anomalyGroup.add(core);\n\n        // Add energy arcs from core to rings\n        const arcCount: number = 8;\n        const arcs: ArcData[] = [];\n\n        for (let i = 0; i < arcCount; i++) {\n            const curve = new THREE.CubicBezierCurve3(\n                new THREE.Vector3(0, 0, 0),\n                new THREE.Vector3(\n                    (Math.random() - 0.5) * 200,\n                    (Math.random() - 0.5) * 200,\n                    (Math.random() - 0.5) * 200\n                ),\n                new THREE.Vector3(\n                    (Math.random() - 0.5) * 300,\n                    (Math.random() - 0.5) * 300,\n                    (Math.random() - 0.5) * 300\n                ),\n                new THREE.Vector3(\n                    (Math.random() - 0.5) * 400,\n                    (Math.random() - 0.5) * 400,\n                    (Math.random() - 0.5) * 400\n                )\n            );\n\n            const points = curve.getPoints(20);\n            const arcGeometry = new THREE.BufferGeometry().setFromPoints(points);\n\n            const arcColor = new THREE.Color().setHSL(0.15, 1.0, 0.6); // Gold color\n            const arcMaterial = new THREE.LineBasicMaterial({\n                color: arcColor,\n                linewidth: 3,\n                transparent: true,\n                opacity: 0.8\n            });\n\n            const arc = new THREE.Line(arcGeometry, arcMaterial);\n            anomalyGroup.add(arc);\n\n            arcs.push({\n                mesh: arc,\n                curve: curve,\n                updatePhase: Math.random() * Math.PI * 2,\n                updateSpeed: 0.2 + Math.random() * 0.3\n            });\n        }\n\n        // Create energy orb in the center\n        const orbRarity: string = getRandomOrbRarityCallback();\n        const orb = createEnergyOrbCallback(orbRarity);\n        anomalyGroup.add(orb.mesh);\n\n        // Add to scene\n        addToSceneCallback(anomalyGroup);\n\n        // Return anomaly data\n        return {\n            type: 'nebulaNexus',\n            mesh: anomalyGroup,\n            position: position.clone(),\n            rings: rings,\n            core: {\n                mesh: core,\n                pulsePhase: 0,\n                pulseSpeed: 0.5\n            },\n            arcs: arcs,\n            orb: orb,\n            collisionRadius: 250,\n            orbCollected: false,\n            rotationSpeed: new THREE.Vector3(0.0003, 0.0004, 0.0002)\n        };\n    }\n\n    update(anomaly: NebulaNexusAnomalyData, deltaTime: number): void {\n        // Animate core\n        anomaly.core.pulsePhase += deltaTime * anomaly.core.pulseSpeed;\n        const scale: number = 1.0 + 0.2 * Math.sin(anomaly.core.pulsePhase);\n        anomaly.core.mesh.scale.set(scale, scale, scale);\n\n        // Animate rings and crystals\n        anomaly.rings.forEach((ring: RingData) => {\n            // Rotate each ring\n            const rotationMatrix = new THREE.Matrix4().makeRotationAxis(\n                ring.rotationAxis,\n                ring.rotationSpeed * deltaTime\n            );\n            ring.mesh.applyMatrix4(rotationMatrix);\n\n            // Animate crystals on the ring\n            ring.crystals.forEach((crystal: CrystalData) => {\n                crystal.pulsePhase += deltaTime * crystal.pulseSpeed;\n                const crystalScale: number = 1.0 + 0.3 * Math.sin(crystal.pulsePhase);\n                crystal.mesh.scale.set(crystalScale, crystalScale, crystalScale);\n            });\n        });\n\n        // Animate energy arcs\n        anomaly.arcs.forEach((arc: ArcData) => {\n            arc.updatePhase += deltaTime * arc.updateSpeed;\n\n            // Update arc control points for dynamic movement\n            const controlPoint1 = arc.curve.v1;\n            const controlPoint2 = arc.curve.v2;\n\n            controlPoint1.x = Math.sin(arc.updatePhase) * 200;\n            controlPoint1.y = Math.cos(arc.updatePhase * 0.7) * 200;\n            controlPoint1.z = Math.sin(arc.updatePhase * 1.3) * 200;\n\n            controlPoint2.x = Math.sin(arc.updatePhase * 0.8 + 1) * 300;\n            controlPoint2.y = Math.cos(arc.updatePhase * 1.2 + 2) * 300;\n            controlPoint2.z = Math.sin(arc.updatePhase * 0.9 + 3) * 300;\n\n            // Update arc geometry\n            const points = arc.curve.getPoints(20);\n            arc.mesh.geometry.setFromPoints(points);\n            (arc.mesh.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;\n        });\n    }\n\n    cleanup(anomaly: NebulaNexusAnomalyData): void {\n        // Clean up rings, core, and arcs\n        if (anomaly.rings) {\n            anomaly.rings.forEach((ring: RingData) => {\n                if (ring.mesh && ring.mesh.geometry) {\n                    ring.mesh.geometry.dispose();\n                }\n                if (ring.mesh && ring.mesh.material) {\n                    if (Array.isArray(ring.mesh.material)) {\n                        ring.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (ring.mesh.material as THREE.Material).dispose();\n                    }\n                }\n            });\n        }\n        if (anomaly.core && anomaly.core.mesh) {\n            if (anomaly.core.mesh.geometry) anomaly.core.mesh.geometry.dispose();\n            if (anomaly.core.mesh.material) {\n                if (Array.isArray(anomaly.core.mesh.material)) {\n                    anomaly.core.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                } else {\n                    (anomaly.core.mesh.material as THREE.Material).dispose();\n                }\n            }\n        }\n        if (anomaly.arcs) {\n            anomaly.arcs.forEach((arc: ArcData) => {\n                if (arc.mesh && arc.mesh.geometry) {\n                    arc.mesh.geometry.dispose();\n                }\n                if (arc.mesh && arc.mesh.material) {\n                    if (Array.isArray(arc.mesh.material)) {\n                        arc.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (arc.mesh.material as THREE.Material).dispose();\n                    }\n                }\n            });\n        }\n    }\n}\n","// quantumFlux.ts - Quantum flux anomaly with rotating cube frames\n\nimport * as THREE from 'three';\n\ninterface FrameData {\n    mesh: THREE.LineSegments;\n    innerBox: THREE.Mesh;\n    rotationAxis: THREE.Vector3;\n    rotationSpeed: number;\n    pulsePhase: number;\n}\n\ninterface ParticleData {\n    mesh: THREE.Points;\n    positions: Float32Array;\n    initialPositions: Float32Array;\n    velocities: THREE.Vector3[];\n}\n\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ninterface QuantumFluxAnomalyData {\n    type: 'quantumFlux';\n    mesh: THREE.Group;\n    position: THREE.Vector3;\n    frames: FrameData[];\n    particles: ParticleData;\n    orb: EnergyOrbData;\n    collisionRadius: number;\n    orbCollected: boolean;\n    rotationSpeed: THREE.Vector3;\n}\n\nexport class QuantumFluxAnomaly {\n    private anomalyScale: number;\n\n    constructor(_scene: THREE.Scene, anomalyScale: number = 4, _orbScale: number = 4) {\n        this.anomalyScale = anomalyScale;\n    }\n\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: (rarity: string) => EnergyOrbData,\n        getRandomOrbRarityCallback: () => string,\n        addToSceneCallback: (object: THREE.Object3D) => void\n    ): QuantumFluxAnomalyData {\n        // Create a quantum flux anomaly with rotating cube frames\n        const anomalyGroup = new THREE.Group();\n        anomalyGroup.position.copy(position);\n\n        // Apply scale to make anomaly 4x bigger\n        anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);\n\n        // Create rotating cubic frames\n        const frames: FrameData[] = [];\n        const frameCount: number = 5;\n\n        for (let i = 0; i < frameCount; i++) {\n            // Create cubic wireframe box\n            const size: number = 250 - i * 40;\n            const geometry = new THREE.BoxGeometry(size, size, size);\n\n            // Add a solid but transparent box inside the wireframe for better visibility\n            const innerGeometry = new THREE.BoxGeometry(size * 0.98, size * 0.98, size * 0.98);\n\n            // Extract only edges to create wireframe\n            const edges = new THREE.EdgesGeometry(geometry);\n\n            // Use extremely vibrant electric colors\n            const hue: number = 0.3 + i * 0.1; // Shift from green to blue\n            const color = new THREE.Color().setHSL(hue, 1.0, 0.6);\n\n            const material = new THREE.LineBasicMaterial({\n                color: color,\n                linewidth: 2,\n                transparent: false, // Changed to non-transparent for better visibility\n                opacity: 1.0\n            });\n\n            // Inner box with semi-transparent material\n            const innerMaterial = new THREE.MeshBasicMaterial({\n                color: color,\n                transparent: true,\n                opacity: 0.1,\n                side: THREE.DoubleSide\n            });\n\n            const frame = new THREE.LineSegments(edges, material);\n            const innerBox = new THREE.Mesh(innerGeometry, innerMaterial);\n\n            // Add both to group and store for animation\n            anomalyGroup.add(frame);\n            anomalyGroup.add(innerBox);\n\n            frames.push({\n                mesh: frame,\n                innerBox: innerBox,\n                rotationAxis: new THREE.Vector3(\n                    Math.random() - 0.5,\n                    Math.random() - 0.5,\n                    Math.random() - 0.5\n                ).normalize(),\n                rotationSpeed: 0.01 + i * 0.005,\n                pulsePhase: Math.random() * Math.PI * 2\n            });\n        }\n\n        // Add energy particles inside\n        const particleCount: number = 200;\n        const particleGeometry = new THREE.BufferGeometry();\n        const particlePositions = new Float32Array(particleCount * 3);\n        const particleSizes = new Float32Array(particleCount);\n\n        for (let i = 0; i < particleCount; i++) {\n            const i3: number = i * 3;\n\n            // Position particles within the inner cube\n            const radius: number = 100 * Math.random();\n            const theta: number = Math.random() * Math.PI * 2;\n            const phi: number = Math.random() * Math.PI;\n\n            particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n            particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n            particlePositions[i3 + 2] = radius * Math.cos(phi);\n\n            // Vary particle sizes\n            particleSizes[i] = 2 + Math.random() * 3;\n        }\n\n        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));\n        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));\n\n        const particleMaterial = new THREE.PointsMaterial({\n            color: 0xff00ff, // Magenta\n            size: 6,\n            blending: THREE.AdditiveBlending,\n            transparent: true,\n            opacity: 0.9\n        });\n\n        const particles = new THREE.Points(particleGeometry, particleMaterial);\n        anomalyGroup.add(particles);\n\n        // Create energy orb in the center\n        const orbRarity: string = getRandomOrbRarityCallback();\n        const orb = createEnergyOrbCallback(orbRarity);\n        anomalyGroup.add(orb.mesh);\n\n        // Add to scene\n        addToSceneCallback(anomalyGroup);\n\n        // Return anomaly data\n        return {\n            type: 'quantumFlux',\n            mesh: anomalyGroup,\n            position: position.clone(),\n            frames: frames,\n            particles: {\n                mesh: particles,\n                positions: particlePositions,\n                initialPositions: particlePositions.slice(), // Clone for reference\n                velocities: Array(particleCount).fill(null).map(() => new THREE.Vector3(\n                    (Math.random() - 0.5) * 0.5,\n                    (Math.random() - 0.5) * 0.5,\n                    (Math.random() - 0.5) * 0.5\n                ))\n            },\n            orb: orb,\n            collisionRadius: 230, // Overall collision size\n            orbCollected: false,\n            rotationSpeed: new THREE.Vector3(0.0001, 0.0002, 0.0001)\n        };\n    }\n\n    update(anomaly: QuantumFluxAnomalyData, deltaTime: number): void {\n        // Animate rotating frames\n        anomaly.frames.forEach((frame: FrameData) => {\n            // Rotate around custom axis\n            const rotationMatrix = new THREE.Matrix4().makeRotationAxis(\n                frame.rotationAxis,\n                frame.rotationSpeed * deltaTime\n            );\n            frame.mesh.applyMatrix4(rotationMatrix);\n\n            // Also rotate the inner box if it exists\n            if (frame.innerBox) {\n                frame.innerBox.applyMatrix4(rotationMatrix);\n            }\n\n            // Pulse effect\n            frame.pulsePhase += deltaTime;\n            const pulseScale: number = 1.0 + 0.05 * Math.sin(frame.pulsePhase);\n            frame.mesh.scale.set(pulseScale, pulseScale, pulseScale);\n\n            // Also pulse the inner box if it exists\n            if (frame.innerBox) {\n                frame.innerBox.scale.set(pulseScale, pulseScale, pulseScale);\n            }\n        });\n\n        // Animate particles\n        const positions = anomaly.particles.positions;\n        const velocities = anomaly.particles.velocities;\n\n        for (let i = 0; i < positions.length / 3; i++) {\n            const i3: number = i * 3;\n\n            // Update position based on velocity\n            positions[i3] += velocities[i].x;\n            positions[i3 + 1] += velocities[i].y;\n            positions[i3 + 2] += velocities[i].z;\n\n            // Contain particles within the inner cube\n            const maxDist: number = 120;\n            const pos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\n            if (pos.length() > maxDist) {\n                // Reflect particles at boundary\n                pos.normalize().multiplyScalar(maxDist);\n                positions[i3] = pos.x;\n                positions[i3 + 1] = pos.y;\n                positions[i3 + 2] = pos.z;\n\n                // Reflect velocity\n                velocities[i].reflect(pos.normalize());\n            }\n        }\n\n        // Update the geometry\n        (anomaly.particles.mesh.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;\n    }\n\n    cleanup(anomaly: QuantumFluxAnomalyData): void {\n        // Clean up frames and particles\n        if (anomaly.frames) {\n            anomaly.frames.forEach((frame: FrameData) => {\n                if (frame.mesh && frame.mesh.geometry) {\n                    frame.mesh.geometry.dispose();\n                }\n                if (frame.mesh && frame.mesh.material) {\n                    if (Array.isArray(frame.mesh.material)) {\n                        frame.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (frame.mesh.material as THREE.Material).dispose();\n                    }\n                }\n                if (frame.innerBox) {\n                    if (frame.innerBox.geometry) frame.innerBox.geometry.dispose();\n                    if (frame.innerBox.material) {\n                        if (Array.isArray(frame.innerBox.material)) {\n                            frame.innerBox.material.forEach((m: THREE.Material) => m.dispose());\n                        } else {\n                            (frame.innerBox.material as THREE.Material).dispose();\n                        }\n                    }\n                }\n            });\n        }\n        if (anomaly.particles && anomaly.particles.mesh) {\n            if (anomaly.particles.mesh.geometry) anomaly.particles.mesh.geometry.dispose();\n            if (anomaly.particles.mesh.material) {\n                if (Array.isArray(anomaly.particles.mesh.material)) {\n                    anomaly.particles.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                } else {\n                    (anomaly.particles.mesh.material as THREE.Material).dispose();\n                }\n            }\n        }\n    }\n}\n","// darkMatter.ts - Dark matter anomaly with gravitational lensing effects\n\nimport * as THREE from 'three';\n\ninterface RingData {\n    mesh: THREE.Mesh;\n    rotationAxis: THREE.Vector3;\n    rotationSpeed: number;\n    warpPhase: number;\n    warpSpeed: number;\n}\n\ninterface ParticleData {\n    mesh: THREE.Points;\n    positions: Float32Array;\n    initialPositions: Float32Array;\n    phases: number[];\n}\n\ninterface CoreData {\n    mesh: THREE.Mesh;\n    pulsePhase: number;\n}\n\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ninterface DarkMatterAnomalyData {\n    type: 'darkMatter';\n    mesh: THREE.Group;\n    position: THREE.Vector3;\n    core: CoreData;\n    rings: RingData[];\n    particles: ParticleData;\n    orb: EnergyOrbData;\n    collisionRadius: number;\n    orbCollected: boolean;\n    rotationSpeed: THREE.Vector3;\n}\n\nexport class DarkMatterAnomaly {\n    private anomalyScale: number;\n\n    constructor(_scene: THREE.Scene, anomalyScale: number = 4, _orbScale: number = 4) {\n        this.anomalyScale = anomalyScale;\n    }\n\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: (rarity: string) => EnergyOrbData,\n        getRandomOrbRarityCallback: () => string,\n        addToSceneCallback: (object: THREE.Object3D) => void\n    ): DarkMatterAnomalyData {\n        // Create a dark matter anomaly with gravitational lensing effects\n        const anomalyGroup = new THREE.Group();\n        anomalyGroup.position.copy(position);\n\n        // Apply scale to make anomaly 4x bigger\n        anomalyGroup.scale.set(this.anomalyScale, this.anomalyScale, this.anomalyScale);\n\n        // Create the dark matter core - a sphere with dark, distortion-like material\n        const coreRadius: number = 100;\n        const coreGeometry = new THREE.SphereGeometry(coreRadius, 32, 32);\n        const coreMaterial = new THREE.MeshStandardMaterial({\n            color: 0x330033,\n            emissive: 0x880088,\n            emissiveIntensity: 1.5,\n            metalness: 1.0,\n            roughness: 0.0,\n            transparent: true,\n            opacity: 0.95\n        });\n\n        const core = new THREE.Mesh(coreGeometry, coreMaterial);\n\n        // Add a glow effect around the core\n        const glowGeometry = new THREE.SphereGeometry(coreRadius * 1.2, 32, 32);\n        const glowMaterial = new THREE.MeshBasicMaterial({\n            color: 0x9900ff,\n            transparent: true,\n            opacity: 0.3,\n            side: THREE.BackSide\n        });\n\n        const glow = new THREE.Mesh(glowGeometry, glowMaterial);\n        core.add(glow);\n\n        anomalyGroup.add(core);\n\n        // Create gravitational distortion rings\n        const rings: RingData[] = [];\n        const ringCount: number = 4;\n\n        for (let i = 0; i < ringCount; i++) {\n            const radius: number = 150 + i * 60;\n            const tubeRadius: number = 4 + i * 2;\n            const geometry = new THREE.TorusGeometry(radius, tubeRadius, 16, 100);\n\n            // Use dark/purple color scheme with increasing brightness outward\n            const color = new THREE.Color().setHSL(0.75, 0.9, 0.1 + i * 0.15);\n\n            const material = new THREE.MeshStandardMaterial({\n                color: color,\n                emissive: color.clone().multiplyScalar(0.7),\n                emissiveIntensity: 0.5 + i * 0.2,\n                metalness: 0.8,\n                roughness: 0.2,\n                transparent: true,\n                opacity: 0.85\n            });\n\n            const ring = new THREE.Mesh(geometry, material);\n\n            // Position with random orientation\n            ring.rotation.x = Math.random() * Math.PI;\n            ring.rotation.y = Math.random() * Math.PI;\n            ring.rotation.z = Math.random() * Math.PI;\n\n            anomalyGroup.add(ring);\n            rings.push({\n                mesh: ring,\n                rotationAxis: new THREE.Vector3(\n                    Math.random() - 0.5,\n                    Math.random() - 0.5,\n                    Math.random() - 0.5\n                ).normalize(),\n                rotationSpeed: 0.002 + i * 0.001,\n                warpPhase: Math.random() * Math.PI * 2,\n                warpSpeed: 0.5 + Math.random() * 0.5\n            });\n        }\n\n        // Create distortion particles\n        const particleCount: number = 300;\n        const particleGeometry = new THREE.BufferGeometry();\n        const particlePositions = new Float32Array(particleCount * 3);\n        const particleSizes = new Float32Array(particleCount);\n\n        for (let i = 0; i < particleCount; i++) {\n            const i3: number = i * 3;\n\n            // Distribute particles in a spherical shell\n            const radius: number = 120 + Math.random() * 250;\n            const theta: number = Math.random() * Math.PI * 2;\n            const phi: number = Math.random() * Math.PI;\n\n            particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n            particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n            particlePositions[i3 + 2] = radius * Math.cos(phi);\n\n            // Vary particle sizes\n            particleSizes[i] = 1 + Math.random() * 3;\n        }\n\n        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));\n        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));\n\n        const particleMaterial = new THREE.PointsMaterial({\n            color: 0x8800ff,\n            size: 5,\n            blending: THREE.AdditiveBlending,\n            transparent: true,\n            opacity: 0.8\n        });\n\n        const particles = new THREE.Points(particleGeometry, particleMaterial);\n        anomalyGroup.add(particles);\n\n        // Create energy orb in the center\n        const orbRarity: string = getRandomOrbRarityCallback();\n        const orb = createEnergyOrbCallback(orbRarity);\n        anomalyGroup.add(orb.mesh);\n\n        // Add to scene\n        addToSceneCallback(anomalyGroup);\n\n        // Return anomaly data\n        return {\n            type: 'darkMatter',\n            mesh: anomalyGroup,\n            position: position.clone(),\n            core: {\n                mesh: core,\n                pulsePhase: 0\n            },\n            rings: rings,\n            particles: {\n                mesh: particles,\n                positions: particlePositions,\n                initialPositions: particlePositions.slice(),\n                phases: Array(particleCount).fill(0).map(() => Math.random() * Math.PI * 2)\n            },\n            orb: orb,\n            collisionRadius: 200, // Overall collision size\n            orbCollected: false,\n            rotationSpeed: new THREE.Vector3(0.0002, 0.0003, 0.0001)\n        };\n    }\n\n    update(anomaly: DarkMatterAnomalyData, deltaTime: number): void {\n        // Animate core\n        anomaly.core.pulsePhase += deltaTime * 0.5;\n        const corePulse: number = 1.0 + 0.1 * Math.sin(anomaly.core.pulsePhase);\n        anomaly.core.mesh.scale.set(corePulse, corePulse, corePulse);\n\n        // Animate rings\n        anomaly.rings.forEach((ring: RingData) => {\n            // Rotate along custom axis\n            const rotationMatrix = new THREE.Matrix4().makeRotationAxis(\n                ring.rotationAxis,\n                ring.rotationSpeed * deltaTime\n            );\n            ring.mesh.applyMatrix4(rotationMatrix);\n\n            // Warp effect\n            ring.warpPhase += deltaTime * ring.warpSpeed;\n            const warpX: number = 1.0 + 0.1 * Math.sin(ring.warpPhase);\n            const warpY: number = 1.0 + 0.1 * Math.sin(ring.warpPhase + Math.PI / 3);\n            const warpZ: number = 1.0 + 0.1 * Math.sin(ring.warpPhase + Math.PI * 2 / 3);\n            ring.mesh.scale.set(warpX, warpY, warpZ);\n        });\n\n        // Animate particles\n        const positions = anomaly.particles.positions;\n        const initialPositions = anomaly.particles.initialPositions;\n        const phases = anomaly.particles.phases;\n\n        for (let i = 0; i < positions.length / 3; i++) {\n            const i3: number = i * 3;\n\n            // Update phase\n            phases[i] += deltaTime;\n\n            // Create gravitational distortion effect\n            const dist: number = Math.sqrt(\n                initialPositions[i3] * initialPositions[i3] +\n                initialPositions[i3 + 1] * initialPositions[i3 + 1] +\n                initialPositions[i3 + 2] * initialPositions[i3 + 2]\n            );\n\n            const orbitSpeed: number = 0.5 + (300 / (dist + 10)); // Faster closer to center\n            phases[i] += deltaTime * orbitSpeed;\n\n            // Create orbiting motion with radial oscillation\n            const radialPulse: number = 1.0 + 0.2 * Math.sin(phases[i] * 0.5);\n\n            // Apply the distortion\n            const pos = new THREE.Vector3(\n                initialPositions[i3],\n                initialPositions[i3 + 1],\n                initialPositions[i3 + 2]\n            );\n\n            // Rotate based on phase\n            const rotY: number = phases[i] * 0.2;\n            const rotZ: number = phases[i] * 0.1;\n\n            pos.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);\n            pos.applyAxisAngle(new THREE.Vector3(0, 0, 1), rotZ);\n\n            // Apply radial pulse\n            pos.multiplyScalar(radialPulse);\n\n            positions[i3] = pos.x;\n            positions[i3 + 1] = pos.y;\n            positions[i3 + 2] = pos.z;\n        }\n\n        // Update the geometry\n        (anomaly.particles.mesh.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;\n    }\n\n    cleanup(anomaly: DarkMatterAnomalyData): void {\n        // Clean up core, rings, and particles\n        if (anomaly.core && anomaly.core.mesh) {\n            if (anomaly.core.mesh.geometry) anomaly.core.mesh.geometry.dispose();\n            if (anomaly.core.mesh.material) {\n                if (Array.isArray(anomaly.core.mesh.material)) {\n                    anomaly.core.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                } else {\n                    (anomaly.core.mesh.material as THREE.Material).dispose();\n                }\n            }\n        }\n        if (anomaly.rings) {\n            anomaly.rings.forEach((ring: RingData) => {\n                if (ring.mesh && ring.mesh.geometry) {\n                    ring.mesh.geometry.dispose();\n                }\n                if (ring.mesh && ring.mesh.material) {\n                    if (Array.isArray(ring.mesh.material)) {\n                        ring.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                    } else {\n                        (ring.mesh.material as THREE.Material).dispose();\n                    }\n                }\n            });\n        }\n        if (anomaly.particles && anomaly.particles.mesh) {\n            if (anomaly.particles.mesh.geometry) anomaly.particles.mesh.geometry.dispose();\n            if (anomaly.particles.mesh.material) {\n                if (Array.isArray(anomaly.particles.mesh.material)) {\n                    anomaly.particles.mesh.material.forEach((m: THREE.Material) => m.dispose());\n                } else {\n                    (anomaly.particles.mesh.material as THREE.Material).dispose();\n                }\n            }\n        }\n    }\n}\n","// anomalyRegistry.ts - Registry and factory for space anomalies\n\nimport { VortexAnomaly } from './vortex';\nimport { CrystalClusterAnomaly } from './crystalCluster';\nimport { NebulaNexusAnomaly } from './nebulaNexus';\nimport { QuantumFluxAnomaly } from './quantumFlux';\nimport { DarkMatterAnomaly } from './darkMatter';\nimport * as THREE from 'three';\n\n// Callback type definitions\ninterface EnergyOrbData {\n    mesh: THREE.Sprite | THREE.Mesh;\n}\n\ntype CreateEnergyOrbCallback = (rarity: string) => EnergyOrbData;\ntype GetRandomOrbRarityCallback = () => string;\ntype AddToSceneCallback = (object: THREE.Object3D) => void;\n\n// Define a common interface for anomaly classes\ninterface BaseAnomaly {\n    create(\n        position: THREE.Vector3,\n        createEnergyOrbCallback: CreateEnergyOrbCallback,\n        getRandomOrbRarityCallback: GetRandomOrbRarityCallback,\n        addToSceneCallback: AddToSceneCallback\n    ): any;\n    update?(anomaly: any, deltaTime: number): void;\n    cleanup?(anomaly: any): void;\n}\n\nexport class AnomalyRegistry {\n    private anomalyTypes: { [key: string]: BaseAnomaly };\n\n    constructor(_scene: THREE.Scene, _anomalyScale: number = 4, _orbScale: number = 4) {\n        \n        // Initialize anomaly implementations\n        this.anomalyTypes = {\n            'vortex': new VortexAnomaly(_scene, _anomalyScale, _orbScale),\n            'crystalCluster': new CrystalClusterAnomaly(_scene, _anomalyScale, _orbScale),\n            'nebulaNexus': new NebulaNexusAnomaly(_scene, _anomalyScale, _orbScale),\n            'quantumFlux': new QuantumFluxAnomaly(_scene, _anomalyScale, _orbScale),\n            'darkMatter': new DarkMatterAnomaly(_scene, _anomalyScale, _orbScale)\n        };\n    }\n\n    /**\n     * Create an anomaly of the specified type\n     * @param type - The type of anomaly to create\n     * @param position - Position where the anomaly should be created\n     * @param createEnergyOrbCallback - Callback to create energy orbs\n     * @param getRandomOrbRarityCallback - Callback to get random orb rarity\n     * @param addToSceneCallback - Callback to add objects to the scene\n     * @returns The created anomaly data\n     */\n    createAnomaly(\n        type: string,\n        position: THREE.Vector3,\n        createEnergyOrbCallback: CreateEnergyOrbCallback,\n        getRandomOrbRarityCallback: GetRandomOrbRarityCallback,\n        addToSceneCallback: AddToSceneCallback\n    ): any {\n        const anomalyClass = this.anomalyTypes[type];\n        if (!anomalyClass) {\n            throw new Error(`Unknown anomaly type: ${type}`);\n        }\n\n        return anomalyClass.create(position, createEnergyOrbCallback, getRandomOrbRarityCallback, addToSceneCallback);\n    }\n\n    /**\n     * Update an anomaly of the specified type\n     * @param anomaly - The anomaly to update\n     * @param deltaTime - Time since last update\n     */\n    updateAnomaly(anomaly: any, deltaTime: number): void {\n        const anomalyClass = this.anomalyTypes[anomaly.type];\n        if (anomalyClass && typeof anomalyClass.update === 'function') {\n            anomalyClass.update(anomaly, deltaTime);\n        }\n    }\n\n    /**\n     * Clean up an anomaly of the specified type\n     * @param anomaly - The anomaly to clean up\n     */\n    cleanupAnomaly(anomaly: any): void {\n        const anomalyClass = this.anomalyTypes[anomaly.type];\n        if (anomalyClass && typeof anomalyClass.cleanup === 'function') {\n            anomalyClass.cleanup(anomaly);\n        }\n    }\n\n    /**\n     * Get all available anomaly type names\n     * @returns Array of anomaly type names\n     */\n    getAvailableTypes(): string[] {\n        return Object.keys(this.anomalyTypes);\n    }\n\n    /**\n     * Check if an anomaly type is supported\n     * @param type - The anomaly type to check\n     * @returns True if the type is supported\n     */\n    isTypeSupported(type: string): boolean {\n        return type in this.anomalyTypes;\n    }\n}","// spaceAnomalies.ts - Creates and manages space anomalies with collectible energy orbs\n\nimport * as THREE from 'three';\nimport { AnomalyRegistry } from './anomalies/anomalyRegistry';\n\ntype OrbRarity = 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n\ninterface OrbData {\n    mesh: THREE.Mesh;\n    rarity: OrbRarity;\n    value: number;\n    size: number;\n    color: THREE.Color;\n    pulsePhase: number;\n    pulseSpeed: number;\n    glow: THREE.Mesh;\n}\n\ninterface AnomalyData {\n    type: string;\n    mesh: THREE.Object3D;\n    position: THREE.Vector3;\n    orb: OrbData;\n    orbCollected: boolean;\n    rotationSpeed?: { x: number; y: number; z: number };\n    rings?: Array<{ mesh: THREE.Mesh; rotationSpeed: { x: number; y: number; z: number } }>;\n    [key: string]: unknown;\n}\n\ninterface GameRenderer {\n    _withGuard?: (fn: () => void) => void;\n    add?: (obj: THREE.Object3D) => void;\n}\n\ninterface GameGlobal {\n    renderer?: GameRenderer;\n    spaceship?: { mesh?: THREE.Object3D };\n}\n\nexport class SpaceAnomalies {\n    scene: THREE.Scene;\n    anomalies: AnomalyData[];\n    minRadius: number;\n    maxRadius: number;\n    width: number;\n    anomalyScale: number;\n    orbScale: number;\n    orbValues: Record<OrbRarity, number>;\n    spawnTimer: number;\n    checkInterval: number;\n    spawnChance: number;\n    despawnChance: number;\n    anomalyRegistry: AnomalyRegistry;\n    anomalyTypes: string[];\n    maxAnomalies: number;\n\n    constructor(scene: THREE.Scene) {\n        this.scene = scene;\n        this.anomalies = [];\n\n        // Anomalies are outside the asteroid belt\n        this.minRadius = 32000; // Beyond asteroid belt\n        this.maxRadius = 45000; // Not too far into deep space\n        this.width = 3000; // Height variation\n\n        // Scale factors for size\n        this.anomalyScale = 4; // Make anomalies 4x bigger\n        this.orbScale = 4;     // Make orbs 4x bigger\n\n        // Orb rarity and values\n        this.orbValues = {\n            common: 100,    // Green orb - 100 credits\n            uncommon: 500,  // Blue orb - 500 credits\n            rare: 1500,     // Purple orb - 1500 credits\n            epic: 5000,     // Orange orb - 5000 credits\n            legendary: 15000 // Red orb - 15000 credits\n        };\n\n        // Initialize timer system for dynamic anomaly spawning\n        this.spawnTimer = 0;\n        this.checkInterval = 60; // Check every 60 seconds (1 minute)\n        this.spawnChance = 0.5; // 50% chance to spawn a new anomaly\n        this.despawnChance = 0.3; // 30% chance for an anomaly to despawn\n\n        // Initialize anomaly registry\n        this.anomalyRegistry = new AnomalyRegistry(scene, this.anomalyScale, this.orbScale);\n        this.anomalyTypes = this.anomalyRegistry.getAvailableTypes();\n\n        // Maximum number of anomalies that can exist simultaneously\n        this.maxAnomalies = 5;\n\n        // Notify about active anomalies\n        this.updateAnomalyCountDisplay();\n    }\n\n    // --- Renderer facade helpers ---\n    _getRenderer(): GameRenderer | null {\n        const game = (window as any).game as GameGlobal | undefined;\n        return game?.renderer ?? null;\n    }\n\n    _addToScene(object: THREE.Object3D): void {\n        const renderer = this._getRenderer();\n        if (renderer && typeof renderer._withGuard === 'function') {\n            renderer._withGuard(() => renderer.add && renderer.add(object));\n        } else if (this.scene && typeof this.scene.add === 'function') {\n            this.scene.add(object);\n        }\n    }\n\n    _removeFromScene(object: THREE.Object3D | null): void {\n        const renderer = this._getRenderer();\n        if (!object) return;\n        if (renderer && typeof renderer._withGuard === 'function') {\n            renderer._withGuard(() => this.scene.remove(object));\n        } else if (this.scene && typeof this.scene.remove === 'function') {\n            this.scene.remove(object);\n        }\n    }\n\n    // Method to check and potentially spawn/despawn anomalies\n    checkAnomalySpawning(deltaTime: number): void {\n        // Increment timer\n        this.spawnTimer += deltaTime;\n\n        // Check if it's time to evaluate spawn/despawn\n        if (this.spawnTimer >= this.checkInterval) {\n            // Reset timer\n            this.spawnTimer -= this.checkInterval;\n\n            // Check for potential new anomaly spawn\n            if (this.anomalies.length < this.maxAnomalies && Math.random() < this.spawnChance) {\n                // Determine which anomaly type to spawn\n                const availableTypes = this.anomalyTypes.filter(type =>\n                    !this.anomalies.some(anomaly => anomaly.type === type)\n                );\n\n                if (availableTypes.length > 0) {\n                    const typeToSpawn = availableTypes[Math.floor(Math.random() * availableTypes.length)];\n                    this.spawnAnomaly(typeToSpawn);\n\n                    // Update HUD with new count\n                    this.updateAnomalyCountDisplay();\n                }\n            }\n\n            // Check each existing anomaly for potential despawn\n            const anomaliesToRemove: AnomalyData[] = [];\n            this.anomalies.forEach(anomaly => {\n                if (Math.random() < this.despawnChance) {\n                    anomaliesToRemove.push(anomaly);\n                }\n            });\n\n            // Remove marked anomalies\n            if (anomaliesToRemove.length > 0) {\n                anomaliesToRemove.forEach(anomaly => {\n                    this.despawnAnomaly(anomaly);\n                });\n\n                // Update HUD with new count\n                this.updateAnomalyCountDisplay();\n            }\n        }\n    }\n\n    // Spawn a specific type of anomaly\n    spawnAnomaly(type: string): void {\n        console.log(`Spawning ${type} anomaly`);\n\n        if (!this.anomalyRegistry.isTypeSupported(type)) {\n            console.error(`Unknown anomaly type: ${type}`);\n            return;\n        }\n\n        const position = this.getRandomAnomalyPosition();\n        const anomaly = this.anomalyRegistry.createAnomaly(\n            type,\n            position,\n            (rarity: string) => this.createEnergyOrb(rarity as OrbRarity),\n            () => this.getRandomOrbRarity(),\n            (object: THREE.Object3D) => this._addToScene(object)\n        ) as AnomalyData;\n\n        this.anomalies.push(anomaly);\n    }\n\n    // Despawn and cleanup a specific anomaly\n    despawnAnomaly(anomaly: AnomalyData): void {\n        console.log(`Despawning ${anomaly.type} anomaly`);\n\n        // Remove from scene\n        this._removeFromScene(anomaly.mesh);\n\n        // Use the registry to clean up the anomaly\n        this.anomalyRegistry.cleanupAnomaly(anomaly);\n\n        // Clean up the orb\n        if (anomaly.orb && anomaly.orb.mesh) {\n            if (anomaly.orb.mesh.geometry) anomaly.orb.mesh.geometry.dispose();\n            if (anomaly.orb.mesh.material) {\n                if (Array.isArray(anomaly.orb.mesh.material)) {\n                    anomaly.orb.mesh.material.forEach(m => m.dispose());\n                } else {\n                    anomaly.orb.mesh.material.dispose();\n                }\n            }\n        }\n\n        // Remove from anomalies array\n        const index = this.anomalies.indexOf(anomaly);\n        if (index !== -1) {\n            this.anomalies.splice(index, 1);\n        }\n    }\n\n    // Update HUD to show active anomaly count\n    updateAnomalyCountDisplay(): void {\n        // Find the anomaly count element in the HUD\n        const anomalyCountEl = document.getElementById('anomaly-count');\n        if (anomalyCountEl) {\n            anomalyCountEl.textContent = this.anomalies.length.toString();\n        }\n    }\n\n    // Get the number of active anomalies\n    getActiveAnomalyCount(): number {\n        return this.anomalies.length;\n    }\n\n    // Modified update method to include anomaly spawning/despawning checks\n    update(deltaTime: number): void {\n        // Check for spawning/despawning anomalies\n        this.checkAnomalySpawning(deltaTime);\n\n        // Get player position if available (from global reference)\n        let playerPosition: THREE.Vector3 | null = null;\n        const game = (window as any).game as GameGlobal | undefined;\n        if (game?.spaceship && game.spaceship.mesh) {\n            playerPosition = (game.spaceship.mesh as THREE.Object3D).position;\n        }\n\n        // Update existing anomalies\n        for (let i = 0; i < this.anomalies.length; i++) {\n            const anomaly = this.anomalies[i];\n\n            // Skip if orb is already collected\n            if (anomaly.orbCollected) {\n                // Simple rotation for collected anomalies\n                if (anomaly.mesh && anomaly.rotationSpeed) {\n                    anomaly.mesh.rotation.x += anomaly.rotationSpeed.x * deltaTime;\n                    anomaly.mesh.rotation.y += anomaly.rotationSpeed.y * deltaTime;\n                    anomaly.mesh.rotation.z += anomaly.rotationSpeed.z * deltaTime;\n                }\n                continue;\n            }\n\n            // Check if player is nearby to enhance effects\n            let playerNearby = false;\n            if (playerPosition) {\n                const distance = playerPosition.distanceTo(anomaly.position);\n                playerNearby = distance < (anomaly.orb.size * 3) * this.orbScale; // Only enhance effects based on orb distance\n            }\n\n            // Rotate the entire anomaly slowly\n            if (anomaly.mesh && anomaly.rotationSpeed) {\n                anomaly.mesh.rotation.x += anomaly.rotationSpeed.x * deltaTime;\n                anomaly.mesh.rotation.y += anomaly.rotationSpeed.y * deltaTime;\n                anomaly.mesh.rotation.z += anomaly.rotationSpeed.z * deltaTime;\n            }\n\n            // Animate anomaly using registry\n            this.anomalyRegistry.updateAnomaly(anomaly, deltaTime);\n\n            // Update orb effects based on player proximity\n            this.updateOrbEffects(anomaly, playerNearby);\n        }\n    }\n\n    createEnergyOrb(rarity: OrbRarity): OrbData {\n        // Create an energy orb with glow effects based on rarity\n\n        // Determine orb color and properties based on rarity\n        let color: THREE.Color, size: number, intensity: number, pulseSpeed: number;\n\n        switch (rarity) {\n            case 'legendary':\n                color = new THREE.Color(0xff0000); // Red\n                size = 30 * this.orbScale;  // 4x bigger\n                intensity = 0.9;\n                pulseSpeed = 2.0;\n                break;\n            case 'epic':\n                color = new THREE.Color(0xff6600); // Orange\n                size = 25 * this.orbScale;  // 4x bigger\n                intensity = 0.8;\n                pulseSpeed = 1.8;\n                break;\n            case 'rare':\n                color = new THREE.Color(0x9900ff); // Purple\n                size = 22 * this.orbScale;  // 4x bigger\n                intensity = 0.7;\n                pulseSpeed = 1.5;\n                break;\n            case 'uncommon':\n                color = new THREE.Color(0x0066ff); // Blue\n                size = 20 * this.orbScale;  // 4x bigger\n                intensity = 0.6;\n                pulseSpeed = 1.2;\n                break;\n            default: // common\n                color = new THREE.Color(0x00ff66); // Green\n                size = 18 * this.orbScale;  // 4x bigger\n                intensity = 0.5;\n                pulseSpeed = 1.0;\n                break;\n        }\n\n        // Create the core orb\n        const orbGeometry = new THREE.SphereGeometry(size, 32, 32);\n        const orbMaterial = new THREE.MeshStandardMaterial({\n            color: color,\n            emissive: color,\n            emissiveIntensity: intensity,\n            metalness: 0.8,\n            roughness: 0.2,\n            transparent: true,\n            opacity: 0.9\n        });\n\n        const orb = new THREE.Mesh(orbGeometry, orbMaterial);\n\n        // Create outer glow\n        const glowSize = size * 1.5;\n        const glowGeometry = new THREE.SphereGeometry(glowSize, 32, 32);\n        const glowMaterial = new THREE.MeshBasicMaterial({\n            color: color,\n            transparent: true,\n            opacity: 0.3,\n            side: THREE.BackSide,\n            blending: THREE.AdditiveBlending\n        });\n\n        const glow = new THREE.Mesh(glowGeometry, glowMaterial);\n        orb.add(glow);\n\n        // Return orb data\n        return {\n            mesh: orb,\n            rarity: rarity,\n            value: this.orbValues[rarity],\n            size: size,\n            color: color,\n            pulsePhase: 0,\n            pulseSpeed: pulseSpeed,\n            glow: glow\n        };\n    }\n\n\n    getRandomAnomalyPosition(): THREE.Vector3 {\n        // Get random position outside asteroid belt\n        const angle = Math.random() * Math.PI * 2;\n        const radius = this.minRadius + Math.random() * (this.maxRadius - this.minRadius);\n        const heightVariation = (Math.random() - 0.5) * this.width;\n\n        return new THREE.Vector3(\n            Math.cos(angle) * radius,\n            heightVariation,\n            Math.sin(angle) * radius\n        );\n    }\n\n    getRandomOrbRarity(): OrbRarity {\n        // Determine orb rarity based on probabilities\n        const roll = Math.random();\n\n        if (roll < 0.005) {\n            return 'legendary'; // 0.5% chance\n        } else if (roll < 0.025) {\n            return 'epic'; // 2% chance\n        } else if (roll < 0.1) {\n            return 'rare'; // 7.5% chance\n        } else if (roll < 0.3) {\n            return 'uncommon'; // 20% chance\n        } else {\n            return 'common'; // 70% chance\n        }\n    }\n\n    getRegionInfo(): { center: THREE.Vector3; innerRadius: number; outerRadius: number } {\n        return {\n            center: new THREE.Vector3(0, 0, 0),\n            innerRadius: this.minRadius,\n            outerRadius: this.maxRadius\n        };\n    }\n\n    findClosestAnomaly(position: THREE.Vector3, maxDistance: number = 8000): AnomalyData | null {\n        let closestAnomaly: AnomalyData | null = null;\n        let closestDistance = maxDistance;\n\n        this.anomalies.forEach(anomaly => {\n            // Calculate distance to this anomaly\n            const distance = position.distanceTo(anomaly.position);\n\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestAnomaly = anomaly;\n            }\n        });\n\n        return closestAnomaly;\n    }\n\n    collectOrb(anomaly: AnomalyData): { rarity: OrbRarity; value: number } | null {\n        if (!anomaly || anomaly.orbCollected) {\n            return null; // Already collected or invalid anomaly\n        }\n\n        // Get orb data before marking as collected\n        const orbData = {\n            rarity: anomaly.orb.rarity,\n            value: this.orbValues[anomaly.orb.rarity] || 100 // Default to 100 if rarity not found\n        };\n\n        // Mark as collected and update visuals\n        anomaly.orbCollected = true;\n\n        // Hide the orb\n        if (anomaly.orb && anomaly.orb.mesh) {\n            anomaly.orb.mesh.visible = false;\n\n            // Also hide glow if present\n            if (anomaly.orb.glow) {\n                anomaly.orb.glow.visible = false;\n            }\n        }\n\n        return orbData; // Return data for player inventory and notification\n    }\n\n    checkCollision(position: THREE.Vector3, anomaly: AnomalyData): boolean {\n        if (!position || !anomaly || !anomaly.position) return false;\n\n        // Calculate distance from player to anomaly center\n        const distance = position.distanceTo(anomaly.position);\n\n        // Check if within orb collection radius - we only want orb collisions, not anomaly collision\n        // Use the original collision radius for orb collection, scaled by orbScale\n        // This ensures we're only checking for the orb and not the anomaly itself\n        return distance < (anomaly.orb.size * 2) * this.orbScale;\n    }\n\n    updateOrbEffects(anomaly: AnomalyData, playerNearby: boolean): void {\n        if (!anomaly || !anomaly.orb || anomaly.orbCollected) return;\n\n        // Enhance orb effects when player is nearby to make collection more obvious\n        if (playerNearby) {\n            // If player is nearby, make the orb pulse more dramatically\n            const scale = 1.5 + Math.sin(performance.now() * 0.005) * 0.5;\n            anomaly.orb.mesh.scale.set(scale, scale, scale);\n\n            // Increase emission intensity\n            const material = anomaly.orb.mesh.material as THREE.MeshStandardMaterial | THREE.MeshStandardMaterial[];\n            if (material) {\n                if (Array.isArray(material)) {\n                    material.forEach(mat => { mat.emissiveIntensity = 2.0; });\n                } else {\n                    material.emissiveIntensity = 2.0;\n                }\n            }\n        } else {\n            // Reset to normal effects when player is not nearby\n            const scale = 1.0 + Math.sin(performance.now() * 0.002) * 0.2;\n            anomaly.orb.mesh.scale.set(scale, scale, scale);\n\n            // Normal emission intensity\n            const material = anomaly.orb.mesh.material as THREE.MeshStandardMaterial | THREE.MeshStandardMaterial[];\n            if (material) {\n                if (Array.isArray(material)) {\n                    material.forEach(mat => { mat.emissiveIntensity = 0.8; });\n                } else {\n                    material.emissiveIntensity = 0.8;\n                }\n            }\n        }\n    }\n\n\n    updateForSystem(systemData: unknown): void {\n        void systemData;\n        console.log(\"Updating space anomalies for new star system\");\n\n        // Clear any existing anomalies\n        this.clearAllAnomalies();\n\n        // Reset the timer to immediately check for spawning in the new system\n        this.spawnTimer = this.checkInterval;\n\n        // Update HUD\n        this.updateAnomalyCountDisplay();\n    }\n\n    clearAllAnomalies(): void {\n        // Clone the array to avoid modification during iteration\n        const anomaliesToRemove = [...this.anomalies];\n\n        // Remove each anomaly\n        anomaliesToRemove.forEach(anomaly => {\n            this.despawnAnomaly(anomaly);\n        });\n\n        // Ensure the array is empty\n        this.anomalies = [];\n\n        // Update HUD\n        this.updateAnomalyCountDisplay();\n    }\n}\n"],"names":["VortexAnomaly","_scene","anomalyScale","_orbScale","__publicField","position","createEnergyOrbCallback","getRandomOrbRarityCallback","addToSceneCallback","anomalyGroup","THREE.Group","ringCount","rings","i","radius","geometry","THREE.TorusGeometry","hue","color","THREE.Color","material","THREE.MeshStandardMaterial","ring","THREE.Mesh","orbRarity","orb","THREE.Vector3","anomaly","deltaTime","m","CrystalClusterAnomaly","crystals","crystalCount","size","crystalType","THREE.OctahedronGeometry","THREE.DodecahedronGeometry","THREE.TetrahedronGeometry","positions","j","vertex","saturation","lightness","crystal","theta","phi","floatOffset","NebulaNexusAnomaly","ringRadius","ringGeometry","ringHue","ringColor","ringMaterial","angle","crystalSize","crystalGeometry","crystalHue","crystalColor","crystalMaterial","coreRadius","coreGeometry","THREE.SphereGeometry","coreColor","coreMaterial","core","arcCount","arcs","curve","THREE.CubicBezierCurve3","points","arcGeometry","THREE.BufferGeometry","arcColor","arcMaterial","THREE.LineBasicMaterial","arc","THREE.Line","scale","rotationMatrix","THREE.Matrix4","crystalScale","controlPoint1","controlPoint2","QuantumFluxAnomaly","frames","frameCount","THREE.BoxGeometry","innerGeometry","edges","THREE.EdgesGeometry","innerMaterial","THREE.MeshBasicMaterial","THREE.DoubleSide","frame","THREE.LineSegments","innerBox","particleCount","particleGeometry","particlePositions","particleSizes","i3","THREE.BufferAttribute","particleMaterial","THREE.PointsMaterial","THREE.AdditiveBlending","particles","THREE.Points","pulseScale","velocities","maxDist","pos","DarkMatterAnomaly","glowGeometry","glowMaterial","THREE.BackSide","glow","tubeRadius","corePulse","warpX","warpY","warpZ","initialPositions","phases","orbitSpeed","radialPulse","rotY","rotZ","AnomalyRegistry","_anomalyScale","type","anomalyClass","SpaceAnomalies","scene","game","object","renderer","availableTypes","typeToSpawn","anomaliesToRemove","rarity","index","anomalyCountEl","playerPosition","playerNearby","intensity","pulseSpeed","orbGeometry","orbMaterial","glowSize","heightVariation","roll","maxDistance","closestAnomaly","closestDistance","distance","orbData","mat","systemData"],"mappings":"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"}