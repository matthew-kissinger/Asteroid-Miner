import{S as E}from"./core-AGMxUAyq.js";import{aN as M,m as S,b as g,G as v,q as x,c as T,M as $}from"./three-DEtojxaq.js";import{F as b}from"./game-modules-DrL_oOTa.js";class R extends E{constructor(t,e,o,s){super(t),this.requiredComponents=["TransformComponent","MeshComponent"],this.priority=100,this.scene=e,this.camera=o,this.renderer=null,this.meshEntities=new Map,this.frustum=new M,this.projScreenMatrix=new S,this.world.messageBus.subscribe("entity.created",this.onEntityCreated.bind(this)),this.world.messageBus.subscribe("entity.destroyed",this.onEntityDestroyed.bind(this)),this.world.messageBus.subscribe("component.added",this.onComponentAdded.bind(this)),console.log("RenderSystem initialized - handling mesh updates only, no rendering")}onComponentAdded(t){const e=t.data.entity,o=t.data.componentType;o!=="MeshComponent"&&o!=="TransformComponent"||this.meshEntities.has(e.id)||(console.log(`RenderSystem: Component ${o} added to entity ${e.id}`),e.getComponent("TransformComponent")&&e.getComponent("MeshComponent")&&(console.log(`Entity ${e.id} now has all required components, adding to scene`),this.addEntityToScene(e)))}initialize(){if(!this.scene||!this.camera){console.error("RenderSystem missing required Three.js scene or camera references");return}this.world.getEntitiesWithComponents(["TransformComponent","MeshComponent"]).forEach(e=>{this.addEntityToScene(e)})}onEntityCreated(t){const e=t.data.entity;console.log(`RenderSystem received entity.created event for entity ${e.id}`),console.log(`Entity ${e.id} components:`,Array.from(e.components.keys()).join(", "));const o=e.getComponent("TransformComponent"),s=e.getComponent("MeshComponent");if(o&&s)console.log(`Entity ${e.id} has required components, adding to scene`),this.addEntityToScene(e);else{console.log(`Entity ${e.id} missing required components (has transform: ${!!o}, has mesh: ${!!s}), will check later`);const l=r=>{var i;if(((i=r.data.entity)==null?void 0:i.id)!==e.id)return;console.log(`Entity ${e.id} got component ${r.data.componentType}`);const n=e.getComponent("TransformComponent"),a=e.getComponent("MeshComponent");n&&a&&(console.log(`Entity ${e.id} now has required components, adding to scene`),this.addEntityToScene(e),this.world.messageBus.unsubscribe("component.added",l))};this.world.messageBus.subscribe("component.added",l)}}onEntityDestroyed(t){const e=t.data.entity;this.meshEntities.has(e.id)&&this.removeEntityFromScene(e)}addEntityToScene(t){const e=t.getComponent("MeshComponent");if(console.log(`Entity ${t.id} components for scene addition:`,Array.from(t.components.keys()).join(", ")),!e||!e.mesh){console.warn(`Entity ${t.id} has no valid mesh to add to scene`),e&&!e.mesh&&console.warn(`Entity ${t.id} has MeshComponent but mesh property is ${e.mesh}`);return}if(e.mesh.geometry?!e.mesh.geometry.boundingSphere&&typeof e.mesh.geometry.computeBoundingSphere=="function"&&e.mesh.geometry.computeBoundingSphere():e.mesh.isGroup&&console.log(`Entity ${t.id} uses a THREE.Group - skipping bounding sphere computation`),!this.scene){console.error(`Cannot add entity ${t.id} mesh to scene - scene reference is missing`);return}this.scene.add(e.mesh),e.mesh.visible=!0;const o=t.getComponent("TransformComponent");o&&(e.mesh.position.copy(o.position),e.mesh.quaternion.copy(o.quaternion),e.mesh.scale.copy(o.scale)),console.log(`Added entity ${t.id} mesh to scene - position: ${e.mesh.position.x.toFixed(0)},${e.mesh.position.y.toFixed(0)},${e.mesh.position.z.toFixed(0)}`),this.meshEntities.set(t.id,t)}removeEntityFromScene(t){const e=t.getComponent("MeshComponent");e.mesh&&e.mesh.parent&&this.scene.remove(e.mesh),this.meshEntities.delete(t.id)}updateFrustum(){if(this.camera)try{if(!this.camera.projectionMatrix||!this.camera.matrixWorldInverse){console.warn("Camera matrices not initialized");return}this.projScreenMatrix=new S,this.projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix,this.camera.matrixWorldInverse),this.frustum=new M,this.frustum.setFromProjectionMatrix(this.projScreenMatrix)}catch(t){console.error("Error updating frustum:",t),window.DEBUG_MODE=!0}}isVisible(t,e){return window.DEBUG_MODE=!0,!0}update(t){this.updateFrustum(),window.DEBUG_MODE&&this.world.time%5<t&&this.scanForMissingEntities();for(const e of this.meshEntities.values()){const o=e.getComponent("TransformComponent"),s=e.getComponent("MeshComponent");if(!(!o||!s||!s.mesh)){if(!s.mesh.parent&&this.scene&&(console.log(`RenderSystem: Adding missing mesh for entity ${e.id} to scene`),this.scene.add(s.mesh)),s.mesh.position.copy(o.position),s.mesh.quaternion.copy(o.quaternion),s.mesh.scale.copy(o.scale),o.needsUpdate=!1,window.DEBUG_MODE){s.mesh.visible=!0;continue}if(s.visible){let l=500;s.mesh.isGroup?l=500:s.mesh.geometry&&(s.mesh.geometry.boundingSphere?l=s.mesh.geometry.boundingSphere.radius:typeof s.mesh.geometry.computeBoundingSphere=="function"&&(s.mesh.geometry.computeBoundingSphere(),s.mesh.geometry.boundingSphere&&(l=s.mesh.geometry.boundingSphere.radius)));const r=this.isVisible(o.position,l);s.mesh.visible=r}else s.mesh.visible=!1}}window.DEBUG_MODE&&this.world.time%5<t&&console.log(`RenderSystem: ${this.meshEntities.size} entities being managed`)}scanForMissingEntities(){const t=this.world.getEntitiesWithComponents(["TransformComponent","MeshComponent"]);let e=0;t.forEach(o=>{this.meshEntities.has(o.id)||(console.log(`RenderSystem: Found untracked entity ${o.id} with mesh, adding to scene`),this.addEntityToScene(o),e++)}),e>0&&console.log(`RenderSystem: Added ${e} missing entities to tracking`)}onDestroyed(){this.projScreenMatrix=null,this.frustum=null;for(const t of this.meshEntities.values())this.removeEntityFromScene(t);this.meshEntities.clear(),this.scene=null,this.camera=null,this.renderer=null,this.world&&this.world.messageBus&&(this.world.messageBus.unsubscribe("entity.created",this.onEntityCreated.bind(this)),this.world.messageBus.unsubscribe("entity.destroyed",this.onEntityDestroyed.bind(this)),this.world.messageBus.unsubscribe("component.added",this.onComponentAdded.bind(this)))}}class D extends E{constructor(t){super(t),this.requiredComponents=["TransformComponent","RigidbodyComponent"],this.priority=20,this.cells=new Map,this.cellSize=2e3,this.processedCollisions=new Set,this.entityCells=new Map,this.potentialColliders=new b(200),this.cellsToCheck=new b(27),this.tempVec1=new g,this.tempVec2=new g,this.collisionNormal=new g,this.relativeVelocity=new g}update(t){this.cells.clear(),this.processedCollisions.clear(),this.entityCells.clear();const e=this.getEntities();for(let o=0;o<e.length;o++)this._insertIntoGrid(e[o]);for(let o=0;o<e.length;o++)this._checkCollisionsOptimized(e[o],t)}_insertIntoGrid(t){const e=t.getComponent("TransformComponent"),o=t.getComponent("RigidbodyComponent");if(!e||!o)return;const s=Math.floor(e.position.x/this.cellSize),l=Math.floor(e.position.y/this.cellSize),r=Math.floor(e.position.z/this.cellSize),n=`${s},${l},${r}`;this.cells.has(n)||this.cells.set(n,[]),this.cells.get(n).push(t),this.entityCells.has(t.id)||this.entityCells.set(t.id,new Set),this.entityCells.get(t.id).add(n);const a=o.collisionRadius,i=t.hasTag("playerProjectile")||t.hasTag("particleProjectile"),c=Math.ceil(a*(i?5:1)/this.cellSize);if(i||c>0){const d=o.velocity||{length:()=>0},f=d.length?Math.min(3,Math.ceil(d.length()/1e3)):1;for(let u=-c;u<=c;u++)for(let h=-c;h<=c;h++)for(let p=-c;p<=c;p++){if(u===0&&h===0&&p===0||i&&f>1&&u*Math.sign(d.x||0)+h*Math.sign(d.y||0)+p*Math.sign(d.z||0)<0)continue;const y=`${s+u},${l+h},${r+p}`;this.cells.has(y)||this.cells.set(y,[]),this.cells.get(y).push(t),this.entityCells.get(t.id).add(y)}}}_checkCollisionsOptimized(t,e){const o=t.getComponent("TransformComponent"),s=t.getComponent("RigidbodyComponent");if(!o||!s||!this.entityCells.has(t.id))return;const l=this.entityCells.get(t.id);this.potentialColliders.clear(),l.forEach(r=>{const n=this.cells.get(r);if(n)for(let a=0;a<n.length;a++){const i=n[a];if(i===t)continue;const m=t.id<i.id?`${t.id}:${i.id}`:`${i.id}:${t.id}`;this.processedCollisions.has(m)||(this.potentialColliders.push(i),this.processedCollisions.add(m))}});for(let r=0;r<this.potentialColliders.length;r++){const n=this.potentialColliders.get(r),a=n.getComponent("TransformComponent"),i=n.getComponent("RigidbodyComponent");!a||!i||this._checkSphereCollision(o.position,s.collisionRadius,a.position,i.collisionRadius)&&(s.isTrigger||i.isTrigger?this._handleTrigger(t,n):this._resolveCollision(t,n,o,s,a,i))}}_checkSphereCollision(t,e,o,s){const l=t.x-o.x,r=t.y-o.y,n=t.z-o.z,a=l*l+r*r+n*n,i=e+s;return a<=i*i}_handleTrigger(t,e){let o=null,s=null;const l=t._isPlayerProjectile||t.hasTag("playerProjectile")||t.hasTag("particleProjectile"),r=e._isEnemy||e.hasTag("enemy")||e.hasComponent("EnemyComponent")||e.hasComponent("EnemyAIComponent");if(l&&r)o=t,s=e;else{const n=e._isPlayerProjectile||e.hasTag("playerProjectile")||e.hasTag("particleProjectile"),a=t._isEnemy||t.hasTag("enemy")||t.hasComponent("EnemyComponent")||t.hasComponent("EnemyAIComponent");n&&a&&(o=e,s=t)}if(o&&s){if(console.log(`DIRECT HIT: Player projectile ${o.id} hit enemy ${s.id}`),s.hasTag("pooled")){console.warn(`Skipping hit on pooled enemy ${s.id}`);return}const n=o.getComponent("TransformComponent"),a=s.getComponent("TransformComponent");if(n&&a){const c=n.position.distanceTo(a.position);console.log(`Hit details: Distance=${c.toFixed(1)}, ProjectilePos=${n.position.x.toFixed(0)},${n.position.y.toFixed(0)},${n.position.z.toFixed(0)}, EnemyPos=${a.position.x.toFixed(0)},${a.position.y.toFixed(0)},${a.position.z.toFixed(0)}`)}const i=s.getComponent("HealthComponent");i&&(console.log(`CRITICAL HIT: Applying 1000 damage to enemy ${s.id}`),i.applyDamage(1e3,"particle",o),i.isDestroyed?console.log("ENEMY DESTROYED CONFIRMED! Health reached zero and isDestroyed=true"):(console.error("ERROR: Enemy not destroyed after particle hit! Sending entity.destroyed event..."),i.isDestroyed=!0,i.health=0,this.world.messageBus.publish("entity.destroyed",{entity:s,source:o,damageType:"particle"})));let m=null;try{m=o.getComponent("TransformComponent").position.clone()}catch{try{m=s.getComponent("TransformComponent").position.clone()}catch{m=new g(0,0,0)}}this.world.messageBus.publish("collision.trigger",{entityA:o,entityB:s,projectileHit:!0}),this.world.messageBus.publish("projectile.hit",{projectile:o,target:s,position:m}),this.world.destroyEntity(o.id)}else this.world.messageBus.publish("collision.trigger",{entityA:t,entityB:e})}_resolveCollision(t,e,o,s,l,r){this.collisionNormal.copy(o.position).sub(l.position).normalize(),this.relativeVelocity.copy(s.velocity).sub(r.velocity);const n=this.relativeVelocity.dot(this.collisionNormal);if(n>0)return;const a=s.isKinematic?0:1/s.mass,i=r.isKinematic?0:1/r.mass,m=-1.3*n/(a+i);this.tempVec1.copy(this.collisionNormal).multiplyScalar(m*a),this.tempVec2.copy(this.collisionNormal).multiplyScalar(m*i),s.velocity.sub(this.tempVec1),r.velocity.add(this.tempVec2);const c=.2,d=.01,f=o.position.distanceToSquared(l.position),h=s.collisionRadius+r.collisionRadius-Math.sqrt(f);if(h>d){const p=Math.max(h-d,0)/(a+i)*c;this.tempVec1.copy(this.collisionNormal).multiplyScalar(p*a),this.tempVec2.copy(this.collisionNormal).multiplyScalar(p*i),o.position.sub(this.tempVec1),l.position.add(this.tempVec2)}}}class z extends E{constructor(t){super(t),this.priority=70,this.activeEffects=new Map,this.effectCounter=0,this.setupEventListeners(),console.log("VisualEffectsSystem initialized")}setupEventListeners(){this.world.messageBus.subscribe("vfx.explosion",this.handleExplosionRequest.bind(this)),this.world.messageBus.subscribe("vfx.damageFlash",this.handleDamageFlashRequest.bind(this))}update(t){for(const[e,o]of this.activeEffects.entries())o.update(t)||this.removeEffect(e)}handleExplosionRequest(t){if(!t||!t.data||!t.data.position){console.error("Invalid explosion effect request",t);return}const e=t.data.position,o=t.data.scale||1,s=t.data.duration||2;this.createExplosionEffect(e,o,s),window.game&&window.game.audio&&window.game.audio.playSound("boink")}handleDamageFlashRequest(t){const e=t&&t.data&&t.data.intensity?t.data.intensity:.3;this.createDamageFlashEffect(e)}createExplosionEffect(t,e=1,o=2){if(!this.world.scene)return console.error("No scene available for explosion effect"),-1;const s=new v;s.position.copy(t),s.scale.set(e,e,e);const l=Math.floor(20*e),r=[],n=window.objectPool&&window.objectPool.pools&&window.objectPool.pools.explosionParticle;for(let m=0;m<l;m++){let c;const d=Math.random()*2+1;if(n){if(c=window.objectPool.get("explosionParticle"),c){const f=Math.random()*10,u=Math.random()*Math.PI*2,h=Math.random()*Math.PI,p=new g(f*Math.sin(h)*Math.cos(u),f*Math.sin(h)*Math.sin(u),f*Math.cos(h));c.reset(p,d,16733440),c.velocity.copy(p).normalize().multiplyScalar(Math.random()*2+1),s.add(c.mesh),r.push(c)}}else{const f=window.game&&window.game.explosionGeometry?window.game.explosionGeometry:new x(d,8,8),u=window.game&&window.game.explosionMaterial?window.game.explosionMaterial.clone():new T({color:16733440,transparent:!0,opacity:.8}),h=new $(f,u),p=Math.random()*10,y=Math.random()*Math.PI*2,C=Math.random()*Math.PI;h.position.set(p*Math.sin(C)*Math.cos(y),p*Math.sin(C)*Math.sin(y),p*Math.cos(C)),h.userData.velocity=h.position.clone().normalize().multiplyScalar(Math.random()*2+1),s.add(h),r.push({mesh:h,material:u,velocity:h.userData.velocity})}}this.world.scene.add(s);const a=this.effectCounter++,i={id:a,type:"explosion",container:s,particles:r,duration:o,elapsed:0,usePooling:n,update:m=>{if(i.elapsed+=m,i.elapsed>=i.duration)return i.usePooling&&i.particles.forEach(d=>{window.objectPool.release("explosionParticle",d)}),this.world.scene.remove(s),!1;const c=i.elapsed/i.duration;return i.particles.forEach(d=>{i.usePooling,d.mesh.position.add(d.velocity.clone().multiplyScalar(m)),d.material.opacity=.8*(1-c),d.mesh.scale.multiplyScalar(.99)}),!0}};return this.activeEffects.set(a,i),a}createDamageFlashEffect(t=.3){const e=document.createElement("div");e.style.position="fixed",e.style.top="0",e.style.left="0",e.style.width="100%",e.style.height="100%",e.style.backgroundColor=`rgba(255, 0, 0, ${t})`,e.style.pointerEvents="none",e.style.zIndex="1000",e.style.opacity="1",e.style.transition="opacity 0.2s ease-out",document.body.appendChild(e);const o=this.effectCounter++,s={id:o,type:"damageFlash",element:e,duration:.3,elapsed:0,update:l=>{if(s.elapsed+=l,s.elapsed>=s.duration)return document.body.contains(e)&&document.body.removeChild(e),!1;const r=s.elapsed/s.duration;return e.style.opacity=(1-r).toString(),!0}};return this.activeEffects.set(o,s),o}removeEffect(t){const e=this.activeEffects.get(t);e&&(e.type==="explosion"?e.container&&this.world.scene&&this.world.scene.remove(e.container):e.type==="damageFlash"&&e.element&&document.body.contains(e.element)&&document.body.removeChild(e.element),this.activeEffects.delete(t))}onDisabled(){for(const t of this.activeEffects.keys())this.removeEffect(t);this.activeEffects.clear()}}export{D as C,R,z as V};
//# sourceMappingURL=physics-rendering-Bkwvzh1H.js.map
